/*! 
* DevExtreme
* Version: 14.2.3
* Build date: Dec 3, 2014
*
* Copyright (c) 2012 - 2014 Developer Express Inc. ALL RIGHTS RESERVED
* EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
*/

"use strict";

if (!window.DevExpress) {
    /*! Module core, file devexpress.js */
    (function($, global, undefined) {
        global.DevExpress = global.DevExpress || {};
        $.extend(global.DevExpress, {
            VERSION: "14.2.3",
            abstract: function() {
                throw global.DevExpress.Error("E0001");
            },
            stringFormat: function() {
                var s = arguments[0];
                for (var i = 0; i < arguments.length - 1; i++) {
                    var reg = new RegExp("\\{" + i + "\\}", "gm");
                    s = s.replace(reg, arguments[i + 1])
                }
                return s
            },
            parseUrl: function() {
                var a = document.createElement("a"),
                    props = ["protocol", "hostname", "port", "pathname", "search", "hash"];
                var normalizePath = function(value) {
                        if (value.charAt(0) !== "/")
                            value = "/" + value;
                        return value
                    };
                return function(url) {
                        a.href = url;
                        var result = {};
                        $.each(props, function() {
                            result[this] = a[this]
                        });
                        result.pathname = normalizePath(result.pathname);
                        return result
                    }
            }(),
            processHardwareBackButton: function() {
                this.hardwareBackButton.fire()
            },
            hardwareBackButton: $.Callbacks(),
            viewPort: function() {
                var $current;
                return function(element) {
                        if (!arguments.length)
                            return $current;
                        var $element = $(element);
                        var isNewViewportFound = !!$element.length;
                        var prevViewPort = this.viewPort();
                        $current = isNewViewportFound ? $element : $("body");
                        this.viewPortChanged.fire(isNewViewportFound ? this.viewPort() : $(), prevViewPort)
                    }
            }(),
            viewPortChanged: $.Callbacks(),
            hideTopOverlayCallback: function() {
                var callbacks = [];
                return {
                        add: function(callback) {
                            var indexOfCallback = $.inArray(callback, callbacks);
                            if (indexOfCallback === -1)
                                callbacks.push(callback)
                        },
                        remove: function(callback) {
                            var indexOfCallback = $.inArray(callback, callbacks);
                            if (indexOfCallback !== -1)
                                callbacks.splice(indexOfCallback, 1)
                        },
                        fire: function() {
                            var callback = callbacks.pop(),
                                result = !!callback;
                            if (result)
                                callback();
                            return result
                        },
                        hasCallback: function() {
                            return callbacks.length > 0
                        },
                        reset: function() {
                            callbacks = []
                        }
                    }
            }(),
            rtlEnabled: false
        });
        $(function() {
            DevExpress.viewPort(".dx-viewport")
        })
    })(jQuery, this);
    /*! Module core, file errors.js */
    (function($, DX) {
        var ERROR_MESSAGES = {
                E0001: "Method is not implemented",
                E0002: "Member name collision: {0}",
                E0003: "A class must be instantiated using the 'new' keyword",
                E0004: "The NAME property of the component is not specified",
                E0005: "Unknown device",
                E0006: "Unknown endpoint key is requested",
                E0007: "'Invalidate' method is called outside the update transaction",
                E0008: "Type of the option name is not appropriate to create an action",
                E0009: "Component '{0}' has not been initialized for an element",
                E0010: "Animation configuration with the '{0}' type requires '{1}' configuration as an plain object",
                E0011: "Unknown animation type '{0}'",
                E0012: "jQuery version is too old. Please upgrade jQuery to 1.10.0 or later",
                E0013: "KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later",
                E0014: "The 'release' method shouldn't be called for an unlocked Lock object",
                E0015: "Queued task returned an unexpected result",
                E0017: "Event namespace is not defined",
                E0018: "DevExpress.ui.dxPopup widget is required",
                E0020: "Template engine '{0}' is not supported",
                E0021: "Unknown theme is set: {0}",
                E0022: "LINK[rel=dx-theme] tags must go before DevExpress included scripts",
                E0023: "Template name is not specified",
                E0100: "Unknown validation type is detected",
                E0101: "Misconfigured range validation rule is detected",
                E0102: "Misconfigured comparison validation rule is detected",
                E0110: "Unknown validation group is detected",
                E0120: "Adapter for a dxValidator component cannot be configured",
                W0000: "'{0}' is deprecated in {1}. {2}",
                W0001: "{0} - '{1}' option is deprecated in {2}. {3}",
                W0002: "{0} - '{1}' method is deprecated in {2}. {3}",
                W0003: "{0} - '{1}' property is deprecated in {2}. {3}",
                W0004: "Timeout for theme loading is over: {0}"
            };
        var ERROR_URL = "http://js.devexpress.com/error/" + DX.VERSION.split(".").slice(0, 2).join("_") + "/";
        var combineMessage = function(args) {
                var id = args[0];
                args = args.slice(1);
                return formatMessage(id, formatDetails(id, args))
            };
        var formatDetails = function(id, args) {
                args = [DX.ERROR_MESSAGES[id]].concat(args);
                return DX.stringFormat.apply(this, args).replace(/\.*\s*?$/, '')
            };
        var formatMessage = function(id, details) {
                return DX.stringFormat.apply(this, ["{0} - {1}. See:\n{2}", id, details, ERROR_URL + id])
            };
        var makeError = function(args) {
                var id = args[0],
                    args = args.slice(1),
                    details = formatDetails(id, args),
                    message = formatMessage(id, details);
                return $.extend(new Error(message), {details: details})
            };
        $.extend(DX, {
            Error: function(id) {
                return makeError($.makeArray(arguments))
            },
            log: function(id) {
                var method = "log",
                    logger = DX.utils.logger;
                if (/^E\d+$/.test(id))
                    method = "error";
                else if (/^W\d+$/.test(id))
                    method = "warn";
                logger[method](method === "log" ? id : combineMessage($.makeArray(arguments)))
            },
            ERROR_MESSAGES: ERROR_MESSAGES
        })
    })($, DevExpress);
    /*! Module core, file class.js */
    (function($, global, DX, undefined) {
        DX.Class = function() {
            var wrapOverridden = function(baseProto, methodName, method) {
                    return function() {
                            var prevCallBase = this.callBase;
                            this.callBase = baseProto[methodName];
                            try {
                                return method.apply(this, arguments)
                            }
                            finally {
                                this.callBase = prevCallBase
                            }
                        }
                };
            var clonePrototype = function(obj) {
                    var func = function(){};
                    func.prototype = obj.prototype;
                    return new func
                };
            var classImpl = function(){};
            var redefine = function(members) {
                    var that = this;
                    if (!members)
                        return that;
                    var memberNames = $.map(members, function(_, k) {
                            return k
                        });
                    $.each(["toString", "toLocaleString", "valueOf"], function() {
                        if (members[this])
                            memberNames.push(this)
                    });
                    $.each(memberNames, function() {
                        var overridden = $.isFunction(that.prototype[this]) && $.isFunction(members[this]);
                        that.prototype[this] = overridden ? wrapOverridden(that.parent.prototype, this, members[this]) : members[this]
                    });
                    return that
                };
            var include = function() {
                    var classObj = this;
                    $.each(arguments, function() {
                        if (this.ctor)
                            classObj._includedCtors.push(this.ctor);
                        if (this.postCtor)
                            classObj._includedPostCtors.push(this.postCtor);
                        for (var name in this) {
                            if (name === "ctor" || name === "postCtor")
                                continue;
                            if (name in classObj.prototype)
                                throw DX.Error("E0002", name);
                            classObj.prototype[name] = this[name]
                        }
                    });
                    return classObj
                };
            var subclassOf = function(parentClass) {
                    if (this.parent === parentClass)
                        return true;
                    if (!this.parent || !this.parent.subclassOf)
                        return false;
                    return this.parent.subclassOf(parentClass)
                };
            classImpl.inherit = function(members) {
                var inheritor = function() {
                        if (!this || this === global || typeof this.constructor !== "function")
                            throw DX.Error("E0003");
                        var instance = this,
                            ctor = instance.ctor;
                        $.each(instance.constructor._includedCtors, function() {
                            this.call(instance)
                        });
                        if (ctor)
                            ctor.apply(instance, arguments);
                        $.each(instance.constructor._includedPostCtors, function() {
                            this.call(instance)
                        })
                    };
                inheritor.prototype = clonePrototype(this);
                inheritor.inherit = this.inherit;
                inheritor.redefine = redefine;
                inheritor.include = include;
                inheritor.subclassOf = subclassOf;
                inheritor.parent = this;
                inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
                inheritor._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [];
                inheritor.prototype.constructor = inheritor;
                inheritor.redefine(members);
                return inheritor
            };
            return classImpl
        }()
    })(jQuery, this, DevExpress);
    /*! Module core, file queue.js */
    (function($, global, undefined) {
        var DX = global.DevExpress;
        function createQueue(discardPendingTasks) {
            var _tasks = [],
                _busy = false;
            function exec() {
                while (_tasks.length) {
                    _busy = true;
                    var task = _tasks.shift(),
                        result = task();
                    if (result === undefined)
                        continue;
                    if (result.then) {
                        $.when(result).always(exec);
                        return
                    }
                    throw DX.Error("E0015");
                }
                _busy = false
            }
            function add(task, removeTaskCallback) {
                if (!discardPendingTasks)
                    _tasks.push(task);
                else {
                    if (_tasks[0] && removeTaskCallback)
                        removeTaskCallback(_tasks[0]);
                    _tasks = [task]
                }
                if (!_busy)
                    exec()
            }
            function busy() {
                return _busy
            }
            return {
                    add: add,
                    busy: busy
                }
        }
        $.extend(global.DevExpress, {
            createQueue: createQueue,
            enqueue: createQueue().add
        })
    })(jQuery, this);
    /*! Module core, file inflector.js */
    (function($, DX, undefined) {
        var _normalize = function(text) {
                if (text === undefined || text === null)
                    return "";
                return String(text)
            };
        var _ucfirst = function(text) {
                return _normalize(text).charAt(0).toUpperCase() + text.substr(1)
            };
        var _chop = function(text) {
                return _normalize(text).replace(/([a-z\d])([A-Z])/g, "$1 $2").split(/[\s_-]+/)
            };
        var dasherize = function(text) {
                return $.map(_chop(text), function(p) {
                        return p.toLowerCase()
                    }).join("-")
            };
        var underscore = function(text) {
                return dasherize(text).replace(/-/g, "_")
            };
        var camelize = function(text, upperFirst) {
                return $.map(_chop(text), function(p, i) {
                        p = p.toLowerCase();
                        if (upperFirst || i > 0)
                            p = _ucfirst(p);
                        return p
                    }).join("")
            };
        var humanize = function(text) {
                return _ucfirst(dasherize(text).replace(/-/g, " "))
            };
        var titleize = function(text) {
                return $.map(_chop(text), function(p) {
                        return _ucfirst(p.toLowerCase())
                    }).join(" ")
            };
        DX.inflector = {
            dasherize: dasherize,
            camelize: camelize,
            humanize: humanize,
            titleize: titleize,
            underscore: underscore
        }
    })(jQuery, DevExpress);
    /*! Module core, file eventsMixin.js */
    (function($, DX, undefined) {
        var EventsMixin = {
                ctor: function() {
                    this._events = {}
                },
                fireEvent: function(eventName, eventArgs) {
                    var callbacks = this._events[eventName];
                    if (callbacks)
                        callbacks.fireWith(this, eventArgs);
                    return this
                },
                on: function(eventName, eventHandler) {
                    if ($.isPlainObject(eventName))
                        $.each(eventName, $.proxy(function(e, h) {
                            this.on(e, h)
                        }, this));
                    else {
                        var callbacks = this._events[eventName],
                            addFn;
                        if (!callbacks) {
                            callbacks = $.Callbacks();
                            this._events[eventName] = callbacks
                        }
                        addFn = callbacks.originalAdd || callbacks.add;
                        addFn.call(callbacks, eventHandler)
                    }
                    return this
                },
                off: function(eventName, eventHandler) {
                    var callbacks = this._events[eventName];
                    if (callbacks)
                        if ($.isFunction(eventHandler))
                            callbacks.remove(eventHandler);
                        else
                            callbacks.empty();
                    return this
                },
                _disposeEvents: function() {
                    $.each(this._events, function() {
                        this.empty()
                    })
                },
                _callbacksToEvents: function(className, eventNames) {
                    var that = this;
                    $.each(eventNames, function(_, eventName) {
                        var callbacksProperty = that[eventName],
                            originalAdd;
                        if (callbacksProperty !== undefined) {
                            originalAdd = callbacksProperty.add;
                            callbacksProperty.originalAdd = originalAdd;
                            callbacksProperty.add = function() {
                                DX.log("W0003", className, eventName, "14.2", "Use the '" + eventName + "' event instead");
                                return originalAdd.apply(that, arguments)
                            };
                            that._events[eventName] = callbacksProperty
                        }
                    })
                }
            };
        $.extend(DX, {EventsMixin: EventsMixin})
    })(jQuery, DevExpress);
    /*! Module core, file jquery.js */
    (function($) {
        (function checkjQueryVersion(version) {
            version = version.split(".");
            if (version[0] < 1 || version[0] == 1 && version[1] < 10)
                throw DX.Error("E0012");
        })($.fn.jquery)
    })(jQuery);
    /*! Module core, file utils.common.js */
    (function($, DX, undefined) {
        var isDefined = function(object) {
                return object !== null && object !== undefined
            };
        var isString = function(object) {
                return $.type(object) === 'string'
            };
        var isNumber = function(object) {
                return typeof object === "number" && isFinite(object) || $.isNumeric(object)
            };
        var isObject = function(object) {
                return $.type(object) === 'object'
            };
        var isArray = function(object) {
                return $.type(object) === 'array'
            };
        var isDate = function(object) {
                return $.type(object) === 'date'
            };
        var isFunction = function(object) {
                return $.type(object) === 'function'
            };
        var isExponential = function(value) {
                return isNumber(value) && value.toString().indexOf('e') !== -1
            };
        var extendFromObject = function(target, source, overrideExistingValues) {
                target = target || {};
                for (var prop in source)
                    if (source.hasOwnProperty(prop)) {
                        var value = source[prop];
                        if (!(prop in target) || overrideExistingValues)
                            target[prop] = value
                    }
                return target
            };
        var clone = function() {
                function Clone(){}
                return function(obj) {
                        Clone.prototype = obj;
                        return new Clone
                    }
            }();
        var executeAsync = function(action, context) {
                var deferred = $.Deferred(),
                    normalizedContext = context || this;
                setTimeout(function() {
                    var result = action.call(normalizedContext);
                    if (result && result.done && $.isFunction(result.done))
                        result.done(function() {
                            deferred.resolveWith(normalizedContext)
                        });
                    else
                        deferred.resolveWith(normalizedContext)
                }, 0);
                return deferred.promise()
            };
        var findBestMatches = function(targetFilter, items, mapFn) {
                var bestMatches = [],
                    maxMatchCount = 0;
                $.each(items, function(index, itemSrc) {
                    var matchCount = 0,
                        item = mapFn ? mapFn(itemSrc) : itemSrc;
                    $.each(targetFilter, function(paramName) {
                        var value = item[paramName];
                        if (value === undefined)
                            return;
                        if (value === targetFilter[paramName]) {
                            matchCount++;
                            return
                        }
                        matchCount = -1;
                        return false
                    });
                    if (matchCount < maxMatchCount)
                        return;
                    if (matchCount > maxMatchCount) {
                        bestMatches.length = 0;
                        maxMatchCount = matchCount
                    }
                    bestMatches.push(itemSrc)
                });
                return bestMatches
            };
        var preg_quote = function(str) {
                return (str + "").replace(/([\+\*\?\\\.\[\^\]\$\(\)\{\}\>\<\|\=\!\:])/g, "\\$1")
            };
        var replaceAll = function(text, searchToken, replacementToken) {
                return text.replace(new RegExp("(" + preg_quote(searchToken) + ")", "gi"), replacementToken)
            };
        var splitPair = function(raw) {
                switch (typeof raw) {
                    case"string":
                        return raw.split(/\s+/, 2);
                    case"object":
                        return [raw.x || raw.h, raw.y || raw.v];
                    case"number":
                        return [raw];
                    default:
                        return raw
                }
            };
        var stringPairToObject = function(raw) {
                var pair = splitPair(raw),
                    h = parseInt(pair && pair[0], 10),
                    v = parseInt(pair && pair[1], 10);
                if (!isFinite(h))
                    h = 0;
                if (!isFinite(v))
                    v = h;
                return {
                        h: h,
                        v: v
                    }
            };
        function icontains(elem, text) {
            var result = false;
            $.each($(elem).contents(), function(index, content) {
                if (content.nodeType === 3 && (content.textContent || content.nodeValue || "").toLowerCase().indexOf((text || "").toLowerCase()) > -1) {
                    result = true;
                    return false
                }
            });
            return result
        }
        $.expr[":"].dxicontains = $.expr.createPseudo(function(text) {
            return function(elem) {
                    return icontains(elem, text)
                }
        });
        function deepExtendArraySafe(target, changes) {
            var prevValue,
                newValue;
            for (var name in changes) {
                prevValue = target[name];
                newValue = changes[name];
                if (target === newValue)
                    continue;
                if ($.isPlainObject(newValue) && !(newValue instanceof $.Event))
                    target[name] = deepExtendArraySafe($.isPlainObject(prevValue) ? prevValue : {}, newValue);
                else if (newValue !== undefined)
                    target[name] = newValue
            }
            return target
        }
        function unwrapObservable(value) {
            if (DX.support.hasKo)
                return ko.utils.unwrapObservable(value);
            return value
        }
        DX.utils = {
            isDefined: isDefined,
            isString: isString,
            isNumber: isNumber,
            isObject: isObject,
            isArray: isArray,
            isDate: isDate,
            isFunction: isFunction,
            isExponential: isExponential,
            extendFromObject: extendFromObject,
            clone: clone,
            executeAsync: executeAsync,
            stringFormat: DX.stringFormat,
            findBestMatches: findBestMatches,
            replaceAll: replaceAll,
            deepExtendArraySafe: deepExtendArraySafe,
            splitPair: splitPair,
            stringPairToObject: stringPairToObject,
            unwrapObservable: unwrapObservable
        }
    })(jQuery, DevExpress);
    /*! Module core, file utils.console.js */
    (function($, DX, undefined) {
        var logger = function() {
                var console = window.console;
                function info(text) {
                    if (!console || !$.isFunction(console.info))
                        return;
                    console.info(text)
                }
                function warn(text) {
                    if (!console || !$.isFunction(console.warn))
                        return;
                    console.warn(text)
                }
                function error(text) {
                    if (!console || !$.isFunction(console.error))
                        return;
                    console.error(text)
                }
                return {
                        info: info,
                        warn: warn,
                        error: error
                    }
            }();
        var debug = function() {
                function assert(condition, message) {
                    if (!condition)
                        throw new Error(message);
                }
                function assertParam(parameter, message) {
                    assert(parameter !== null && parameter !== undefined, message)
                }
                return {
                        assert: assert,
                        assertParam: assertParam
                    }
            }();
        $.extend(DX.utils, {
            logger: logger,
            debug: debug
        })
    })(jQuery, DevExpress);
    /*! Module core, file utils.math.js */
    (function($, DX, undefined) {
        var PI = Math.PI,
            LN10 = Math.LN10;
        var cos = Math.cos,
            sin = Math.sin,
            abs = Math.abs,
            log = Math.log,
            floor = Math.floor,
            ceil = Math.ceil,
            max = Math.max,
            min = Math.min,
            isNaN = window.isNaN,
            Number = window.Number,
            NaN = window.NaN;
        var isNumber = DX.utils.isNumber,
            isExponential = DX.utils.isExponential;
        var getPrecision = function(value) {
                var stringFraction,
                    stringValue = value.toString(),
                    pointIndex = stringValue.indexOf('.'),
                    startIndex,
                    precision;
                if (isExponential(value)) {
                    precision = getDecimalOrder(value);
                    if (precision < 0)
                        return Math.abs(precision);
                    else
                        return 0
                }
                if (pointIndex !== -1) {
                    startIndex = pointIndex + 1;
                    stringFraction = stringValue.substring(startIndex, startIndex + 20);
                    return stringFraction.length
                }
                return 0
            };
        var getLog = function(value, base) {
                if (!value)
                    return 0;
                return Math.log(value) / Math.log(base)
            };
        var raiseTo = function(power, base) {
                return Math.pow(base, power)
            };
        var sign = function(value) {
                if (value === 0)
                    return 0;
                return value / abs(value)
            };
        var normalizeAngle = function(angle) {
                return (angle % 360 + 360) % 360
            };
        var convertAngleToRendererSpace = function(angle) {
                return 90 - angle
            };
        var degreesToRadians = function(value) {
                return PI * value / 180
            };
        var getCosAndSin = function(angle) {
                var angleInRadians = degreesToRadians(angle);
                return {
                        cos: cos(angleInRadians),
                        sin: sin(angleInRadians)
                    }
            };
        var DECIMAL_ORDER_THRESHOLD = 1E-14;
        var getDistance = function(x1, y1, x2, y2) {
                var diffX = x2 - x1,
                    diffY = y2 - y1;
                return Math.sqrt(diffY * diffY + diffX * diffX)
            };
        var getDecimalOrder = function(number) {
                var n = abs(number),
                    cn;
                if (!isNaN(n)) {
                    if (n > 0) {
                        n = log(n) / LN10;
                        cn = ceil(n);
                        return cn - n < DECIMAL_ORDER_THRESHOLD ? cn : floor(n)
                    }
                    return 0
                }
                return NaN
            };
        var getAppropriateFormat = function(start, end, count) {
                var order = max(getDecimalOrder(start), getDecimalOrder(end)),
                    precision = -getDecimalOrder(abs(end - start) / count),
                    format;
                if (!isNaN(order) && !isNaN(precision)) {
                    if (abs(order) <= 4) {
                        format = 'fixedPoint';
                        precision < 0 && (precision = 0);
                        precision > 4 && (precision = 4)
                    }
                    else {
                        format = 'exponential';
                        precision += order - 1;
                        precision > 3 && (precision = 3)
                    }
                    return {
                            format: format,
                            precision: precision
                        }
                }
                return null
            };
        var getFraction = function(value) {
                var valueString,
                    dotIndex;
                if (isNumber(value)) {
                    valueString = value.toString();
                    dotIndex = valueString.indexOf('.');
                    if (dotIndex >= 0)
                        if (isExponential(value))
                            return valueString.substr(dotIndex + 1, valueString.indexOf('e') - dotIndex - 1);
                        else {
                            valueString = value.toFixed(20);
                            return valueString.substr(dotIndex + 1, valueString.length - dotIndex + 1)
                        }
                }
                return ''
            };
        var getSignificantDigitPosition = function(value) {
                var fraction = getFraction(value),
                    i;
                if (fraction)
                    for (i = 0; i < fraction.length; i++)
                        if (fraction.charAt(i) !== '0')
                            return i + 1;
                return 0
            };
        var adjustValue = function(value) {
                var fraction = getFraction(value),
                    nextValue,
                    i;
                if (fraction)
                    for (i = 1; i <= fraction.length; i++) {
                        nextValue = roundValue(value, i);
                        if (nextValue !== 0 && fraction[i - 2] && fraction[i - 1] && fraction[i - 2] === fraction[i - 1])
                            return nextValue
                    }
                return value
            };
        var roundValue = function(value, precision) {
                if (precision > 20)
                    precision = 20;
                if (isNumber(value))
                    if (isExponential(value))
                        return Number(value.toExponential(precision));
                    else
                        return Number(value.toFixed(precision))
            };
        var applyPrecisionByMinDelta = function(min, delta, value) {
                var minPrecision = getPrecision(min),
                    deltaPrecision = getPrecision(delta);
                return roundValue(value, minPrecision < deltaPrecision ? deltaPrecision : minPrecision)
            };
        var fitIntoRange = function(value, minValue, maxValue) {
                return Math.min(Math.max(value, minValue), maxValue)
            };
        $.extend(DX.utils, {
            getLog: getLog,
            raiseTo: raiseTo,
            sign: sign,
            normalizeAngle: normalizeAngle,
            convertAngleToRendererSpace: convertAngleToRendererSpace,
            degreesToRadians: degreesToRadians,
            getCosAndSin: getCosAndSin,
            getDecimalOrder: getDecimalOrder,
            getAppropriateFormat: getAppropriateFormat,
            getDistance: getDistance,
            getFraction: getFraction,
            adjustValue: adjustValue,
            roundValue: roundValue,
            applyPrecisionByMinDelta: applyPrecisionByMinDelta,
            getSignificantDigitPosition: getSignificantDigitPosition,
            fitIntoRange: fitIntoRange
        });
        DX.utils.getPrecision = getPrecision
    })(jQuery, DevExpress);
    /*! Module core, file utils.date.js */
    (function($, DX, undefined) {
        var isObject = DX.utils.isObject,
            isString = DX.utils.isString,
            isDate = DX.utils.isDate,
            isDefined = DX.utils.isDefined;
        var dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'];
        var addSubValues = function(value1, value2, isSub) {
                return value1 + (isSub ? -1 : 1) * value2
            };
        var toMilliseconds = function(value) {
                switch (value) {
                    case'millisecond':
                        return 1;
                    case'second':
                        return toMilliseconds('millisecond') * 1000;
                    case'minute':
                        return toMilliseconds('second') * 60;
                    case'hour':
                        return toMilliseconds('minute') * 60;
                    case'day':
                        return toMilliseconds('hour') * 24;
                    case'week':
                        return toMilliseconds('day') * 7;
                    case'month':
                        return toMilliseconds('day') * 30;
                    case'quarter':
                        return toMilliseconds('month') * 3;
                    case'year':
                        return toMilliseconds('day') * 365;
                    default:
                        return 0
                }
            };
        function parseISO8601(isoString) {
            var result = new Date(0);
            var chunks = isoString.replace("Z", "").split("T"),
                date = String(chunks[0]).split("-"),
                time = String(chunks[1]).split(":");
            var year,
                month,
                day,
                hours,
                minutes,
                seconds,
                milliseconds;
            year = Number(date[0]);
            month = Number(date[1]) - 1;
            day = Number(date[2]);
            result.setDate(day);
            result.setMonth(month);
            result.setFullYear(year);
            if (time.length) {
                hours = Number(time[0]);
                minutes = Number(time[1]);
                seconds = Number(String(time[2]).split(".")[0]);
                milliseconds = Number(String(time[2]).split(".")[1]) || 0;
                result.setHours(hours);
                result.setMinutes(minutes);
                result.setSeconds(seconds);
                result.setMilliseconds(milliseconds)
            }
            return result
        }
        function formatISO8601(date) {
            function pad(n) {
                if (n < 10)
                    return "0".concat(n);
                return String(n)
            }
            return [date.getFullYear(), "-", pad(date.getMonth() + 1), "-", pad(date.getDate()), "T", pad(date.getHours()), ":", pad(date.getMinutes()), ":", pad(date.getSeconds()), "Z"].join("")
        }
        var convertMillisecondsToDateUnits = function(value) {
                var i,
                    dateUnitCount,
                    dateUnitInterval,
                    dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year'],
                    result = {};
                for (i = dateUnitIntervals.length - 1; i >= 0; i--) {
                    dateUnitInterval = dateUnitIntervals[i];
                    dateUnitCount = Math.floor(value / toMilliseconds(dateUnitInterval));
                    if (dateUnitCount > 0) {
                        result[dateUnitInterval + 's'] = dateUnitCount;
                        value -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount)
                    }
                }
                return result
            };
        var convertDateTickIntervalToMilliseconds = function(tickInterval) {
                var milliseconds = 0;
                if (isObject(tickInterval))
                    $.each(tickInterval, function(key, value) {
                        milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value)
                    });
                if (isString(tickInterval))
                    milliseconds = convertDateUnitToMilliseconds(tickInterval, 1);
                return milliseconds
            };
        var convertDateUnitToMilliseconds = function(dateUnit, count) {
                return toMilliseconds(dateUnit) * count
            };
        var getDateUnitInterval = function(tickInterval) {
                var maxInterval = -1,
                    i;
                if (isString(tickInterval))
                    return tickInterval;
                if (isObject(tickInterval)) {
                    $.each(tickInterval, function(key, value) {
                        for (i = 0; i < dateUnitIntervals.length; i++)
                            if (value && (key === dateUnitIntervals[i] + 's' || key === dateUnitIntervals[i]) && maxInterval < i)
                                maxInterval = i
                    });
                    return dateUnitIntervals[maxInterval]
                }
                return ''
            };
        var correctDateWithUnitBeginning = function(date, dateInterval) {
                var dayMonth,
                    firstQuarterMonth,
                    dateUnitInterval = getDateUnitInterval(dateInterval);
                switch (dateUnitInterval) {
                    case'second':
                        date.setMilliseconds(0);
                        break;
                    case'minute':
                        date.setSeconds(0, 0);
                        break;
                    case'hour':
                        date.setMinutes(0, 0, 0);
                        break;
                    case'year':
                        date.setMonth(0);
                    case'month':
                        date.setDate(1);
                    case'day':
                        date.setHours(0, 0, 0, 0);
                        break;
                    case'week':
                        dayMonth = date.getDate();
                        if (date.getDay() !== 0)
                            dayMonth += 7 - date.getDay();
                        date.setDate(dayMonth);
                        date.setHours(0, 0, 0, 0);
                        break;
                    case'quarter':
                        firstQuarterMonth = DX.formatHelper.getFirstQuarterMonth(date.getMonth());
                        if (date.getMonth() !== firstQuarterMonth)
                            date.setMonth(firstQuarterMonth);
                        date.setDate(1);
                        date.setHours(0, 0, 0, 0);
                        break
                }
            };
        var getDatesDifferences = function(date1, date2) {
                var differences,
                    counter = 0;
                differences = {
                    year: date1.getFullYear() !== date2.getFullYear(),
                    month: date1.getMonth() !== date2.getMonth(),
                    day: date1.getDate() !== date2.getDate(),
                    hour: date1.getHours() !== date2.getHours(),
                    minute: date1.getMinutes() !== date2.getMinutes(),
                    second: date1.getSeconds() !== date2.getSeconds()
                };
                $.each(differences, function(key, value) {
                    if (value)
                        counter++
                });
                differences.count = counter;
                return differences
            };
        var addInterval = function(value, interval, isNegative) {
                var result = null,
                    intervalObject;
                if (isDate(value)) {
                    intervalObject = isString(interval) ? getDateIntervalByString(interval.toLowerCase()) : interval;
                    result = new Date(value.getTime());
                    if (intervalObject.years)
                        result.setFullYear(addSubValues(result.getFullYear(), intervalObject.years, isNegative));
                    if (intervalObject.quarters)
                        result.setMonth(addSubValues(result.getMonth(), 3 * intervalObject.quarters, isNegative));
                    if (intervalObject.months)
                        result.setMonth(addSubValues(result.getMonth(), intervalObject.months, isNegative));
                    if (intervalObject.weeks)
                        result.setDate(addSubValues(result.getDate(), 7 * intervalObject.weeks, isNegative));
                    if (intervalObject.days)
                        result.setDate(addSubValues(result.getDate(), intervalObject.days, isNegative));
                    if (intervalObject.hours)
                        result.setHours(addSubValues(result.getHours(), intervalObject.hours, isNegative));
                    if (intervalObject.minutes)
                        result.setMinutes(addSubValues(result.getMinutes(), intervalObject.minutes, isNegative));
                    if (intervalObject.seconds)
                        result.setSeconds(addSubValues(result.getSeconds(), intervalObject.seconds, isNegative));
                    if (intervalObject.milliseconds)
                        result.setMilliseconds(addSubValues(value.getMilliseconds(), intervalObject.milliseconds, isNegative))
                }
                else
                    result = addSubValues(value, interval, isNegative);
                return result
            };
        var getDateIntervalByString = function(intervalString) {
                var result = {};
                switch (intervalString) {
                    case'year':
                        result.years = 1;
                        break;
                    case'month':
                        result.months = 1;
                        break;
                    case'quarter':
                        result.months = 3;
                        break;
                    case'week':
                        result.days = 7;
                        break;
                    case'day':
                        result.days = 1;
                        break;
                    case'hour':
                        result.hours = 1;
                        break;
                    case'minute':
                        result.minutes = 1;
                        break;
                    case'second':
                        result.seconds = 1;
                        break;
                    case'millisecond':
                        result.milliseconds = 1;
                        break
                }
                return result
            };
        var sameMonthAndYear = function(date1, date2) {
                return date1 && date2 && date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth()
            };
        var getFirstMonthDate = function(date) {
                return new Date(date.getFullYear(), date.getMonth(), 1)
            };
        var dateInRange = function(date, min, max) {
                return normalizeDate(date, min, max) === date
            };
        var normalizeDate = function(date, min, max) {
                var normalizedDate = date;
                if (isDefined(min) && date < min)
                    normalizedDate = min;
                if (isDefined(max) && date > max)
                    normalizedDate = max;
                return normalizedDate
            };
        var getPower = function(value) {
                return value.toExponential().split("e")[1]
            };
        $.extend(DX.utils, {
            dateUnitIntervals: dateUnitIntervals,
            parseIso8601Date: parseISO8601,
            formatIso8601Date: formatISO8601,
            convertMillisecondsToDateUnits: convertMillisecondsToDateUnits,
            convertDateTickIntervalToMilliseconds: convertDateTickIntervalToMilliseconds,
            convertDateUnitToMilliseconds: convertDateUnitToMilliseconds,
            getDateUnitInterval: getDateUnitInterval,
            getDatesDifferences: getDatesDifferences,
            correctDateWithUnitBeginning: correctDateWithUnitBeginning,
            addInterval: addInterval,
            getDateIntervalByString: getDateIntervalByString,
            sameMonthAndYear: sameMonthAndYear,
            getFirstMonthDate: getFirstMonthDate,
            dateInRange: dateInRange,
            normalizeDate: normalizeDate,
            getPower: getPower
        })
    })(jQuery, DevExpress);
    /*! Module core, file utils.dom.js */
    (function($, DX, undefined) {
        var IOS_APP_BAR_HEIGHT = "20px";
        var timeRedrawOnResize = 100;
        var createResizeHandler = function(callback) {
                var $window = $(window),
                    timeout;
                var debug_callback = arguments[1];
                var handler = function() {
                        var width = $window.width(),
                            height = $window.height();
                        clearTimeout(timeout);
                        timeout = setTimeout(function() {
                            $window.width() === width && $window.height() === height && callback();
                            debug_callback && debug_callback()
                        }, timeRedrawOnResize)
                    };
                handler.stop = function() {
                    clearTimeout(timeout);
                    return this
                };
                return handler
            };
        var windowResizeCallbacks = function() {
                var prevSize,
                    callbacks = $.Callbacks(),
                    jqWindow = $(window),
                    resizeEventHandlerAttached = false,
                    originalCallbacksAdd = callbacks.add,
                    originalCallbacksRemove = callbacks.remove;
                var formatSize = function() {
                        return [jqWindow.width(), jqWindow.height()].join()
                    };
                var handleResize = function() {
                        var now = formatSize();
                        if (now === prevSize)
                            return;
                        prevSize = now;
                        setTimeout(callbacks.fire)
                    };
                prevSize = formatSize();
                callbacks.add = function() {
                    var result = originalCallbacksAdd.apply(callbacks, arguments);
                    if (!resizeEventHandlerAttached && callbacks.has()) {
                        jqWindow.on("resize", handleResize);
                        resizeEventHandlerAttached = true
                    }
                    return result
                };
                callbacks.remove = function() {
                    var result = originalCallbacksRemove.apply(callbacks, arguments);
                    if (!callbacks.has() && resizeEventHandlerAttached) {
                        jqWindow.off("resize", handleResize);
                        resizeEventHandlerAttached = false
                    }
                    return result
                };
                return callbacks
            }();
        var resetActiveElement = function() {
                var activeElement = document.activeElement;
                if (activeElement && activeElement !== document.body && activeElement.blur)
                    activeElement.blur()
            };
        var createMarkupFromString = function(str) {
                var tempElement = $("<div />");
                if (window.WinJS)
                    WinJS.Utilities.setInnerHTMLUnsafe(tempElement.get(0), str);
                else
                    tempElement.append(str);
                return tempElement.contents()
            };
        var initMobileViewport = function(options) {
                options = $.extend({}, options);
                var device = DX.devices.current();
                var realDevice = DX.devices.real();
                var allowZoom = options.allowZoom,
                    allowPan = options.allowPan,
                    allowSelection = "allowSelection" in options ? options.allowSelection : device.platform == "desktop";
                var metaSelector = "meta[name=viewport]";
                if (!$(metaSelector).length)
                    $("<meta />").attr("name", "viewport").appendTo("head");
                var metaVerbs = ["width=device-width"],
                    msTouchVerbs = [];
                if (allowZoom)
                    msTouchVerbs.push("pinch-zoom");
                else
                    metaVerbs.push("initial-scale=1.0", "maximum-scale=1.0, user-scalable=no");
                if (allowPan)
                    msTouchVerbs.push("pan-x", "pan-y");
                if (!allowPan && !allowZoom)
                    $("html, body").css({
                        "-ms-content-zooming": "none",
                        "-ms-user-select": "none",
                        overflow: "hidden"
                    });
                else
                    $("html").css("-ms-overflow-style", "-ms-autohiding-scrollbar");
                if (!allowSelection) {
                    if (realDevice.ios)
                        $(document).on("selectstart", function() {
                            return false
                        });
                    $(".dx-viewport").css("user-select", "none")
                }
                $(metaSelector).attr("content", metaVerbs.join());
                $("html").css("-ms-touch-action", msTouchVerbs.join(" ") || "none");
                if (DX.support.touch)
                    $(document).off(".dxInitMobileViewport").on("dxpointermove.dxInitMobileViewport", function(e) {
                        var count = e.pointers.length,
                            isTouchEvent = e.pointerType === "touch",
                            zoomDisabled = !allowZoom && count > 1,
                            panDisabled = !allowPan && count === 1 && !e.isScrollingEvent;
                        if (isTouchEvent && (zoomDisabled || panDisabled))
                            e.preventDefault()
                    });
                realDevice = DX.devices.real();
                if (realDevice.ios) {
                    var isPhoneGap = document.location.protocol === "file:";
                    if (!isPhoneGap)
                        windowResizeCallbacks.add(function() {
                            var windowWidth = $(window).width();
                            $("body").width(windowWidth)
                        })
                }
            };
        var triggerVisibilityChangeEvent = function(eventName) {
                var VISIBILITY_CHANGE_SELECTOR = ".dx-visibility-change-handler";
                return function(element) {
                        var $element = $(element || "body");
                        var $changeHandlers = $element.find(VISIBILITY_CHANGE_SELECTOR).add($element.filter(VISIBILITY_CHANGE_SELECTOR));
                        $changeHandlers.each(function() {
                            $(this).triggerHandler(eventName)
                        })
                    }
            };
        DX.dataOptionsAttributeName = "data-options";
        var getElementOptions = function(element) {
                var optionsString = $(element).attr(DX.dataOptionsAttributeName),
                    result;
                if ($.trim(optionsString).charAt(0) !== "{")
                    optionsString = "{" + optionsString + "}";
                try {
                    result = new Function("return " + optionsString)()
                }
                catch(ex) {
                    throw DX.Error("E3018", ex, optionsString);
                }
                return result
            };
        var createComponents = function(elements, componentTypes) {
                var that = this,
                    result = [],
                    selector = "[" + DX.dataOptionsAttributeName + "]";
                elements.find(selector).addBack(selector).each(function(index, element) {
                    var $element = $(element),
                        options = getElementOptions(element);
                    for (var componentName in options)
                        if (!componentTypes || $.inArray(componentName, componentTypes) > -1)
                            if ($element[componentName]) {
                                $element[componentName](options[componentName]);
                                result.push($element[componentName]("instance"))
                            }
                });
                return result
            };
        var htmlToJQuery = function(htmlString) {
                htmlString = $.trim(htmlString);
                if (!htmlString.length)
                    return;
                if (htmlString[0] !== '<' || htmlString[htmlString.length - 1] !== '>')
                    htmlString = "<div>" + htmlString + "</div>";
                return $(htmlString)
            };
        var normalizeTemplateElement = function(element) {
                element = $(element);
                if (element.length && element[0].nodeName.toLowerCase() === "script")
                    element = htmlToJQuery(element.html());
                return element
            };
        var stringToJquery = function(string) {
                if (string == null)
                    string = "";
                if (string.nodeType || string.jquery)
                    return string;
                if (string[0] == "<")
                    return $(string);
                return $("<span>" + string + "</span>")
            };
        var clearSelection = function() {
                if (window.getSelection) {
                    if (window.getSelection().empty)
                        window.getSelection().empty();
                    else if (window.getSelection().removeAllRanges)
                        window.getSelection().removeAllRanges()
                }
                else if (document.selection)
                    document.selection.empty()
            };
        $.extend(DX.utils, {
            createResizeHandler: createResizeHandler,
            windowResizeCallbacks: windowResizeCallbacks,
            resetActiveElement: resetActiveElement,
            createMarkupFromString: createMarkupFromString,
            triggerShownEvent: triggerVisibilityChangeEvent("dxshown"),
            triggerHidingEvent: triggerVisibilityChangeEvent("dxhiding"),
            initMobileViewport: initMobileViewport,
            getElementOptions: getElementOptions,
            createComponents: createComponents,
            htmlToJQuery: htmlToJQuery,
            normalizeTemplateElement: normalizeTemplateElement,
            stringToJquery: stringToJquery,
            clearSelection: clearSelection
        });
        DX.utils.__timeRedrawOnResize = timeRedrawOnResize
    })(jQuery, DevExpress);
    /*! Module core, file utils.graphics.js */
    (function($, DX, undefined) {
        var isFunction = DX.utils.isFunction,
            _inArray = $.inArray,
            iDevice = /iphone|ipad/.test(navigator.userAgent.toLowerCase());
        var processSeriesTemplate = function(seriesTemplate, items) {
                var customizeSeries = isFunction(seriesTemplate.customizeSeries) ? seriesTemplate.customizeSeries : $.noop,
                    nameField = seriesTemplate.nameField || 'series',
                    generatedSeries = {},
                    seriesOrder = [],
                    series;
                for (var i = 0, length = items.length; i < length; i++) {
                    var data = items[i];
                    if (nameField in data) {
                        series = generatedSeries[data[nameField]];
                        if (!series) {
                            series = generatedSeries[data[nameField]] = {
                                name: data[nameField],
                                data: []
                            };
                            seriesOrder.push(series.name)
                        }
                        series.data.push(data)
                    }
                }
                return $.map(seriesOrder, function(orderedName) {
                        var group = generatedSeries[orderedName],
                            seriesOptions = customizeSeries.call(null, group.name);
                        return $.extend(group, seriesOptions)
                    })
            };
        var getNextDefsSvgId = function() {
                var numDefsSvgElements = 1;
                return function() {
                        return 'DevExpress_' + numDefsSvgElements++
                    }
            }();
        var getRootOffset = function(renderer) {
                var node,
                    result = {
                        left: 0,
                        top: 0
                    },
                    pointTransform,
                    root = renderer.root;
                if (root) {
                    node = root.element;
                    if (node.getScreenCTM && !iDevice) {
                        var ctm = node.getScreenCTM();
                        if (ctm) {
                            pointTransform = node.createSVGPoint().matrixTransform(ctm);
                            result.left = pointTransform.x + (document.body.scrollLeft || document.documentElement.scrollLeft);
                            result.top = pointTransform.y + (document.body.scrollTop || document.documentElement.scrollTop)
                        }
                        else {
                            result.left = document.body.scrollLeft || document.documentElement.scrollLeft;
                            result.top = document.body.scrollTop || document.documentElement.scrollTop
                        }
                    }
                    else
                        result = $(node).offset()
                }
                return result
            };
        var checkOverlapping = function(firstRect, secondRect) {
                return (firstRect.x <= secondRect.x && secondRect.x <= firstRect.x + firstRect.width || firstRect.x >= secondRect.x && firstRect.x <= secondRect.x + secondRect.width) && (firstRect.y <= secondRect.y && secondRect.y <= firstRect.y + firstRect.height || firstRect.y >= secondRect.y && firstRect.y <= secondRect.y + secondRect.height)
            };
        var getCategoriesInfo = function(categories, startValue, endValue) {
                if (!(categories && categories.length > 0 && startValue && endValue))
                    return {};
                var visibleCategories = [],
                    indexStartValue = _inArray(startValue, categories),
                    indexEndValue = _inArray(endValue, categories),
                    swapBuf,
                    i,
                    hasVisibleCategories,
                    inverted = false,
                    visibleCategoriesLen;
                indexStartValue < 0 && (indexStartValue = 0);
                indexEndValue < 0 && (indexEndValue = categories.length - 1);
                if (indexEndValue < indexStartValue) {
                    swapBuf = indexEndValue;
                    indexEndValue = indexStartValue;
                    indexStartValue = swapBuf;
                    inverted = true
                }
                visibleCategories = categories.slice(indexStartValue, indexEndValue + 1);
                visibleCategoriesLen = visibleCategories.length;
                hasVisibleCategories = visibleCategoriesLen > 0;
                return {
                        categories: hasVisibleCategories ? visibleCategories : null,
                        start: hasVisibleCategories ? visibleCategories[inverted ? visibleCategoriesLen - 1 : 0] : null,
                        end: hasVisibleCategories ? visibleCategories[inverted ? 0 : visibleCategoriesLen - 1] : null,
                        inverted: inverted
                    }
            };
        $.extend(DX.utils, {
            processSeriesTemplate: processSeriesTemplate,
            getNextDefsSvgId: getNextDefsSvgId,
            getRootOffset: getRootOffset,
            getCategoriesInfo: getCategoriesInfo,
            checkOverlapping: checkOverlapping
        })
    })(jQuery, DevExpress);
    /*! Module core, file utils.arrays.js */
    (function($, DX, undefined) {
        var wrapToArray = function(entity) {
                return $.isArray(entity) ? entity : [entity]
            };
        var removeDublicates = function(from, what) {
                if (!$.isArray(from) || from.length === 0)
                    return [];
                if (!$.isArray(what) || what.length === 0)
                    return from.slice();
                var result = [];
                $.each(from, function(_, value) {
                    var bIndex = $.inArray(value, what);
                    if (bIndex === -1)
                        result.push(value)
                });
                return result
            };
        $.extend(DX.utils, {
            wrapToArray: wrapToArray,
            removeDublicates: removeDublicates
        })
    })(jQuery, DevExpress);
    /*! Module core, file devices.js */
    (function($, DX, undefined) {
        var KNOWN_UA_TABLE = {
                iPhone: "iPhone",
                iPhone5: "iPhone",
                iPhone6: "iPhone",
                iPhone6plus: "iPhone",
                iPad: "iPad",
                iPadMini: "iPad Mini",
                androidPhone: "Android Mobile",
                androidTablet: "Android",
                win8: "MSAppHost",
                win8Phone: "Windows Phone 8",
                msSurface: "MSIE ARM Tablet PC",
                desktop: "desktop",
                tizen: "Tizen Mobile"
            };
        var DEFAULT_DEVICE = {
                deviceType: "",
                platform: "",
                version: [],
                phone: false,
                tablet: false,
                android: false,
                ios: false,
                win8: false,
                tizen: false,
                generic: false,
                mac: false
            };
        var GENERIC_DEVICE = $.extend(DEFAULT_DEVICE, {
                platform: "generic",
                deviceType: "desktop",
                generic: true
            });
        var uaParsers = {
                win8: function(userAgent) {
                    var isPhone = /windows phone/i.test(userAgent),
                        isTablet = !isPhone && /arm(.*)trident/i.test(userAgent),
                        isDesktop = !isPhone && !isTablet && /msapphost/i.test(userAgent);
                    if (!(isPhone || isTablet || isDesktop))
                        return;
                    var matches = userAgent.match(/windows phone (\d+).(\d+)/i) || userAgent.match(/windows nt (\d+).(\d+)/i),
                        version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10)] : [];
                    return {
                            deviceType: isPhone ? "phone" : isTablet ? "tablet" : "desktop",
                            platform: "win8",
                            version: version
                        }
                },
                ios: function(userAgent) {
                    if (!/ip(hone|od|ad)/i.test(userAgent))
                        return;
                    var isPhone = /ip(hone|od)/i.test(userAgent);
                    var matches = userAgent.match(/os (\d+)_(\d+)_?(\d+)?/i);
                    var version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [];
                    return {
                            deviceType: isPhone ? "phone" : "tablet",
                            platform: "ios",
                            version: version
                        }
                },
                android: function(userAgent) {
                    if (!/android|htc_|silk/i.test(userAgent))
                        return;
                    var isPhone = /mobile/i.test(userAgent);
                    var matches = userAgent.match(/android (\d+)\.(\d+)\.?(\d+)?/i);
                    var version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [];
                    return {
                            deviceType: isPhone ? "phone" : "tablet",
                            platform: "android",
                            version: version
                        }
                },
                tizen: function(userAgent) {
                    if (!/tizen/i.test(userAgent))
                        return;
                    var isPhone = /mobile/i.test(userAgent);
                    var matches = userAgent.match(/tizen (\d+)\.(\d+)/i);
                    var version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10)] : [];
                    return {
                            deviceType: isPhone ? "phone" : "tablet",
                            platform: "tizen",
                            version: version
                        }
                }
            };
        DX.Devices = DX.Class.inherit({
            ctor: function(options) {
                this._window = options && options.window || window;
                this._realDevice = this._getDevice();
                this._currentDevice = undefined;
                this._currentOrientation = undefined;
                this.orientationChanged = $.Callbacks();
                this._callbacksToEvents("Devices", ["orientationChanged"]);
                this._recalculateOrientation();
                DX.utils.windowResizeCallbacks.add($.proxy(this._recalculateOrientation, this))
            },
            current: function(deviceOrName) {
                if (deviceOrName) {
                    this._currentDevice = this._getDevice(deviceOrName);
                    DX.ui.themes.init({_autoInit: true})
                }
                else {
                    if (!this._currentDevice) {
                        deviceOrName = undefined;
                        try {
                            deviceOrName = this._getDeviceOrNameFromWindowScope()
                        }
                        catch(e) {
                            deviceOrName = this._getDeviceNameFromSessionStorage()
                        }
                        finally {
                            if (!deviceOrName)
                                deviceOrName = this._getDeviceNameFromSessionStorage()
                        }
                        this._currentDevice = this._getDevice(deviceOrName)
                    }
                    return this._currentDevice
                }
            },
            real: function() {
                var forceDevice = arguments[0];
                if ($.isPlainObject(forceDevice)) {
                    $.extend(this._realDevice, forceDevice);
                    return
                }
                return $.extend({}, this._realDevice)
            },
            orientation: function() {
                return this._currentOrientation
            },
            isRippleEmulator: function() {
                return !!this._window.tinyHippos
            },
            _getCssClasses: function(device) {
                var result = [];
                var realDevice = this._realDevice;
                device = device || this.current();
                if (device.deviceType)
                    result.push("dx-device-" + device.deviceType);
                result.push("dx-device-" + realDevice.platform);
                if (realDevice.version && realDevice.version.length)
                    result.push("dx-device-" + realDevice.platform + "-" + realDevice.version[0]);
                if (DX.devices.isSimulator())
                    result.push("dx-simulator");
                if (DX.rtlEnabled)
                    result.push("dx-rtl");
                return result
            },
            attachCssClasses: function(element, device) {
                $(element).addClass(this._getCssClasses(device).join(" "))
            },
            detachCssClasses: function(element, device) {
                $(element).removeClass(this._getCssClasses(device).join(" "))
            },
            isSimulator: function() {
                try {
                    return this._isSimulator || this._window.top !== this._window.self && this._window.top["dx-force-device"] || this.isRippleEmulator()
                }
                catch(e) {
                    return false
                }
            },
            forceSimulator: function() {
                this._isSimulator = true
            },
            _getDevice: function(deviceName) {
                if (deviceName === "genericPhone")
                    deviceName = {
                        deviceType: "phone",
                        platform: "generic",
                        generic: true
                    };
                if ($.isPlainObject(deviceName))
                    return this._fromConfig(deviceName);
                else {
                    var ua;
                    if (deviceName) {
                        ua = KNOWN_UA_TABLE[deviceName];
                        if (!ua)
                            throw DX.Error("E0005");
                    }
                    else
                        ua = navigator.userAgent;
                    return this._fromUA(ua)
                }
            },
            _getDeviceOrNameFromWindowScope: function() {
                var result;
                if (this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"])
                    result = this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"];
                return result
            },
            _getDeviceNameFromSessionStorage: function() {
                var sessionStorage = this._window.sessionStorage;
                if (!sessionStorage)
                    return;
                var deviceOrName = sessionStorage.getItem("dx-force-device");
                try {
                    var deviceObject = $.parseJSON(deviceOrName)
                }
                catch(ex) {
                    return deviceOrName
                }
                return deviceObject
            },
            _fromConfig: function(config) {
                var shortcuts = {
                        phone: config.deviceType === "phone",
                        tablet: config.deviceType === "tablet",
                        android: config.platform === "android",
                        ios: config.platform === "ios",
                        win8: config.platform === "win8",
                        tizen: config.platform === "tizen",
                        generic: config.platform === "generic"
                    };
                return $.extend({}, DEFAULT_DEVICE, this._currentDevice, shortcuts, config)
            },
            _fromUA: function(ua) {
                var config;
                $.each(uaParsers, function(platform, parser) {
                    config = parser(ua);
                    return !config
                });
                if (config)
                    return this._fromConfig(config);
                var isMac = /(mac os)/.test(ua.toLowerCase()),
                    deviceWithOS = DEFAULT_DEVICE;
                deviceWithOS.mac = isMac;
                return deviceWithOS
            },
            _changeOrientation: function() {
                var $window = $(this._window),
                    orientation = $window.height() > $window.width() ? "portrait" : "landscape";
                if (this._currentOrientation === orientation)
                    return;
                this._currentOrientation = orientation;
                this.orientationChanged.fire({orientation: orientation})
            },
            _recalculateOrientation: function() {
                var windowWidth = $(this._window).width();
                if (this._currentWidth === windowWidth)
                    return;
                this._currentWidth = windowWidth;
                this._changeOrientation()
            }
        }).include(DX.EventsMixin);
        DX.devices = new DX.Devices;
        DX.viewPortChanged.add(function(viewPort, prevViewport) {
            DX.devices.detachCssClasses(prevViewport);
            DX.devices.attachCssClasses(viewPort)
        })
    })(jQuery, DevExpress);
    /*! Module core, file browser.js */
    (function($, DX, global, undefined) {
        var webkitRegExp = /(webkit)[ \/]([\w.]+)/,
            operaRegExp = /(opera)(?:.*version)?[ \/]([\w.]+)/,
            ieRegExp = /(msie) (\d{1,2}\.\d)/,
            ie11RegExp = /(trident).*rv:(\d{1,2}\.\d)/,
            mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))?/;
        var ua = navigator.userAgent.toLowerCase();
        var browser = function() {
                var result = {},
                    matches = webkitRegExp.exec(ua) || operaRegExp.exec(ua) || ieRegExp.exec(ua) || ie11RegExp.exec(ua) || ua.indexOf("compatible") < 0 && mozillaRegExp.exec(ua) || [],
                    browserName = matches[1],
                    browserVersion = matches[2];
                if (browserName === "trident")
                    browserName = "msie";
                if (browserName) {
                    result[browserName] = true;
                    result.version = browserVersion
                }
                return result
            }();
        DX.browser = browser
    })(jQuery, DevExpress, this);
    /*! Module core, file support.js */
    (function($, DX, window) {
        var jsPrefixes = ["", "Webkit", "Moz", "O", "ms"],
            cssPrefixes = {
                Webkit: "-webkit-",
                Moz: "-moz-",
                O: "-o-",
                ms: "-ms-"
            },
            styles = document.createElement("dx").style;
        var transitionEndEventNames = {
                WebkitTransition: 'webkitTransitionEnd',
                MozTransition: 'transitionend',
                OTransition: 'oTransitionEnd',
                msTransition: 'MsTransitionEnd',
                transition: 'transitionend'
            };
        var forEachPrefixes = function(prop, callBack) {
                prop = DX.inflector.camelize(prop, true);
                var result;
                for (var i = 0, cssPrefixesCount = jsPrefixes.length; i < cssPrefixesCount; i++) {
                    result = callBack(jsPrefixes[i] + prop, jsPrefixes[i]);
                    if (result)
                        return result
                }
            };
        var styleProp = function(prop) {
                return forEachPrefixes(prop, function(specific) {
                        if (specific in styles)
                            return specific
                    })
            };
        var stylePropPrefix = function(prop) {
                return forEachPrefixes(prop, function(specific, jsPrefix) {
                        if (specific in styles)
                            return cssPrefixes[jsPrefix]
                    }) || ""
            };
        var supportProp = function(prop) {
                return !!styleProp(prop)
            };
        var isNativeScrollingSupported = function(device) {
                var realDevice = DX.devices.real(),
                    realPlatform = realDevice.platform,
                    realVersion = realDevice.version,
                    isObsoleteAndroid = realVersion && realVersion[0] < 4 && realPlatform === "android",
                    isNativeScrollDevice = !isObsoleteAndroid && $.inArray(realPlatform, ["ios", "android", "win8"]) > -1 || realDevice.mac;
                return isNativeScrollDevice
            };
        DX.support = {
            touchEvents: "ontouchstart" in window,
            touch: "ontouchstart" in window || !!window.navigator.msMaxTouchPoints,
            pointer: window.navigator.pointerEnabled || window.navigator.msPointerEnabled,
            transform: supportProp("transform"),
            transition: supportProp("transition"),
            transitionEndEventName: transitionEndEventNames[styleProp("transition")],
            animation: supportProp("animation"),
            nativeScrolling: isNativeScrollingSupported(),
            winJS: "WinJS" in window,
            styleProp: styleProp,
            stylePropPrefix: stylePropPrefix,
            supportProp: supportProp,
            hasKo: !!window.ko,
            hasNg: !window.ko && !!window.angular,
            inputType: function(type) {
                if (type === "text")
                    return true;
                var input = document.createElement("input");
                try {
                    input.setAttribute("type", type);
                    input.value = "wrongValue";
                    return !input.value
                }
                catch(e) {
                    return false
                }
            }
        }
    })(jQuery, DevExpress, this);
    /*! Module core, file position.js */
    (function($, DX, undefined) {
        var horzRe = /left|right/,
            vertRe = /top|bottom/,
            collisionRe = /fit|flip|none/;
        var normalizeAlign = function(raw) {
                var result = {
                        h: "center",
                        v: "center"
                    };
                var pair = DX.utils.splitPair(raw);
                if (pair)
                    $.each(pair, function() {
                        var w = String(this).toLowerCase();
                        if (horzRe.test(w))
                            result.h = w;
                        else if (vertRe.test(w))
                            result.v = w
                    });
                return result
            };
        var normalizeOffset = function(raw) {
                return DX.utils.stringPairToObject(raw)
            };
        var normalizeCollision = function(raw) {
                var pair = DX.utils.splitPair(raw),
                    h = String(pair && pair[0]).toLowerCase(),
                    v = String(pair && pair[1]).toLowerCase();
                if (!collisionRe.test(h))
                    h = "none";
                if (!collisionRe.test(v))
                    v = h;
                return {
                        h: h,
                        v: v
                    }
            };
        var getAlignFactor = function(align) {
                switch (align) {
                    case"center":
                        return 0.5;
                    case"right":
                    case"bottom":
                        return 1;
                    default:
                        return 0
                }
            };
        var inverseAlign = function(align) {
                switch (align) {
                    case"left":
                        return "right";
                    case"right":
                        return "left";
                    case"top":
                        return "bottom";
                    case"bottom":
                        return "top";
                    default:
                        return align
                }
            };
        var calculateOversize = function(data, bounds) {
                var oversize = 0;
                if (data.myLocation < bounds.min)
                    oversize += bounds.min - data.myLocation;
                if (data.myLocation > bounds.max)
                    oversize += data.myLocation - bounds.max;
                return oversize
            };
        var initMyLocation = function(data) {
                data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset
            };
        var decolliders = {
                fit: function(data, bounds) {
                    var result = false;
                    if (data.myLocation > bounds.max) {
                        data.myLocation = bounds.max;
                        result = true
                    }
                    if (data.myLocation < bounds.min) {
                        data.myLocation = bounds.min;
                        result = true
                    }
                    return result
                },
                flip: function(data, bounds) {
                    if (data.myAlign === "center" && data.atAlign === "center")
                        return false;
                    if (data.myLocation < bounds.min || data.myLocation > bounds.max) {
                        var inverseData = $.extend({}, data, {
                                myAlign: inverseAlign(data.myAlign),
                                atAlign: inverseAlign(data.atAlign),
                                offset: -data.offset
                            });
                        initMyLocation(inverseData);
                        inverseData.oversize = calculateOversize(inverseData, bounds);
                        if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || inverseData.myLocation > data.myLocation || inverseData.oversize < data.oversize) {
                            data.myLocation = inverseData.myLocation;
                            data.oversize = inverseData.oversize;
                            return true
                        }
                    }
                    return false
                }
            };
        var scrollbarWidth;
        var defaultPositionResult = {
                h: {
                    location: 0,
                    flip: false,
                    fit: false,
                    oversize: 0
                },
                v: {
                    location: 0,
                    flip: false,
                    fit: false,
                    oversize: 0
                }
            };
        var calculatePosition = function(what, options) {
                var $what = $(what),
                    currentOffset = $what.offset(),
                    result = $.extend(true, {}, defaultPositionResult, {
                        h: {location: currentOffset.left},
                        v: {location: currentOffset.top}
                    });
                if (!options)
                    return result;
                var my = normalizeAlign(options.my),
                    at = normalizeAlign(options.at),
                    of = options.of || window,
                    offset = normalizeOffset(options.offset),
                    collision = normalizeCollision(options.collision),
                    boundary = options.boundary,
                    boundaryOffset = normalizeOffset(options.boundaryOffset);
                var h = {
                        mySize: $what.outerWidth(),
                        myAlign: my.h,
                        atAlign: at.h,
                        offset: offset.h,
                        collision: collision.h,
                        boundaryOffset: boundaryOffset.h
                    };
                var v = {
                        mySize: $what.outerHeight(),
                        myAlign: my.v,
                        atAlign: at.v,
                        offset: offset.v,
                        collision: collision.v,
                        boundaryOffset: boundaryOffset.v
                    };
                if (of.preventDefault) {
                    h.atLocation = of.pageX;
                    v.atLocation = of.pageY;
                    h.atSize = 0;
                    v.atSize = 0
                }
                else {
                    of = $(of);
                    if ($.isWindow(of[0])) {
                        h.atLocation = of.scrollLeft();
                        v.atLocation = of.scrollTop();
                        h.atSize = of.width();
                        v.atSize = of.height()
                    }
                    else if (of[0].nodeType === 9) {
                        h.atLocation = 0;
                        v.atLocation = 0;
                        h.atSize = of.width();
                        v.atSize = of.height()
                    }
                    else {
                        var o = of.offset();
                        h.atLocation = o.left;
                        v.atLocation = o.top;
                        h.atSize = of.outerWidth();
                        v.atSize = of.outerHeight()
                    }
                }
                initMyLocation(h);
                initMyLocation(v);
                var bounds = function() {
                        var win = $(window),
                            windowWidth = win.width(),
                            windowHeight = win.height(),
                            left = win.scrollLeft(),
                            top = win.scrollTop(),
                            hScrollbar = document.width > document.documentElement.clientWidth,
                            vScrollbar = document.height > document.documentElement.clientHeight,
                            hZoomLevel = DX.support.touch ? document.documentElement.clientWidth / (vScrollbar ? windowWidth - scrollbarWidth : windowWidth) : 1,
                            vZoomLevel = DX.support.touch ? document.documentElement.clientHeight / (hScrollbar ? windowHeight - scrollbarWidth : windowHeight) : 1;
                        if (scrollbarWidth === undefined)
                            scrollbarWidth = calculateScrollbarWidth();
                        var boundaryWidth = windowWidth,
                            boundaryHeight = windowHeight;
                        if (boundary) {
                            var $boundary = $(boundary),
                                boundaryPosition = $boundary.offset();
                            left += boundaryPosition.left;
                            top += boundaryPosition.top;
                            boundaryWidth = $boundary.width();
                            boundaryHeight = $boundary.height()
                        }
                        return {
                                h: {
                                    min: left + h.boundaryOffset,
                                    max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset
                                },
                                v: {
                                    min: top + v.boundaryOffset,
                                    max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
                                }
                            }
                    }();
                h.oversize = calculateOversize(h, bounds.h);
                v.oversize = calculateOversize(v, bounds.v);
                if (decolliders[h.collision])
                    result.h[h.collision] = decolliders[h.collision](h, bounds.h);
                if (decolliders[v.collision])
                    result.v[v.collision] = decolliders[v.collision](v, bounds.v);
                $.extend(true, result, {
                    h: {
                        location: Math.round(h.myLocation),
                        oversize: Math.round(h.oversize)
                    },
                    v: {
                        location: Math.round(v.myLocation),
                        oversize: Math.round(v.oversize)
                    }
                });
                return result
            };
        var position = function(what, options) {
                var $what = $(what);
                if (!options)
                    return $what.offset();
                DX.translator.resetPosition($what);
                var offset = $what.offset(),
                    targetPosition = options.h && options.v ? options : calculatePosition($what, options);
                DX.translator.move($what, {
                    left: Math.round(targetPosition.h.location - offset.left),
                    top: Math.round(targetPosition.v.location - offset.top)
                });
                return targetPosition
            };
        $.extend(DX, {
            calculatePosition: calculatePosition,
            position: position,
            inverseAlign: inverseAlign
        });
        var calculateScrollbarWidth = function() {
                var $scrollDiv = $("<div>").css({
                        width: 100,
                        height: 100,
                        overflow: "scroll",
                        position: "absolute",
                        top: -9999
                    }).appendTo($("body")),
                    result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
                $scrollDiv.remove();
                return result
            }
    })(jQuery, DevExpress);
    /*! Module core, file action.js */
    (function($, DX, undefined) {
        var actionExecutors = {};
        var registerExecutor = function(name, executor) {
                if ($.isPlainObject(name)) {
                    $.each(name, registerExecutor);
                    return
                }
                actionExecutors[name] = executor
            };
        var unregisterExecutor = function(name) {
                var args = $.makeArray(arguments);
                $.each(args, function() {
                    delete actionExecutors[this]
                })
            };
        registerExecutor({
            func: {execute: function(e) {
                    if ($.isFunction(e.action)) {
                        e.result = e.action.apply(e.context, e.args);
                        e.handled = true
                    }
                }},
            url: {execute: function(e) {
                    if (typeof e.action === "string" && e.action.charAt(0) !== "#")
                        document.location = e.action
                }},
            hash: {execute: function(e) {
                    if (typeof e.action === "string" && e.action.charAt(0) === "#")
                        document.location.hash = e.action
                }}
        });
        var Action = DX.Class.inherit({
                ctor: function(action, config) {
                    config = config || {};
                    this._action = action || $.noop;
                    this._context = config.context || window;
                    this._beforeExecute = config.beforeExecute || $.noop;
                    this._afterExecute = config.afterExecute || $.noop;
                    this._component = config.component;
                    this._excludeValidators = config.excludeValidators;
                    this._validatingTargetName = config.validatingTargetName
                },
                execute: function() {
                    var e = {
                            action: this._action,
                            args: Array.prototype.slice.call(arguments),
                            context: this._context,
                            component: this._component,
                            validatingTargetName: this._validatingTargetName,
                            cancel: false,
                            handled: false
                        };
                    if (!this._validateAction(e))
                        return;
                    this._beforeExecute.call(this._context, e);
                    if (e.cancel)
                        return;
                    var result = this._executeAction(e);
                    this._afterExecute.call(this._context, e);
                    return result
                },
                _validateAction: function(e) {
                    var excludeValidators = this._excludeValidators;
                    $.each(actionExecutors, function(name, executor) {
                        if (excludeValidators && $.inArray(name, excludeValidators) > -1)
                            return;
                        if (executor.validate)
                            executor.validate(e);
                        if (e.cancel)
                            return false
                    });
                    return !e.cancel
                },
                _executeAction: function(e) {
                    var result;
                    $.each(actionExecutors, function(index, executor) {
                        if (executor.execute)
                            executor.execute(e);
                        if (e.handled) {
                            result = e.result;
                            return false
                        }
                    });
                    return result
                }
            });
        $.extend(DX, {
            registerActionExecutor: registerExecutor,
            unregisterActionExecutor: unregisterExecutor,
            Action: Action
        });
        DX.__internals = {actionExecutors: actionExecutors}
    })(jQuery, DevExpress);
    /*! Module core, file translator.js */
    (function($, DX, undefined) {
        var support = DX.support,
            TRANSLATOR_DATA_KEY = "dxTranslator",
            TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/,
            TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
        var locate = function($element) {
                var translate = support.transform ? getTranslate($element) : getTranslateFallback($element);
                return {
                        left: translate.x,
                        top: translate.y
                    }
            };
        var move = function($element, position) {
                if (!support.transform) {
                    $element.css(position);
                    return
                }
                var translate = getTranslate($element),
                    left = position.left,
                    top = position.top;
                if (left !== undefined)
                    translate.x = left || 0;
                if (top !== undefined)
                    translate.y = top || 0;
                $element.css({transform: getTranslateCss(translate)});
                if (isPersentValue(left) || isPersentValue(top))
                    clearCache($element)
            };
        var isPersentValue = function(value) {
                return $.type(value) === "string" && value[value.length - 1] === "%"
            };
        var getTranslateFallback = function($element) {
                var result;
                try {
                    var originalTop = $element.css("top"),
                        originalLeft = $element.css("left");
                    var position = $element.position();
                    $element.css({
                        transform: "none",
                        top: 0,
                        left: 0
                    });
                    clearCache($element);
                    var finalPosition = $element.position();
                    result = {
                        x: position.left - finalPosition.left || parseInt(originalLeft) || 0,
                        y: position.top - finalPosition.top || parseInt(originalTop) || 0
                    };
                    $element.css({
                        top: originalTop,
                        left: originalLeft
                    })
                }
                catch(e) {
                    result = {
                        x: 0,
                        y: 0
                    }
                }
                return result
            };
        var getTranslate = function($element) {
                var result = $element.data(TRANSLATOR_DATA_KEY);
                if (!result) {
                    var transformValue = $element.css("transform") || getTranslateCss({
                            x: 0,
                            y: 0
                        }),
                        matrix = transformValue.match(TRANSFORM_MATRIX_REGEX),
                        is3D = matrix && matrix[1];
                    if (matrix) {
                        matrix = matrix[2].split(",");
                        if (is3D === "3d")
                            matrix = matrix.slice(12, 15);
                        else {
                            matrix.push(0);
                            matrix = matrix.slice(4, 7)
                        }
                    }
                    else
                        matrix = [0, 0, 0];
                    result = {
                        x: parseFloat(matrix[0]),
                        y: parseFloat(matrix[1]),
                        z: parseFloat(matrix[2])
                    };
                    cacheTranslate($element, result)
                }
                return result
            };
        var cacheTranslate = function($element, translate) {
                $element.data(TRANSLATOR_DATA_KEY, translate)
            };
        var clearCache = function($element) {
                $element.removeData(TRANSLATOR_DATA_KEY)
            };
        var resetPosition = function($element) {
                $element.css({
                    left: 0,
                    top: 0,
                    transform: "none"
                });
                clearCache($element)
            };
        var parseTranslate = function(translateString) {
                var result = translateString.match(TRANSLATE_REGEX);
                if (!result || !result[1])
                    return;
                result = result[1].split(",");
                result = {
                    x: parseFloat(result[0]),
                    y: parseFloat(result[1]),
                    z: parseFloat(result[2])
                };
                return result
            };
        var getTranslateCss = function(translate) {
                translate.x = translate.x || 0;
                translate.y = translate.y || 0;
                var xValueString = isPersentValue(translate.x) ? translate.x : translate.x + "px";
                var yValueString = isPersentValue(translate.y) ? translate.y : translate.y + "px";
                return "translate(" + xValueString + ", " + yValueString + ")"
            };
        DX.translator = {
            move: move,
            locate: locate,
            clearCache: clearCache,
            parseTranslate: parseTranslate,
            getTranslate: getTranslate,
            getTranslateCss: getTranslateCss,
            resetPosition: resetPosition
        }
    })(jQuery, DevExpress);
    /*! Module core, file animationFrame.js */
    (function($, DX, undefined) {
        var FRAME_ANIMATION_STEP_TIME = 1000 / 60,
            requestAnimationFrame = function(callback) {
                return this.setTimeout(callback, FRAME_ANIMATION_STEP_TIME)
            },
            cancelAnimationFrame = function(requestID) {
                this.clearTimeout(requestID)
            },
            nativeRequestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame,
            nativeCancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
        if (nativeRequestAnimationFrame && nativeCancelAnimationFrame) {
            requestAnimationFrame = nativeRequestAnimationFrame;
            cancelAnimationFrame = nativeCancelAnimationFrame
        }
        if (nativeRequestAnimationFrame && !nativeCancelAnimationFrame) {
            var cancelledRequests = {};
            requestAnimationFrame = function(callback) {
                var requestId = nativeRequestAnimationFrame.call(window, function() {
                        try {
                            if (requestId in cancelledRequests)
                                return;
                            callback.apply(this, arguments)
                        }
                        finally {
                            delete cancelledRequests[requestId]
                        }
                    });
                return requestId
            };
            cancelAnimationFrame = function(requestId) {
                cancelledRequests[requestId] = true
            }
        }
        requestAnimationFrame = $.proxy(requestAnimationFrame, window);
        cancelAnimationFrame = $.proxy(cancelAnimationFrame, window);
        $.extend(DX, {
            requestAnimationFrame: requestAnimationFrame,
            cancelAnimationFrame: cancelAnimationFrame
        })
    })(jQuery, DevExpress);
    /*! Module core, file animator.js */
    (function($, DX, undefined) {
        DX.Animator = DX.Class.inherit({
            ctor: function() {
                this._finished = true;
                this._stopped = false
            },
            start: function() {
                this._stopped = false;
                this._finished = false;
                this._stepCore()
            },
            stop: function() {
                this._stopped = true
            },
            _stepCore: function() {
                if (this._isStopped()) {
                    this._stop();
                    return
                }
                if (this._isFinished()) {
                    this._finished = true;
                    this._complete();
                    return
                }
                this._step();
                DX.requestAnimationFrame.call(window, $.proxy(this._stepCore, this))
            },
            _step: DX.abstract,
            _isFinished: $.noop,
            _stop: $.noop,
            _complete: $.noop,
            _isStopped: function() {
                return this._stopped
            },
            inProgress: function() {
                return !(this._stopped || this._finished)
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file fx.js */
    (function($, DX, undefined) {
        var translator = DX.translator,
            support = DX.support,
            transitionEndEventName = support.transitionEndEventName + ".dxFX";
        var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/,
            RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i,
            ANIM_DATA_KEY = "dxAnimData",
            ANIM_QUEUE_KEY = "dxAnimQueue",
            TRANSFORM_PROP = "transform";
        var TransitionAnimationStrategy = {
                animate: function($element, config) {
                    var that = this,
                        deferred = $.Deferred();
                    config.transitionAnimation = {finish: function() {
                            that._cleanup($element, config);
                            deferred.resolveWith($element, [config, $element])
                        }};
                    this._startAnimation($element, config);
                    this._completeAnimationCallback($element, config).done(function() {
                        config.transitionAnimation.finish()
                    });
                    if (!config.duration)
                        config.transitionAnimation.finish();
                    return deferred.promise()
                },
                _completeAnimationCallback: function($element, config) {
                    var startTime = $.now() + config.delay,
                        deferred = $.Deferred(),
                        transitionEndFired = $.Deferred(),
                        simulatedTransitionEndFired = $.Deferred();
                    $element.one(transitionEndEventName, function(e) {
                        if ($.now() - startTime >= config.duration)
                            transitionEndFired.reject()
                    });
                    config.transitionAnimation.simulatedEndEventTimer = setTimeout(function() {
                        simulatedTransitionEndFired.reject()
                    }, config.duration + config.delay);
                    $.when(transitionEndFired, simulatedTransitionEndFired).fail($.proxy(function() {
                        deferred.resolve()
                    }, this));
                    return deferred.promise()
                },
                _startAnimation: function($element, config) {
                    $element.css("transform");
                    $element.css({
                        transitionProperty: "all",
                        transitionDelay: config.delay + "ms",
                        transitionDuration: config.duration + "ms",
                        transitionTimingFunction: config.easing
                    });
                    setProps($element, config.to)
                },
                _cleanup: function($element, config) {
                    $element.css("transition", "none").off(transitionEndEventName);
                    clearTimeout(config.transitionAnimation.simulatedEndEventTimer)
                },
                stop: function($element, config, jumpToEnd) {
                    if (!config)
                        return;
                    if (jumpToEnd)
                        config.transitionAnimation.finish();
                    else {
                        $.each(config.to, function(key) {
                            $element.css(key, $element.css(key))
                        });
                        this._cleanup($element, config)
                    }
                }
            };
        var FrameAnimationStrategy = {
                animate: function($element, config) {
                    var deferred = $.Deferred(),
                        that = this;
                    if (!config)
                        return deferred.reject().promise();
                    $.each(config.to, function(prop) {
                        if (config.from[prop] === undefined)
                            config.from[prop] = that._normalizeValue($element.css(prop))
                    });
                    if (config.to[TRANSFORM_PROP]) {
                        config.from[TRANSFORM_PROP] = that._parseTransform(config.from[TRANSFORM_PROP]);
                        config.to[TRANSFORM_PROP] = that._parseTransform(config.to[TRANSFORM_PROP])
                    }
                    config.frameAnimation = {
                        to: config.to,
                        from: config.from,
                        currentValue: config.from,
                        easing: convertTransitionTimingFuncToJQueryEasing(config.easing),
                        duration: config.duration,
                        startTime: (new Date).valueOf(),
                        finish: function() {
                            this.currentValue = this.to;
                            this.draw();
                            deferred.resolve()
                        },
                        draw: function() {
                            var currentValue = $.extend({}, this.currentValue);
                            if (currentValue[TRANSFORM_PROP])
                                currentValue[TRANSFORM_PROP] = $.map(currentValue[TRANSFORM_PROP], function(value, prop) {
                                    if (prop === "translate")
                                        return translator.getTranslateCss(value);
                                    else if (prop === "scale")
                                        return "scale(" + value + ")";
                                    else if (prop.substr(0, prop.length - 1) === "rotate")
                                        return prop + "(" + value + "deg)"
                                }).join(" ");
                            $element.css(currentValue)
                        }
                    };
                    if (config.delay) {
                        config.frameAnimation.startTime += config.delay;
                        config.frameAnimation.delayTimeout = setTimeout(function() {
                            that._animationStep($element, config)
                        }, config.delay)
                    }
                    else
                        that._animationStep($element, config);
                    return deferred.promise()
                },
                _parseTransform: function(transformString) {
                    var result = {};
                    $.each(transformString.match(/(\w|\d)+\([^\)]*\)\s*/g), function(i, part) {
                        var translateData = translator.parseTranslate(part),
                            scaleData = part.match(/scale\((.+?)\)/),
                            rotateData = part.match(/(rotate.)\((.+)deg\)/);
                        if (translateData)
                            result.translate = translateData;
                        if (scaleData && scaleData[1])
                            result.scale = parseFloat(scaleData[1]);
                        if (rotateData && rotateData[1])
                            result[rotateData[1]] = parseFloat(rotateData[2])
                    });
                    return result
                },
                stop: function($element, config, jumpToEnd) {
                    var frameAnimation = config && config.frameAnimation;
                    if (!frameAnimation)
                        return;
                    clearTimeout(frameAnimation.delayTimeout);
                    if (jumpToEnd)
                        frameAnimation.finish();
                    delete config.frameAnimation
                },
                _animationStep: function($element, config) {
                    var frameAnimation = config && config.frameAnimation;
                    if (!frameAnimation)
                        return;
                    var now = (new Date).valueOf();
                    if (now >= frameAnimation.startTime + frameAnimation.duration) {
                        frameAnimation.finish();
                        return
                    }
                    frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
                    frameAnimation.draw();
                    DX.requestAnimationFrame($.proxy(function() {
                        this._animationStep($element, config)
                    }, this))
                },
                _calcStepValue: function(frameAnimation, currentDuration) {
                    var calcValueRecursively = function(from, to) {
                            var result = $.isArray(to) ? [] : {};
                            var calcEasedValue = function(propName) {
                                    var x = currentDuration / frameAnimation.duration,
                                        t = currentDuration,
                                        b = 1 * from[propName],
                                        c = to[propName] - from[propName],
                                        d = frameAnimation.duration;
                                    return $.easing[frameAnimation.easing](x, t, b, c, d)
                                };
                            $.each(to, function(propName, endPropValue) {
                                if (typeof endPropValue === "string" && parseFloat(endPropValue, 10) === false)
                                    return true;
                                result[propName] = typeof endPropValue === "object" ? calcValueRecursively(from[propName], endPropValue) : calcEasedValue(propName)
                            });
                            return result
                        };
                    return calcValueRecursively(frameAnimation.from, frameAnimation.to)
                },
                _normalizeValue: function(value) {
                    var numericValue = parseFloat(value, 10);
                    if (numericValue === false)
                        return value;
                    return numericValue
                }
            };
        var animationStrategies = {
                transition: support.transition ? TransitionAnimationStrategy : FrameAnimationStrategy,
                frame: FrameAnimationStrategy
            };
        var getAnimationStrategy = function(config) {
                return animationStrategies[config && config.strategy || "transition"]
            };
        var TransitionTimingFuncMap = {
                linear: "cubic-bezier(0, 0, 1, 1)",
                ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
                "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
                "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
                "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
            };
        var convertTransitionTimingFuncToJQueryEasing = function(cssTransitionEasing) {
                cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
                var bezCoeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
                if (!bezCoeffs)
                    return "linear";
                bezCoeffs = bezCoeffs.slice(1, 5);
                $.each(bezCoeffs, function(index, value) {
                    bezCoeffs[index] = parseFloat(value)
                });
                var easingName = "cubicbezier_" + bezCoeffs.join("_").replace(/\./g, "p");
                if (!$.isFunction($.easing[easingName])) {
                    var polynomBezier = function(x1, y1, x2, y2) {
                            var Cx = 3 * x1,
                                Bx = 3 * (x2 - x1) - Cx,
                                Ax = 1 - Cx - Bx,
                                Cy = 3 * y1,
                                By = 3 * (y2 - y1) - Cy,
                                Ay = 1 - Cy - By;
                            var bezierX = function(t) {
                                    return t * (Cx + t * (Bx + t * Ax))
                                };
                            var bezierY = function(t) {
                                    return t * (Cy + t * (By + t * Ay))
                                };
                            var findXfor = function(t) {
                                    var x = t,
                                        i = 0,
                                        z;
                                    while (i < 14) {
                                        z = bezierX(x) - t;
                                        if (Math.abs(z) < 1e-3)
                                            break;
                                        x = x - z / derivativeX(x);
                                        i++
                                    }
                                    return x
                                };
                            var derivativeX = function(t) {
                                    return Cx + t * (2 * Bx + t * 3 * Ax)
                                };
                            return function(t) {
                                    return bezierY(findXfor(t))
                                }
                        };
                    $.easing[easingName] = function(x, t, b, c, d) {
                        return c * polynomBezier(bezCoeffs[0], bezCoeffs[1], bezCoeffs[2], bezCoeffs[3])(t / d) + b
                    }
                }
                return easingName
            };
        var baseConfigValidator = function(config, animationType) {
                $.each(["from", "to"], function() {
                    if (!$.isPlainObject(config[this]))
                        throw DX.Error("E0010", animationType, this);
                })
            };
        var CustomAnimationConfigurator = {setup: function($element, config){}};
        var positionAliases = {
                top: {
                    my: "bottom center",
                    at: "top center"
                },
                bottom: {
                    my: "top center",
                    at: "bottom center"
                },
                right: {
                    my: "left center",
                    at: "right center"
                },
                left: {
                    my: "right center",
                    at: "left center"
                }
            };
        var SlideAnimationConfigurator = {
                validateConfig: function(config) {
                    baseConfigValidator(config, "slide")
                },
                setup: function($element, config) {
                    var location = translator.locate($element);
                    if (config.type !== "slide") {
                        var positioningConfig = config.type === "slideIn" ? config.from : config.to;
                        positioningConfig.position = $.extend({of: window}, positionAliases[config.direction]);
                        setupPosition($element, positioningConfig)
                    }
                    this._setUpConfig(location, config.from);
                    this._setUpConfig(location, config.to);
                    translator.clearCache($element);
                    if (!support.transform && $element.css("position") === "static")
                        $element.css("position", "relative")
                },
                _setUpConfig: function(location, config) {
                    config.left = "left" in config ? config.left : "+=0";
                    config.top = "top" in config ? config.top : "+=0";
                    this._initNewPosition(location, config)
                },
                _initNewPosition: function(location, config) {
                    var position = {
                            left: config.left,
                            top: config.top
                        };
                    delete config.left;
                    delete config.top;
                    var relativeValue = this._getRelativeValue(position.left);
                    if (relativeValue !== undefined)
                        position.left = relativeValue + location.left;
                    else
                        config.left = 0;
                    relativeValue = this._getRelativeValue(position.top);
                    if (relativeValue !== undefined)
                        position.top = relativeValue + location.top;
                    else
                        config.top = 0;
                    var translate = {
                            x: 0,
                            y: 0
                        };
                    if (support.transform)
                        translate = {
                            x: position.left,
                            y: position.top
                        };
                    else {
                        config.left = position.left;
                        config.top = position.top
                    }
                    config[TRANSFORM_PROP] = translator.getTranslateCss(translate)
                },
                _getRelativeValue: function(value) {
                    var relativeValue;
                    if (typeof value === "string" && (relativeValue = RELATIVE_VALUE_REGEX.exec(value)))
                        return parseInt(relativeValue[1] + "1") * relativeValue[2]
                }
            };
        var FadeAnimationConfigurator = {setup: function($element, config) {
                    var from = config.from,
                        fromOpacity = $.isPlainObject(from) ? $element.css("opacity") : String(from),
                        toOpacity;
                    switch (config.type) {
                        case"fadeIn":
                            toOpacity = 1;
                            break;
                        case"fadeOut":
                            toOpacity = 0;
                            break;
                        default:
                            toOpacity = String(config.to)
                    }
                    config.from = {
                        visibility: "visible",
                        opacity: fromOpacity
                    };
                    config.to = {opacity: toOpacity}
                }};
        var PopAnimationConfigurator = {
                validateConfig: function(config) {
                    baseConfigValidator(config, "pop")
                },
                setup: function($element, config) {
                    var from = config.from,
                        to = config.to,
                        fromOpacity = "opacity" in from ? from.opacity : $element.css("opacity"),
                        toOpacity = "opacity" in to ? to.opacity : 1,
                        fromScale = "scale" in from ? from.scale : 0,
                        toScale = "scale" in to ? to.scale : 1;
                    config.from = {opacity: fromOpacity};
                    var translate = translator.getTranslate($element);
                    config.from[TRANSFORM_PROP] = this._getCssTransform(translate, fromScale);
                    config.to = {opacity: toOpacity};
                    config.to[TRANSFORM_PROP] = this._getCssTransform(translate, toScale)
                },
                _getCssTransform: function(translate, scale) {
                    return translator.getTranslateCss(translate) + "scale(" + scale + ")"
                }
            };
        var animationConfigurators = {
                custom: CustomAnimationConfigurator,
                slide: SlideAnimationConfigurator,
                slideIn: SlideAnimationConfigurator,
                slideOut: SlideAnimationConfigurator,
                fade: FadeAnimationConfigurator,
                fadeIn: FadeAnimationConfigurator,
                fadeOut: FadeAnimationConfigurator,
                pop: PopAnimationConfigurator
            };
        var getAnimationConfigurator = function(type) {
                var result = animationConfigurators[type];
                if (!result)
                    throw DX.Error("E0011", type);
                return result
            };
        var defaultConfig = {
                type: "custom",
                from: {},
                to: {},
                duration: 400,
                start: $.noop,
                complete: $.noop,
                easing: "ease",
                delay: 0
            };
        var animate = function(element, config) {
                var $element = $(element);
                config = $.extend(true, {}, defaultConfig, config);
                if (!$element.length)
                    return $.Deferred().resolve().promise();
                var configurator = getAnimationConfigurator(config.type);
                if ($.isFunction(configurator.validateConfig))
                    configurator.validateConfig(config);
                return pushInAnimationQueue($element, config)
            };
        var pushInAnimationQueue = function($element, config) {
                config.deferred = config.deferred || $.Deferred();
                var queueData = getAnimQueueData($element);
                writeAnimQueueData($element, queueData);
                queueData.push(config);
                if (!isAnimating($element))
                    shiftFromAnimationQueue($element, queueData);
                return config.deferred.promise()
            };
        var getAnimQueueData = function($element) {
                return $element.data(ANIM_QUEUE_KEY) || []
            };
        var writeAnimQueueData = function($element, queueData) {
                $element.data(ANIM_QUEUE_KEY, queueData)
            };
        var destroyAnimQueueData = function($element) {
                $element.removeData(ANIM_QUEUE_KEY)
            };
        var isAnimating = function($element) {
                return !!$element.data(ANIM_DATA_KEY)
            };
        var shiftFromAnimationQueue = function($element, queueData) {
                var queueData = getAnimQueueData($element);
                if (!queueData.length)
                    return;
                var config = queueData.shift();
                if (queueData.length === 0)
                    destroyAnimQueueData($element);
                executeAnimation($element, config).done(function() {
                    shiftFromAnimationQueue($element)
                })
            };
        var executeAnimation = function($element, config) {
                setupPosition($element, config.from);
                setupPosition($element, config.to);
                var configurator = getAnimationConfigurator(config.type);
                configurator.setup($element, config);
                $element.data(ANIM_DATA_KEY, config);
                if (DX.fx.off)
                    config.duration = 0;
                setProps($element, config.from);
                config.start.apply(this, [$element, config]);
                return getAnimationStrategy(config).animate($element, config).done(function() {
                        $element.removeData(ANIM_DATA_KEY);
                        config.complete.apply(this, [$element, config]);
                        config.deferred.resolveWith(this, [$element, config])
                    })
            };
        var setupPosition = function($element, config) {
                if (!config.position)
                    return;
                var position = DX.calculatePosition($element, config.position),
                    offset = $element.offset(),
                    currentPosition = $element.position();
                $.extend(config, {
                    left: position.h.location - offset.left + currentPosition.left,
                    top: position.v.location - offset.top + currentPosition.top
                });
                delete config.position
            };
        var setProps = function($element, props) {
                $.each(props, function(key, value) {
                    $element.css(key, value)
                })
            };
        var stop = function(element, jumpToEnd) {
                var $element = $(element),
                    queueData = getAnimQueueData($element);
                $.each(queueData, function(_, config) {
                    config.duration = 0
                });
                if (!isAnimating($element))
                    shiftFromAnimationQueue($element, queueData);
                var config = $element.data(ANIM_DATA_KEY);
                getAnimationStrategy(config).stop($element, config, jumpToEnd);
                $element.removeData(ANIM_DATA_KEY);
                destroyAnimQueueData($element)
            };
        DX.fx = {
            off: false,
            animationTypes: animationConfigurators,
            animate: animate,
            isAnimating: isAnimating,
            stop: stop
        };
        DX.fx.__internals = {convertTransitionTimingFuncToJQueryEasing: convertTransitionTimingFuncToJQueryEasing}
    })(jQuery, DevExpress);
    /*! Module core, file endpointSelector.js */
    (function($, DX, undefined) {
        var location = window.location,
            DXPROXY_HOST = "dxproxy.devexpress.com:8000",
            IS_WINJS_ORIGIN = location.protocol === "ms-appx:",
            IS_DXPROXY_ORIGIN = location.host === DXPROXY_HOST,
            IS_LOCAL_ORIGIN = isLocalHostName(location.hostname);
        function isLocalHostName(url) {
            return /^(localhost$|127\.)/i.test(url)
        }
        var extractProxyAppId = function() {
                return location.pathname.split("/")[1]
            };
        var formatProxyUrl = function(localUrl) {
                var urlData = DX.parseUrl(localUrl);
                if (!isLocalHostName(urlData.hostname))
                    return localUrl;
                return "http://" + DXPROXY_HOST + "/" + extractProxyAppId() + "_" + urlData.port + urlData.pathname + urlData.search
            };
        var EndpointSelector = DX.EndpointSelector = function(config) {
                this.config = config
            };
        EndpointSelector.prototype = {urlFor: function(key) {
                var bag = this.config[key];
                if (!bag)
                    throw DX.Error("E0006");
                if (IS_DXPROXY_ORIGIN)
                    return formatProxyUrl(bag.local);
                if (bag.production)
                    if (IS_WINJS_ORIGIN && !Debug.debuggerEnabled || !IS_WINJS_ORIGIN && !IS_LOCAL_ORIGIN)
                        return bag.production;
                return bag.local
            }}
    })(jQuery, DevExpress);
    /*! Module core, file formatHelper.js */
    (function($, DX, undefined) {
        var utils = DX.utils;
        DX.NumericFormat = {
            currency: 'C',
            fixedpoint: 'N',
            exponential: '',
            percent: 'P',
            decimal: 'D'
        };
        DX.LargeNumberFormatPostfixes = {
            1: 'K',
            2: 'M',
            3: 'B',
            4: 'T'
        };
        var MAX_LARGE_NUMBER_POWER = 4,
            DECIMAL_BASE = 10;
        DX.LargeNumberFormatPowers = {
            largenumber: 'auto',
            thousands: 1,
            millions: 2,
            billions: 3,
            trillions: 4
        };
        DX.DateTimeFormat = {
            longdate: 'D',
            longtime: 'T',
            monthandday: 'M',
            monthandyear: 'Y',
            quarterandyear: 'qq',
            shortdate: 'd',
            shorttime: 't',
            millisecond: 'fff',
            second: 'T',
            minute: 't',
            hour: 't',
            day: 'dd',
            week: 'dd',
            month: 'MMMM',
            quarter: 'qq',
            year: 'yyyy',
            longdatelongtime: 'D',
            shortdateshorttime: 'd',
            shortyear: 'yy'
        };
        DX.formatHelper = {
            defaultQuarterFormat: 'Q{0}',
            romanDigits: ['I', 'II', 'III', 'IV'],
            _addFormatSeparator: function(format1, format2) {
                var separator = ' ';
                if (format2)
                    return format1 + separator + format2;
                return format1
            },
            _getDateTimeFormatPattern: function(dateTimeFormat) {
                return Globalize.findClosestCulture().calendar.patterns[DX.DateTimeFormat[dateTimeFormat.toLowerCase()]]
            },
            _isDateFormatContains: function(format) {
                var result = false;
                $.each(DX.DateTimeFormat, function(key, value) {
                    result = key === format.toLowerCase();
                    return !result
                });
                return result
            },
            getQuarter: function(month) {
                return Math.floor(month / 3)
            },
            getFirstQuarterMonth: function(month) {
                return this.getQuarter(month) * 3
            },
            _getQuarterString: function(date, format) {
                var quarter = this.getQuarter(date.getMonth());
                switch (format) {
                    case'q':
                        return this.romanDigits[quarter];
                    case'qq':
                        return utils.stringFormat(this.defaultQuarterFormat, this.romanDigits[quarter]);
                    case'Q':
                        return (quarter + 1).toString();
                    case'QQ':
                        return utils.stringFormat(this.defaultQuarterFormat, (quarter + 1).toString())
                }
                return ''
            },
            _formatCustomString: function(value, format) {
                var regExp = /qq|q|QQ|Q/g,
                    quarterFormat,
                    result = '',
                    index = 0;
                regExp.lastIndex = 0;
                while (index < format.length) {
                    quarterFormat = regExp.exec(format);
                    if (!quarterFormat || quarterFormat.index > index)
                        result += Globalize.format(value, format.substring(index, quarterFormat ? quarterFormat.index : format.length));
                    if (quarterFormat) {
                        result += this._getQuarterString(value, quarterFormat[0]);
                        index = quarterFormat.index + quarterFormat[0].length
                    }
                    else
                        index = format.length
                }
                return result
            },
            _parseNumberFormatString: function(format) {
                var formatList,
                    formatObject = {};
                if (!format || typeof format !== 'string')
                    return;
                formatList = format.toLowerCase().split(' ');
                $.each(formatList, function(index, value) {
                    if (value in DX.NumericFormat)
                        formatObject.formatType = value;
                    else if (value in DX.LargeNumberFormatPowers)
                        formatObject.power = DX.LargeNumberFormatPowers[value]
                });
                if (formatObject.power && !formatObject.formatType)
                    formatObject.formatType = 'fixedpoint';
                if (formatObject.formatType)
                    return formatObject
            },
            _calculateNumberPower: function(value, base, minPower, maxPower) {
                var number = Math.abs(value);
                var power = 0;
                if (number > 1)
                    while (number && number >= base && (maxPower === undefined || power < maxPower)) {
                        power++;
                        number = number / base
                    }
                else if (number > 0 && number < 1)
                    while (number < 1 && (minPower === undefined || power > minPower)) {
                        power--;
                        number = number * base
                    }
                return power
            },
            _getNumberByPower: function(number, power, base) {
                var result = number;
                while (power > 0) {
                    result = result / base;
                    power--
                }
                while (power < 0) {
                    result = result * base;
                    power++
                }
                return result
            },
            _formatNumber: function(value, formatObject, precision) {
                var powerPostfix;
                if (formatObject.power === 'auto')
                    formatObject.power = this._calculateNumberPower(value, 1000, 0, MAX_LARGE_NUMBER_POWER);
                if (formatObject.power)
                    value = this._getNumberByPower(value, formatObject.power, 1000);
                powerPostfix = DX.LargeNumberFormatPostfixes[formatObject.power] || '';
                return this._formatNumberCore(value, formatObject.formatType, precision) + powerPostfix
            },
            _formatNumberExponential: function(value, precision) {
                var power = this._calculateNumberPower(value, DECIMAL_BASE),
                    number = this._getNumberByPower(value, power, DECIMAL_BASE),
                    powString;
                precision = precision === undefined ? 1 : precision;
                if (number.toFixed(precision || 0) >= DECIMAL_BASE) {
                    power++;
                    number = number / DECIMAL_BASE
                }
                powString = (power >= 0 ? '+' : '') + power.toString();
                return this._formatNumberCore(number, 'fixedpoint', precision) + 'E' + powString
            },
            _formatNumberCore: function(value, format, precision) {
                if (format === 'exponential')
                    return this._formatNumberExponential(value, precision);
                else
                    return Globalize.format(value, DX.NumericFormat[format] + (utils.isNumber(precision) ? precision : 0))
            },
            _formatDate: function(date, format, formatString) {
                var resultFormat = DX.DateTimeFormat[format.toLowerCase()];
                format = format.toLowerCase();
                if (format === 'quarterandyear')
                    resultFormat = this._getQuarterString(date, resultFormat) + ' yyyy';
                if (format === 'quarter')
                    return this._getQuarterString(date, resultFormat);
                if (format === 'longdatelongtime')
                    return this._formatDate(date, 'longdate') + ' ' + this._formatDate(date, 'longtime');
                if (format === 'shortdateshorttime')
                    return this._formatDate(date, 'shortDate') + ' ' + this._formatDate(date, 'shortTime');
                return Globalize.format(date, resultFormat)
            },
            format: function(value, format, precision) {
                if (format && format.format)
                    if (format.dateType)
                        return this._formatDateEx(value, format);
                    else if (utils.isNumber(value) && isFinite(value))
                        return this._formatNumberEx(value, format);
                return this._format(value, format, precision)
            },
            _format: function(value, format, precision) {
                var numberFormatObject;
                if (!utils.isString(format) || format === '' || !utils.isNumber(value) && !utils.isDate(value))
                    return utils.isDefined(value) ? value.toString() : '';
                numberFormatObject = this._parseNumberFormatString(format);
                if (utils.isNumber(value) && numberFormatObject)
                    return this._formatNumber(value, numberFormatObject, precision);
                if (utils.isDate(value) && this._isDateFormatContains(format))
                    return this._formatDate(value, format);
                if (!numberFormatObject && !this._isDateFormatContains(format))
                    return this._formatCustomString(value, format)
            },
            _formatNumberEx: function(value, formatInfo) {
                var that = this,
                    numericFormatType = DX.NumericFormat[formatInfo.format.toLowerCase()],
                    numberFormat = Globalize.culture().numberFormat,
                    currencyFormat = formatInfo.currencyCulture && Globalize.cultures[formatInfo.currencyCulture] ? Globalize.cultures[formatInfo.currencyCulture].numberFormat.currency : numberFormat.currency,
                    percentFormat = numberFormat.percent,
                    formatSettings = that._getUnitFormatSettings(value, formatInfo),
                    unit = formatSettings.unit,
                    precision = formatSettings.precision,
                    showTrailingZeros = formatSettings.showTrailingZeros,
                    includeGroupSeparator = formatSettings.includeGroupSeparator,
                    groupSymbol = numberFormat[","],
                    floatingSymbol = numberFormat["."],
                    number,
                    isNegative,
                    pattern,
                    currentFormat,
                    regexParts = /n|\$|-|%/g,
                    result = "";
                if (!utils.isDefined(value))
                    return '';
                value = that._applyUnitToValue(value, unit);
                number = Math.abs(value);
                isNegative = value < 0;
                switch (numericFormatType) {
                    case DX.NumericFormat.decimal:
                        pattern = "n";
                        number = Math[isNegative ? "ceil" : "floor"](number);
                        if (precision > 0) {
                            var str = "" + number;
                            for (var i = str.length; i < precision; i += 1)
                                str = "0" + str;
                            number = str
                        }
                        if (isNegative)
                            number = "-" + number;
                        break;
                    case DX.NumericFormat.fixedpoint:
                        currentFormat = numberFormat;
                    case DX.NumericFormat.currency:
                        currentFormat = currentFormat || currencyFormat;
                    case DX.NumericFormat.percent:
                        currentFormat = currentFormat || percentFormat;
                        pattern = isNegative ? currentFormat.pattern[0] : currentFormat.pattern[1] || "n";
                        number = Globalize.format(number * (numericFormatType === DX.NumericFormat.percent ? 100 : 1), "N" + precision);
                        if (!showTrailingZeros)
                            number = that._excludeTrailingZeros(number, floatingSymbol);
                        if (!includeGroupSeparator)
                            number = number.replace(new RegExp('\\' + groupSymbol, 'g'), '');
                        break;
                    case DX.NumericFormat.exponential:
                        return that._formatNumberExponential(value, precision);
                    default:
                        throw"Illegal numeric format: '" + numericFormatType + "'";
                }
                for (; ; ) {
                    var lastIndex = regexParts.lastIndex,
                        matches = regexParts.exec(pattern);
                    result += pattern.slice(lastIndex, matches ? matches.index : pattern.length);
                    if (matches)
                        switch (matches[0]) {
                            case"-":
                                if (/[1-9]/.test(number))
                                    result += numberFormat["-"];
                                break;
                            case"$":
                                result += currencyFormat.symbol;
                                break;
                            case"%":
                                result += percentFormat.symbol;
                                break;
                            case"n":
                                result += number + unit;
                                break
                        }
                    else
                        break
                }
                return (formatInfo.plus && value > 0 ? "+" : '') + result
            },
            _excludeTrailingZeros: function(strValue, floatingSymbol) {
                var floatingIndex = strValue.indexOf(floatingSymbol),
                    stopIndex,
                    i;
                if (floatingIndex < 0)
                    return strValue;
                stopIndex = strValue.length;
                for (i = stopIndex - 1; i >= floatingIndex && (strValue[i] === '0' || i === floatingIndex); i--)
                    stopIndex--;
                return strValue.substring(0, stopIndex)
            },
            _getUnitFormatSettings: function(value, formatInfo) {
                var unit = formatInfo.unit || '',
                    precision = formatInfo.precision || 0,
                    includeGroupSeparator = formatInfo.includeGroupSeparator || false,
                    showTrailingZeros = formatInfo.showTrailingZeros === undefined ? true : formatInfo.showTrailingZeros,
                    significantDigits = formatInfo.significantDigits || 1,
                    absValue;
                if (unit.toLowerCase() === 'auto') {
                    showTrailingZeros = false;
                    absValue = Math.abs(value);
                    if (significantDigits < 1)
                        significantDigits = 1;
                    if (absValue >= 1000000000) {
                        unit = 'B';
                        absValue /= 1000000000
                    }
                    else if (absValue >= 1000000) {
                        unit = 'M';
                        absValue /= 1000000
                    }
                    else if (absValue >= 1000) {
                        unit = 'K';
                        absValue /= 1000
                    }
                    else
                        unit = '';
                    if (absValue == 0)
                        precision = 0;
                    else if (absValue < 1) {
                        precision = significantDigits;
                        var smallValue = Math.pow(10, -significantDigits);
                        while (absValue < smallValue) {
                            smallValue /= 10;
                            precision++
                        }
                    }
                    else if (absValue >= 100)
                        precision = significantDigits - 3;
                    else if (absValue >= 10)
                        precision = significantDigits - 2;
                    else
                        precision = significantDigits - 1
                }
                if (precision < 0)
                    precision = 0;
                return {
                        unit: unit,
                        precision: precision,
                        showTrailingZeros: showTrailingZeros,
                        includeGroupSeparator: includeGroupSeparator
                    }
            },
            _applyUnitToValue: function(value, unit) {
                if (unit == 'B')
                    return value.toFixed(1) / 1000000000;
                if (unit == 'M')
                    return value / 1000000;
                if (unit == 'K')
                    return value / 1000;
                return value
            },
            _formatDateEx: function(value, formatInfo) {
                var that = this,
                    format = formatInfo.format,
                    dateType = formatInfo.dateType,
                    calendar = Globalize.culture().calendars.standard,
                    time = undefined,
                    index,
                    dateStr;
                format = format.toLowerCase();
                if (!utils.isDefined(value))
                    return '';
                if (dateType !== 'num' || format === 'dayofweek')
                    switch (format) {
                        case'monthyear':
                            return that._formatDate(value, 'monthandyear');
                        case'quarteryear':
                            return that._getQuarterString(value, 'QQ') + ' ' + value.getFullYear();
                        case'daymonthyear':
                            return that._formatDate(value, dateType + 'Date');
                        case'datehour':
                            time = new Date(value.getTime());
                            time.setMinutes(0);
                            dateStr = dateType === 'timeOnly' ? '' : that._formatDate(value, dateType + 'Date');
                            return dateType === 'timeOnly' ? that._formatDate(time, 'shorttime') : dateStr + ' ' + that._formatDate(time, 'shorttime');
                        case'datehourminute':
                            dateStr = dateType === 'timeOnly' ? '' : that._formatDate(value, dateType + 'Date');
                            return dateType === 'timeOnly' ? that._formatDate(value, 'shorttime') : dateStr + ' ' + that._formatDate(value, 'shorttime');
                        case'datehourminutesecond':
                            dateStr = dateType === 'timeOnly' ? '' : that._formatDate(value, dateType + 'Date');
                            return dateType === 'timeOnly' ? that._formatDate(value, 'longtime') : dateStr + ' ' + that._formatDate(value, 'longtime');
                        case'year':
                            dateStr = value.toString();
                            return dateType === 'abbr' ? dateStr.slice(2, 4) : dateStr;
                        case'dateyear':
                            return dateType === 'abbr' ? that._formatDate(value, 'shortyear') : that._formatDate(value, 'year');
                        case'quarter':
                            return utils.stringFormat(that.defaultQuarterFormat, value.toString());
                        case'month':
                            index = value - 1;
                            return dateType === 'abbr' ? calendar.months.namesAbbr[index] : calendar.months.names[index];
                        case'hour':
                            if (dateType === 'long') {
                                time = new Date;
                                time.setHours(value);
                                time.setMinutes(0);
                                return that._formatDate(time, 'shorttime')
                            }
                            else
                                return value.toString();
                        case'dayofweek':
                            index = utils.isString(value) ? $.inArray(value, ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']) : value;
                            if (dateType !== 'num')
                                return dateType === 'abbr' ? calendar.days.namesAbbr[index] : calendar.days.names[index];
                            else
                                return ((index - calendar.firstDay + 1 + 7) % 8).toString();
                        default:
                            return value.toString()
                    }
                else
                    return value.toString()
            },
            getTimeFormat: function(showSecond) {
                if (showSecond)
                    return this._getDateTimeFormatPattern('longtime');
                return this._getDateTimeFormatPattern('shorttime')
            },
            getDateFormatByDifferences: function(dateDifferences) {
                var resultFormat = '';
                if (dateDifferences.millisecond)
                    resultFormat = DX.DateTimeFormat.millisecond;
                if (dateDifferences.hour || dateDifferences.minute || dateDifferences.second)
                    resultFormat = this._addFormatSeparator(this.getTimeFormat(dateDifferences.second), resultFormat);
                if (dateDifferences.year && dateDifferences.month && dateDifferences.day)
                    return this._addFormatSeparator(this._getDateTimeFormatPattern('shortdate'), resultFormat);
                if (dateDifferences.year && dateDifferences.month)
                    return DX.DateTimeFormat['monthandyear'];
                if (dateDifferences.year)
                    return DX.DateTimeFormat['year'];
                if (dateDifferences.month && dateDifferences.day)
                    return this._addFormatSeparator(this._getDateTimeFormatPattern('monthandday'), resultFormat);
                if (dateDifferences.month)
                    return DX.DateTimeFormat['month'];
                if (dateDifferences.day)
                    return this._addFormatSeparator('dddd, dd', resultFormat);
                return resultFormat
            },
            getDateFormatByTicks: function(ticks) {
                var resultFormat,
                    maxDif,
                    currentDif,
                    i,
                    dateUnitInterval;
                if (ticks.length > 1) {
                    maxDif = utils.getDatesDifferences(ticks[0], ticks[1]);
                    for (i = 1; i < ticks.length - 1; i++) {
                        currentDif = utils.getDatesDifferences(ticks[i], ticks[i + 1]);
                        if (maxDif.count < currentDif.count)
                            maxDif = currentDif
                    }
                }
                else
                    maxDif = {
                        year: true,
                        month: true,
                        day: true,
                        hour: ticks[0].getHours() > 0,
                        minute: ticks[0].getMinutes() > 0,
                        second: ticks[0].getSeconds() > 0
                    };
                resultFormat = this.getDateFormatByDifferences(maxDif);
                return resultFormat
            },
            getDateFormatByTickInterval: function(startValue, endValue, tickInterval) {
                var resultFormat,
                    dateDifferences,
                    dateUnitInterval,
                    dateDifferencesConverter = {
                        quarter: 'month',
                        week: 'day'
                    },
                    correctDateDifferences = function(dateDifferences, tickInterval, value) {
                        switch (tickInterval) {
                            case'year':
                                dateDifferences.month = value;
                            case'quarter':
                            case'month':
                                dateDifferences.day = value;
                            case'week':
                            case'day':
                                dateDifferences.hour = value;
                            case'hour':
                                dateDifferences.minute = value;
                            case'minute':
                                dateDifferences.second = value;
                            case'second':
                                dateDifferences.millisecond = value
                        }
                    },
                    correctDifferencesByMaxDate = function(differences, minDate, maxDate) {
                        if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
                            if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
                                differences.millisecond = true;
                                differences.second = false
                            }
                        }
                        else if (!maxDate.getSeconds() && maxDate.getMinutes()) {
                            if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
                                differences.second = true;
                                differences.minute = false
                            }
                        }
                        else if (!maxDate.getMinutes() && maxDate.getHours()) {
                            if (maxDate.getHours() - minDate.getHours() === 1) {
                                differences.minute = true;
                                differences.hour = false
                            }
                        }
                        else if (!maxDate.getHours() && maxDate.getDate() > 1) {
                            if (maxDate.getDate() - minDate.getDate() === 1) {
                                differences.hour = true;
                                differences.day = false
                            }
                        }
                        else if (maxDate.getDate() === 1 && maxDate.getMonth()) {
                            if (maxDate.getMonth() - minDate.getMonth() === 1) {
                                differences.day = true;
                                differences.month = false
                            }
                        }
                        else if (!maxDate.getMonth() && maxDate.getFullYear())
                            if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
                                differences.month = true;
                                differences.year = false
                            }
                    };
                tickInterval = utils.isString(tickInterval) ? tickInterval.toLowerCase() : tickInterval;
                dateDifferences = utils.getDatesDifferences(startValue, endValue);
                if (startValue !== endValue)
                    correctDifferencesByMaxDate(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue);
                dateUnitInterval = utils.getDateUnitInterval(dateDifferences);
                correctDateDifferences(dateDifferences, dateUnitInterval, true);
                dateUnitInterval = utils.getDateUnitInterval(tickInterval || 'second');
                correctDateDifferences(dateDifferences, dateUnitInterval, false);
                dateDifferences[dateDifferencesConverter[dateUnitInterval] || dateUnitInterval] = true;
                resultFormat = this.getDateFormatByDifferences(dateDifferences);
                return resultFormat
            }
        }
    })(jQuery, DevExpress);
    /*! Module core, file color.js */
    (function(DX, undefined) {
        var standardColorNames = {
                aliceblue: 'f0f8ff',
                antiquewhite: 'faebd7',
                aqua: '00ffff',
                aquamarine: '7fffd4',
                azure: 'f0ffff',
                beige: 'f5f5dc',
                bisque: 'ffe4c4',
                black: '000000',
                blanchedalmond: 'ffebcd',
                blue: '0000ff',
                blueviolet: '8a2be2',
                brown: 'a52a2a',
                burlywood: 'deb887',
                cadetblue: '5f9ea0',
                chartreuse: '7fff00',
                chocolate: 'd2691e',
                coral: 'ff7f50',
                cornflowerblue: '6495ed',
                cornsilk: 'fff8dc',
                crimson: 'dc143c',
                cyan: '00ffff',
                darkblue: '00008b',
                darkcyan: '008b8b',
                darkgoldenrod: 'b8860b',
                darkgray: 'a9a9a9',
                darkgreen: '006400',
                darkkhaki: 'bdb76b',
                darkmagenta: '8b008b',
                darkolivegreen: '556b2f',
                darkorange: 'ff8c00',
                darkorchid: '9932cc',
                darkred: '8b0000',
                darksalmon: 'e9967a',
                darkseagreen: '8fbc8f',
                darkslateblue: '483d8b',
                darkslategray: '2f4f4f',
                darkturquoise: '00ced1',
                darkviolet: '9400d3',
                deeppink: 'ff1493',
                deepskyblue: '00bfff',
                dimgray: '696969',
                dodgerblue: '1e90ff',
                feldspar: 'd19275',
                firebrick: 'b22222',
                floralwhite: 'fffaf0',
                forestgreen: '228b22',
                fuchsia: 'ff00ff',
                gainsboro: 'dcdcdc',
                ghostwhite: 'f8f8ff',
                gold: 'ffd700',
                goldenrod: 'daa520',
                gray: '808080',
                green: '008000',
                greenyellow: 'adff2f',
                honeydew: 'f0fff0',
                hotpink: 'ff69b4',
                indianred: 'cd5c5c',
                indigo: '4b0082',
                ivory: 'fffff0',
                khaki: 'f0e68c',
                lavender: 'e6e6fa',
                lavenderblush: 'fff0f5',
                lawngreen: '7cfc00',
                lemonchiffon: 'fffacd',
                lightblue: 'add8e6',
                lightcoral: 'f08080',
                lightcyan: 'e0ffff',
                lightgoldenrodyellow: 'fafad2',
                lightgrey: 'd3d3d3',
                lightgreen: '90ee90',
                lightpink: 'ffb6c1',
                lightsalmon: 'ffa07a',
                lightseagreen: '20b2aa',
                lightskyblue: '87cefa',
                lightslateblue: '8470ff',
                lightslategray: '778899',
                lightsteelblue: 'b0c4de',
                lightyellow: 'ffffe0',
                lime: '00ff00',
                limegreen: '32cd32',
                linen: 'faf0e6',
                magenta: 'ff00ff',
                maroon: '800000',
                mediumaquamarine: '66cdaa',
                mediumblue: '0000cd',
                mediumorchid: 'ba55d3',
                mediumpurple: '9370d8',
                mediumseagreen: '3cb371',
                mediumslateblue: '7b68ee',
                mediumspringgreen: '00fa9a',
                mediumturquoise: '48d1cc',
                mediumvioletred: 'c71585',
                midnightblue: '191970',
                mintcream: 'f5fffa',
                mistyrose: 'ffe4e1',
                moccasin: 'ffe4b5',
                navajowhite: 'ffdead',
                navy: '000080',
                oldlace: 'fdf5e6',
                olive: '808000',
                olivedrab: '6b8e23',
                orange: 'ffa500',
                orangered: 'ff4500',
                orchid: 'da70d6',
                palegoldenrod: 'eee8aa',
                palegreen: '98fb98',
                paleturquoise: 'afeeee',
                palevioletred: 'd87093',
                papayawhip: 'ffefd5',
                peachpuff: 'ffdab9',
                peru: 'cd853f',
                pink: 'ffc0cb',
                plum: 'dda0dd',
                powderblue: 'b0e0e6',
                purple: '800080',
                red: 'ff0000',
                rosybrown: 'bc8f8f',
                royalblue: '4169e1',
                saddlebrown: '8b4513',
                salmon: 'fa8072',
                sandybrown: 'f4a460',
                seagreen: '2e8b57',
                seashell: 'fff5ee',
                sienna: 'a0522d',
                silver: 'c0c0c0',
                skyblue: '87ceeb',
                slateblue: '6a5acd',
                slategray: '708090',
                snow: 'fffafa',
                springgreen: '00ff7f',
                steelblue: '4682b4',
                tan: 'd2b48c',
                teal: '008080',
                thistle: 'd8bfd8',
                tomato: 'ff6347',
                turquoise: '40e0d0',
                violet: 'ee82ee',
                violetred: 'd02090',
                wheat: 'f5deb3',
                white: 'ffffff',
                whitesmoke: 'f5f5f5',
                yellow: 'ffff00',
                yellowgreen: '9acd32'
            };
        var standardColorTypes = [{
                    re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
                    process: function(colorString) {
                        return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10)]
                    }
                }, {
                    re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*\.*\d+)\)$/,
                    process: function(colorString) {
                        return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10), parseFloat(colorString[4])]
                    }
                }, {
                    re: /^#(\w{2})(\w{2})(\w{2})$/,
                    process: function(colorString) {
                        return [parseInt(colorString[1], 16), parseInt(colorString[2], 16), parseInt(colorString[3], 16)]
                    }
                }, {
                    re: /^#(\w{1})(\w{1})(\w{1})$/,
                    process: function(colorString) {
                        return [parseInt(colorString[1] + colorString[1], 16), parseInt(colorString[2] + colorString[2], 16), parseInt(colorString[3] + colorString[3], 16)]
                    }
                }, {
                    re: /^hsv\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
                    process: function(colorString) {
                        var h = parseInt(colorString[1], 10),
                            s = parseInt(colorString[2], 10),
                            v = parseInt(colorString[3], 10),
                            rgb = hsvToRgb(h, s, v);
                        return [rgb[0], rgb[1], rgb[2], 1, [h, s, v]]
                    }
                }, {
                    re: /^hsl\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
                    process: function(colorString) {
                        var h = parseInt(colorString[1], 10),
                            s = parseInt(colorString[2], 10),
                            l = parseInt(colorString[3], 10),
                            rgb = hslToRgb(h, s, l);
                        return [rgb[0], rgb[1], rgb[2], 1, null, [h, s, l]]
                    }
                }];
        function Color(value) {
            this.baseColor = value;
            var color;
            if (value) {
                color = String(value).toLowerCase().replace(/ /g, '');
                color = standardColorNames[color] ? '#' + standardColorNames[color] : color;
                color = parseColor(color)
            }
            if (!color)
                this.colorIsInvalid = true;
            color = color || {};
            this.r = normalize(color[0]);
            this.g = normalize(color[1]);
            this.b = normalize(color[2]);
            this.a = normalize(color[3], 1, 1);
            if (color[4])
                this.hsv = {
                    h: color[4][0],
                    s: color[4][1],
                    v: color[4][2]
                };
            else
                this.hsv = toHsvFromRgb(this.r, this.g, this.b);
            if (color[5])
                this.hsl = {
                    h: color[5][0],
                    s: color[5][1],
                    l: color[5][2]
                };
            else
                this.hsl = toHslFromRgb(this.r, this.g, this.b)
        }
        function parseColor(color) {
            if (color === "transparent")
                return [0, 0, 0, 0];
            var result,
                i = 0,
                ii = standardColorTypes.length,
                str;
            for (; i < ii; ++i) {
                str = standardColorTypes[i].re.exec(color);
                if (str)
                    return standardColorTypes[i].process(str)
            }
            return null
        }
        function normalize(colorComponent, def, max) {
            def = def || 0;
            max = max || 255;
            return colorComponent < 0 || isNaN(colorComponent) ? def : colorComponent > max ? max : colorComponent
        }
        function toHexFromRgb(r, g, b) {
            return '#' + (0X01000000 | r << 16 | g << 8 | b).toString(16).slice(1)
        }
        function toHsvFromRgb(r, g, b) {
            var max = Math.max(r, g, b),
                min = Math.min(r, g, b),
                delta = max - min,
                H,
                S,
                V;
            V = max;
            S = max === 0 ? 0 : 1 - min / max;
            if (max === min)
                H = 0;
            else
                switch (max) {
                    case r:
                        H = 60 * ((g - b) / delta);
                        if (g < b)
                            H = H + 360;
                        break;
                    case g:
                        H = 60 * ((b - r) / delta) + 120;
                        break;
                    case b:
                        H = 60 * ((r - g) / delta) + 240;
                        break
                }
            S *= 100;
            V *= 100 / 255;
            return {
                    h: Math.round(H),
                    s: Math.round(S),
                    v: Math.round(V)
                }
        }
        function hsvToRgb(h, s, v) {
            var Vdec,
                Vinc,
                Vmin,
                Hi,
                a,
                r,
                g,
                b;
            Hi = Math.floor(h / 60);
            Vmin = (100 - s) * v / 100;
            a = (v - Vmin) * (h % 60 / 60);
            Vinc = Vmin + a;
            Vdec = v - a;
            switch (Hi) {
                case 0:
                    r = v;
                    g = Vinc;
                    b = Vmin;
                    break;
                case 1:
                    r = Vdec;
                    g = v;
                    b = Vmin;
                    break;
                case 2:
                    r = Vmin;
                    g = v;
                    b = Vinc;
                    break;
                case 3:
                    r = Vmin;
                    g = Vdec;
                    b = v;
                    break;
                case 4:
                    r = Vinc;
                    g = Vmin;
                    b = v;
                    break;
                case 5:
                    r = v;
                    g = Vmin;
                    b = Vdec;
                    break
            }
            return [Math.round(r * 2.55), Math.round(g * 2.55), Math.round(b * 2.55)]
        }
        function calculateHue(r, g, b, delta) {
            var max = Math.max(r, g, b);
            switch (max) {
                case r:
                    return (g - b) / delta + (g < b ? 6 : 0);
                case g:
                    return (b - r) / delta + 2;
                case b:
                    return (r - g) / delta + 4
            }
        }
        function toHslFromRgb(r, g, b) {
            r = convertTo01Bounds(r, 255);
            g = convertTo01Bounds(g, 255);
            b = convertTo01Bounds(b, 255);
            var max = Math.max(r, g, b),
                min = Math.min(r, g, b),
                maxMinSumm = max + min,
                h,
                s,
                l = maxMinSumm / 2;
            if (max === min)
                h = s = 0;
            else {
                var delta = max - min;
                if (l > 0.5)
                    s = delta / (2 - maxMinSumm);
                else
                    s = delta / maxMinSumm;
                h = calculateHue(r, g, b, delta);
                h /= 6
            }
            return {
                    h: _round(h * 360),
                    s: _round(s * 100),
                    l: _round(l * 100)
                }
        }
        function makeTc(colorPart, h) {
            var Tc = h;
            if (colorPart === "r")
                Tc = h + 1 / 3;
            if (colorPart === "b")
                Tc = h - 1 / 3;
            return Tc
        }
        function modifyTc(Tc) {
            if (Tc < 0)
                Tc += 1;
            if (Tc > 1)
                Tc -= 1;
            return Tc
        }
        function hueToRgb(p, q, Tc) {
            Tc = modifyTc(Tc);
            if (Tc < 1 / 6)
                return p + (q - p) * 6 * Tc;
            if (Tc < 1 / 2)
                return q;
            if (Tc < 2 / 3)
                return p + (q - p) * (2 / 3 - Tc) * 6;
            return p
        }
        function hslToRgb(h, s, l) {
            var r,
                g,
                b,
                h = convertTo01Bounds(h, 360),
                s = convertTo01Bounds(s, 100),
                l = convertTo01Bounds(l, 100);
            if (s === 0)
                r = g = b = l;
            else {
                var q = l < 0.5 ? l * (1 + s) : l + s - l * s,
                    p = 2 * l - q;
                r = hueToRgb(p, q, makeTc("r", h));
                g = hueToRgb(p, q, makeTc("g", h));
                b = hueToRgb(p, q, makeTc("b", h))
            }
            return [_round(r * 255), _round(g * 255), _round(b * 255)]
        }
        function convertTo01Bounds(n, max) {
            n = Math.min(max, Math.max(0, parseFloat(n)));
            if (Math.abs(n - max) < 0.000001)
                return 1;
            return n % max / parseFloat(max)
        }
        function isIntegerBtwMinAndMax(number, min, max) {
            min = min || 0;
            max = max || 255;
            if (number % 1 !== 0 || number < min || number > max || typeof number !== 'number' || isNaN(number))
                return false;
            return true
        }
        var _round = Math.round;
        Color.prototype = {
            constructor: Color,
            highlight: function(step) {
                step = step || 10;
                return this.alter(step).toHex()
            },
            darken: function(step) {
                step = step || 10;
                return this.alter(-step).toHex()
            },
            alter: function(step) {
                var result = new Color;
                result.r = normalize(this.r + step);
                result.g = normalize(this.g + step);
                result.b = normalize(this.b + step);
                return result
            },
            blend: function(blendColor, opacity) {
                var other = blendColor instanceof Color ? blendColor : new Color(blendColor),
                    result = new Color;
                result.r = normalize(_round(this.r * (1 - opacity) + other.r * opacity));
                result.g = normalize(_round(this.g * (1 - opacity) + other.g * opacity));
                result.b = normalize(_round(this.b * (1 - opacity) + other.b * opacity));
                return result
            },
            toHex: function() {
                return toHexFromRgb(this.r, this.g, this.b)
            },
            getPureColor: function() {
                var rgb = hsvToRgb(this.hsv.h, 100, 100);
                return new Color("rgb(" + rgb.join(",") + ")")
            },
            isValidHex: function(hex) {
                return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex)
            },
            isValidRGB: function(r, g, b) {
                if (!isIntegerBtwMinAndMax(r) || !isIntegerBtwMinAndMax(g) || !isIntegerBtwMinAndMax(b))
                    return false;
                return true
            },
            isValidAlpha: function(a) {
                if (isNaN(a) || a < 0 || a > 1 || typeof a !== 'number')
                    return false;
                return true
            },
            colorIsInvalid: false
        };
        DX.Color = Color
    })(DevExpress);
    /*! Module core, file localization.js */
    (function($, DX, undefined) {
        Globalize.localize = function(key, cultureSelector) {
            var neutral = (cultureSelector || this.cultureSelector || "").substring(0, 2);
            return this.findClosestCulture(cultureSelector).messages[key] || this.findClosestCulture(neutral).messages[key] || this.cultures["default"].messages[key]
        };
        var localization = function() {
                var newMessages = {};
                return {
                        setup: function(localizablePrefix) {
                            this.localizeString = function(text) {
                                var regex = new RegExp("(^|[^a-zA-Z_0-9" + localizablePrefix + "-]+)(" + localizablePrefix + "{1,2})([a-zA-Z_0-9-]+)", "g"),
                                    escapeString = localizablePrefix + localizablePrefix;
                                return text.replace(regex, function(str, prefix, escape, localizationKey) {
                                        var result = prefix + localizablePrefix + localizationKey;
                                        if (escape !== escapeString)
                                            if (Globalize.cultures["default"].messages[localizationKey])
                                                result = prefix + Globalize.localize(localizationKey);
                                            else
                                                newMessages[localizationKey] = DX.inflector.humanize(localizationKey);
                                        return result
                                    })
                            }
                        },
                        localizeNode: function(node) {
                            var that = this;
                            $(node).each(function(index, nodeItem) {
                                if (!nodeItem.nodeType)
                                    return;
                                if (nodeItem.nodeType === 3)
                                    nodeItem.nodeValue = that.localizeString(nodeItem.nodeValue);
                                else {
                                    $.each(nodeItem.attributes || [], function(index, attr) {
                                        if (typeof attr.value === "string") {
                                            var localizedValue = that.localizeString(attr.value);
                                            if (attr.value !== localizedValue)
                                                attr.value = localizedValue
                                        }
                                    });
                                    $(nodeItem).contents().each(function(index, node) {
                                        that.localizeNode(node)
                                    })
                                }
                            })
                        },
                        getDictionary: function(onlyNew) {
                            if (onlyNew)
                                return newMessages;
                            return $.extend({}, newMessages, Globalize.cultures["default"].messages)
                        }
                    }
            }();
        localization.setup("@");
        DX.localization = localization
    })(jQuery, DevExpress);
    /*! Module core, file core.en.js */
    Globalize.addCultureInfo("default", {messages: {
            Yes: "Yes",
            No: "No",
            Cancel: "Cancel",
            Clear: "Clear",
            Done: "Done",
            Loading: "Loading...",
            Select: "Select...",
            Search: "Search",
            Back: "Back",
            OK: "OK",
            "dxCollectionWidget-noDataText": "No data to display",
            "validation-required": "Required",
            "validation-required-formatted": "{0} is required",
            "validation-numeric": "Value should be a number",
            "validation-numeric-formatted": "{0} should be a number",
            "validation-range": "Value is out of range",
            "validation-range-formatted": "{0} is out of range",
            "validation-stringLength": "The length of the value is not correct",
            "validation-stringLength-formatted": "The length of {0} is not correct",
            "validation-custom": "Value is invalid",
            "validation-custom-formatted": "{0} is invalid",
            "validation-compare": "Values do not match",
            "validation-compare-formatted": "{0} does not match",
            "validation-pattern": "Value does not match pattern",
            "validation-pattern-formatted": "{0} does not match pattern",
            "validation-email": "Email is invalid",
            "validation-email-formatted": "{0} is invalid"
        }});
    /*! Module core, file widgets-base.en.js */
    Globalize.addCultureInfo("default", {messages: {
            "dxLookup-searchPlaceholder": "Minimum character number: {0}",
            "dxList-pullingDownText": "Pull down to refresh...",
            "dxList-pulledDownText": "Release to refresh...",
            "dxList-refreshingText": "Refreshing...",
            "dxList-pageLoadingText": "Loading...",
            "dxList-nextButtonText": "More",
            "dxList-selectAll": "Select All",
            "dxListEditDecorator-delete": "Delete",
            "dxListEditDecorator-more": "More",
            "dxScrollView-pullingDownText": "Pull down to refresh...",
            "dxScrollView-pulledDownText": "Release to refresh...",
            "dxScrollView-refreshingText": "Refreshing...",
            "dxScrollView-reachBottomText": "Loading...",
            "dxDateBox-simulatedDataPickerTitleTime": "Select time",
            "dxDateBox-simulatedDataPickerTitleDate": "Select date",
            "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
            "dxFileUploader-selectFile": "Select file",
            "dxFileUploader-dropFile": "or Drop file here",
            "dxFileUploader-bytes": "bytes",
            "dxFileUploader-kb": "kb",
            "dxFileUploader-Mb": "Mb",
            "dxFileUploader-Gb": "Gb"
        }});
    /*! Module core, file widgets-mobile.en.js */
    Globalize.addCultureInfo("default", {messages: {
            "dxSwitch-onText": "ON",
            "dxSwitch-offText": "OFF"
        }});
    /*! Module core, file widgets-web.en.js */
    Globalize.addCultureInfo("default", {messages: {
            "dxDataGrid-columnChooserTitle": "Column Chooser",
            "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
            "dxDataGrid-groupContinuesMessage": "Continues on the next page",
            "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
            "dxDataGrid-editingEditRow": "Edit",
            "dxDataGrid-editingSaveRowChanges": "Save",
            "dxDataGrid-editingCancelRowChanges": "Cancel",
            "dxDataGrid-editingDeleteRow": "Delete",
            "dxDataGrid-editingUndeleteRow": "Undelete",
            "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
            "dxDataGrid-editingConfirmDeleteTitle": "",
            "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
            "dxDataGrid-noDataText": "No data",
            "dxDataGrid-searchPanelPlaceholder": "Search...",
            "dxDataGrid-filterRowShowAllText": "(All)",
            "dxDataGrid-filterRowResetOperationText": "Reset",
            "dxDataGrid-filterRowOperationEquals": "Equals",
            "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
            "dxDataGrid-filterRowOperationLess": "Less than",
            "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
            "dxDataGrid-filterRowOperationGreater": "Greater than",
            "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
            "dxDataGrid-filterRowOperationStartsWith": "Starts with",
            "dxDataGrid-filterRowOperationContains": "Contains",
            "dxDataGrid-filterRowOperationNotContains": "Does not contain",
            "dxDataGrid-filterRowOperationEndsWith": "Ends with",
            "dxDataGrid-applyFilterText": "Apply filter",
            "dxDataGrid-trueText": "true",
            "dxDataGrid-falseText": "false",
            "dxDataGrid-sortingAscendingText": "Sort Ascending",
            "dxDataGrid-sortingDescendingText": "Sort Descending",
            "dxDataGrid-sortingClearText": "Clear Sorting",
            "dxDataGrid-editingSaveAllChanges": "Save changes",
            "dxDataGrid-editingCancelAllChanges": "Discard changes",
            "dxDataGrid-editingAddRow": "Add a row",
            "dxDataGrid-summaryMin": "Min: {0}",
            "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
            "dxDataGrid-summaryMax": "Max: {0}",
            "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
            "dxDataGrid-summaryAvg": "Avg: {0}",
            "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
            "dxDataGrid-summarySum": "Sum: {0}",
            "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
            "dxDataGrid-summaryCount": "Count: {0}",
            "dxPager-infoText": "Page {0} of {1}"
        }});
    /*! Module core, file validationEngine.js */
    (function($, DX, undefined) {
        var utils = DX.utils;
        var rulesValidators = {
                required: {
                    validate: function(value, rule) {
                        if (!utils.isDefined(value))
                            return false;
                        if (value === false)
                            return false;
                        value = String(value);
                        if (rule.trim || !utils.isDefined(rule.trim))
                            value = $.trim(value);
                        return value !== ""
                    },
                    defaultMessage: Globalize.localize("validation-required"),
                    defaultFormattedMessage: Globalize.localize("validation-required-formatted")
                },
                numeric: {
                    validate: function(value, rule) {
                        return $.isNumeric(value)
                    },
                    defaultMessage: Globalize.localize("validation-numeric"),
                    defaultFormattedMessage: Globalize.localize("validation-numeric-formatted")
                },
                range: {
                    validate: function(value, rule) {
                        var validNumber = rulesValidators["numeric"].validate(value, rule),
                            validValue = utils.isDefined(value),
                            number = validNumber ? parseFloat(value) : validValue && value.valueOf(),
                            min = rule.min,
                            max = rule.max;
                        if (!(validNumber || utils.isDate(value)) && !validValue)
                            return false;
                        if (utils.isDefined(min)) {
                            if (utils.isDefined(max))
                                return number >= min && number <= max;
                            return number >= min
                        }
                        else if (utils.isDefined(max))
                            return number <= max;
                        else
                            throw DX.Error("E0101");
                        return false
                    },
                    defaultMessage: Globalize.localize("validation-range"),
                    defaultFormattedMessage: Globalize.localize("validation-range-formatted")
                },
                stringLength: {
                    validate: function(value, rule) {
                        value = String(value);
                        if (rule.trim || !utils.isDefined(rule.trim))
                            value = $.trim(value);
                        return rulesValidators.range.validate(value.length, $.extend({}, rule))
                    },
                    defaultMessage: Globalize.localize("validation-stringLength"),
                    defaultFormattedMessage: Globalize.localize("validation-stringLength-formatted")
                },
                custom: {
                    validate: function(value, rule) {
                        return rule.validationCallback({
                                value: value,
                                validator: rule.validator,
                                rule: rule
                            })
                    },
                    defaultMessage: Globalize.localize("validation-custom"),
                    defaultFormattedMessage: Globalize.localize("validation-custom-formatted")
                },
                compare: {
                    validate: function(value, rule) {
                        if (!rule.comparisonTarget)
                            throw DX.Error("E0102");
                        var otherValue = rule.comparisonTarget(),
                            type = rule.comparisonType || "==";
                        switch (type) {
                            case"==":
                                return value == otherValue;
                                break;
                            case"===":
                                return value === otherValue;
                                break;
                            case">":
                                return value > otherValue;
                                break;
                            case">=":
                                return value >= otherValue;
                                break;
                            case"<":
                                return value < otherValue;
                                break;
                            case"<=":
                                return value <= otherValue;
                                break
                        }
                    },
                    defaultMessage: Globalize.localize("validation-compare"),
                    defaultFormattedMessage: Globalize.localize("validation-compare-formatted")
                },
                pattern: {
                    validate: function(value, rule) {
                        var pattern = rule.pattern;
                        if (utils.isString(pattern))
                            pattern = new RegExp(pattern);
                        return pattern.test(value)
                    },
                    defaultMessage: Globalize.localize("validation-pattern"),
                    defaultFormattedMessage: Globalize.localize("validation-pattern-formatted")
                },
                email: {
                    validate: function(value, rule) {
                        return rulesValidators.pattern.validate(value, $.extend({}, rule, {pattern: /^[\d\w\._\-]+@([\d\w\._\-]+\.)+[\w]+$/i}))
                    },
                    defaultMessage: Globalize.localize("validation-email"),
                    defaultFormattedMessage: Globalize.localize("validation-email-formatted")
                }
            };
        var GroupConfig = DX.Class.inherit({
                ctor: function(group) {
                    this.group = group;
                    this.validators = []
                },
                validate: function() {
                    var result = {
                            isValid: true,
                            brokenRules: [],
                            validators: []
                        };
                    $.each(this.validators, function(_, validator) {
                        var validatorResult = validator.validate();
                        result.isValid = result.isValid && validatorResult.isValid;
                        if (validatorResult.brokenRule)
                            result.brokenRules.push(validatorResult.brokenRule);
                        result.validators.push(validator)
                    });
                    this.fireEvent("validated", [{
                            validators: result.validators,
                            brokenRules: result.brokenRules,
                            isValid: result.isValid
                        }]);
                    return result
                }
            }).include(DX.EventsMixin);
        DX.validationEngine = {
            groups: [],
            getGroupConfig: function(group) {
                var result = $.grep(this.groups, function(config) {
                        return config.group === group
                    });
                if (result.length)
                    return result[0]
            },
            initGroups: function() {
                this.groups = [];
                this.addGroup()
            },
            addGroup: function(group) {
                var config = this.getGroupConfig(group);
                if (!config) {
                    config = new GroupConfig(group);
                    this.groups.push(config)
                }
                return config
            },
            removeGroup: function(group) {
                var config = this.getGroupConfig(group),
                    index = $.inArray(config, this.groups);
                if (index > -1)
                    this.groups.splice(index, 1);
                return config
            },
            _setDefaultMessage: function(rule, validator, name) {
                if (!utils.isDefined(rule.message))
                    if (validator.defaultFormattedMessage && utils.isDefined(name))
                        rule.message = validator.defaultFormattedMessage.replace(/\{0\}/, name);
                    else
                        rule.message = validator.defaultMessage
            },
            validate: function validate(value, rules, name) {
                var result = {
                        name: name,
                        value: value,
                        brokenRule: undefined,
                        isValid: true,
                        validationRules: rules
                    },
                    that = this;
                $.each(rules || [], function(_, rule) {
                    var ruleValidator = rulesValidators[rule.type],
                        ruleValidationResult;
                    if (ruleValidator) {
                        if (utils.isDefined(rule.isValid) && rule.value === value) {
                            if (!rule.isValid) {
                                result.isValid = false;
                                result.brokenRule = rule;
                                return false
                            }
                            return true
                        }
                        rule.value = value;
                        ruleValidationResult = ruleValidator.validate(value, rule);
                        rule.isValid = ruleValidationResult;
                        if (!ruleValidationResult) {
                            result.isValid = false;
                            that._setDefaultMessage(rule, ruleValidator, name);
                            result.brokenRule = rule
                        }
                        if (!rule.isValid)
                            return false
                    }
                    else
                        throw DX.Error("E0100");
                });
                return result
            },
            registerValidatorInGroup: function(group, validator) {
                var groupConfig = DX.validationEngine.addGroup(group);
                if ($.inArray(validator, groupConfig.validators) < 0)
                    groupConfig.validators.push(validator)
            },
            removeRegistredValidator: function(group, validator) {
                var config = DX.validationEngine.getGroupConfig(group),
                    validatorsInGroup = config && config.validators;
                var index = $.inArray(validator, validatorsInGroup);
                if (index > -1)
                    validatorsInGroup.splice(index, 1)
            },
            validateGroup: function(group) {
                var groupConfig = DX.validationEngine.getGroupConfig(group);
                if (!groupConfig)
                    throw DX.Error("E0110");
                return groupConfig.validate()
            }
        };
        DX.validationEngine.initGroups()
    })(jQuery, DevExpress);
    /*! Module core, file data.errors.js */
    (function($, DX) {
        $.extend(DX.ERROR_MESSAGES, {
            E4000: "[DevExpress.data]: {0}",
            E4001: "Unknown aggregating function is detected: '{0}'",
            E4002: "Unsupported OData protocol version is used",
            E4003: "Unknown filter operation is used: {0}",
            E4004: "The thenby() method is called before the sortby() method",
            E4005: "Store requires a key expression for this operation",
            E4006: "ArrayStore 'data' option must be an array",
            E4007: "Compound keys cannot be auto-generated",
            E4008: "Attempt to insert an item with the a duplicated key",
            E4009: "Data item cannot be found by the parameters passed to the update(key,values) function",
            E4010: "CustomStore does not support creating queries",
            E4011: "Custom Store method is not implemented or is not a function: {0}",
            E4012: "Custom Store method returns an invalid value: {0}",
            E4013: "Local Store requires the 'name' configuration option is specified",
            E4014: "Unknown key type is detected: {0}",
            E4015: "Unknown entity name or alias is used: {0}",
            E4016: "The compileSetter(expr) method is called with 'self' passed as a parameter"
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.js */
    (function($, DX, undefined) {
        var bracketsToDots = function(expr) {
                return expr.replace(/\[/g, ".").replace(/\]/g, "")
            };
        var unwrapObservable = DX.utils.unwrapObservable;
        var isObservable = function(value) {
                return DX.support.hasKo && ko.isObservable(value)
            };
        var readPropValue = function(obj, propName) {
                if (propName === "this")
                    return obj;
                return obj[propName]
            };
        var assignPropValue = function(obj, propName, value, options) {
                if (propName === "this")
                    throw new DX.Error("E4016");
                var propValue = obj[propName];
                if (options.unwrapObservables && isObservable(propValue))
                    propValue(value);
                else
                    obj[propName] = value
            };
        var prepareOptions = function(options) {
                options = options || {};
                options.unwrapObservables = options.unwrapObservables !== undefined ? options.unwrapObservables : true;
                return options
            };
        var unwrap = function(value, options) {
                return options.unwrapObservables ? unwrapObservable(value) : value
            };
        var compileGetter = function(expr) {
                if (arguments.length > 1)
                    expr = $.makeArray(arguments);
                if (!expr || expr === "this")
                    return function(obj) {
                            return obj
                        };
                if ($.isFunction(expr))
                    return expr;
                if ($.isArray(expr))
                    return combineGetters(expr);
                expr = bracketsToDots(expr);
                var path = expr.split(".");
                return function(obj, options) {
                        options = prepareOptions(options);
                        var current = unwrap(obj, options);
                        $.each(path, function() {
                            if (!current)
                                return false;
                            var next = unwrap(current[this], options);
                            if ($.isFunction(next) && !options.functionsAsIs)
                                next = next.call(current);
                            current = next
                        });
                        return current
                    }
            };
        var combineGetters = function(getters) {
                var compiledGetters = {};
                $.each(getters, function() {
                    compiledGetters[this] = compileGetter(this)
                });
                return function(obj, options) {
                        var result = {};
                        $.each(compiledGetters, function(name) {
                            var value = this(obj, options),
                                current,
                                path,
                                last,
                                i;
                            if (value === undefined)
                                return;
                            current = result;
                            path = name.split(".");
                            last = path.length - 1;
                            for (i = 0; i < last; i++)
                                current = current[path[i]] = {};
                            current[path[i]] = value
                        });
                        return result
                    }
            };
        var compileSetter = function(expr) {
                expr = expr || "this";
                expr = bracketsToDots(expr);
                var pos = expr.lastIndexOf("."),
                    targetGetter = compileGetter(expr.substr(0, pos)),
                    targetPropName = expr.substr(1 + pos);
                return function(obj, value, options) {
                        options = prepareOptions(options);
                        var target = targetGetter(obj, {
                                functionsAsIs: options.functionsAsIs,
                                unwrapObservables: options.unwrapObservables
                            }),
                            prevTargetValue = readPropValue(target, targetPropName);
                        if (!options.functionsAsIs && $.isFunction(prevTargetValue) && !isObservable(prevTargetValue))
                            target[targetPropName](value);
                        else {
                            prevTargetValue = unwrap(prevTargetValue, options);
                            if (options.merge && $.isPlainObject(value) && (prevTargetValue === undefined || $.isPlainObject(prevTargetValue)) && !(value instanceof $.Event)) {
                                if (!prevTargetValue)
                                    assignPropValue(target, targetPropName, {}, options);
                                DX.utils.deepExtendArraySafe(unwrap(readPropValue(target, targetPropName), options), value)
                            }
                            else
                                assignPropValue(target, targetPropName, value, options)
                        }
                    }
            };
        var normalizeBinaryCriterion = function(crit) {
                return [crit[0], crit.length < 3 ? "=" : String(crit[1]).toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]]
            };
        var normalizeSortingInfo = function(info) {
                if (!$.isArray(info))
                    info = [info];
                return $.map(info, function(i) {
                        return {
                                selector: $.isFunction(i) || typeof i === "string" ? i : i.getter || i.field || i.selector,
                                desc: !!(i.desc || String(i.dir).charAt(0).toLowerCase() === "d")
                            }
                    })
            };
        var Guid = DX.Class.inherit({
                ctor: function(value) {
                    if (value)
                        value = String(value);
                    this._value = this._normalize(value || this._generate())
                },
                _normalize: function(value) {
                    value = value.replace(/[^a-f0-9]/ig, "").toLowerCase();
                    while (value.length < 32)
                        value += "0";
                    return [value.substr(0, 8), value.substr(8, 4), value.substr(12, 4), value.substr(16, 4), value.substr(20, 12)].join("-")
                },
                _generate: function() {
                    var value = "";
                    for (var i = 0; i < 32; i++)
                        value += Math.round(Math.random() * 15).toString(16);
                    return value
                },
                toString: function() {
                    return this._value
                },
                valueOf: function() {
                    return this._value
                },
                toJSON: function() {
                    return this._value
                }
            });
        var toComparable = function(value, caseSensitive) {
                if (value instanceof Date)
                    return value.getTime();
                if (value instanceof Guid)
                    return value.valueOf();
                if (!caseSensitive && typeof value === "string")
                    return value.toLowerCase();
                return value
            };
        var keysEqual = function(keyExpr, key1, key2) {
                if ($.isArray(keyExpr)) {
                    var names = $.map(key1, function(v, k) {
                            return k
                        }),
                        name;
                    for (var i = 0; i < names.length; i++) {
                        name = names[i];
                        if (toComparable(key1[name], true) != toComparable(key2[name], true))
                            return false
                    }
                    return true
                }
                return toComparable(key1, true) == toComparable(key2, true)
            };
        var BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var base64_encode = function(input) {
                if (!$.isArray(input))
                    input = stringToByteArray(String(input));
                var result = "";
                for (var i = 0; i < input.length; i += 3) {
                    var octet1 = input[i],
                        octet2 = input[i + 1],
                        octet3 = input[i + 2];
                    result += $.map([octet1 >> 2, (octet1 & 3) << 4 | octet2 >> 4, isNaN(octet2) ? 64 : (octet2 & 15) << 2 | octet3 >> 6, isNaN(octet3) ? 64 : octet3 & 63], function(item) {
                        return BASE64_CHARS.charAt(item)
                    }).join("")
                }
                return result
            };
        var stringToByteArray = function(str) {
                var bytes = [],
                    code,
                    i;
                for (i = 0; i < str.length; i++) {
                    code = str.charCodeAt(i);
                    if (code < 128)
                        bytes.push(code);
                    else if (code < 2048)
                        bytes.push(192 + (code >> 6), 128 + (code & 63));
                    else if (code < 65536)
                        bytes.push(224 + (code >> 12), 128 + (code >> 6 & 63), 128 + (code & 63));
                    else if (code < 2097152)
                        bytes.push(240 + (code >> 18), 128 + (code >> 12 & 63), 128 + (code >> 6 & 63), 128 + (code & 63))
                }
                return bytes
            };
        var errorMessageFromXhr = function() {
                var textStatusMessages = {
                        timeout: "Network connection timeout",
                        error: "Unspecified network error",
                        parsererror: "Unexpected server response"
                    };
                var textStatusDetails = {
                        timeout: "possible causes: the remote host is not accessible, overloaded or is not included into the domain white-list when being run in the native container",
                        error: "if the remote host is located on another domain, make sure it properly supports cross-origin resource sharing (CORS), or use the JSONP approach instead",
                        parsererror: "the remote host did not respond with valid JSON data"
                    };
                var explainTextStatus = function(textStatus) {
                        var result = textStatusMessages[textStatus];
                        if (!result)
                            return textStatus;
                        result += " (" + textStatusDetails[textStatus] + ")";
                        return result
                    };
                return function(xhr, textStatus) {
                        if (xhr.status < 400)
                            return explainTextStatus(textStatus);
                        return xhr.statusText
                    }
            }();
        var aggregators = {
                count: {
                    seed: 0,
                    step: function(count) {
                        return 1 + count
                    }
                },
                sum: {
                    seed: 0,
                    step: function(sum, item) {
                        return sum + item
                    }
                },
                min: {step: function(min, item) {
                        return item < min ? item : min
                    }},
                max: {step: function(max, item) {
                        return item > max ? item : max
                    }},
                avg: {
                    seed: [0, 0],
                    step: function(pair, value) {
                        return [pair[0] + value, pair[1] + 1]
                    },
                    finalize: function(pair) {
                        return pair[1] ? pair[0] / pair[1] : NaN
                    }
                }
            };
        var data = DX.data = {
                utils: {
                    compileGetter: compileGetter,
                    compileSetter: compileSetter,
                    normalizeBinaryCriterion: normalizeBinaryCriterion,
                    normalizeSortingInfo: normalizeSortingInfo,
                    toComparable: toComparable,
                    keysEqual: keysEqual,
                    errorMessageFromXhr: errorMessageFromXhr,
                    aggregators: aggregators
                },
                Guid: Guid,
                base64_encode: base64_encode,
                queryImpl: {},
                queryAdapters: {},
                query: function() {
                    var impl = $.isArray(arguments[0]) ? "array" : "remote";
                    return data.queryImpl[impl].apply(this, arguments)
                },
                errorHandler: null,
                _errorHandler: function(error) {
                    DX.log("E4000", error);
                    if (data.errorHandler)
                        data.errorHandler(error)
                }
            }
    })(jQuery, DevExpress);
    /*! Module core, file data.aggregateCalculator.js */
    (function($, DX, undefined) {
        var data = DX.data,
            utils = data.utils;
        function isCount(aggregator) {
            return aggregator === utils.aggregators.count
        }
        function normalizeAggregate(aggregate) {
            var selector = utils.compileGetter(aggregate.selector),
                aggregator = aggregate.aggregator;
            if (typeof aggregator === "string") {
                aggregator = data.utils.aggregators[aggregator];
                if (!aggregator)
                    throw DX.Error("E4001", aggregate.aggregator);
            }
            return {
                    selector: selector,
                    aggregator: aggregator
                }
        }
        data.AggregateCalculator = DX.Class.inherit({
            ctor: function(options) {
                this._data = options.data;
                this._groupLevel = options.groupLevel || 0;
                this._totalAggregates = $.map(options.totalAggregates || [], normalizeAggregate);
                this._groupAggregates = $.map(options.groupAggregates || [], normalizeAggregate);
                this._totals = []
            },
            calculate: function() {
                if (this._totalAggregates.length)
                    this._calculateTotals(0, {items: this._data});
                if (this._groupAggregates.length && this._groupLevel > 0)
                    this._calculateGroups(0, {items: this._data})
            },
            _aggregate: function(data, aggregates, container) {
                var i,
                    j;
                for (i = 0; i < aggregates.length; i++) {
                    if (isCount(aggregates[i].aggregator)) {
                        container[i] = (container[i] || 0) + data.items.length;
                        continue
                    }
                    for (j = 0; j < data.items.length; j++)
                        this._accumulate(i, aggregates[i], container, data.items[j])
                }
            },
            _calculateTotals: function(level, data) {
                var i,
                    j;
                if (level === 0)
                    this._totals = this._seed(this._totalAggregates);
                if (level === this._groupLevel)
                    this._aggregate(data, this._totalAggregates, this._totals);
                else
                    for (i = 0; i < data.items.length; i++)
                        this._calculateTotals(level + 1, data.items[i]);
                if (level === 0)
                    this._totals = this._finalize(this._totalAggregates, this._totals)
            },
            _calculateGroups: function(level, data, outerAggregates) {
                var i,
                    j,
                    innerAggregates;
                if (level === this._groupLevel)
                    this._aggregate(data, this._groupAggregates, outerAggregates);
                else
                    for (i = 0; i < data.items.length; i++) {
                        innerAggregates = this._seed(this._groupAggregates);
                        this._calculateGroups(level + 1, data.items[i], innerAggregates);
                        data.items[i].aggregates = this._finalize(this._groupAggregates, innerAggregates);
                        if (level > 0) {
                            outerAggregates = outerAggregates || this._seed(this._groupAggregates);
                            this._calculateGroups(level + 1, data.items[i], outerAggregates)
                        }
                    }
            },
            totalAggregates: function() {
                return this._totals
            },
            _seed: function(aggregates) {
                return $.map(aggregates, function(aggregate, index) {
                        var aggregator = aggregate.aggregator,
                            seed = "seed" in aggregator ? aggregator.seed : NaN;
                        return $.isArray(seed) ? [seed] : seed
                    })
            },
            _accumulate: function(aggregateIndex, aggregate, results, item) {
                var value = aggregate.selector(item),
                    aggregator = aggregate.aggregator;
                results[aggregateIndex] = results[aggregateIndex] !== results[aggregateIndex] ? value : aggregator.step(results[aggregateIndex], value)
            },
            _finalize: function(aggregates, results) {
                return $.map(aggregates, function(aggregate, index) {
                        var fin = aggregate.aggregator.finalize;
                        return fin ? fin(results[index]) : results[index]
                    })
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.query.array.js */
    (function($, DX, undefined) {
        var Class = DX.Class,
            data = DX.data,
            queryImpl = data.queryImpl,
            compileGetter = data.utils.compileGetter,
            toComparable = data.utils.toComparable;
        var Iterator = Class.inherit({
                toArray: function() {
                    var result = [];
                    this.reset();
                    while (this.next())
                        result.push(this.current());
                    return result
                },
                countable: function() {
                    return false
                }
            });
        var ArrayIterator = Iterator.inherit({
                ctor: function(array) {
                    this.array = array;
                    this.index = -1
                },
                next: function() {
                    if (this.index + 1 < this.array.length) {
                        this.index++;
                        return true
                    }
                    return false
                },
                current: function() {
                    return this.array[this.index]
                },
                reset: function() {
                    this.index = -1
                },
                toArray: function() {
                    return this.array.slice(0)
                },
                countable: function() {
                    return true
                },
                count: function() {
                    return this.array.length
                }
            });
        var WrappedIterator = Iterator.inherit({
                ctor: function(iter) {
                    this.iter = iter
                },
                next: function() {
                    return this.iter.next()
                },
                current: function() {
                    return this.iter.current()
                },
                reset: function() {
                    return this.iter.reset()
                }
            });
        var MapIterator = WrappedIterator.inherit({
                ctor: function(iter, mapper) {
                    this.callBase(iter);
                    this.index = -1;
                    this.mapper = mapper
                },
                current: function() {
                    return this.mapper(this.callBase(), this.index)
                },
                next: function() {
                    var hasNext = this.callBase();
                    if (hasNext)
                        this.index++;
                    return hasNext
                }
            });
        var SortIterator = Iterator.inherit({
                ctor: function(iter, getter, desc) {
                    if (!(iter instanceof MapIterator))
                        iter = new MapIterator(iter, this._wrap);
                    this.iter = iter;
                    this.rules = [{
                            getter: getter,
                            desc: desc
                        }]
                },
                thenBy: function(getter, desc) {
                    var result = new SortIterator(this.sortedIter || this.iter, getter, desc);
                    if (!this.sortedIter)
                        result.rules = this.rules.concat(result.rules);
                    return result
                },
                next: function() {
                    this._ensureSorted();
                    return this.sortedIter.next()
                },
                current: function() {
                    this._ensureSorted();
                    return this.sortedIter.current()
                },
                reset: function() {
                    delete this.sortedIter
                },
                countable: function() {
                    return this.sortedIter || this.iter.countable()
                },
                count: function() {
                    if (this.sortedIter)
                        return this.sortedIter.count();
                    return this.iter.count()
                },
                _ensureSorted: function() {
                    if (this.sortedIter)
                        return;
                    $.each(this.rules, function() {
                        this.getter = compileGetter(this.getter)
                    });
                    this.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort($.proxy(this._compare, this))), this._unwrap)
                },
                _wrap: function(record, index) {
                    return {
                            index: index,
                            value: record
                        }
                },
                _unwrap: function(wrappedItem) {
                    return wrappedItem.value
                },
                _compare: function(x, y) {
                    var xIndex = x.index,
                        yIndex = y.index;
                    x = x.value;
                    y = y.value;
                    if (x === y)
                        return xIndex - yIndex;
                    for (var i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
                        var rule = this.rules[i],
                            xValue = toComparable(rule.getter(x)),
                            yValue = toComparable(rule.getter(y)),
                            factor = rule.desc ? -1 : 1;
                        if (xValue < yValue)
                            return -factor;
                        if (xValue > yValue)
                            return factor;
                        if (xValue !== yValue)
                            return !xValue ? -factor : factor
                    }
                    return xIndex - yIndex
                }
            });
        var compileCriteria = function() {
                var compileGroup = function(crit) {
                        var operands = [],
                            bag = ["return function(d) { return "],
                            index = 0,
                            pushAnd = false;
                        $.each(crit, function() {
                            if ($.isArray(this) || $.isFunction(this)) {
                                if (pushAnd)
                                    bag.push(" && ");
                                operands.push(compileCriteria(this));
                                bag.push("op[", index, "](d)");
                                index++;
                                pushAnd = true
                            }
                            else {
                                bag.push(/and|&/i.test(this) ? " && " : " || ");
                                pushAnd = false
                            }
                        });
                        bag.push(" }");
                        return new Function("op", bag.join(""))(operands)
                    };
                var toString = function(value) {
                        return DX.utils.isDefined(value) ? value.toString() : ''
                    };
                var compileBinary = function(crit) {
                        crit = data.utils.normalizeBinaryCriterion(crit);
                        var getter = compileGetter(crit[0]),
                            op = crit[1],
                            value = crit[2];
                        value = toComparable(value);
                        switch (op.toLowerCase()) {
                            case"=":
                                return compileEquals(getter, value);
                            case"<>":
                                return compileEquals(getter, value, true);
                            case">":
                                return function(obj) {
                                        return toComparable(getter(obj)) > value
                                    };
                            case"<":
                                return function(obj) {
                                        return toComparable(getter(obj)) < value
                                    };
                            case">=":
                                return function(obj) {
                                        return toComparable(getter(obj)) >= value
                                    };
                            case"<=":
                                return function(obj) {
                                        return toComparable(getter(obj)) <= value
                                    };
                            case"startswith":
                                return function(obj) {
                                        return toComparable(toString(getter(obj))).indexOf(value) === 0
                                    };
                            case"endswith":
                                return function(obj) {
                                        var getterValue = toComparable(toString(getter(obj)));
                                        return getterValue.lastIndexOf(value) === getterValue.length - toString(value).length
                                    };
                            case"contains":
                                return function(obj) {
                                        return toComparable(toString(getter(obj))).indexOf(value) > -1
                                    };
                            case"notcontains":
                                return function(obj) {
                                        return toComparable(toString(getter(obj))).indexOf(value) === -1
                                    }
                        }
                        throw DX.Error("E4003", op);
                    };
                function compileEquals(getter, value, negate) {
                    return function(obj) {
                            obj = toComparable(getter(obj));
                            var result = useStrictComparison(value) ? obj === value : obj == value;
                            if (negate)
                                result = !result;
                            return result
                        }
                }
                function useStrictComparison(value) {
                    return value === "" || value === 0 || value === null || value === false || value === undefined
                }
                return function(crit) {
                        if ($.isFunction(crit))
                            return crit;
                        if ($.isArray(crit[0]))
                            return compileGroup(crit);
                        return compileBinary(crit)
                    }
            }();
        var FilterIterator = WrappedIterator.inherit({
                ctor: function(iter, criteria) {
                    this.callBase(iter);
                    this.criteria = compileCriteria(criteria)
                },
                next: function() {
                    while (this.iter.next())
                        if (this.criteria(this.current()))
                            return true;
                    return false
                }
            });
        var GroupIterator = Iterator.inherit({
                ctor: function(iter, getter) {
                    this.iter = iter;
                    this.getter = getter
                },
                next: function() {
                    this._ensureGrouped();
                    return this.groupedIter.next()
                },
                current: function() {
                    this._ensureGrouped();
                    return this.groupedIter.current()
                },
                reset: function() {
                    delete this.groupedIter
                },
                countable: function() {
                    return !!this.groupedIter
                },
                count: function() {
                    return this.groupedIter.count()
                },
                _ensureGrouped: function() {
                    if (this.groupedIter)
                        return;
                    var hash = {},
                        keys = [],
                        iter = this.iter,
                        getter = compileGetter(this.getter);
                    iter.reset();
                    while (iter.next()) {
                        var current = iter.current(),
                            key = getter(current);
                        if (key in hash)
                            hash[key].push(current);
                        else {
                            hash[key] = [current];
                            keys.push(key)
                        }
                    }
                    this.groupedIter = new ArrayIterator($.map(keys, function(key) {
                        return {
                                key: key,
                                items: hash[key]
                            }
                    }))
                }
            });
        var SelectIterator = WrappedIterator.inherit({
                ctor: function(iter, getter) {
                    this.callBase(iter);
                    this.getter = compileGetter(getter)
                },
                current: function() {
                    return this.getter(this.callBase())
                },
                countable: function() {
                    return this.iter.countable()
                },
                count: function() {
                    return this.iter.count()
                }
            });
        var SliceIterator = WrappedIterator.inherit({
                ctor: function(iter, skip, take) {
                    this.callBase(iter);
                    this.skip = Math.max(0, skip);
                    this.take = Math.max(0, take);
                    this.pos = 0
                },
                next: function() {
                    if (this.pos >= this.skip + this.take)
                        return false;
                    while (this.pos < this.skip && this.iter.next())
                        this.pos++;
                    this.pos++;
                    return this.iter.next()
                },
                reset: function() {
                    this.callBase();
                    this.pos = 0
                },
                countable: function() {
                    return this.iter.countable()
                },
                count: function() {
                    return Math.min(this.iter.count() - this.skip, this.take)
                }
            });
        queryImpl.array = function(iter, queryOptions) {
            queryOptions = queryOptions || {};
            if (!(iter instanceof Iterator))
                iter = new ArrayIterator(iter);
            var handleError = function(error) {
                    var handler = queryOptions.errorHandler;
                    if (handler)
                        handler(error);
                    data._errorHandler(error)
                };
            var aggregateCore = function(aggregator) {
                    var d = $.Deferred().fail(handleError),
                        seed,
                        step = aggregator.step,
                        finalize = aggregator.finalize;
                    try {
                        iter.reset();
                        if ("seed" in aggregator)
                            seed = aggregator.seed;
                        else
                            seed = iter.next() ? iter.current() : NaN;
                        var accumulator = seed;
                        while (iter.next())
                            accumulator = step(accumulator, iter.current());
                        d.resolve(finalize ? finalize(accumulator) : accumulator)
                    }
                    catch(x) {
                        d.reject(x)
                    }
                    return d.promise()
                };
            var aggregate = function(seed, step, finalize) {
                    if (arguments.length < 2)
                        return aggregateCore({step: arguments[0]});
                    return aggregateCore({
                            seed: seed,
                            step: step,
                            finalize: finalize
                        })
                };
            var standardAggregate = function(name) {
                    return aggregateCore(data.utils.aggregators[name])
                };
            var select = function(getter) {
                    if (!$.isFunction(getter) && !$.isArray(getter))
                        getter = $.makeArray(arguments);
                    return chainQuery(new SelectIterator(iter, getter))
                };
            var selectProp = function(name) {
                    return select(compileGetter(name))
                };
            var chainQuery = function(iter) {
                    return queryImpl.array(iter, queryOptions)
                };
            return {
                    toArray: function() {
                        return iter.toArray()
                    },
                    enumerate: function() {
                        var d = $.Deferred().fail(handleError);
                        try {
                            d.resolve(iter.toArray())
                        }
                        catch(x) {
                            d.reject(x)
                        }
                        return d.promise()
                    },
                    sortBy: function(getter, desc) {
                        return chainQuery(new SortIterator(iter, getter, desc))
                    },
                    thenBy: function(getter, desc) {
                        if (iter instanceof SortIterator)
                            return chainQuery(iter.thenBy(getter, desc));
                        throw DX.Error("E4004");
                    },
                    filter: function(criteria) {
                        if (!$.isArray(criteria))
                            criteria = $.makeArray(arguments);
                        return chainQuery(new FilterIterator(iter, criteria))
                    },
                    slice: function(skip, take) {
                        if (take === undefined)
                            take = Number.MAX_VALUE;
                        return chainQuery(new SliceIterator(iter, skip, take))
                    },
                    select: select,
                    groupBy: function(getter) {
                        return chainQuery(new GroupIterator(iter, getter))
                    },
                    aggregate: aggregate,
                    count: function() {
                        if (iter.countable()) {
                            var d = $.Deferred().fail(handleError);
                            try {
                                d.resolve(iter.count())
                            }
                            catch(x) {
                                d.reject(x)
                            }
                            return d.promise()
                        }
                        return standardAggregate("count")
                    },
                    sum: function(getter) {
                        if (getter)
                            return selectProp(getter).sum();
                        return standardAggregate("sum")
                    },
                    min: function(getter) {
                        if (getter)
                            return selectProp(getter).min();
                        return standardAggregate("min")
                    },
                    max: function(getter) {
                        if (getter)
                            return selectProp(getter).max();
                        return standardAggregate("max")
                    },
                    avg: function(getter) {
                        if (getter)
                            return selectProp(getter).avg();
                        return standardAggregate("avg")
                    }
                }
        }
    })(jQuery, DevExpress);
    /*! Module core, file data.query.remote.js */
    (function($, DX, undefined) {
        var data = DX.data,
            queryImpl = data.queryImpl;
        queryImpl.remote = function(url, queryOptions, tasks) {
            tasks = tasks || [];
            queryOptions = queryOptions || {};
            var createTask = function(name, args) {
                    return {
                            name: name,
                            args: args
                        }
                };
            var exec = function(executorTask) {
                    var d = $.Deferred(),
                        _adapterFactory,
                        _adapter,
                        _taskQueue,
                        _currentTask,
                        _mergedSortArgs;
                    var rejectWithNotify = function(error) {
                            var handler = queryOptions.errorHandler;
                            if (handler)
                                handler(error);
                            data._errorHandler(error);
                            d.reject(error)
                        };
                    function mergeSortTask(task) {
                        switch (task.name) {
                            case"sortBy":
                                _mergedSortArgs = [task.args];
                                return true;
                            case"thenBy":
                                if (!_mergedSortArgs)
                                    throw DX.Error("E4004");
                                _mergedSortArgs.push(task.args);
                                return true
                        }
                        return false
                    }
                    function unmergeSortTasks() {
                        var head = _taskQueue[0],
                            unmergedTasks = [];
                        if (head && head.name === "multiSort") {
                            _taskQueue.shift();
                            $.each(head.args[0], function() {
                                unmergedTasks.push(createTask(unmergedTasks.length ? "thenBy" : "sortBy", this))
                            })
                        }
                        _taskQueue = unmergedTasks.concat(_taskQueue)
                    }
                    try {
                        _adapterFactory = queryOptions.adapter || "odata";
                        if (!$.isFunction(_adapterFactory))
                            _adapterFactory = data.queryAdapters[_adapterFactory];
                        _adapter = _adapterFactory(queryOptions);
                        _taskQueue = [].concat(tasks).concat(executorTask);
                        while (_taskQueue.length) {
                            _currentTask = _taskQueue[0];
                            if (!mergeSortTask(_currentTask)) {
                                if (_mergedSortArgs) {
                                    _taskQueue.unshift(createTask("multiSort", [_mergedSortArgs]));
                                    _mergedSortArgs = null;
                                    continue
                                }
                                if (String(_currentTask.name) !== "enumerate")
                                    if (!_adapter[_currentTask.name] || _adapter[_currentTask.name].apply(_adapter, _currentTask.args) === false)
                                        break
                            }
                            _taskQueue.shift()
                        }
                        unmergeSortTasks();
                        _adapter.exec(url).done(function(result, extra) {
                            if (!_taskQueue.length)
                                d.resolve(result, extra);
                            else {
                                var clientChain = queryImpl.array(result, {errorHandler: queryOptions.errorHandler});
                                $.each(_taskQueue, function() {
                                    clientChain = clientChain[this.name].apply(clientChain, this.args)
                                });
                                clientChain.done(d.resolve).fail(d.reject)
                            }
                        }).fail(rejectWithNotify)
                    }
                    catch(x) {
                        rejectWithNotify(x)
                    }
                    return d.promise()
                };
            var query = {};
            $.each(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], function() {
                var name = String(this);
                query[name] = function() {
                    return queryImpl.remote(url, queryOptions, tasks.concat(createTask(name, arguments)))
                }
            });
            $.each(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], function() {
                var name = String(this);
                query[name] = function() {
                    return exec.call(this, createTask(name, arguments))
                }
            });
            return query
        }
    })(jQuery, DevExpress);
    /*! Module core, file data.odata.js */
    (function($, DX, undefined) {
        var data = DX.data,
            utils = DX.utils,
            Guid = data.Guid;
        var GUID_REGEX = /^(\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0,1})$/;
        var VERBOSE_DATE_REGEX = /^\/Date\((-?\d+)((\+|-)?(\d+)?)\)\/$/;
        var ISO8601_DATE_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z?$/;
        var JSON_VERBOSE_MIME_TYPE = "application/json;odata=verbose";
        function stringify(object) {
            return JSON.stringify(object, replacer);
            function replacer(key, value) {
                if (this[key] instanceof Date)
                    return utils.formatIso8601Date(this[key]);
                return value
            }
        }
        function isAbsoluteUrl(url) {
            return /^(?:[a-z]+:)?\/\//i.test(url)
        }
        function toAbsoluteUrl(basePath, relativePath) {
            var part,
                baseParts = basePath.split("/"),
                relativeParts = relativePath.split("/");
            baseParts.pop();
            while (relativeParts.length) {
                part = relativeParts.shift();
                if (part === "..")
                    baseParts.pop();
                else
                    baseParts.push(part)
            }
            return baseParts.join("/")
        }
        var ajaxOptionsForRequest = function(request, requestOptions) {
                request = $.extend({
                    method: "get",
                    url: "",
                    params: {},
                    payload: null,
                    headers: {}
                }, request);
                requestOptions = requestOptions || {};
                var beforeSend = requestOptions.beforeSend;
                if (beforeSend)
                    beforeSend(request);
                var method = (request.method || "get").toLowerCase(),
                    isGet = method === "get",
                    useJsonp = isGet && requestOptions.jsonp,
                    params = $.extend({}, request.params),
                    ajaxData = isGet ? params : stringify(request.payload),
                    qs = !isGet && $.param(params),
                    url = request.url,
                    contentType = !isGet && JSON_VERBOSE_MIME_TYPE;
                if (qs)
                    url += (url.indexOf("?") > -1 ? "&" : "?") + qs;
                if (useJsonp)
                    ajaxData["$format"] = "json";
                return {
                        url: url,
                        data: ajaxData,
                        dataType: useJsonp ? "jsonp" : "json",
                        jsonp: useJsonp && "$callback",
                        type: method,
                        timeout: 30000,
                        headers: request.headers,
                        contentType: contentType,
                        accepts: {json: [JSON_VERBOSE_MIME_TYPE, "text/plain"].join()},
                        xhrFields: {withCredentials: requestOptions.withCredentials}
                    }
            };
        var sendRequest = function(request, requestOptions) {
                var d = $.Deferred();
                var options = ajaxOptionsForRequest(request, requestOptions);
                $.ajax(options).always(function(obj, textStatus) {
                    var tuplet = interpretJsonFormat(obj, textStatus),
                        error = tuplet.error,
                        data = tuplet.data,
                        nextUrl = tuplet.nextUrl,
                        extra;
                    if (error)
                        d.reject(error);
                    else if (requestOptions.countOnly)
                        d.resolve(tuplet.count);
                    else if (nextUrl) {
                        if (!isAbsoluteUrl(nextUrl))
                            nextUrl = toAbsoluteUrl(options.url, nextUrl);
                        sendRequest({url: nextUrl}, requestOptions).fail(d.reject).done(function(nextData) {
                            d.resolve(data.concat(nextData))
                        })
                    }
                    else {
                        if (isFinite(tuplet.count))
                            extra = {totalCount: tuplet.count};
                        d.resolve(data, extra)
                    }
                });
                return d.promise()
            };
        var formatDotNetError = function(errorObj) {
                var message,
                    currentError = errorObj;
                if ("message" in errorObj)
                    if (errorObj.message.value)
                        message = errorObj.message.value;
                    else
                        message = errorObj.message;
                while (currentError = currentError.innererror || currentError.internalexception) {
                    message = currentError.message;
                    if (currentError.internalexception && message.indexOf("inner exception") === -1)
                        break
                }
                return message
            };
        var errorFromResponse = function(obj, textStatus) {
                if (textStatus === "nocontent")
                    return null;
                var httpStatus = 200,
                    message = "Unknown error",
                    response = obj;
                if (textStatus !== "success") {
                    httpStatus = obj.status;
                    message = data.utils.errorMessageFromXhr(obj, textStatus);
                    try {
                        response = $.parseJSON(obj.responseText)
                    }
                    catch(x) {}
                }
                var errorObj = response && (response.error || response["@odata.error"]);
                if (errorObj) {
                    message = formatDotNetError(errorObj) || message;
                    if (httpStatus === 200)
                        httpStatus = 500;
                    if (errorObj.code)
                        httpStatus = Number(errorObj.code);
                    return $.extend(Error(message), {
                            httpStatus: httpStatus,
                            errorDetails: errorObj
                        })
                }
                else if (httpStatus !== 200)
                    return $.extend(Error(message), {httpStatus: httpStatus})
            };
        var interpretJsonFormat = function(obj, textStatus) {
                var error = errorFromResponse(obj, textStatus),
                    value;
                if (error)
                    return {error: error};
                if (!$.isPlainObject(obj))
                    return {data: obj};
                if ("d" in obj && (utils.isArray(obj.d) || utils.isObject(obj.d)))
                    value = interpretVerboseJsonFormat(obj, textStatus);
                else
                    value = interpretLightJsonFormat(obj, textStatus);
                transformTypes(value);
                return value
            };
        var interpretVerboseJsonFormat = function(obj, textStatus) {
                var data = obj.d;
                if (!data)
                    return {error: Error("Malformed or unsupported JSON response received")};
                data = data.results || data;
                return {
                        data: data,
                        nextUrl: obj.d.__next,
                        count: parseInt(obj.d.__count, 10)
                    }
            };
        var interpretLightJsonFormat = function(obj, textStatus) {
                var data = obj.value || obj;
                if (!data)
                    return {error: Error("Malformed or unsupported JSON response received")};
                return {
                        data: data,
                        nextUrl: obj["@odata.nextLink"],
                        count: parseInt(obj["@odata.count"], 10)
                    }
            };
        var EdmLiteral = DX.Class.inherit({
                ctor: function(value) {
                    this._value = value
                },
                valueOf: function() {
                    return this._value
                }
            });
        var transformTypes = function(obj) {
                $.each(obj, function(key, value) {
                    if (value !== null && typeof value === "object")
                        transformTypes(value);
                    else if (typeof value === "string")
                        if (GUID_REGEX.test(value))
                            obj[key] = new Guid(value);
                        else if (value.match(VERBOSE_DATE_REGEX)) {
                            var date = new Date(Number(RegExp.$1) + RegExp.$2 * 60 * 1000);
                            obj[key] = new Date(date.valueOf() + date.getTimezoneOffset() * 60 * 1000)
                        }
                        else if (ISO8601_DATE_REGEX.test(value))
                            obj[key] = new Date(utils.parseIso8601Date(obj[key]).valueOf())
                })
            };
        var serializeDate = function() {
                var pad = function(part) {
                        part = String(part);
                        if (part.length < 2)
                            part = "0" + part;
                        return part
                    };
                return function(date) {
                        var result = ["datetime'", date.getFullYear(), "-", pad(date.getMonth() + 1), "-", pad(date.getDate())];
                        if (date.getHours() || date.getMinutes() || date.getSeconds() || date.getMilliseconds()) {
                            result.push("T", pad(date.getHours()), ":", pad(date.getMinutes()), ":", pad(date.getSeconds()));
                            if (date.getMilliseconds())
                                result.push(".", date.getMilliseconds())
                        }
                        result.push("'");
                        return result.join("")
                    }
            }();
        var serializeString = function(value) {
                return "'" + value.replace(/</g, "%26lt").replace(/'/g, "''") + "'"
            };
        var serializePropName = function(propName) {
                if (propName instanceof EdmLiteral)
                    return propName.valueOf();
                return propName.replace(/\./g, "/")
            };
        var serializeValueV4 = function(value) {
                if (value instanceof Date)
                    return utils.formatIso8601Date(value);
                return serializeValueV2(value)
            };
        var serializeValueV2 = function(value) {
                if (value instanceof Date)
                    return serializeDate(value);
                if (value instanceof Guid)
                    return "guid'" + value + "'";
                if (value instanceof EdmLiteral)
                    return value.valueOf();
                if (typeof value === "string")
                    return serializeString(value);
                return String(value)
            };
        var DEFAULT_PROTOCOL_VERSION = 2;
        var serializeValue = function(value, protocolVersion) {
                protocolVersion = protocolVersion || DEFAULT_PROTOCOL_VERSION;
                switch (protocolVersion) {
                    case 2:
                    case 3:
                        return serializeValueV2(value);
                    case 4:
                        return serializeValueV4(value);
                    default:
                        throw DX.Error("E4002");
                }
            };
        var serializeKey = function(key, protocolVersion) {
                if ($.isPlainObject(key)) {
                    var parts = [];
                    $.each(key, function(k, v) {
                        parts.push(serializePropName(k) + "=" + serializeValue(v, protocolVersion))
                    });
                    return parts.join()
                }
                return serializeValue(key)
            };
        var keyConverters = {
                String: function(value) {
                    return value + ""
                },
                Int32: function(value) {
                    return Math.floor(value)
                },
                Int64: function(value) {
                    if (value instanceof EdmLiteral)
                        return value;
                    return new EdmLiteral(value + "L")
                },
                Guid: function(value) {
                    if (value instanceof Guid)
                        return value;
                    return new Guid(value)
                },
                Boolean: function(value) {
                    return !!value
                },
                Single: function(value) {
                    if (value instanceof EdmLiteral)
                        return value;
                    return new EdmLiteral(value + "f")
                },
                Decimal: function(value) {
                    if (value instanceof EdmLiteral)
                        return value;
                    return new EdmLiteral(value + "m")
                }
            };
        var compileCriteria = function() {
                var createBinaryOperationFormatter = function(op) {
                        return function(prop, val, bag) {
                                bag.push(prop, " ", op, " ", val)
                            }
                    };
                var createStringFuncFormatter = function(op, reverse) {
                        return function(prop, val, bag) {
                                if (reverse)
                                    bag.push(op, "(", val, ",", prop, ")");
                                else
                                    bag.push(op, "(", prop, ",", val, ")")
                            }
                    };
                var formatters = {
                        "=": createBinaryOperationFormatter("eq"),
                        "<>": createBinaryOperationFormatter("ne"),
                        ">": createBinaryOperationFormatter("gt"),
                        ">=": createBinaryOperationFormatter("ge"),
                        "<": createBinaryOperationFormatter("lt"),
                        "<=": createBinaryOperationFormatter("le"),
                        startswith: createStringFuncFormatter("startswith"),
                        endswith: createStringFuncFormatter("endswith")
                    };
                var formattersV2 = $.extend({}, formatters, {
                        contains: createStringFuncFormatter("substringof", true),
                        notcontains: createStringFuncFormatter("not substringof", true)
                    });
                var formattersV4 = $.extend({}, formatters, {
                        contains: createStringFuncFormatter("contains"),
                        notcontains: createStringFuncFormatter("not contains")
                    });
                var compileBinary = function(criteria, bag, protocolVersion) {
                        criteria = data.utils.normalizeBinaryCriterion(criteria);
                        var op = criteria[1],
                            formatters = protocolVersion === 4 ? formattersV4 : formattersV2,
                            formatter = formatters[op.toLowerCase()];
                        if (!formatter)
                            throw DX.Error("E4003", op);
                        formatter(serializePropName(criteria[0]), serializeValue(criteria[2], protocolVersion), bag)
                    };
                var compileGroup = function(criteria, bag, protocolVersion) {
                        var pushAnd = false;
                        $.each(criteria, function() {
                            if ($.isArray(this)) {
                                if (pushAnd)
                                    bag.push(" and ");
                                bag.push("(");
                                compileCore(this, bag, protocolVersion);
                                bag.push(")");
                                pushAnd = true
                            }
                            else {
                                bag.push(/and|&/i.test(this) ? " and " : " or ");
                                pushAnd = false
                            }
                        })
                    };
                var compileCore = function(criteria, bag, protocolVersion) {
                        if ($.isArray(criteria[0]))
                            compileGroup(criteria, bag, protocolVersion);
                        else
                            compileBinary(criteria, bag, protocolVersion)
                    };
                return function(criteria, protocolVersion) {
                        var bag = [];
                        compileCore(criteria, bag, protocolVersion);
                        return bag.join("")
                    }
            }();
        var createODataQueryAdapter = function(queryOptions) {
                var _sorting = [],
                    _criteria = [],
                    _select,
                    _skip,
                    _take,
                    _countQuery;
                var hasSlice = function() {
                        return _skip || _take !== undefined
                    };
                var generateExpand = function() {
                        var hash = {};
                        if (queryOptions.expand)
                            $.each($.makeArray(queryOptions.expand), function() {
                                hash[serializePropName(this)] = 1
                            });
                        if (_select)
                            $.each(_select, function() {
                                var path = this.split(".");
                                if (path.length < 2)
                                    return;
                                path.pop();
                                hash[serializePropName(path.join("."))] = 1
                            });
                        return $.map(hash, function(k, v) {
                                return v
                            }).join() || undefined
                    };
                var requestData = function() {
                        var result = {};
                        if (!_countQuery) {
                            if (_sorting.length)
                                result["$orderby"] = _sorting.join(",");
                            if (_skip)
                                result["$skip"] = _skip;
                            if (_take !== undefined)
                                result["$top"] = _take;
                            if (_select)
                                result["$select"] = serializePropName(_select.join());
                            result["$expand"] = generateExpand()
                        }
                        if (_criteria.length)
                            result["$filter"] = compileCriteria(_criteria.length < 2 ? _criteria[0] : _criteria, queryOptions.version);
                        if (_countQuery)
                            result["$top"] = 0;
                        if (queryOptions.requireTotalCount || _countQuery)
                            if (queryOptions.version !== 4)
                                result["$inlinecount"] = "allpages";
                            else
                                result["$count"] = "true";
                        return result
                    };
                return {
                        exec: function(url) {
                            return sendRequest({
                                    url: url,
                                    params: $.extend(requestData(), queryOptions && queryOptions.params)
                                }, {
                                    beforeSend: queryOptions.beforeSend,
                                    jsonp: queryOptions.jsonp,
                                    withCredentials: queryOptions.withCredentials,
                                    countOnly: _countQuery
                                })
                        },
                        multiSort: function(args) {
                            var rules;
                            if (hasSlice())
                                return false;
                            for (var i = 0; i < args.length; i++) {
                                var getter = args[i][0],
                                    desc = !!args[i][1],
                                    rule;
                                if (typeof getter !== "string")
                                    return false;
                                rule = serializePropName(getter);
                                if (desc)
                                    rule += " desc";
                                rules = rules || [];
                                rules.push(rule)
                            }
                            _sorting = rules
                        },
                        slice: function(skipCount, takeCount) {
                            if (hasSlice())
                                return false;
                            _skip = skipCount;
                            _take = takeCount
                        },
                        filter: function(criterion) {
                            if (hasSlice() || $.isFunction(criterion))
                                return false;
                            if (!$.isArray(criterion))
                                criterion = $.makeArray(arguments);
                            if (_criteria.length)
                                _criteria.push("and");
                            _criteria.push(criterion)
                        },
                        select: function(expr) {
                            if (_select || $.isFunction(expr))
                                return false;
                            if (!$.isArray(expr))
                                expr = $.makeArray(arguments);
                            _select = expr
                        },
                        count: function() {
                            _countQuery = true
                        }
                    }
            };
        $.extend(true, data, {
            EdmLiteral: EdmLiteral,
            utils: {odata: {
                    sendRequest: sendRequest,
                    serializePropName: serializePropName,
                    serializeValue: serializeValue,
                    serializeKey: serializeKey,
                    keyConverters: keyConverters
                }},
            queryAdapters: {odata: createODataQueryAdapter}
        });
        data.OData__internals = {interpretJsonFormat: interpretJsonFormat}
    })(jQuery, DevExpress);
    /*! Module core, file data.store.abstract.js */
    (function($, DX, undefined) {
        var Class = DX.Class,
            abstract = DX.abstract,
            data = DX.data,
            normalizeSortingInfo = data.utils.normalizeSortingInfo;
        var STORE_CALLBACK_NAMES = ["loading", "loaded", "modifying", "modified", "inserting", "inserted", "updating", "updated", "removing", "removed"];
        function multiLevelGroup(query, groupInfo) {
            query = query.groupBy(groupInfo[0].selector);
            if (groupInfo.length > 1)
                query = query.select(function(g) {
                    return $.extend({}, g, {items: multiLevelGroup(data.query(g.items), groupInfo.slice(1)).toArray()})
                });
            return query
        }
        data.utils.multiLevelGroup = multiLevelGroup;
        function arrangeSortingInfo(groupInfo, sortInfo) {
            var filteredGroup = [];
            $.each(groupInfo, function(_, group) {
                var collision = $.grep(sortInfo, function(sort) {
                        return group.selector == sort.selector
                    });
                if (collision.length < 1)
                    filteredGroup.push(group)
            });
            return filteredGroup.concat(sortInfo)
        }
        data.utils.arrangeSortingInfo = arrangeSortingInfo;
        data.Store = Class.inherit({
            ctor: function(options) {
                var that = this;
                options = options || {};
                $.each(STORE_CALLBACK_NAMES, function() {
                    var eventName = this;
                    var callbacks = that[eventName] = $.Callbacks();
                    var originalAdd = callbacks.add;
                    callbacks.add = function() {
                        DX.log("W0003", "Store", eventName, "14.2", "Use the '" + eventName + "' event instead");
                        return originalAdd.apply(eventName, arguments)
                    };
                    if (eventName in options)
                        callbacks.add(options[eventName]);
                    var propertyName = "on" + eventName.charAt(0).toUpperCase() + eventName.slice(1);
                    if (propertyName in options)
                        that.on(eventName, options[propertyName])
                });
                this._key = options.key;
                this._errorHandler = options.errorHandler;
                this._useDefaultSearch = true
            },
            _customLoadOptions: function() {
                return null
            },
            key: function() {
                return this._key
            },
            keyOf: function(obj) {
                if (!this._keyGetter)
                    this._keyGetter = data.utils.compileGetter(this.key());
                return this._keyGetter(obj)
            },
            _requireKey: function() {
                if (!this.key())
                    throw DX.Error("E4005");
            },
            load: function(options) {
                var that = this;
                options = options || {};
                this.fireEvent("loading", [options]);
                this.loading.fire(options);
                return this._loadImpl(options).done(function(result, extra) {
                        that.fireEvent("loaded", [result, options]);
                        that.loaded.fire(result, extra)
                    })
            },
            _loadImpl: function(options) {
                var filter = options.filter,
                    sort = options.sort,
                    select = options.select,
                    group = options.group,
                    skip = options.skip,
                    take = options.take,
                    q = this.createQuery(options);
                if (filter)
                    q = q.filter(filter);
                if (group)
                    group = normalizeSortingInfo(group);
                if (sort || group) {
                    sort = normalizeSortingInfo(sort || []);
                    if (group)
                        sort = arrangeSortingInfo(group, sort);
                    $.each(sort, function(index) {
                        q = q[index ? "thenBy" : "sortBy"](this.selector, this.desc)
                    })
                }
                if (select)
                    q = q.select(select);
                if (group)
                    q = multiLevelGroup(q, group);
                if (take || skip)
                    q = q.slice(skip || 0, take);
                return q.enumerate()
            },
            createQuery: abstract,
            totalCount: function(options) {
                return this._addFailHandlers(this._totalCountImpl(options))
            },
            _totalCountImpl: function(options) {
                options = options || {};
                var q = this.createQuery(),
                    group = options.group,
                    filter = options.filter;
                if (filter)
                    q = q.filter(filter);
                if (group) {
                    group = normalizeSortingInfo(group);
                    q = multiLevelGroup(q, group)
                }
                return q.count()
            },
            byKey: function(key, extraOptions) {
                return this._addFailHandlers(this._byKeyImpl(key, extraOptions))
            },
            _byKeyImpl: abstract,
            insert: function(values) {
                var that = this;
                that.fireEvent("modifying");
                that.fireEvent("inserting", [values]);
                that.modifying.fire();
                that.inserting.fire(values);
                return that._addFailHandlers(that._insertImpl(values).done(function(callbackValues, callbackKey) {
                        that.fireEvent("inserted", [callbackValues, callbackKey]);
                        that.fireEvent("modified");
                        that.inserted.fire(callbackValues, callbackKey);
                        that.modified.fire()
                    }))
            },
            _insertImpl: abstract,
            update: function(key, values) {
                var that = this;
                that.fireEvent("modifying");
                that.fireEvent("updating", [key, values]);
                that.modifying.fire();
                that.updating.fire(key, values);
                return that._addFailHandlers(that._updateImpl(key, values).done(function(callbackKey, callbackValues) {
                        that.fireEvent("updated", [callbackKey, callbackValues]);
                        that.fireEvent("modified");
                        that.updated.fire(callbackKey, callbackValues);
                        that.modified.fire()
                    }))
            },
            _updateImpl: abstract,
            remove: function(key) {
                var that = this;
                that.fireEvent("modifying");
                that.fireEvent("removing", [key]);
                that.modifying.fire();
                that.removing.fire(key);
                return that._addFailHandlers(that._removeImpl(key).done(function(callbackKey) {
                        that.fireEvent("removed", [callbackKey]);
                        that.fireEvent("modified");
                        that.removed.fire(callbackKey);
                        that.modified.fire()
                    }))
            },
            _removeImpl: abstract,
            _addFailHandlers: function(deferred) {
                return deferred.fail(this._errorHandler, data._errorHandler)
            }
        }).include(DX.EventsMixin)
    })(jQuery, DevExpress);
    /*! Module core, file data.store.array.js */
    (function($, DX, undefined) {
        var data = DX.data,
            Guid = data.Guid;
        var trivialPromise = function(_) {
                var d = $.Deferred();
                return d.resolve.apply(d, arguments).promise()
            };
        var rejectedPromise = function(_) {
                var d = $.Deferred();
                return d.reject.apply(d, arguments).promise()
            };
        data.ArrayStore = data.Store.inherit({
            ctor: function(options) {
                if ($.isArray(options))
                    options = {data: options};
                else
                    options = options || {};
                this.callBase(options);
                var initialArray = options.data;
                if (initialArray && !$.isArray(initialArray))
                    throw DX.Error("E4006");
                this._array = initialArray || []
            },
            createQuery: function() {
                return data.query(this._array, {errorHandler: this._errorHandler})
            },
            _byKeyImpl: function(key) {
                var index = this._indexByKey(key);
                if (index === -1)
                    return rejectedPromise();
                return trivialPromise(this._array[index])
            },
            _insertImpl: function(values) {
                var keyExpr = this.key(),
                    keyValue,
                    obj;
                if ($.isPlainObject(values))
                    obj = $.extend({}, values);
                else
                    obj = values;
                if (keyExpr) {
                    keyValue = this.keyOf(obj);
                    if (keyValue === undefined || typeof keyValue === "object" && $.isEmptyObject(keyValue)) {
                        if ($.isArray(keyExpr))
                            throw DX.Error("E4007");
                        keyValue = obj[keyExpr] = String(new Guid)
                    }
                    else if (this._array[this._indexByKey(keyValue)] !== undefined)
                        return rejectedPromise(DX.Error("E4008"))
                }
                else
                    keyValue = obj;
                this._array.push(obj);
                return trivialPromise(values, keyValue)
            },
            _updateImpl: function(key, values) {
                var target;
                if (this.key()) {
                    var index = this._indexByKey(key);
                    if (index < 0)
                        return rejectedPromise(DX.Error("E4009"));
                    target = this._array[index]
                }
                else
                    target = key;
                DX.utils.deepExtendArraySafe(target, values);
                return trivialPromise(key, values)
            },
            _removeImpl: function(key) {
                var index = this._indexByKey(key);
                if (index > -1)
                    this._array.splice(index, 1);
                return trivialPromise(key)
            },
            _indexByKey: function(key) {
                for (var i = 0, arrayLength = this._array.length; i < arrayLength; i++)
                    if (data.utils.keysEqual(this.key(), this.keyOf(this._array[i]), key))
                        return i;
                return -1
            },
            clear: function() {
                this._array = []
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.store.local.js */
    (function($, DX, undefined) {
        var Class = DX.Class,
            abstract = DX.abstract,
            data = DX.data;
        var LocalStoreBackend = Class.inherit({
                ctor: function(store, storeOptions) {
                    this._store = store;
                    this._dirty = false;
                    var immediate = this._immediate = storeOptions.immediate;
                    var flushInterval = Math.max(100, storeOptions.flushInterval || 10 * 1000);
                    if (!immediate) {
                        var saveProxy = $.proxy(this.save, this);
                        setInterval(saveProxy, flushInterval);
                        $(window).on("beforeunload", saveProxy);
                        if (window.cordova)
                            document.addEventListener("pause", saveProxy, false)
                    }
                },
                notifyChanged: function() {
                    this._dirty = true;
                    if (this._immediate)
                        this.save()
                },
                load: function() {
                    this._store._array = this._loadImpl();
                    this._dirty = false
                },
                save: function() {
                    if (!this._dirty)
                        return;
                    this._saveImpl(this._store._array);
                    this._dirty = false
                },
                _loadImpl: abstract,
                _saveImpl: abstract
            });
        var DomLocalStoreBackend = LocalStoreBackend.inherit({
                ctor: function(store, storeOptions) {
                    this.callBase(store, storeOptions);
                    var name = storeOptions.name;
                    if (!name)
                        throw DX.Error("E4013");
                    this._key = "dx-data-localStore-" + name
                },
                _loadImpl: function() {
                    var raw = localStorage.getItem(this._key);
                    if (raw)
                        return JSON.parse(raw);
                    return []
                },
                _saveImpl: function(array) {
                    if (!array.length)
                        localStorage.removeItem(this._key);
                    else
                        localStorage.setItem(this._key, JSON.stringify(array))
                }
            });
        var localStoreBackends = {dom: DomLocalStoreBackend};
        data.LocalStore = data.ArrayStore.inherit({
            ctor: function(options) {
                if (typeof options === "string")
                    options = {name: options};
                else
                    options = options || {};
                this.callBase(options);
                this._backend = new localStoreBackends[options.backend || "dom"](this, options);
                this._backend.load()
            },
            clear: function() {
                this.callBase();
                this._backend.notifyChanged()
            },
            _insertImpl: function(values) {
                var b = this._backend;
                return this.callBase(values).done($.proxy(b.notifyChanged, b))
            },
            _updateImpl: function(key, values) {
                var b = this._backend;
                return this.callBase(key, values).done($.proxy(b.notifyChanged, b))
            },
            _removeImpl: function(key) {
                var b = this._backend;
                return this.callBase(key).done($.proxy(b.notifyChanged, b))
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.store.odata.js */
    (function($, DX, undefined) {
        var Class = DX.Class,
            data = DX.data,
            utils = DX.utils,
            odataUtils = data.utils.odata;
        var escapeServiceOperationParams = function(params, version) {
                if (!params)
                    return params;
                var result = {};
                $.each(params, function(k, v) {
                    result[k] = odataUtils.serializeValue(v, version)
                });
                return result
            };
        var convertSimpleKey = function(keyType, keyValue) {
                var converter = odataUtils.keyConverters[keyType];
                if (!converter)
                    throw DX.Error("E4014", keyType);
                return converter(keyValue)
            };
        var SharedMethods = {
                _extractServiceOptions: function(options) {
                    options = options || {};
                    this._url = String(options.url).replace(/\/+$/, "");
                    this._beforeSend = options.beforeSend;
                    this._jsonp = options.jsonp;
                    this._version = options.version;
                    this._withCredentials = options.withCredentials
                },
                _sendRequest: function(url, method, params, payload) {
                    return odataUtils.sendRequest({
                            url: url,
                            method: method,
                            params: params || {},
                            payload: payload
                        }, {
                            beforeSend: this._beforeSend,
                            jsonp: this._jsonp,
                            withCredentials: this._withCredentials
                        })
                },
                version: function() {
                    return this._version
                }
            };
        var ODataStore = data.Store.inherit({
                ctor: function(options) {
                    this.callBase(options);
                    this._extractServiceOptions(options);
                    this._keyType = options.keyType
                },
                _customLoadOptions: function() {
                    return ["expand", "customQueryParams"]
                },
                _byKeyImpl: function(key, extraOptions) {
                    var params = {};
                    if (extraOptions)
                        if (extraOptions.expand)
                            params["$expand"] = $.map($.makeArray(extraOptions.expand), odataUtils.serializePropName).join();
                    return this._sendRequest(this._byKeyUrl(key), "GET", params)
                },
                createQuery: function(loadOptions) {
                    loadOptions = loadOptions || {};
                    return data.query(this._url, {
                            beforeSend: this._beforeSend,
                            errorHandler: this._errorHandler,
                            jsonp: this._jsonp,
                            version: this._version,
                            withCredentials: this._withCredentials,
                            params: escapeServiceOperationParams(loadOptions.customQueryParams, this._version),
                            expand: loadOptions.expand,
                            requireTotalCount: loadOptions.requireTotalCount
                        })
                },
                _insertImpl: function(values) {
                    this._requireKey();
                    var that = this,
                        d = $.Deferred();
                    $.when(this._sendRequest(this._url, "POST", null, values)).done(function(serverResponse) {
                        d.resolve(values, that.keyOf(serverResponse))
                    }).fail(d.reject, d);
                    return d.promise()
                },
                _updateImpl: function(key, values) {
                    var d = $.Deferred();
                    $.when(this._sendRequest(this._byKeyUrl(key), "MERGE", null, values)).done(function() {
                        d.resolve(key, values)
                    }).fail(d.reject, d);
                    return d.promise()
                },
                _removeImpl: function(key) {
                    var d = $.Deferred();
                    $.when(this._sendRequest(this._byKeyUrl(key), "DELETE")).done(function() {
                        d.resolve(key)
                    }).fail(d.reject, d);
                    return d.promise()
                },
                _byKeyUrl: function(key) {
                    var keyObj = key,
                        keyType = this._keyType;
                    if ($.isPlainObject(keyType)) {
                        keyObj = {};
                        $.each(keyType, function(subKeyName, subKeyType) {
                            keyObj[subKeyName] = convertSimpleKey(subKeyType, key[subKeyName])
                        })
                    }
                    else if (keyType)
                        keyObj = convertSimpleKey(keyType, key);
                    return this._url + "(" + encodeURIComponent(odataUtils.serializeKey(keyObj, this._version)) + ")"
                }
            }).include(SharedMethods);
        var ODataContext = Class.inherit({
                ctor: function(options) {
                    var that = this;
                    that._extractServiceOptions(options);
                    that._errorHandler = options.errorHandler;
                    $.each(options.entities || [], function(entityAlias, entityOptions) {
                        that[entityAlias] = new ODataStore($.extend({}, options, {url: that._url + "/" + encodeURIComponent(entityOptions.name || entityAlias)}, entityOptions))
                    })
                },
                get: function(operationName, params) {
                    return this.invoke(operationName, params, "GET")
                },
                invoke: function(operationName, params, httpMethod) {
                    httpMethod = httpMethod || "POST";
                    var d = $.Deferred();
                    $.when(this._sendRequest(this._url + "/" + encodeURIComponent(operationName), httpMethod, escapeServiceOperationParams(params, this._version))).done(function(r) {
                        if (r && operationName in r)
                            r = r[operationName];
                        d.resolve(r)
                    }).fail([this._errorHandler, data._errorHandler, d.reject]);
                    return d.promise()
                },
                objectLink: function(entityAlias, key) {
                    var store = this[entityAlias];
                    if (!store)
                        throw DX.Error("E4015", entityAlias);
                    if (!utils.isDefined(key))
                        return null;
                    return {__metadata: {uri: store._byKeyUrl(key)}}
                }
            }).include(SharedMethods);
        $.extend(data, {
            ODataStore: ODataStore,
            ODataContext: ODataContext
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.store.custom.js */
    (function($, DX, undefined) {
        var data = DX.data;
        var TOTAL_COUNT = "totalCount",
            LOAD = "load",
            BY_KEY = "byKey",
            INSERT = "insert",
            UPDATE = "update",
            REMOVE = "remove";
        function isPromise(obj) {
            return obj && $.isFunction(obj.then)
        }
        function trivialPromise(value) {
            return $.Deferred().resolve(value).promise()
        }
        function ensureRequiredFuncOption(name, obj) {
            if (!$.isFunction(obj))
                throw DX.Error("E4011", name);
        }
        function throwInvalidUserFuncResult(name) {
            throw DX.Error("E4012", name);
        }
        function createUserFuncFailureHandler(pendingDeferred) {
            function errorMessageFromXhr(promiseArguments) {
                var xhr = promiseArguments[0],
                    textStatus = promiseArguments[1];
                if (!xhr || !xhr.getResponseHeader)
                    return null;
                return data.utils.errorMessageFromXhr(xhr, textStatus)
            }
            return function(arg) {
                    var error;
                    if (arg instanceof Error)
                        error = arg;
                    else
                        error = new Error(errorMessageFromXhr(arguments) || arg && String(arg) || "Unknown error");
                    pendingDeferred.reject(error)
                }
        }
        data.CustomStore = data.Store.inherit({
            ctor: function(options) {
                options = options || {};
                this.callBase(options);
                this._useDefaultSearch = false;
                this._loadFunc = options[LOAD];
                this._totalCountFunc = options[TOTAL_COUNT];
                this._byKeyFunc = options[BY_KEY] || options.lookup;
                this._insertFunc = options[INSERT];
                this._updateFunc = options[UPDATE];
                this._removeFunc = options[REMOVE]
            },
            createQuery: function() {
                throw DX.Error("E4010");
            },
            _totalCountImpl: function(options) {
                var userFunc = this._totalCountFunc,
                    userResult,
                    d = $.Deferred();
                ensureRequiredFuncOption(TOTAL_COUNT, userFunc);
                userResult = userFunc(options);
                if (!isPromise(userResult)) {
                    userResult = Number(userResult);
                    if (!isFinite(userResult))
                        throwInvalidUserFuncResult(TOTAL_COUNT);
                    userResult = trivialPromise(userResult)
                }
                userResult.then(function(count) {
                    d.resolve(Number(count))
                }, createUserFuncFailureHandler(d));
                return d.promise()
            },
            _loadImpl: function(options) {
                var userFunc = this._loadFunc,
                    userResult,
                    d = $.Deferred();
                ensureRequiredFuncOption(LOAD, userFunc);
                userResult = userFunc(options);
                if ($.isArray(userResult))
                    userResult = trivialPromise(userResult);
                else if (userResult === null || userResult === undefined)
                    userResult = trivialPromise([]);
                else if (!isPromise(userResult))
                    throwInvalidUserFuncResult(LOAD);
                userResult.then(function(data, extra) {
                    d.resolve(data, extra)
                }, createUserFuncFailureHandler(d));
                return this._addFailHandlers(d.promise())
            },
            _byKeyImpl: function(key) {
                var userFunc = this._byKeyFunc,
                    userResult,
                    d = $.Deferred();
                ensureRequiredFuncOption(BY_KEY, userFunc);
                userResult = userFunc(key);
                if (!isPromise(userResult))
                    userResult = trivialPromise(userResult);
                userResult.then(function(obj) {
                    d.resolve(obj)
                }, createUserFuncFailureHandler(d));
                return d.promise()
            },
            _insertImpl: function(values) {
                var userFunc = this._insertFunc,
                    userResult,
                    d = $.Deferred();
                ensureRequiredFuncOption(INSERT, userFunc);
                userResult = userFunc(values);
                if (!isPromise(userResult))
                    userResult = trivialPromise(userResult);
                userResult.then(function(newKey) {
                    d.resolve(values, newKey)
                }, createUserFuncFailureHandler(d));
                return d.promise()
            },
            _updateImpl: function(key, values) {
                var userFunc = this._updateFunc,
                    userResult,
                    d = $.Deferred();
                ensureRequiredFuncOption(UPDATE, userFunc);
                userResult = userFunc(key, values);
                if (!isPromise(userResult))
                    userResult = trivialPromise();
                userResult.then(function() {
                    d.resolve(key, values)
                }, createUserFuncFailureHandler(d));
                return d.promise()
            },
            _removeImpl: function(key) {
                var userFunc = this._removeFunc,
                    userResult,
                    d = $.Deferred();
                ensureRequiredFuncOption(REMOVE, userFunc);
                userResult = userFunc(key);
                if (!isPromise(userResult))
                    userResult = trivialPromise();
                userResult.then(function() {
                    d.resolve(key)
                }, createUserFuncFailureHandler(d));
                return d.promise()
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.dataSource.js */
    (function($, DX, undefined) {
        var data = DX.data,
            CustomStore = data.CustomStore,
            Class = DX.Class;
        var storeTypeRegistry = {
                jaydata: "JayDataStore",
                breeze: "BreezeStore",
                odata: "ODataStore",
                local: "LocalStore",
                array: "ArrayStore"
            };
        var nextLoadOperationId = function() {
                var id = -1;
                return function() {
                        return ++id
                    }
            }();
        var canceledOperationsRegistry = function() {
                var registry = {};
                return {
                        add: function(operationId) {
                            registry[operationId] = true
                        },
                        has: function(operationId) {
                            return operationId in registry
                        },
                        remove: function(operationId) {
                            delete registry[operationId]
                        }
                    }
            }();
        var ensureIsNotRejected = function(loadOperationId, pendingDeferred) {
                if (canceledOperationsRegistry.has(loadOperationId)) {
                    canceledOperationsRegistry.remove(loadOperationId);
                    pendingDeferred.reject("canceled");
                    return false
                }
                return true
            };
        function normalizeDataSourceOptions(options) {
            var store;
            function createCustomStoreFromLoadFunc() {
                var storeConfig = {};
                $.each(["key", "load", "byKey", "lookup", "totalCount", "insert", "update", "remove"], function() {
                    storeConfig[this] = options[this];
                    delete options[this]
                });
                return new CustomStore(storeConfig)
            }
            function createStoreFromConfig(storeConfig) {
                var storeCtor = data[storeTypeRegistry[storeConfig.type]];
                delete storeConfig.type;
                return new storeCtor(storeConfig)
            }
            function createCustomStoreFromUrl(url) {
                return new CustomStore({load: function() {
                            return $.getJSON(url)
                        }})
            }
            if (typeof options === "string")
                options = createCustomStoreFromUrl(options);
            if (options === undefined)
                options = [];
            if ($.isArray(options) || options instanceof data.Store)
                options = {store: options};
            else
                options = $.extend({}, options);
            if (options.store === undefined)
                options.store = [];
            store = options.store;
            if ("load" in options)
                store = createCustomStoreFromLoadFunc();
            else if ($.isArray(store))
                store = new data.ArrayStore(store);
            else if ($.isPlainObject(store))
                store = createStoreFromConfig($.extend({}, store));
            options.store = store;
            return options
        }
        function normalizeStoreLoadOptionAccessorArguments(originalArguments) {
            switch (originalArguments.length) {
                case 0:
                    return undefined;
                case 1:
                    return originalArguments[0]
            }
            return $.makeArray(originalArguments)
        }
        function generateStoreLoadOptionAccessor(optionName) {
            return function() {
                    var args = normalizeStoreLoadOptionAccessorArguments(arguments);
                    if (args !== undefined)
                        this._storeLoadOptions[optionName] = args;
                    return this._storeLoadOptions[optionName]
                }
        }
        function mapDataRespectingGrouping(items, mapper, groupInfo) {
            function mapRecursive(items, level) {
                return level ? mapGroup(items, level) : $.map(items, mapper)
            }
            function mapGroup(group, level) {
                return $.map(group, function(item) {
                        return {
                                key: item.key,
                                items: mapRecursive(item.items, level - 1)
                            }
                    })
            }
            return mapRecursive(items, groupInfo ? data.utils.normalizeSortingInfo(groupInfo).length : 0)
        }
        var DataSource = Class.inherit({
                ctor: function(options) {
                    options = normalizeDataSourceOptions(options);
                    this._store = options.store;
                    this._storeLoadOptions = this._extractLoadOptions(options);
                    this._mapFunc = options.map;
                    this._postProcessFunc = options.postProcess;
                    this._pageIndex = options.pageIndex !== undefined ? options.pageIndex : 0;
                    this._pageSize = options.pageSize !== undefined ? options.pageSize : 20;
                    this._items = [];
                    this._totalCount = -1;
                    this._isLoaded = false;
                    this._loadingCount = 0;
                    this._preferSync = options._preferSync;
                    this._loadQueue = this._createLoadQueue();
                    this._searchValue = "searchValue" in options ? options.searchValue : null;
                    this._searchOperation = options.searchOperation || "contains";
                    this._searchExpr = options.searchExpr;
                    this._paginate = options.paginate;
                    if (this._paginate === undefined)
                        this._paginate = !this.group();
                    this._isLastPage = !this._paginate;
                    this._userData = {};
                    $.each(["changed", "loadError", "loadingChanged"], $.proxy(function(_, eventName) {
                        var callbacks = this[eventName] = $.Callbacks();
                        var originalAdd = callbacks.add;
                        callbacks.add = function() {
                            DX.log("W0003", "DataSource", eventName, "14.2", "Use the '" + eventName + "' event instead");
                            return originalAdd.apply(eventName, arguments)
                        }
                    }, this));
                    $.each(["changed", "loadError", "loadingChanged", "customizeLoadResult", "customizeStoreLoadOptions"], $.proxy(function(_, eventName) {
                        var optionName = "on" + eventName[0].toUpperCase() + eventName.slice(1);
                        if (options.hasOwnProperty(optionName))
                            this.on(eventName, options[optionName])
                    }, this))
                },
                dispose: function() {
                    this.changed.empty();
                    this.loadError.empty();
                    this.loadingChanged.empty();
                    this._disposeEvents();
                    delete this._store;
                    this._disposed = true
                },
                _extractLoadOptions: function(options) {
                    var result = {},
                        names = ["sort", "filter", "select", "group", "requireTotalCount"],
                        customNames = this._store._customLoadOptions();
                    if (customNames)
                        names = names.concat(customNames);
                    $.each(names, function() {
                        result[this] = options[this]
                    });
                    return result
                },
                loadOptions: function() {
                    return this._storeLoadOptions
                },
                items: function() {
                    return this._items
                },
                pageIndex: function(newIndex) {
                    if (newIndex !== undefined) {
                        this._pageIndex = newIndex;
                        this._isLastPage = !this._paginate
                    }
                    return this._pageIndex
                },
                paginate: function(value) {
                    if (arguments.length < 1)
                        return this._paginate;
                    value = !!value;
                    if (this._paginate !== value) {
                        this._paginate = value;
                        this.pageIndex(0)
                    }
                },
                pageSize: function(value) {
                    if (arguments.length < 1)
                        return this._pageSize;
                    this._pageSize = value
                },
                isLastPage: function() {
                    return this._isLastPage
                },
                sort: generateStoreLoadOptionAccessor("sort"),
                filter: function() {
                    var newFilter = normalizeStoreLoadOptionAccessorArguments(arguments);
                    if (newFilter !== undefined) {
                        this._storeLoadOptions.filter = newFilter;
                        this.pageIndex(0)
                    }
                    return this._storeLoadOptions.filter
                },
                group: generateStoreLoadOptionAccessor("group"),
                select: generateStoreLoadOptionAccessor("select"),
                searchValue: function(value) {
                    if (value !== undefined) {
                        this.pageIndex(0);
                        this._searchValue = value
                    }
                    return this._searchValue
                },
                searchOperation: function(op) {
                    if (op !== undefined) {
                        this.pageIndex(0);
                        this._searchOperation = op
                    }
                    return this._searchOperation
                },
                searchExpr: function(expr) {
                    var argc = arguments.length;
                    if (argc) {
                        if (argc > 1)
                            expr = $.makeArray(arguments);
                        this.pageIndex(0);
                        this._searchExpr = expr
                    }
                    return this._searchExpr
                },
                store: function() {
                    return this._store
                },
                key: function() {
                    return this._store && this._store.key()
                },
                totalCount: function() {
                    return this._totalCount
                },
                isLoaded: function() {
                    return this._isLoaded
                },
                isLoading: function() {
                    return this._loadingCount > 0
                },
                _createLoadQueue: function() {
                    return DX.createQueue()
                },
                _changeLoadingCount: function(increment) {
                    var oldLoading = this.isLoading(),
                        newLoading;
                    this._loadingCount += increment;
                    newLoading = this.isLoading();
                    if (oldLoading ^ newLoading) {
                        this.fireEvent("loadingChanged", [newLoading]);
                        this.loadingChanged.fire(newLoading)
                    }
                },
                _scheduleLoadCallbacks: function(deferred) {
                    var thisSource = this;
                    thisSource._changeLoadingCount(1);
                    deferred.always(function() {
                        thisSource._changeLoadingCount(-1)
                    })
                },
                _scheduleChangedCallbacks: function(deferred) {
                    var that = this;
                    deferred.done(function() {
                        that.fireEvent("changed");
                        that.changed.fire()
                    })
                },
                loadSingle: function(propName, propValue) {
                    var that = this;
                    var d = $.Deferred().fail(function() {
                            that.fireEvent("loadError", arguments);
                            that.loadError.fire.apply(that, arguments)
                        }),
                        key = this.key(),
                        store = this._store,
                        loadOptions = this._createStoreLoadOptions();
                    function handleSuccess(data) {
                        if (data === null || typeof data === "undefined" || $.isArray(data) && data.length < 1)
                            d.reject();
                        else
                            d.resolve(that._transformLoadedData(data)[0])
                    }
                    if (arguments.length < 2) {
                        propValue = propName;
                        propName = key
                    }
                    delete loadOptions.skip;
                    delete loadOptions.group;
                    delete loadOptions.refresh;
                    delete loadOptions.pageIndex;
                    delete loadOptions.searchString;
                    if (propName === key || store instanceof data.CustomStore)
                        store.byKey(propValue, loadOptions).done(handleSuccess).fail(d.reject);
                    else {
                        loadOptions.take = 1;
                        loadOptions._preferSync = true;
                        loadOptions.filter = loadOptions.filter ? [loadOptions.filter, [propName, propValue]] : [propName, propValue];
                        store.load(loadOptions).done(handleSuccess).fail(d.reject)
                    }
                    return d.promise()
                },
                load: function() {
                    var thisSource = this,
                        d = $.Deferred().fail(errorCallback),
                        loadOptions;
                    this._scheduleLoadCallbacks(d);
                    this._scheduleChangedCallbacks(d);
                    loadOptions = this._createLoadOptions();
                    this.fireEvent("customizeStoreLoadOptions", [loadOptions]);
                    if (!ensureIsNotRejected(loadOptions.operationId, d))
                        return d.promise();
                    function errorCallback() {
                        if (arguments[0] !== "canceled") {
                            thisSource.fireEvent("loadError", arguments);
                            thisSource.loadError.fire.apply(thisSource.loadError, arguments)
                        }
                    }
                    function loadTask() {
                        if (thisSource._disposed)
                            return undefined;
                        return thisSource._loadFromStore(loadOptions, d)
                    }
                    this._loadQueue.add(function() {
                        if (typeof loadOptions.delay === "number")
                            setTimeout(loadTask, loadOptions.delay);
                        else
                            loadTask();
                        return d.promise()
                    }, function() {
                        thisSource._changeLoadingCount(-1)
                    });
                    return d.promise({loadOperationId: loadOptions.operationId})
                },
                reload: function() {
                    var prop,
                        userData = this._userData;
                    for (prop in userData)
                        if (userData.hasOwnProperty(prop))
                            delete userData[prop];
                    this._totalCount = -1;
                    this._isLoaded = false;
                    return this.load()
                },
                cancel: function(loadOperationId) {
                    canceledOperationsRegistry.add(loadOperationId)
                },
                _addSearchOptions: function(storeLoadOptions) {
                    if (this._disposed)
                        return;
                    if (this.store()._useDefaultSearch)
                        this._addSearchFilter(storeLoadOptions);
                    else {
                        storeLoadOptions.searchValue = this._searchValue;
                        storeLoadOptions.searchExpr = this._searchExpr
                    }
                },
                _createStoreLoadOptions: function() {
                    var result = $.extend({}, this._storeLoadOptions);
                    this._addSearchOptions(result);
                    if (this._paginate)
                        if (this._pageSize) {
                            result.skip = this._pageIndex * this._pageSize;
                            result.take = this._pageSize
                        }
                    result.userData = this._userData;
                    return result
                },
                _createLoadOptions: function() {
                    return {
                            operationId: nextLoadOperationId(),
                            storeLoadOptions: this._createStoreLoadOptions()
                        }
                },
                _addSearchFilter: function(storeLoadOptions) {
                    var value = this._searchValue,
                        op = this._searchOperation,
                        selector = this._searchExpr,
                        searchFilter = [];
                    if (!value)
                        return;
                    if (!selector)
                        selector = "this";
                    if (!$.isArray(selector))
                        selector = [selector];
                    $.each(selector, function(i, item) {
                        if (searchFilter.length)
                            searchFilter.push("or");
                        searchFilter.push([item, op, value])
                    });
                    if (storeLoadOptions.filter)
                        storeLoadOptions.filter = [searchFilter, storeLoadOptions.filter];
                    else
                        storeLoadOptions.filter = searchFilter
                },
                _loadFromStore: function(loadOptions, pendingDeferred) {
                    var thisSource = this;
                    function handleSuccess(data, extra) {
                        function processResult() {
                            var loadResult;
                            loadResult = $.extend({
                                data: data,
                                extra: extra
                            }, loadOptions);
                            thisSource.fireEvent("customizeLoadResult", [loadResult]);
                            if (ensureIsNotRejected(loadOptions.operationId, pendingDeferred))
                                thisSource._processStoreLoadResult(loadResult, pendingDeferred)
                        }
                        if (thisSource._preferSync)
                            processResult();
                        else
                            DX.utils.executeAsync(processResult)
                    }
                    if (!ensureIsNotRejected(loadOptions.operationId, pendingDeferred))
                        return pendingDeferred.promise();
                    return this.store().load(loadOptions.storeLoadOptions).done(handleSuccess).fail(pendingDeferred.reject)
                },
                _processStoreLoadResult: function(loadResult, pendingDeferred) {
                    var thisSource = this;
                    var data = loadResult.data,
                        extra = loadResult.extra,
                        storeLoadOptions = loadResult.storeLoadOptions;
                    function resolvePendingDeferred() {
                        if (!ensureIsNotRejected(loadResult.operationId, pendingDeferred))
                            return pendingDeferred;
                        thisSource._isLoaded = true;
                        thisSource._totalCount = isFinite(extra.totalCount) ? extra.totalCount : -1;
                        return pendingDeferred.resolve(data, extra)
                    }
                    function proceedLoadingTotalCount() {
                        thisSource.store().totalCount(storeLoadOptions).done(function(count) {
                            extra.totalCount = count;
                            resolvePendingDeferred()
                        }).fail(function(){})
                    }
                    if (thisSource._disposed)
                        return;
                    data = thisSource._transformLoadedData(data);
                    if (!$.isPlainObject(extra))
                        extra = {};
                    thisSource._items = data;
                    if (!data.length || !thisSource._paginate || thisSource._pageSize && data.length < thisSource._pageSize)
                        thisSource._isLastPage = true;
                    if (storeLoadOptions.requireTotalCount && !isFinite(extra.totalCount))
                        proceedLoadingTotalCount();
                    else
                        resolvePendingDeferred()
                },
                _transformLoadedData: function(data) {
                    var result = $.makeArray(data);
                    if (this._mapFunc)
                        result = mapDataRespectingGrouping(result, this._mapFunc, this.group());
                    if (this._postProcessFunc)
                        result = this._postProcessFunc(result);
                    return result
                }
            }).include(DX.EventsMixin);
        $.extend(true, data, {
            DataSource: DataSource,
            utils: {
                storeTypeRegistry: storeTypeRegistry,
                normalizeDataSourceOptions: normalizeDataSourceOptions
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file ko.js */
    (function($, DX, undefined) {
        if (!DX.support.hasKo)
            return;
        var ko = window.ko;
        (function checkKnockoutVersion(version) {
            version = version.split(".");
            if (version[0] < 2 || version[0] == 2 && version[1] < 3)
                throw DX.Error("E0013");
        })(ko.version)
    })(jQuery, DevExpress);
    /*! Module core, file ng.js */
    (function($, DX, undefined) {
        if (!DX.support.hasNg)
            return;
        DX.ng = {module: window.angular.module("dx", ["ngSanitize"])}
    })(jQuery, DevExpress);
    /*! Module core, file component.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            dataUtils = DX.data.utils,
            inflector = DX.inflector;
        var Component = DX.Class.inherit({
                NAME: "Component",
                _setDeprecatedOptions: function() {
                    this._deprecatedOptions = {}
                },
                _getDeprecatedOptions: function() {
                    return this._deprecatedOptions
                },
                _setOptionAliases: function() {
                    var aliases = this._optionAliases = {};
                    $.each(this._getDeprecatedOptions(), function(optionName, info) {
                        var optionAlias = info.alias;
                        if (optionAlias)
                            aliases[optionName] = optionAlias
                    })
                },
                _getOptionAliases: function() {
                    return this._optionAliases
                },
                _getOptionAliasesByName: function(optionName) {
                    return $.map(this._getOptionAliases(), function(aliasedOption, aliasName) {
                            return optionName === aliasedOption ? aliasName : undefined
                        })
                },
                _setDefaultOptions: function() {
                    this.option({
                        onOptionChanged: null,
                        onDisposing: null,
                        defaultOptionsRules: null
                    })
                },
                _defaultOptionsRules: function() {
                    return []
                },
                _setOptionsByDevice: function(userRules) {
                    var rules = this._defaultOptionsRules(),
                        currentDevice = DX.devices.current(),
                        result = {};
                    if (this._customRules)
                        rules = rules.concat(this._customRules);
                    if ($.isArray(userRules))
                        rules = rules.concat(userRules);
                    var deviceMatch = function(device, filter) {
                            filter = $.makeArray(filter);
                            return filter.length === 1 && $.isEmptyObject(filter[0]) || utils.findBestMatches(device, filter).length > 0
                        };
                    $.each(rules, function(index, rule) {
                        var deviceFilter = rule.device || {},
                            match;
                        if ($.isFunction(deviceFilter))
                            match = deviceFilter(currentDevice);
                        else
                            match = deviceMatch(currentDevice, deviceFilter);
                        if (match)
                            $.extend(result, rule.options)
                    });
                    this.option(result)
                },
                _setOptionsByReference: function() {
                    this._optionsByReference = {}
                },
                _getOptionsByReference: function() {
                    return this._optionsByReference
                },
                ctor: function(options) {
                    if (!this.NAME)
                        throw DX.Error("E0004");
                    options = options || {};
                    this._options = {};
                    this._updateLockCount = 0;
                    this.optionChanged = $.Callbacks();
                    this.disposing = $.Callbacks();
                    $.each(["optionChanged", "disposing"], $.proxy(function(_, propertyName) {
                        var that = this,
                            originalAdd = this[propertyName].add;
                        this[propertyName].add = function() {
                            DX.log("W0003", that.NAME, propertyName, "14.2", "Use the '" + propertyName + "' event instead");
                            return originalAdd.apply(this, arguments)
                        }
                    }, this));
                    this.beginUpdate();
                    try {
                        this._suppressDeprecatedWarnings();
                        this._setOptionsByReference();
                        this._setDeprecatedOptions();
                        this._setOptionAliases();
                        this._setDefaultOptions();
                        this._setOptionsByDevice(options.defaultOptionsRules);
                        this._resumeDeprecatedWarnings();
                        this._initialOptions = $.extend({}, this.option());
                        this._initOptions(options)
                    }
                    finally {
                        this.endUpdate()
                    }
                },
                _initOptions: function(options) {
                    this.option(options)
                },
                _optionValuesEqual: function(name, oldValue, newValue) {
                    oldValue = dataUtils.toComparable(oldValue, true);
                    newValue = dataUtils.toComparable(newValue, true);
                    if (oldValue && newValue && oldValue.jquery && newValue.jquery)
                        return newValue.is(oldValue);
                    if (oldValue === null || typeof oldValue !== "object")
                        return oldValue === newValue;
                    return false
                },
                _init: function() {
                    this._createOptionChangedAction();
                    this._createDisposingAction()
                },
                _createOptionChangedAction: function() {
                    this._optionChangedAction = this._createActionByOption("onOptionChanged")
                },
                _createDisposingAction: function() {
                    this._disposingAction = this._createActionByOption("onDisposing")
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"onOptionChanged":
                            this._createOptionChangedAction();
                            break;
                        case"onDisposing":
                            this._createDisposingAction();
                            break;
                        case"defaultOptionsRules":
                            break
                    }
                },
                _dispose: function() {
                    this.optionChanged.empty();
                    this.disposing.fireWith(this).empty();
                    this._disposingAction();
                    this._disposeEvents()
                },
                instance: function() {
                    return this
                },
                beginUpdate: function() {
                    this._updateLockCount++
                },
                endUpdate: function() {
                    this._updateLockCount--;
                    if (!this._updateLockCount)
                        if (!this._initializing && !this._initialized) {
                            this._initializing = true;
                            try {
                                this._init()
                            }
                            finally {
                                this._initializing = false;
                                this._initialized = true
                            }
                        }
                },
                _logWarningIfDeprecated: function(option) {
                    var info = this._getDeprecatedOptions()[option];
                    if (info && !this._deprecatedOptionsSuppressed)
                        this._logDeprecatedWarning(option, info)
                },
                _logDeprecatedWarningCount: 0,
                _logDeprecatedWarning: function(option, info) {
                    var message = info.message || "Use the '" + info.alias + "' option instead";
                    DX.log("W0001", this.NAME, option, info.since, message);
                    ++this._logDeprecatedWarningCount
                },
                _suppressDeprecatedWarnings: function() {
                    this._deprecatedOptionsSuppressed = true
                },
                _resumeDeprecatedWarnings: function() {
                    this._deprecatedOptionsSuppressed = false
                },
                _notifyOptionChanged: function(option, value, previousValue) {
                    var that = this;
                    if (this._initialized)
                        $.each(that._getOptionAliasesByName(option).concat([option]), function(index, name) {
                            var args = {
                                    name: name.split(/[.\[]/)[0],
                                    fullName: name,
                                    value: value,
                                    previousValue: previousValue
                                };
                            that.optionChanged.fireWith(that, [args.name, value, previousValue]);
                            that._optionChangedAction($.extend({}, args));
                            that._optionChanged(args)
                        })
                },
                initialOption: function(optionName) {
                    var options = this._initialOptions;
                    return options[optionName]
                },
                _defaultActionConfig: function() {
                    return {
                            context: this,
                            component: this
                        }
                },
                _defaultActionArgs: function() {
                    return {component: this}
                },
                _createAction: function(actionSource, config) {
                    var that = this,
                        action = new DX.Action(actionSource, $.extend(config, that._defaultActionConfig()));
                    return function(e) {
                            if (!arguments.length)
                                e = {};
                            if (e instanceof $.Event)
                                throw Error("Action must be executed with jQuery.Event like action({ jQueryEvent: event })");
                            if (!$.isPlainObject(e))
                                e = {actionValue: e};
                            return action.execute.call(action, $.extend(e, that._defaultActionArgs()))
                        }
                },
                _createActionByOption: function(optionName, config) {
                    config = config || {};
                    if (typeof optionName !== "string")
                        throw DX.Error("E0008");
                    var matches = /^on(\w+)/.exec(optionName);
                    if (matches) {
                        var eventName = inflector.camelize(matches[1]),
                            afterExecute = config.afterExecute || $.noop,
                            that = this;
                        config.afterExecute = function(args) {
                            that.fireEvent(eventName, args.args);
                            return afterExecute.apply(this, arguments)
                        }
                    }
                    else {
                        var optionAlias = this._getOptionAliasesByName(optionName),
                            isOptionDeprecated = Boolean(this._getDeprecatedOptions()[optionName]);
                        if (isOptionDeprecated) {
                            if (optionAlias.length)
                                throw Error("The '" + optionName + "' is deprecated and has alias '" + optionAlias + "'");
                        }
                        else
                            throw Error("The '" + optionName + "' option name should start with 'on' prefix");
                    }
                    this._suppressDeprecatedWarnings();
                    var action = this._createAction(this.option(optionName), config);
                    this._resumeDeprecatedWarnings();
                    return action
                },
                option: function(options) {
                    var that = this,
                        name = options,
                        value = arguments[1],
                        optionAliases = this._getOptionAliases();
                    var normalizeOptionName = function(name) {
                            if (name) {
                                that._logWarningIfDeprecated(name);
                                if (optionAliases[name])
                                    name = optionAliases[name]
                            }
                            return name
                        };
                    var getOptionValue = function(name, unwrapObservables) {
                            return dataUtils.compileGetter(name)(that._options, {
                                    functionsAsIs: true,
                                    unwrapObservables: unwrapObservables
                                })
                        };
                    if (arguments.length < 2 && $.type(name) !== "object") {
                        name = normalizeOptionName(name);
                        return getOptionValue(name)
                    }
                    if (typeof name === "string") {
                        options = {};
                        options[name] = value
                    }
                    that.beginUpdate();
                    try {
                        $.each(options, function(name, value) {
                            name = normalizeOptionName(name);
                            var prevValue = getOptionValue(name, false);
                            if (that._optionValuesEqual(name, prevValue, value))
                                return;
                            dataUtils.compileSetter(name)(that._options, value, {
                                functionsAsIs: true,
                                merge: !that._getOptionsByReference()[name],
                                unwrapObservables: false
                            });
                            that._notifyOptionChanged(name, value, prevValue)
                        })
                    }
                    finally {
                        that.endUpdate()
                    }
                }
            }).include(DX.EventsMixin);
        $.extend(DX, {Component: Component})
    })(jQuery, DevExpress);
    /*! Module core, file DOMComponent.js */
    (function($, DX, undefined) {
        var windowResizeCallbacks = DX.utils.windowResizeCallbacks;
        var RTL_DIRECTION_CLASS = "dx-rtl",
            COMPONENT_NAMES_DATA_KEY = "dxComponents",
            VISIBILITY_CHANGE_CLASS = "dx-visibility-change-handler",
            VISIBILITY_CHANGE_EVENTNAMESPACE = "dxVisibilityChange";
        var DOMComponent = DX.Component.inherit({
                NAME: "DOMComponent",
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({rtlEnabled: DX.rtlEnabled})
                },
                ctor: function(element, options) {
                    this._$element = $(element);
                    this.element().data(this.NAME, this);
                    this._attachInstanceToElement(this._$element);
                    this.callBase(options)
                },
                _attachInstanceToElement: $.noop,
                _visibilityChanged: DX.abstract,
                _dimensionChanged: DX.abstract,
                _init: function() {
                    this.callBase();
                    this._attachWindowResizeCallback()
                },
                _attachWindowResizeCallback: function() {
                    if (this._isDimensionChangeSupported()) {
                        var windowResizeCallBack = this._windowResizeCallBack = $.proxy(this._dimensionChanged, this);
                        windowResizeCallbacks.add(windowResizeCallBack)
                    }
                },
                _isDimensionChangeSupported: function() {
                    return this._dimensionChanged !== DX.abstract
                },
                _render: function() {
                    this._toggleRTLDirection(this.option("rtlEnabled"));
                    this._renderVisibilityChange()
                },
                _renderVisibilityChange: function() {
                    if (!this._isVisibilityChangeSupported())
                        return;
                    this.element().addClass(VISIBILITY_CHANGE_CLASS);
                    this._attachVisiblityChangeHandlers()
                },
                _attachVisiblityChangeHandlers: function() {
                    var that = this;
                    that.element().off("." + VISIBILITY_CHANGE_EVENTNAMESPACE).on("dxhiding." + VISIBILITY_CHANGE_EVENTNAMESPACE, function() {
                        that._visibilityChanged(false)
                    }).on("dxshown." + VISIBILITY_CHANGE_EVENTNAMESPACE, function() {
                        that._visibilityChanged(true)
                    })
                },
                _isVisibilityChangeSupported: function() {
                    return this._visibilityChanged !== DX.abstract
                },
                _clean: $.noop,
                _modelByElement: $.noop,
                _invalidate: function() {
                    if (!this._updateLockCount)
                        throw DX.Error("E0007");
                    this._requireRefresh = true
                },
                _refresh: function() {
                    this._clean();
                    this._render()
                },
                _dispose: function() {
                    this.callBase();
                    this._clean();
                    this._detachWindowResizeCallback()
                },
                _detachWindowResizeCallback: function() {
                    if (this._isDimensionChangeSupported())
                        windowResizeCallbacks.remove(this._windowResizeCallBack)
                },
                _toggleRTLDirection: function(rtl) {
                    this.element().toggleClass(RTL_DIRECTION_CLASS, rtl)
                },
                _defaultActionConfig: function() {
                    return $.extend(this.callBase(), {context: this._modelByElement(this.element())})
                },
                _defaultActionArgs: function() {
                    var element = this.element(),
                        model = this._modelByElement(this.element());
                    return $.extend(this.callBase(), {
                            element: element,
                            model: model
                        })
                },
                _optionChanged: function(args) {
                    if (args.name === "rtlEnabled")
                        this._invalidate();
                    else
                        this.callBase(args)
                },
                endUpdate: function() {
                    var requireRender = !this._initializing && !this._initialized;
                    this.callBase.apply(this, arguments);
                    if (!this._updateLockCount)
                        if (requireRender)
                            this._render();
                        else if (this._requireRefresh) {
                            this._requireRefresh = false;
                            this._refresh()
                        }
                },
                element: function() {
                    return this._$element
                }
            });
        var registerComponent = function(name, namespace, componentClass) {
                if (!componentClass) {
                    componentClass = namespace;
                    namespace = DX
                }
                componentClass.redefine({_attachInstanceToElement: function($element) {
                        $element.data(name, this);
                        if (!$element.data(COMPONENT_NAMES_DATA_KEY))
                            $element.data(COMPONENT_NAMES_DATA_KEY, []);
                        $element.data(COMPONENT_NAMES_DATA_KEY).push(name)
                    }});
                namespace[name] = componentClass;
                componentClass.prototype.NAME = name;
                componentClass.defaultOptions = function(rule) {
                    componentClass.prototype._customRules = componentClass.prototype._customRules || [];
                    componentClass.prototype._customRules.push(rule)
                };
                $.fn[name] = function(options) {
                    var isMemberInvoke = typeof options === "string",
                        result;
                    if (isMemberInvoke) {
                        var memberName = options,
                            memberArgs = $.makeArray(arguments).slice(1);
                        this.each(function() {
                            var instance = $(this).data(name);
                            if (!instance)
                                throw DX.Error("E0009", name);
                            var member = instance[memberName],
                                memberValue = member.apply(instance, memberArgs);
                            if (result === undefined)
                                result = memberValue
                        })
                    }
                    else {
                        this.each(function() {
                            var instance = $(this).data(name);
                            if (instance)
                                instance.option(options);
                            else
                                new componentClass(this, options)
                        });
                        result = this
                    }
                    return result
                }
            };
        var getComponents = function(element) {
                element = $(element);
                var names = element.data(COMPONENT_NAMES_DATA_KEY);
                if (!names)
                    return [];
                return $.map(names, function(name) {
                        return element.data(name)
                    })
            };
        var disposeComponents = function() {
                $.each(getComponents(this), function() {
                    this._dispose()
                })
            };
        var originalCleanData = $.cleanData;
        $.cleanData = function(element) {
            $.each(element, disposeComponents);
            return originalCleanData.apply(this, arguments)
        };
        registerComponent("DOMComponent", DOMComponent);
        DX.registerComponent = registerComponent
    })(jQuery, DevExpress);
    /*! Module core, file ui.js */
    (function($, DX, undefined) {
        var ui = DX.ui = {};
        DX.registerActionExecutor({
            designMode: {validate: function(e) {
                    if (DX.designMode)
                        e.cancel = true
                }},
            disabled: {validate: function(e) {
                    if (!e.args.length)
                        return;
                    var args = e.args[0],
                        jQueryEvent = args.jQueryEvent;
                    var args = e.args[0],
                        element = args[e.validatingTargetName] || args.element;
                    if (element && element.is(".dx-state-disabled, .dx-state-disabled *"))
                        e.cancel = true
                }},
            readOnly: {validate: function(e) {
                    if (!e.args.length)
                        return;
                    var args = e.args[0],
                        jQueryEvent = args.jQueryEvent;
                    var args = e.args[0],
                        element = args[e.validatingTargetName] || args.element;
                    if (element && element.is(".dx-state-readonly, .dx-state-readonly *"))
                        e.cancel = true
                }}
        });
        $.extend(ui, {initViewport: function() {
                DX.log("W1002", "DevExpress.ui.initViewport", "14.1", "Use DX.utils.initMobileViewport instead");
                DX.utils.initMobileViewport()
            }})
    })(jQuery, DevExpress);
    /*! Module core, file ui.templates.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            triggerShownEvent = DX.utils.triggerShownEvent;
        var TemplateProviderBase = DX.Class.inherit({
                ctor: function() {
                    this.widgetTemplatesCache = {}
                },
                createTemplate: DX.abstract,
                getTemplates: function(widget) {
                    var cache = this.widgetTemplatesCache,
                        key = widget.NAME;
                    if (!cache[key])
                        cache[key] = this._getWidgetTemplates(widget.constructor);
                    return cache[key]
                },
                _getWidgetTemplates: function(widget) {
                    if (!widget.prototype.NAME)
                        return {};
                    if (widget.prototype.NAME === widget.parent.prototype.NAME)
                        return this._getWidgetTemplates(widget.parent);
                    return $.extend(this._getWidgetTemplates(widget.parent), this._templatesForWidget(widget.prototype.NAME))
                },
                _templatesForWidget: DX.abstract
            });
        var TemplateBase = DX.Class.inherit({
                ctor: function(element, owner) {
                    this._element = $(element);
                    if (!this._element.is("script"))
                        this._element.detach();
                    this._owner = owner
                },
                owner: function() {
                    return this._owner
                },
                render: function(data, container, index) {
                    if (data instanceof jQuery) {
                        container = data;
                        data = undefined
                    }
                    if (container)
                        data = this._prepareDataForContainer(data, container);
                    var result = this._renderCore(data, index, container);
                    if (this._shouldAppend && container) {
                        container.append(result);
                        if (typeof result !== "string" && container.is(":visible"))
                            triggerShownEvent(result)
                    }
                    return result
                },
                _prepareDataForContainer: function(data, container) {
                    return data
                },
                _renderCore: DX.abstract,
                _shouldAppend: true,
                dispose: function() {
                    this._owner = null
                }
            });
        $.extend(ui, {
            TemplateProviderBase: TemplateProviderBase,
            TemplateBase: TemplateBase
        })
    })(jQuery, DevExpress);
    /*! Module core, file jquery.templates.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            isString = DX.utils.isString,
            currentTemplateEngine,
            templateEngines = {};
        var Template = ui.TemplateBase.inherit({
                ctor: function(element, owner) {
                    this.callBase(element, owner);
                    this._compiledTemplate = currentTemplateEngine.compile(element)
                },
                _renderCore: function(data) {
                    return currentTemplateEngine.render(this._compiledTemplate, data)
                }
            });
        var setTemplateEngine = function(templateEngine) {
                if (isString(templateEngine)) {
                    currentTemplateEngine = templateEngines[templateEngine];
                    if (!currentTemplateEngine)
                        throw DX.Error("E0020", templateEngine);
                }
                else
                    currentTemplateEngine = templateEngine
            };
        var registerTemplateEngine = function(name, templateEngine) {
                templateEngines[name] = templateEngine
            };
        var outerHtml = function(element) {
                element = $(element);
                if (!element.length || element[0].nodeName.toLowerCase() !== "script")
                    element = $("<div>").append(element);
                return element.html()
            };
        registerTemplateEngine("default", {
            compile: function(element) {
                return DX.utils.normalizeTemplateElement(element)
            },
            render: function(template, data) {
                return template.clone()
            }
        });
        registerTemplateEngine("jquery-tmpl", {
            compile: function(element) {
                return $("<div>").append(DX.utils.normalizeTemplateElement(element))
            },
            render: function(template, data) {
                return template.tmpl(data)
            }
        });
        registerTemplateEngine("jsrender", {
            compile: function(element) {
                return $.templates(outerHtml(element))
            },
            render: function(template, data) {
                return template.render(data)
            }
        });
        registerTemplateEngine("mustache", {
            compile: function(element) {
                return Mustache.compile(outerHtml(element))
            },
            render: function(template, data) {
                return template(data)
            }
        });
        registerTemplateEngine("hogan", {
            compile: function(element) {
                return Hogan.compile(outerHtml(element))
            },
            render: function(template, data) {
                return template.render(data)
            }
        });
        registerTemplateEngine("underscore", {
            compile: function(element) {
                return _.template(outerHtml(element))
            },
            render: function(template, data) {
                return template(data)
            }
        });
        registerTemplateEngine("handlebars", {
            compile: function(element) {
                return Handlebars.compile(outerHtml(element))
            },
            render: function(template, data) {
                return template(data)
            }
        });
        registerTemplateEngine("doT", {
            compile: function(element) {
                return doT.template(outerHtml(element))
            },
            render: function(template, data) {
                return template(data)
            }
        });
        setTemplateEngine("default");
        var TemplateProvider = ui.TemplateProviderBase.inherit({
                createTemplate: function(element, owner) {
                    return new Template(element, owner)
                },
                _templatesForWidget: function(name) {
                    return defaultTemplates(name)
                }
            });
        var DefaultTemplate = ui.TemplateBase.inherit({
                ctor: function(render, owner) {
                    this.callBase($("<div>"), owner);
                    this._render = render
                },
                _renderCore: function(data, index, container) {
                    return DX.utils.stringToJquery(this._render(data, index, container))
                }
            });
        var defaultTemplates = function() {
                var cache = {};
                return function(widgetName) {
                        if (!cache[widgetName]) {
                            var templateGenerators = TEMPLATE_GENERATORS[widgetName] || {},
                                templates = {};
                            $.each(templateGenerators, function(name, generator) {
                                templates[name] = new ui.DefaultTemplate(generator)
                            });
                            cache[widgetName] = templates
                        }
                        return cache[widgetName]
                    }
            }();
        var TEMPLATE_GENERATORS = {};
        var ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder";
        TEMPLATE_GENERATORS.CollectionWidget = {
            item: function(itemData) {
                var $itemContent = $("<div>");
                if ($.isPlainObject(itemData)) {
                    if (itemData.text)
                        $itemContent.text(itemData.text);
                    if (itemData.html)
                        $itemContent.html(itemData.html)
                }
                else
                    $itemContent.html(String(itemData));
                return $itemContent
            },
            itemFrame: function(itemData) {
                var $itemFrame = $("<div>");
                $itemFrame.toggleClass("dx-state-invisible", itemData.visible !== undefined && !itemData.visible);
                $itemFrame.toggleClass("dx-state-disabled", !!itemData.disabled);
                var $placeholder = $("<div>").addClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
                $itemFrame.append($placeholder);
                return $itemFrame
            }
        };
        var LIST_ITEM_BADGE_CONTAINER_CLASS = "dx-list-item-badge-container",
            LIST_ITEM_BADGE_CLASS = "dx-list-item-badge",
            BADGE_CLASS = "dx-badge",
            LIST_ITEM_CHEVRON_CONTAINER_CLASS = "dx-list-item-chevron-container",
            LIST_ITEM_CHEVRON_CLASS = "dx-list-item-chevron";
        TEMPLATE_GENERATORS.dxList = {
            item: function(itemData) {
                var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.item(itemData);
                if (itemData.key) {
                    var $key = $("<div>").text(itemData.key);
                    $key.appendTo($itemContent)
                }
                return $itemContent
            },
            itemFrame: function(itemData) {
                var $itemFrame = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(itemData);
                if (itemData.badge) {
                    var $badgeContainer = $("<div>").addClass(LIST_ITEM_BADGE_CONTAINER_CLASS),
                        $badge = $("<div>").addClass(LIST_ITEM_BADGE_CLASS).addClass(BADGE_CLASS);
                    $badge.text(itemData.badge);
                    $badgeContainer.append($badge).appendTo($itemFrame)
                }
                if (itemData.showChevron) {
                    var $chevronContainer = $("<div>").addClass(LIST_ITEM_CHEVRON_CONTAINER_CLASS),
                        $chevron = $("<div>").addClass(LIST_ITEM_CHEVRON_CLASS);
                    $chevronContainer.append($chevron).appendTo($itemFrame)
                }
                return $itemFrame
            },
            group: function(groupData) {
                var $groupContent = $("<div>");
                if ($.isPlainObject(groupData)) {
                    if (groupData.key)
                        $groupContent.text(groupData.key)
                }
                else
                    $groupContent.html(String(groupData));
                return $groupContent
            }
        };
        TEMPLATE_GENERATORS.dxDropDownMenu = {item: TEMPLATE_GENERATORS.dxList.item};
        TEMPLATE_GENERATORS.dxDropDownList = {item: TEMPLATE_GENERATORS.dxList.item};
        TEMPLATE_GENERATORS.dxRadioGroup = {item: TEMPLATE_GENERATORS.CollectionWidget.item};
        TEMPLATE_GENERATORS.dxSlideOut = {
            menuItem: TEMPLATE_GENERATORS.dxList.item,
            menuGroup: TEMPLATE_GENERATORS.dxList.group
        };
        var titleTemplate = function(titleData) {
                var $titleContent = $("<div>");
                if ($.isPlainObject(titleData)) {
                    if (titleData.title)
                        $titleContent.text(titleData.title)
                }
                else
                    $titleContent.html(String(titleData));
                return $titleContent
            };
        TEMPLATE_GENERATORS.dxAccordion = {
            title: titleTemplate,
            item: TEMPLATE_GENERATORS.CollectionWidget.item
        };
        TEMPLATE_GENERATORS.dxActionSheet = {item: function(itemData) {
                return $("<div>").dxButton($.extend({onClick: itemData.click}, itemData))
            }};
        TEMPLATE_GENERATORS.dxGallery = {item: function(itemData) {
                var $itemContent = $("<div>");
                if (itemData.imageSrc)
                    $('<img>').attr('src', itemData.imageSrc).appendTo($itemContent);
                else
                    $('<img>').attr('src', String(itemData)).appendTo($itemContent);
                return $itemContent
            }};
        var DX_ICON_CLASS = "dx-icon",
            DX_MENU_ITEM_CAPTION_CLASS = 'dx-menu-item-text',
            DX_MENU_ITEM_POPOUT_CLASS = 'dx-menu-item-popout',
            DX_MENU_ITEM_POPOUT_CONTAINER_CLASS = 'dx-menu-item-popout-container';
        TEMPLATE_GENERATORS.dxMenuBase = {item: function(itemData) {
                var $itemContent = $("<div>");
                var $itemImage;
                if (itemData.icon)
                    $itemImage = $('<span>').addClass(DX_ICON_CLASS + "-" + itemData.icon).appendTo($itemContent);
                else if (itemData.iconSrc)
                    $itemImage = $('<img>').attr('src', itemData.iconSrc).appendTo($itemContent);
                if ($itemImage)
                    $itemImage.addClass(DX_ICON_CLASS);
                var $itemCaption;
                $itemCaption = $('<span>').addClass(DX_MENU_ITEM_CAPTION_CLASS);
                if ($.isPlainObject(itemData)) {
                    if (itemData.text)
                        $itemCaption.text(itemData.text)
                }
                else
                    $itemCaption.html(String(itemData));
                $itemContent.append($itemCaption);
                var $popOutImage,
                    $popOutContainer;
                if (itemData.items && itemData.items.length > 0) {
                    $popOutContainer = $('<span>').addClass(DX_MENU_ITEM_POPOUT_CONTAINER_CLASS).appendTo($itemContent);
                    $popOutImage = $('<div>').addClass(DX_MENU_ITEM_POPOUT_CLASS).appendTo($popOutContainer)
                }
                return $itemContent
            }};
        var PANORAMA_ITEM_TITLE_CLASS = "dx-panorama-item-title";
        TEMPLATE_GENERATORS.dxPanorama = {itemFrame: function(itemData) {
                var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(itemData);
                if (itemData.title) {
                    var $itemHeader = $("<div>").addClass(PANORAMA_ITEM_TITLE_CLASS).text(itemData.title);
                    $itemContent.prepend($itemHeader)
                }
                return $itemContent
            }};
        TEMPLATE_GENERATORS.dxPivotTabs = {item: function(itemData) {
                var $itemContent = $("<div>");
                var $itemText = $("<span>").text(itemData.title);
                $itemContent.html($itemText);
                return $itemContent
            }};
        var TABS_ITEM_TEXT_CLASS = "dx-tab-text";
        TEMPLATE_GENERATORS.dxTabs = {item: function(itemData) {
                var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.item(itemData);
                if (itemData.html)
                    return $itemContent;
                var text = itemData.text,
                    icon = itemData.icon,
                    iconSrc = itemData.iconSrc,
                    iconElement;
                if (text)
                    $itemContent.wrapInner($("<span>").addClass(TABS_ITEM_TEXT_CLASS));
                if (icon)
                    iconElement = $("<span>").addClass(DX_ICON_CLASS + "-" + icon);
                else if (iconSrc)
                    iconElement = $("<img>").attr("src", iconSrc);
                if (iconElement)
                    iconElement.addClass(DX_ICON_CLASS).prependTo($itemContent);
                return $itemContent
            }};
        TEMPLATE_GENERATORS.dxTabPanel = {
            item: TEMPLATE_GENERATORS.CollectionWidget.item,
            title: titleTemplate
        };
        var NAVBAR_ITEM_BADGE_CLASS = "dx-navbar-item-badge";
        TEMPLATE_GENERATORS.dxNavBar = {itemFrame: function(itemData) {
                var $itemFrame = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(itemData);
                if (itemData.badge) {
                    var $badge = $("<div>").addClass(NAVBAR_ITEM_BADGE_CLASS).addClass(BADGE_CLASS);
                    $badge.text(itemData.badge);
                    $badge.appendTo($itemFrame)
                }
                return $itemFrame
            }};
        TEMPLATE_GENERATORS.dxToolbar = {
            item: function(itemData) {
                var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.item(itemData);
                var widget = itemData.widget;
                if (widget) {
                    var widgetElement = $("<div>").appendTo($itemContent),
                        widgetName = DX.inflector.camelize("dx-" + widget),
                        options = itemData.options || {};
                    widgetElement[widgetName](options)
                }
                else if (itemData.text)
                    $itemContent.wrapInner("<div>");
                return $itemContent
            },
            menuItem: TEMPLATE_GENERATORS.dxList.item,
            actionSheetItem: TEMPLATE_GENERATORS.dxActionSheet.item
        };
        TEMPLATE_GENERATORS.dxTreeView = {item: function(itemData) {
                var $itemContent = $("<div>");
                if (itemData.icon)
                    $('<span>').addClass(DX_ICON_CLASS + "-" + itemData.icon).addClass(DX_ICON_CLASS).appendTo($itemContent);
                if (itemData.iconSrc)
                    $('<img>').attr("src", itemData.iconSrc).addClass(DX_ICON_CLASS).appendTo($itemContent);
                $("<span>").text(itemData.text).appendTo($itemContent);
                return $itemContent
            }};
        var popupTitleAndBottom = function(itemData) {
                return $("<div>").dxToolbar({items: itemData})
            };
        TEMPLATE_GENERATORS.dxPopup = {
            title: popupTitleAndBottom,
            bottom: popupTitleAndBottom
        };
        TEMPLATE_GENERATORS.dxLookup = {
            title: TEMPLATE_GENERATORS.dxPopup.title,
            group: TEMPLATE_GENERATORS.dxList.group
        };
        $.extend(ui, {
            TemplateProvider: TemplateProvider,
            Template: Template,
            DefaultTemplate: DefaultTemplate,
            setTemplateEngine: setTemplateEngine
        })
    })(jQuery, DevExpress);
    /*! Module core, file ko.components.js */
    (function($, DX, undefined) {
        if (!DX.support.hasKo)
            return;
        var ko = window.ko,
            ui = DX.ui,
            LOCKS_DATA_KEY = "dxKoLocks",
            CREATED_WITH_KO_DATA_KEY = "dxKoCreation";
        var Locks = function() {
                var info = {};
                var currentCount = function(lockName) {
                        return info[lockName] || 0
                    };
                return {
                        obtain: function(lockName) {
                            info[lockName] = currentCount(lockName) + 1
                        },
                        release: function(lockName) {
                            var count = currentCount(lockName);
                            if (count < 1)
                                throw DX.Error("E0014");
                            if (count === 1)
                                delete info[lockName];
                            else
                                info[lockName] = count - 1
                        },
                        locked: function(lockName) {
                            return currentCount(lockName) > 0
                        }
                    }
            };
        var registerComponentKoBinding = function(componentName, componentClass) {
                ko.bindingHandlers[componentName] = {init: function(domNode, valueAccessor) {
                        var $element = $(domNode),
                            ctorOptions = {templateProvider: new ui.KoTemplateProvider},
                            optionNameToModelMap = {};
                        var applyModelValueToOption = function(optionName, modelValue) {
                                var component = $element.data(componentName),
                                    locks = $element.data(LOCKS_DATA_KEY),
                                    optionValue = ko.unwrap(modelValue);
                                if (ko.isWriteableObservable(modelValue))
                                    optionNameToModelMap[optionName] = modelValue;
                                if (component) {
                                    if (locks.locked(optionName))
                                        return;
                                    locks.obtain(optionName);
                                    try {
                                        component.option(optionName, optionValue)
                                    }
                                    finally {
                                        locks.release(optionName)
                                    }
                                }
                                else
                                    ctorOptions[optionName] = optionValue
                            };
                        var handleOptionChanged = function(args) {
                                var optionName = args.fullName,
                                    optionValue = args.value;
                                if (!(optionName in optionNameToModelMap))
                                    return;
                                var $element = this._$element,
                                    locks = $element.data(LOCKS_DATA_KEY);
                                if (locks.locked(optionName))
                                    return;
                                locks.obtain(optionName);
                                try {
                                    optionNameToModelMap[optionName](optionValue)
                                }
                                finally {
                                    locks.release(optionName)
                                }
                            };
                        var createComponent = function() {
                                $element.data(CREATED_WITH_KO_DATA_KEY, true).data(LOCKS_DATA_KEY, new Locks)[componentName](ctorOptions)[componentName]("on", "optionChanged", handleOptionChanged);
                                ctorOptions = null
                            };
                        var unwrapModelValue = function(option, model) {
                                var modelUnwrapped;
                                ko.computed(function() {
                                    applyModelValueToOption(option, model);
                                    modelUnwrapped = ko.unwrap(model)
                                }, null, {disposeWhenNodeIsRemoved: domNode});
                                if ($.isPlainObject(modelUnwrapped))
                                    $.each(modelUnwrapped, function(optionName, modelValue) {
                                        unwrapModelValue(option + "." + optionName, modelValue)
                                    })
                            };
                        ko.computed(function() {
                            var component = $element.data(componentName);
                            if (component)
                                component.beginUpdate();
                            $.each(ko.unwrap(valueAccessor()), function(optionName, modelValue) {
                                unwrapModelValue(optionName, modelValue)
                            });
                            if (component)
                                component.endUpdate();
                            else
                                createComponent()
                        }, null, {disposeWhenNodeIsRemoved: domNode});
                        return {controlsDescendantBindings: componentClass.subclassOf(ui.Widget)}
                    }}
            };
        DX.DOMComponent.redefine({_modelByElement: function(element) {
                if (element.length)
                    return ko.dataFor(element.get(0))
            }});
        var originalRegisterComponent = DX.registerComponent;
        var registerKoComponent = function(componentName, _, componentClass) {
                componentClass = componentClass || _;
                originalRegisterComponent.apply(this, arguments);
                registerComponentKoBinding(componentName, componentClass)
            };
        DX.registerComponent = registerKoComponent;
        var cleanKoData = function(element, andSelf) {
                var cleanNode = function() {
                        ko.cleanNode(this)
                    };
                if (andSelf)
                    element.each(cleanNode);
                else
                    element.find("*").each(cleanNode)
            };
        var originalEmpty = $.fn.empty;
        $.fn.empty = function() {
            cleanKoData(this, false);
            return originalEmpty.apply(this, arguments)
        };
        var originalRemove = $.fn.remove;
        $.fn.remove = function(selector, keepData) {
            if (!keepData) {
                var subject = this;
                if (selector)
                    subject = subject.filter(selector);
                cleanKoData(subject, true)
            }
            return originalRemove.call(this, selector, keepData)
        };
        var originalHtml = $.fn.html;
        $.fn.html = function(value) {
            if (typeof value === "string")
                cleanKoData(this, false);
            return originalHtml.apply(this, arguments)
        };
        ko.bindingHandlers.dxAction = {update: function(element, valueAccessor, allBindingsAccessor, viewModel) {
                var $element = $(element);
                var unwrappedValue = ko.utils.unwrapObservable(valueAccessor()),
                    actionSource = unwrappedValue,
                    actionOptions = {context: element};
                if (unwrappedValue.execute) {
                    actionSource = unwrappedValue.execute;
                    $.extend(actionOptions, unwrappedValue)
                }
                var action = new DX.Action(actionSource, actionOptions);
                $element.off(".dxActionBinding").on("dxclick.dxActionBinding", function(e) {
                    action.execute({
                        element: $element,
                        model: viewModel,
                        evaluate: function(expression) {
                            var context = viewModel;
                            if (expression.length > 0 && expression[0] === "$")
                                context = ko.contextFor(element);
                            var getter = DX.data.utils.compileGetter(expression);
                            return getter(context)
                        },
                        jQueryEvent: e
                    });
                    if (!actionOptions.bubbling)
                        e.stopPropagation()
                })
            }}
    })(jQuery, DevExpress);
    /*! Module core, file ng.components.js */
    (function($, DX, undefined) {
        if (!DX.support.hasNg)
            return;
        var ui = DX.ui,
            compileSetter = DX.data.utils.compileSetter,
            compileGetter = DX.data.utils.compileGetter;
        var CREATED_WITH_NG_DATA_KEY = "dxNgCreation",
            TEMPLATES_DATA_KEY = "dxTemplates",
            COMPILER_DATA_KEY = "dxNgCompiler",
            DEFAULT_COMPILER_DATA_KEY = "dxDefaultCompilerGetter",
            ANONYMOUS_TEMPLATE_NAME = "template";
        var phoneJsModule = DX.ng.module;
        var ComponentBuilder = DX.Class.inherit({
                ctor: function(options) {
                    this._$element = options.$element.data(CREATED_WITH_NG_DATA_KEY, true);
                    this._$templates = options.$templates;
                    this._componentClass = options.componentClass;
                    this._scope = options.scope;
                    this._compile = options.compile;
                    this._ngOptions = options.ngOptions;
                    this._componentDisposing = $.Callbacks();
                    if (options.ngOptions.data)
                        this._initDataScope(options.ngOptions.data)
                },
                initDefaultCompilerGetter: function() {
                    this._$element.data(DEFAULT_COMPILER_DATA_KEY, $.proxy(function($template) {
                        return this._compilerByTemplate($template)
                    }, this))
                },
                initTemplateCompilers: function() {
                    var that = this;
                    if (this._$templates)
                        this._$templates.each(function(i, template) {
                            $(template).data(COMPILER_DATA_KEY, that._compilerByTemplate(template))
                        })
                },
                initComponentWithBindings: function() {
                    this._initComponent(this._scope);
                    this._initComponentBindings()
                },
                _initDataScope: function(data) {
                    if (typeof data === "string") {
                        var dataStr = data,
                            rootScope = this._scope;
                        data = rootScope.$eval(data);
                        this._scope = rootScope.$new();
                        this._synchronizeDataScopes(rootScope, this._scope, data, dataStr)
                    }
                    $.extend(this._scope, data)
                },
                _synchronizeDataScopes: function(parentScope, childScope, data, parentPrefix) {
                    var that = this;
                    $.each(data, function(fieldPath) {
                        that._synchronizeScopeField({
                            parentScope: parentScope,
                            childScope: childScope,
                            fieldPath: fieldPath,
                            parentPrefix: parentPrefix
                        })
                    })
                },
                _initComponent: function(scope) {
                    this._component = new this._componentClass(this._$element, this._evalOptions(scope))
                },
                _initComponentBindings: function() {
                    var that = this,
                        optionDependencies = {};
                    if (that._ngOptions.bindingOptions)
                        $.each(that._ngOptions.bindingOptions, function(optionPath, valuePath) {
                            var separatorIndex = optionPath.search(/\[|\./),
                                optionForSubscribe = separatorIndex > -1 ? optionPath.substring(0, separatorIndex) : optionPath,
                                prevWatchMethod,
                                clearWatcher;
                            if (!optionDependencies[optionForSubscribe])
                                optionDependencies[optionForSubscribe] = {};
                            optionDependencies[optionForSubscribe][optionPath] = valuePath;
                            var watchCallback = function(newValue, oldValue) {
                                    if (newValue !== oldValue) {
                                        that._component.option(optionPath, newValue);
                                        updateWatcher()
                                    }
                                };
                            var updateWatcher = function() {
                                    var watchMethod = $.isArray(that._scope.$eval(valuePath)) ? "$watchCollection" : "$watch";
                                    if (prevWatchMethod !== watchMethod) {
                                        if (clearWatcher)
                                            clearWatcher();
                                        clearWatcher = that._scope[watchMethod](valuePath, watchCallback, true);
                                        prevWatchMethod = watchMethod
                                    }
                                };
                            updateWatcher();
                            that._component.on("disposing", function() {
                                clearWatcher();
                                that._componentDisposing.fire()
                            })
                        });
                    that._component.on("optionChanged", function(args) {
                        var optionName = args.name,
                            optionValue = args.value;
                        if (that._scope.$root.$$phase === "$digest" || !optionDependencies || !optionDependencies[optionName])
                            return;
                        safeApply(function(scope) {
                            $.each(optionDependencies[optionName], function(optionPath, valuePath) {
                                var setter = compileSetter(valuePath),
                                    getter = compileGetter(optionPath);
                                var tmpData = {};
                                tmpData[optionName] = optionValue;
                                setter(scope, getter(tmpData))
                            })
                        }, that._scope)
                    })
                },
                _compilerByTemplate: function(template) {
                    var that = this,
                        scopeItemsPath = this._getScopeItemsPath();
                    return function(data, index) {
                            var $resultMarkup = $(template).clone(),
                                templateScope;
                            if (data !== undefined) {
                                var dataIsScope = data.$id,
                                    templateScope = dataIsScope ? data : that._createScopeWithData(data);
                                $resultMarkup.on("$destroy", function() {
                                    var destroyAlreadyCalled = !templateScope.$parent;
                                    if (destroyAlreadyCalled)
                                        return;
                                    templateScope.$destroy()
                                })
                            }
                            else
                                templateScope = that._scope;
                            if (scopeItemsPath)
                                that._synchronizeScopes(templateScope, scopeItemsPath, index);
                            safeApply(that._compile($resultMarkup), templateScope);
                            return $resultMarkup
                        }
                },
                _getScopeItemsPath: function() {
                    if (this._componentClass.subclassOf(ui.CollectionWidget) && this._ngOptions.bindingOptions)
                        return this._ngOptions.bindingOptions.items
                },
                _createScopeWithData: function(data) {
                    var newScope = this._scope.$new(true);
                    if ($.isPlainObject(data))
                        $.extend(newScope, data);
                    else
                        newScope.scopeValue = data;
                    return newScope
                },
                _synchronizeScopes: function(itemScope, parentPrefix, itemIndex) {
                    var that = this,
                        item = compileGetter(parentPrefix + "[" + itemIndex + "]")(this._scope);
                    if (!$.isPlainObject(item))
                        item = {scopeValue: item};
                    $.each(item, function(itemPath) {
                        that._synchronizeScopeField({
                            parentScope: that._scope,
                            childScope: itemScope,
                            fieldPath: itemPath,
                            parentPrefix: parentPrefix,
                            itemIndex: itemIndex
                        })
                    })
                },
                _synchronizeScopeField: function(args) {
                    var parentScope = args.parentScope,
                        childScope = args.childScope,
                        fieldPath = args.fieldPath,
                        parentPrefix = args.parentPrefix,
                        itemIndex = args.itemIndex;
                    var innerPathSuffix = fieldPath === "scopeValue" ? "" : "." + fieldPath,
                        collectionField = itemIndex !== undefined,
                        optionOuterBag = [parentPrefix],
                        optionOuterPath;
                    if (collectionField)
                        optionOuterBag.push("[", itemIndex, "]");
                    optionOuterBag.push(innerPathSuffix);
                    optionOuterPath = optionOuterBag.join("");
                    var clearParentWatcher = parentScope.$watch(optionOuterPath, function(newValue, oldValue) {
                            if (newValue !== oldValue)
                                compileSetter(fieldPath)(childScope, newValue)
                        });
                    var clearItemWatcher = childScope.$watch(fieldPath, function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                if (collectionField && !compileGetter(parentPrefix)(parentScope)[itemIndex]) {
                                    clearItemWatcher();
                                    return
                                }
                                compileSetter(optionOuterPath)(parentScope, newValue)
                            }
                        });
                    this._componentDisposing.add([clearParentWatcher, clearItemWatcher])
                },
                _evalOptions: function(scope) {
                    var result = $.extend({}, this._ngOptions);
                    delete result.data;
                    delete result.bindingOptions;
                    if (this._ngOptions.bindingOptions)
                        $.each(this._ngOptions.bindingOptions, function(key, value) {
                            result[key] = scope.$eval(value)
                        });
                    result.templateProvider = new ui.NgTemplateProvider;
                    return result
                }
            });
        var safeApply = function(func, scope) {
                if (scope.$root.$$phase)
                    func(scope);
                else
                    scope.$apply(function() {
                        func(scope)
                    })
            };
        var extractTemplates = function($element, componentClass) {
                if ($element.data(TEMPLATES_DATA_KEY))
                    return $element.data(TEMPLATES_DATA_KEY);
                var $templates;
                if (componentClass.subclassOf(ui.Widget) && $.trim($element.html())) {
                    var isAnonymousTemplate = !$element.children().first().attr("data-options");
                    if (isAnonymousTemplate)
                        $templates = $("<div/>").attr("data-options", "dxTemplate: { name: '" + ANONYMOUS_TEMPLATE_NAME + "' }").append($element.contents());
                    else
                        $templates = $element.children().detach();
                    $element.data(TEMPLATES_DATA_KEY, $templates)
                }
                return $templates
            };
        var NgComponent = DX.DOMComponent.inherit({
                _modelByElement: function(element) {
                    if (element.length)
                        return element.scope()
                },
                _createAction: function() {
                    var action = this.callBase.apply(this, arguments);
                    var component = this,
                        wrappedAction = function() {
                            var that = this,
                                scope = component._modelByElement(component.element()),
                                args = arguments;
                            if (!scope || !scope.$root || scope.$root.$$phase)
                                return action.apply(that, args);
                            return scope.$apply(function() {
                                    return action.apply(that, args)
                                })
                        };
                    return wrappedAction
                }
            });
        var originalRegisterComponent = DX.registerComponent;
        var registerNgComponent = function(componentName, _, componentClass) {
                componentClass = componentClass || _;
                originalRegisterComponent.apply(this, arguments);
                phoneJsModule.directive(componentName, ["$compile", function(compile) {
                        return {
                                restrict: "A",
                                compile: function($element) {
                                    var $templates = extractTemplates($element, componentClass);
                                    return function(scope, $element, attrs) {
                                            var componentBuilder = new ComponentBuilder({
                                                    componentClass: componentClass,
                                                    componentName: componentName,
                                                    compile: compile,
                                                    $element: $element,
                                                    scope: scope,
                                                    ngOptions: attrs[componentName] ? scope.$eval(attrs[componentName]) : {},
                                                    $templates: $templates
                                                });
                                            componentBuilder.initTemplateCompilers();
                                            componentBuilder.initDefaultCompilerGetter();
                                            componentBuilder.initComponentWithBindings()
                                        }
                                }
                            }
                    }])
            };
        DX.registerComponent = registerNgComponent;
        registerNgComponent("DOMComponent", NgComponent)
    })(jQuery, DevExpress);
    /*! Module core, file ko.templates.js */
    (function($, DX, undefined) {
        if (!DX.support.hasKo)
            return;
        var ko = window.ko,
            ui = DX.ui,
            CREATED_WITH_KO_DATA_KEY = "dxKoCreation";
        var KoTemplate = ui.TemplateBase.inherit({
                ctor: function(element) {
                    this.callBase.apply(this, arguments);
                    this._template = $("<div>").append(DX.utils.normalizeTemplateElement(element));
                    this._registerKoTemplate()
                },
                _registerKoTemplate: function() {
                    var template = this._template.get(0);
                    new ko.templateSources.anonymousTemplate(template)['nodes'](template)
                },
                _prepareDataForContainer: function(data, container) {
                    var result = data,
                        containerElement,
                        containerContext;
                    if (container.length) {
                        containerElement = container.get(0);
                        data = DX.utils.isDefined(data) ? data : ko.dataFor(containerElement) || {};
                        containerContext = ko.contextFor(containerElement);
                        if (containerContext)
                            result = data === containerContext.$data ? containerContext : containerContext.createChildContext(data);
                        else
                            result = data
                    }
                    return result
                },
                _renderCore: function(data) {
                    var renderBag = $("<div />"),
                        result;
                    ko.renderTemplate(this._template.get(0), data, null, renderBag.get(0));
                    result = renderBag.contents();
                    result.detach();
                    renderBag.remove();
                    return result
                },
                dispose: function() {
                    this.callBase();
                    this._template.remove()
                }
            });
        var KoTemplateProvider = ui.TemplateProviderBase.inherit({
                createTemplate: function(element, owner) {
                    return new KoTemplate(element, owner)
                },
                applyTemplate: function(element, model) {
                    ko.applyBindings(model, element)
                },
                _templatesForWidget: function(name) {
                    return defaultTemplates(name)
                }
            });
        var defaultTemplates = function() {
                var cache = {};
                return function(widgetName) {
                        if (!cache[widgetName]) {
                            var templateGenerators = TEMPLATE_GENERATORS[widgetName] || {},
                                templates = {};
                            $.each(templateGenerators, function(name, generator) {
                                var markup = DX.utils.createMarkupFromString(generator());
                                templates[name] = new KoTemplate(markup)
                            });
                            cache[widgetName] = templates
                        }
                        return cache[widgetName]
                    }
            }();
        var createElementWithBindAttr = function(tagName, bindings, closeTag, additionalProperties) {
                closeTag = closeTag === undefined ? true : closeTag;
                var bindAttr = $.map(bindings, function(value, key) {
                        return key + ":" + value
                    }).join(",");
                additionalProperties = additionalProperties || "";
                return "<" + tagName + " data-bind=\"" + bindAttr + "\" " + additionalProperties + ">" + (closeTag ? "</" + tagName + ">" : "")
            };
        var defaultKoTemplateBasicBindings = {css: "{ 'dx-state-disabled': $data.disabled, 'dx-state-invisible': !($data.visible === undefined || ko.unwrap($data.visible)) }"};
        var TEMPLATE_GENERATORS = {};
        TEMPLATE_GENERATORS.CollectionWidget = {
            itemFrame: function() {
                var markup = [createElementWithBindAttr("div", defaultKoTemplateBasicBindings, false), "<div class='dx-item-content-placeholder'></div>", "</div>"];
                return markup.join("")
            },
            item: function() {
                var htmlBinding = createElementWithBindAttr("div", {html: "html"}),
                    textBinding = createElementWithBindAttr("div", {text: "text"}),
                    primitiveBinding = createElementWithBindAttr("div", {text: "String($data)"});
                var markup = ["<div>", "<!-- ko if: $data.html && !$data.text -->", htmlBinding, "<!-- /ko -->", "<!-- ko if: !$data.html && $data.text -->", textBinding, "<!-- /ko -->", "<!-- ko ifnot: $.isPlainObject($data) -->", primitiveBinding, "<!-- /ko -->", "</div>"];
                return markup.join("")
            }
        };
        var LIST_ITEM_BADGE_CONTAINER_CLASS = "dx-list-item-badge-container",
            LIST_ITEM_BADGE_CLASS = "dx-list-item-badge",
            BADGE_CLASS = "dx-badge",
            LIST_ITEM_CHEVRON_CONTAINER_CLASS = "dx-list-item-chevron-container",
            LIST_ITEM_CHEVRON_CLASS = "dx-list-item-chevron";
        TEMPLATE_GENERATORS.dxList = {
            item: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.item(),
                    keyBinding = createElementWithBindAttr("div", {text: "key"});
                template = [template.substring(0, template.length - 6), "<!-- ko if: $data.key -->" + keyBinding + "<!-- /ko -->", "</div>"];
                return template.join("")
            },
            itemFrame: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(),
                    badgeBinding = createElementWithBindAttr("div", {text: "badge"}, true, 'class="' + LIST_ITEM_BADGE_CLASS + " " + BADGE_CLASS + '"');
                var markup = [template.substring(0, template.length - 6), "<!-- ko if: $data.badge -->", "<div class=\"" + LIST_ITEM_BADGE_CONTAINER_CLASS + "\">", badgeBinding, "</div>", "<!-- /ko -->", "<!-- ko if: $data.showChevron -->", "<div class=\"" + LIST_ITEM_CHEVRON_CONTAINER_CLASS + "\">", "<div class=\"" + LIST_ITEM_CHEVRON_CLASS + "\"></div>", "</div>", "<!-- /ko -->", "</div>"];
                return markup.join("")
            },
            group: function() {
                var keyBinding = createElementWithBindAttr("div", {text: "key"}),
                    primitiveBinding = createElementWithBindAttr("div", {text: "String($data)"});
                var markup = ["<div>", "<!-- ko if: $data.key -->", keyBinding, "<!-- /ko -->", "<!-- ko ifnot: $.isPlainObject($data) -->", primitiveBinding, "<!-- /ko -->", "</div>"];
                return markup.join("")
            }
        };
        TEMPLATE_GENERATORS.dxDropDownMenu = {item: TEMPLATE_GENERATORS.dxList.item};
        TEMPLATE_GENERATORS.dxDropDownList = {item: TEMPLATE_GENERATORS.dxList.item};
        TEMPLATE_GENERATORS.dxRadioGroup = {item: TEMPLATE_GENERATORS.CollectionWidget.item};
        TEMPLATE_GENERATORS.dxSlideOut = {
            menuItem: TEMPLATE_GENERATORS.dxList.item,
            menuGroup: TEMPLATE_GENERATORS.dxList.group
        };
        var titleTemplate = function() {
                var titleBinding = createElementWithBindAttr("div", {text: "title"}),
                    primitiveBinding = createElementWithBindAttr("div", {text: "String($data)"});
                var markup = ["<div>", "<!-- ko if: $data.title -->", titleBinding, "<!-- /ko -->", "<!-- ko ifnot: $.isPlainObject($data) -->", primitiveBinding, "<!-- /ko -->", "</div>"];
                return markup.join("")
            };
        TEMPLATE_GENERATORS.dxAccordion = {
            title: titleTemplate,
            item: TEMPLATE_GENERATORS.CollectionWidget.item
        };
        TEMPLATE_GENERATORS.dxResponsiveBox = {item: TEMPLATE_GENERATORS.CollectionWidget.item},
        TEMPLATE_GENERATORS.dxPivotTabs = {item: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.item(),
                    titleBinding = createElementWithBindAttr("span", {text: "title"});
                var divInnerStart = template.indexOf(">") + 1,
                    divInnerFinish = template.length - 6;
                template = [template.substring(0, divInnerStart), titleBinding, template.substring(divInnerFinish, template.length)];
                return template.join("")
            }};
        var PANORAMA_ITEM_TITLE_CLASS = "dx-panorama-item-title";
        TEMPLATE_GENERATORS.dxPanorama = {itemFrame: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(),
                    headerBinding = createElementWithBindAttr("div", {text: "title"}, true, 'class="' + PANORAMA_ITEM_TITLE_CLASS + '"');
                var divInnerStart = template.indexOf(">") + 1;
                template = [template.substring(0, divInnerStart), "<!-- ko if: $data.title -->", headerBinding, "<!-- /ko -->", template.substring(divInnerStart, template.length)];
                return template.join("")
            }};
        TEMPLATE_GENERATORS.dxActionSheet = {item: function() {
                return createElementWithBindAttr("div", {dxButton: "{ text: $data.text, onClick: $data.clickAction || $data.onClick, type: $data.type, disabled: !!ko.unwrap($data.disabled) }"})
            }};
        TEMPLATE_GENERATORS.dxToolbar = {
            item: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.item();
                template = [template.substring(0, template.length - 6), "<!-- ko if: $data.widget -->"];
                $.each(["button", "tabs", "dropDownMenu"], function() {
                    var bindingName = DX.inflector.camelize(["dx", "-", this].join("")),
                        bindingObj = {};
                    bindingObj[bindingName] = "$data.options";
                    template.push("<!-- ko if: $data.widget === '", this, "' -->", createElementWithBindAttr("div", bindingObj), "<!-- /ko -->")
                });
                template.push("<!-- /ko -->");
                return template.join("")
            },
            menuItem: TEMPLATE_GENERATORS.dxList.item,
            actionSheetItem: TEMPLATE_GENERATORS.dxActionSheet.item
        };
        TEMPLATE_GENERATORS.dxGallery = {item: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.item(),
                    primitiveBinding = createElementWithBindAttr("div", {text: "String($data)"}),
                    imgBinding = createElementWithBindAttr("img", {attr: "{ src: String($data) }"}, false);
                template = [template.substring(0, template.length - 6).replace(primitiveBinding, imgBinding), "<!-- ko if: $data.imageSrc -->", createElementWithBindAttr("img", {attr: "{ src: $data.imageSrc }"}, false), "<!-- /ko -->"].join("");
                return template
            }};
        TEMPLATE_GENERATORS.dxTabs = {item: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.item(),
                    baseTextBinding = createElementWithBindAttr("div", {text: "text"}),
                    iconBinding = createElementWithBindAttr("span", {
                        attr: "{ 'class': 'dx-icon-' + $data.icon }",
                        css: "{ 'dx-icon': true }"
                    }),
                    iconSrcBinding = createElementWithBindAttr("img", {
                        attr: "{ src: $data.iconSrc }",
                        css: "{ 'dx-icon': true }"
                    }, false),
                    textBinding = "<!-- ko if: $data.icon -->" + iconBinding + "<!-- /ko -->" + "<!-- ko if: !$data.icon && $data.iconSrc -->" + iconSrcBinding + "<!-- /ko -->" + "<span class=\"dx-tab-text\" data-bind=\"text: $data.text\"></span>";
                template = template.replace("<!-- ko if: !$data.html && $data.text -->", "<!-- ko if: !$data.html && ($data.text || $data.icon || $data.iconSrc) -->").replace(baseTextBinding, textBinding);
                return template
            }};
        TEMPLATE_GENERATORS.dxTabPanel = {
            item: TEMPLATE_GENERATORS.CollectionWidget.item,
            title: titleTemplate
        };
        var NAVBAR_ITEM_BADGE_CLASS = "dx-navbar-item-badge";
        TEMPLATE_GENERATORS.dxNavBar = {itemFrame: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(),
                    badgeBinding = createElementWithBindAttr("div", {text: "badge"}, true, 'class="' + NAVBAR_ITEM_BADGE_CLASS + " " + BADGE_CLASS + '"');
                var markup = [template.substring(0, template.length - 6), "<!-- ko if: $data.badge -->", badgeBinding, "<!-- /ko -->", "</div>"];
                return markup.join("")
            }};
        TEMPLATE_GENERATORS.dxMenuBase = {item: function() {
                var template = [createElementWithBindAttr("div", defaultKoTemplateBasicBindings, false)],
                    iconBinding = createElementWithBindAttr("span", {
                        attr: "{ 'class': 'dx-icon-' + $data.icon }",
                        css: "{ 'dx-icon': true }"
                    }),
                    iconSrcBinding = createElementWithBindAttr("img", {
                        attr: "{ src: $data.iconSrc }",
                        css: "{ 'dx-icon': true }"
                    }),
                    textBinding = createElementWithBindAttr("span", {
                        text: "text",
                        css: "{ 'dx-menu-item-text': true }"
                    }),
                    primitiveBinding = createElementWithBindAttr("span", {
                        text: "String($data)",
                        css: "{ 'dx-menu-item-text': true }"
                    }),
                    popout = '<span class="dx-menu-item-popout-container"><div class="dx-menu-item-popout"></div></span>';
                template.push('<!-- ko if: $data.icon -->', iconBinding, '<!-- /ko -->', '<!-- ko if: !$data.icon && $data.iconSrc -->', iconSrcBinding, '<!-- /ko -->', '<!-- ko if: $.isPlainObject($data) -->', textBinding, '<!-- /ko -->', '<!-- ko ifnot: $.isPlainObject($data) -->', primitiveBinding, '<!-- /ko -->', '<!-- ko if: $data.items -->', popout, '<!-- /ko -->', '</div>');
                return template.join("")
            }};
        TEMPLATE_GENERATORS.dxTreeView = {item: function() {
                var node = [createElementWithBindAttr("div", defaultKoTemplateBasicBindings, false)],
                    link = createElementWithBindAttr("span", {text: "text"}, true),
                    iconBinding = createElementWithBindAttr("span", {
                        attr: "{ 'class': 'dx-icon-' + $data.icon }",
                        css: "{ 'dx-icon': true }"
                    }),
                    iconSrcBinding = createElementWithBindAttr("img", {
                        attr: "{ src: $data.iconSrc }",
                        css: "{ 'dx-icon': true }"
                    }, false);
                node.push("<div>", "<!-- ko if: $data.icon -->", iconBinding, "<!-- /ko -->", "<!-- ko if: !$data.icon && $data.iconSrc -->", iconSrcBinding, "<!-- /ko -->", "<!-- ko if: !$data.html && $data.text -->" + link + "<!-- /ko -->", "</div>");
                return node.join("")
            }};
        var popupTitleAndBottom = function(itemData) {
                return createElementWithBindAttr("div", {dxToolbar: "{ items: $data }"})
            };
        TEMPLATE_GENERATORS.dxPopup = {
            title: popupTitleAndBottom,
            bottom: popupTitleAndBottom
        };
        TEMPLATE_GENERATORS.dxLookup = {
            title: TEMPLATE_GENERATORS.dxPopup.title,
            group: TEMPLATE_GENERATORS.dxList.group
        };
        $.extend(ui, {
            KoTemplateProvider: KoTemplateProvider,
            KoTemplate: KoTemplate
        })
    })(jQuery, DevExpress);
    /*! Module core, file ng.templates.js */
    (function($, DX, undefined) {
        if (!DX.support.hasNg)
            return;
        var ui = DX.ui;
        var CREATED_WITH_NG_DATA_KEY = "dxNgCreation",
            COMPILER_DATA_KEY = "dxNgCompiler",
            DEFAULT_COMPILER_DATA_KEY = "dxDefaultCompilerGetter";
        var NgTemplate = ui.TemplateBase.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    this._compiler = this._element.data(COMPILER_DATA_KEY)
                },
                _renderCore: function(data, index) {
                    var compiler = this._compiler,
                        result = $.isFunction(compiler) ? compiler(data, index) : compiler;
                    return result
                },
                setCompiler: function(compilerGetter) {
                    this._compiler = compilerGetter(this._element)
                }
            });
        var NgTemplateProvider = ui.TemplateProviderBase.inherit({
                createTemplate: function(element, owner) {
                    return new NgTemplate(element, owner)
                },
                getTemplates: function(widget) {
                    var compilerGetter = widget.element().data(DEFAULT_COMPILER_DATA_KEY);
                    var templates = this.callBase.apply(this, arguments);
                    $.each(templates, function(_, template) {
                        template.setCompiler(compilerGetter)
                    });
                    return templates
                },
                _templatesForWidget: function(name) {
                    return defaultTemplates(name)
                }
            });
        var defaultTemplates = function() {
                var cache = {};
                return function(widgetName) {
                        if (!cache[widgetName]) {
                            var templateGenerators = TEMPLATE_GENERATORS[widgetName] || {},
                                templates = {};
                            $.each(templateGenerators, function(name, generator) {
                                var markup = DX.utils.createMarkupFromString(generator());
                                templates[name] = new NgTemplate(markup)
                            });
                            cache[widgetName] = templates
                        }
                        return cache[widgetName]
                    }
            }();
        var baseElements = {
                container: function() {
                    return $("<div>")
                },
                html: function() {
                    return $("<div>").attr("ng-if", "html").attr("ng-bind-html", "html")
                },
                text: function() {
                    return $("<div>").attr("ng-if", "text").attr("ng-bind", "text")
                },
                primitive: function() {
                    return $("<div>").attr("ng-if", "scopeValue").attr("ng-bind-html", "'' + scopeValue")
                }
            };
        var TEMPLATE_GENERATORS = {};
        TEMPLATE_GENERATORS.CollectionWidget = {
            item: function() {
                return baseElements.container().append(baseElements.html()).append(baseElements.text()).append(baseElements.primitive())
            },
            itemFrame: function() {
                var $container = $("<div>").attr("ng-class", "{ 'dx-state-invisible': !visible && visible != undefined, 'dx-state-disabled': !!disabled }"),
                    $placeholder = $("<div>").addClass("dx-item-content-placeholder");
                $container.append($placeholder);
                return $container
            }
        };
        var LIST_ITEM_BADGE_CONTAINER_CLASS = "dx-list-item-badge-container",
            LIST_ITEM_BADGE_CLASS = "dx-list-item-badge",
            BADGE_CLASS = "dx-badge",
            LIST_ITEM_CHEVRON_CONTAINER_CLASS = "dx-list-item-chevron-container",
            LIST_ITEM_CHEVRON_CLASS = "dx-list-item-chevron";
        TEMPLATE_GENERATORS.dxList = {
            item: function() {
                return TEMPLATE_GENERATORS.CollectionWidget.item().append($("<div>").attr("ng-if", "key").attr("ng-bind", "key"))
            },
            itemFrame: function() {
                var $badgeContainer = $("<div>").addClass(LIST_ITEM_BADGE_CONTAINER_CLASS).attr("ng-if", "badge"),
                    $badge = $("<div>").addClass(LIST_ITEM_BADGE_CLASS).addClass(BADGE_CLASS).attr("ng-bind", "badge");
                var $chevronContainer = $("<div>").addClass(LIST_ITEM_CHEVRON_CONTAINER_CLASS).attr("ng-if", "showChevron"),
                    $chevron = $("<div>").addClass(LIST_ITEM_CHEVRON_CLASS);
                return TEMPLATE_GENERATORS.CollectionWidget.itemFrame().append($badgeContainer.append($badge)).append($chevronContainer.append($chevron))
            },
            group: function() {
                var $keyBinding = $("<div>").attr("ng-if", "key").attr("ng-bind", "key");
                return baseElements.container().append($keyBinding).append(baseElements.primitive())
            }
        };
        TEMPLATE_GENERATORS.dxDropDownMenu = {item: TEMPLATE_GENERATORS.dxList.item};
        TEMPLATE_GENERATORS.dxDropDownList = {item: TEMPLATE_GENERATORS.dxList.item};
        TEMPLATE_GENERATORS.dxRadioGroup = {item: TEMPLATE_GENERATORS.CollectionWidget.item};
        TEMPLATE_GENERATORS.dxSlideOut = {
            menuItem: TEMPLATE_GENERATORS.dxList.item,
            menuGroup: TEMPLATE_GENERATORS.dxList.group
        };
        var titleTemplate = function() {
                var $titleBinding = $("<div>").attr("ng-if", "title").attr("ng-bind", "title");
                return baseElements.container().append($titleBinding).append(baseElements.primitive())
            };
        TEMPLATE_GENERATORS.dxAccordion = {
            title: titleTemplate,
            content: TEMPLATE_GENERATORS.CollectionWidget.item
        };
        TEMPLATE_GENERATORS.dxPivotTabs = {item: function() {
                return baseElements.container().append($("<span>").attr("ng-bind", "title"))
            }};
        var PANORAMA_ITEM_TITLE_CLASS = "dx-panorama-item-title";
        TEMPLATE_GENERATORS.dxPanorama = {itemFrame: function() {
                return TEMPLATE_GENERATORS.CollectionWidget.itemFrame().prepend($("<div>").addClass(PANORAMA_ITEM_TITLE_CLASS).attr("ng-if", "title").attr("ng-bind", "title"))
            }};
        TEMPLATE_GENERATORS.dxActionSheet = {item: function() {
                return $("<div>").attr("dx-button", "{ bindingOptions: { text: 'text', onClick: 'onClick', type: 'type', disabled: 'disabled' } }")
            }};
        TEMPLATE_GENERATORS.dxToolbar = {
            item: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.item();
                $.each(["button", "tabs", "dropDownMenu"], function(i, widgetName) {
                    var bindingName = "dx-" + DX.inflector.dasherize(this);
                    $("<div>").attr("ng-if", "widget === '" + widgetName + "'").attr(bindingName, "options").appendTo(template)
                });
                return template
            },
            menuItem: TEMPLATE_GENERATORS.dxList.item,
            actionSheetItem: TEMPLATE_GENERATORS.dxActionSheet.item
        };
        TEMPLATE_GENERATORS.dxGallery = {item: function() {
                return baseElements.container().append(baseElements.html()).append(baseElements.text()).append($("<img>").attr("ng-if", "scopeValue").attr("ng-src", "{{'' + scopeValue}}")).append($("<img>").attr("ng-if", "imageSrc").attr("ng-src", "{{imageSrc}}"))
            }};
        TEMPLATE_GENERATORS.dxTabs = {item: function() {
                var container = baseElements.container();
                var text = $("<span>").addClass("dx-tab-text").attr("ng-bind", "text").attr("ng-if", "text"),
                    icon = $("<span>").attr("ng-if", "icon").addClass("dx-icon").attr("ng-class", "'dx-icon-' + icon"),
                    iconSrc = $("<img>").attr("ng-if", "iconSrc").addClass("dx-icon").attr("ng-src", "{{iconSrc}}");
                return container.append(baseElements.html()).append(icon).append(iconSrc).append(text).append(baseElements.primitive())
            }};
        var NAVBAR_ITEM_BADGE_CLASS = "dx-navbar-item-badge";
        TEMPLATE_GENERATORS.dxNavBar = {itemFrame: function() {
                var $badge = $("<div>").addClass(NAVBAR_ITEM_BADGE_CLASS).addClass(BADGE_CLASS).attr("ng-if", "badge").attr("ng-bind", "badge");
                return TEMPLATE_GENERATORS.CollectionWidget.itemFrame().append($badge)
            }};
        TEMPLATE_GENERATORS.dxMenuBase = {item: function() {
                var container = baseElements.container();
                var text = $("<span>").attr("ng-if", "text").addClass("dx-menu-item-text").attr("ng-bind", "text"),
                    icon = $("<span>").attr("ng-if", "icon").addClass("dx-icon").attr("ng-class", "'dx-icon-' + icon"),
                    iconSrc = $("<img>").attr("ng-if", "iconSrc").addClass("dx-icon").attr("ng-src", "{{iconSrc}}"),
                    popout = $("<span>").addClass("dx-menu-item-popout-container").attr("ng-if", "items").append($("<div>").addClass("dx-menu-item-popout"));
                container.append(baseElements.html()).append(icon).append(iconSrc).append(text).append(popout).append(baseElements.primitive()).appendTo(container);
                return container
            }};
        TEMPLATE_GENERATORS.dxTreeView = {item: function() {
                var container = baseElements.container();
                var content = $("<div />"),
                    link = $("<span/>").attr("ng-bind", "text"),
                    icon = $("<span>").attr("ng-if", "icon").addClass("dx-icon").attr("ng-class", "'dx-icon-' + icon"),
                    iconSrc = $("<img>").attr("ng-if", "iconSrc").addClass("dx-icon").attr("ng-src", "{{iconSrc}}");
                content.append(baseElements.html()).append(icon).append(iconSrc).append(link).append(baseElements.primitive()).appendTo(container);
                return container
            }};
        TEMPLATE_GENERATORS.dxTabPanel = {
            item: TEMPLATE_GENERATORS.CollectionWidget.item,
            title: titleTemplate
        };
        var popupTitleAndBottom = function() {
                return $("<div>").attr("dx-toolbar", "{ bindingOptions: { items: 'scopeValue' } }")
            };
        TEMPLATE_GENERATORS.dxPopup = {
            title: popupTitleAndBottom,
            bottom: popupTitleAndBottom
        };
        TEMPLATE_GENERATORS.dxLookup = {
            title: TEMPLATE_GENERATORS.dxPopup.title,
            group: TEMPLATE_GENERATORS.dxList.group
        };
        $.extend(ui, {
            NgTemplate: NgTemplate,
            NgTemplateProvider: NgTemplateProvider
        })
    })(jQuery, DevExpress);
    /*! Module core, file ko.validation.js */
    (function($, DX, undefined) {
        if (!DX.support.hasKo)
            return;
        var ko = window.ko;
        var koDxValidator = DX.Class.inherit({
                ctor: function(target, option) {
                    var that = this;
                    that.target = target;
                    that.validationRules = option.validationRules;
                    that.name = option.name;
                    that.isValid = ko.observable(true);
                    that.validationError = ko.observable();
                    $.each(this.validationRules, function(_, rule) {
                        rule.validator = that
                    })
                },
                validate: function() {
                    var result = DevExpress.validationEngine.validate(this.target(), this.validationRules, this.name);
                    this.target.dxValidator.isValid(result.isValid);
                    this.target.dxValidator.validationError(result.brokenRule);
                    this.fireEvent("validated", [result]);
                    return result
                }
            }).include(DX.EventsMixin);
        ko.extenders.dxValidator = function(target, option) {
            target.dxValidator = new koDxValidator(target, option);
            target.subscribe($.proxy(target.dxValidator.validate, target.dxValidator));
            return target
        };
        DevExpress.validationEngine.registerModelForValidation = function(model) {
            $.each(model, function(name, member) {
                if (ko.isObservable(member) && member.dxValidator)
                    DevExpress.validationEngine.registerValidatorInGroup(model, member.dxValidator)
            })
        };
        DevExpress.validationEngine.validateModel = DevExpress.validationEngine.validateGroup
    })(jQuery, DevExpress);
    /*! Module core, file ui.themes.js */
    (function($, DX, undefined) {
        var DX_LINK_SELECTOR = "link[rel=dx-theme]",
            THEME_ATTR = "data-theme",
            ACTIVE_ATTR = "data-active";
        var context,
            $activeThemeLink,
            knownThemes,
            currentThemeName,
            pendingThemeName;
        var THEME_MARKER_PREFIX = "dx.";
        function readThemeMarker() {
            var element = $("<div></div>", context).addClass("dx-theme-marker").appendTo(context.documentElement),
                result;
            try {
                result = element.css("font-family");
                if (!result)
                    return null;
                result = result.replace(/["']/g, "");
                if (result.substr(0, THEME_MARKER_PREFIX.length) !== THEME_MARKER_PREFIX)
                    return null;
                return result.substr(THEME_MARKER_PREFIX.length)
            }
            finally {
                element.remove()
            }
        }
        function waitForThemeLoad(themeName, callback) {
            var timerId,
                waitStartTime;
            pendingThemeName = themeName;
            function handleLoaded() {
                pendingThemeName = null;
                callback()
            }
            if (isPendingThemeLoaded())
                handleLoaded();
            else {
                waitStartTime = $.now();
                timerId = setInterval(function() {
                    var isLoaded = isPendingThemeLoaded(),
                        isTimeout = !isLoaded && $.now() - waitStartTime > 15 * 1000;
                    if (isTimeout)
                        DX.log("W0004", pendingThemeName);
                    if (isLoaded || isTimeout) {
                        clearInterval(timerId);
                        handleLoaded()
                    }
                }, 10)
            }
        }
        function isPendingThemeLoaded() {
            return !pendingThemeName || readThemeMarker() === pendingThemeName
        }
        function processMarkup() {
            var $allThemeLinks = $(DX_LINK_SELECTOR, context);
            if (!$allThemeLinks.length)
                return;
            knownThemes = {};
            $activeThemeLink = $(DX.utils.createMarkupFromString("<link rel=stylesheet>"), context);
            $allThemeLinks.each(function() {
                var link = $(this, context),
                    fullThemeName = link.attr(THEME_ATTR),
                    url = link.attr("href"),
                    isActive = link.attr(ACTIVE_ATTR) === "true";
                knownThemes[fullThemeName] = {
                    url: url,
                    isActive: isActive
                }
            });
            $allThemeLinks.last().after($activeThemeLink);
            $allThemeLinks.remove()
        }
        function resolveFullThemeName(desiredThemeName) {
            var desiredThemeParts = desiredThemeName.split("."),
                result = null;
            if (knownThemes)
                $.each(knownThemes, function(knownThemeName, themeData) {
                    var knownThemeParts = knownThemeName.split(".");
                    if (knownThemeParts[0] !== desiredThemeParts[0])
                        return;
                    if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1])
                        return;
                    if (!result || themeData.isActive)
                        result = knownThemeName;
                    if (themeData.isActive)
                        return false
                });
            return result
        }
        function initContext(newContext) {
            try {
                if (newContext !== context)
                    knownThemes = null
            }
            catch(x) {
                knownThemes = null
            }
            context = newContext
        }
        function init(options) {
            options = options || {};
            initContext(options.context || document);
            processMarkup();
            currentThemeName = undefined;
            current(options)
        }
        function current(options) {
            if (!arguments.length)
                return currentThemeName || readThemeMarker();
            detachCssClasses(DX.viewPort(), currentThemeName);
            options = options || {};
            if (typeof options === "string")
                options = {theme: options};
            var isAutoInit = options._autoInit,
                loadCallback = options.loadCallback,
                currentThemeData;
            currentThemeName = options.theme || currentThemeName;
            if (isAutoInit && !currentThemeName)
                currentThemeName = themeNameFromDevice(DX.devices.current());
            currentThemeName = resolveFullThemeName(currentThemeName);
            if (currentThemeName)
                currentThemeData = knownThemes[currentThemeName];
            if (currentThemeData) {
                $activeThemeLink.removeAttr("href");
                $activeThemeLink.attr("href", knownThemes[currentThemeName].url);
                if (loadCallback)
                    waitForThemeLoad(currentThemeName, loadCallback);
                else if (pendingThemeName)
                    pendingThemeName = currentThemeName
            }
            else if (isAutoInit) {
                if (loadCallback)
                    loadCallback()
            }
            else
                throw DX.Error("E0021", currentThemeName);
            attachCssClasses(DX.viewPort(), currentThemeName)
        }
        function themeNameFromDevice(device) {
            var themeName = device.platform,
                majorVersion = device.version && device.version[0];
            if (themeName === "ios" && (!majorVersion || majorVersion > 6))
                themeName += "7";
            if (themeName === "android" && (!majorVersion || majorVersion > 4))
                themeName += "5";
            return themeName
        }
        function getCssClasses(themeName) {
            themeName = themeName || current();
            var result = [],
                themeNameParts = themeName && themeName.split(".");
            if (themeNameParts) {
                result.push("dx-theme-" + themeNameParts[0], "dx-theme-" + themeNameParts[0] + "-typography");
                if (themeNameParts.length > 1)
                    result.push("dx-color-scheme-" + themeNameParts[1])
            }
            return result
        }
        function attachCssClasses(element, themeName) {
            $(element).addClass(getCssClasses(themeName).join(" "))
        }
        function detachCssClasses(element, themeName) {
            $(element).removeClass(getCssClasses(themeName).join(" "))
        }
        $.holdReady(true);
        init({
            _autoInit: true,
            loadCallback: function() {
                $.holdReady(false)
            }
        });
        $(function() {
            if ($(DX_LINK_SELECTOR, context).length)
                throw DX.Error("E0022");
        });
        DX.viewPortChanged.add(function(viewPort, prevViewPort) {
            detachCssClasses(prevViewPort);
            attachCssClasses(viewPort)
        });
        DX.ui.themes = {
            init: init,
            current: current,
            attachCssClasses: attachCssClasses,
            detachCssClasses: detachCssClasses
        };
        DX.ui.themes.__internals = {
            themeNameFromDevice: themeNameFromDevice,
            waitForThemeLoad: waitForThemeLoad,
            resetTheme: function() {
                $activeThemeLink.attr("href", "about:blank");
                currentThemeName = null;
                pendingThemeName = null
            }
        }
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            eventNS = $.event,
            hooksNS = eventNS.fixHooks,
            specialNS = eventNS.special,
            EVENT_SOURCES_REGEX = {
                dx: /^dx/i,
                mouse: /(mouse|wheel)/i,
                touch: /^touch/i,
                keyboard: /^key/i,
                pointer: /^(ms)?pointer/i
            };
        var eventSource = function(e) {
                var result = "other";
                $.each(EVENT_SOURCES_REGEX, function(key) {
                    if (this.test(e.type)) {
                        result = key;
                        return false
                    }
                });
                return result
            };
        var isDxEvent = function(e) {
                return eventSource(e) === "dx"
            };
        var isNativeMouseEvent = function(e) {
                return eventSource(e) === "mouse"
            };
        var isNativeTouchEvent = function(e) {
                return eventSource(e) === "touch"
            };
        var isPointerEvent = function(e) {
                return eventSource(e) === "pointer"
            };
        var isMouseEvent = function(e) {
                return isNativeMouseEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && e.pointerType === "mouse"
            };
        var isTouchEvent = function(e) {
                return isNativeTouchEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && e.pointerType === "touch"
            };
        var isKeyboardEvent = function(e) {
                return eventSource(e) === "keyboard"
            };
        var eventData = function(e) {
                return {
                        x: e.pageX,
                        y: e.pageY,
                        time: e.timeStamp
                    }
            };
        var eventDelta = function(from, to) {
                return {
                        x: to.x - from.x,
                        y: to.y - from.y,
                        time: to.time - from.time || 1
                    }
            };
        var hasTouches = function(e) {
                if (isNativeTouchEvent(e))
                    return (e.originalEvent.touches || []).length;
                if (isDxEvent(e))
                    return (e.pointers || []).length;
                return 0
            };
        var needSkipEvent = function(e) {
                var $target = $(e.target),
                    touchInInput = $target.is("input, textarea, select");
                if (isMouseEvent(e))
                    return touchInInput || e.which > 1;
                if (isTouchEvent(e))
                    return touchInInput && $target.is(":focus")
            };
        var createEvent = function(originalEvent, args) {
                var event = $.Event(originalEvent),
                    fixHook = hooksNS[originalEvent.type] || eventNS.mouseHooks;
                var props = fixHook.props ? eventNS.props.concat(fixHook.props) : eventNS.props,
                    propIndex = props.length;
                while (propIndex--) {
                    var prop = props[propIndex];
                    event[prop] = originalEvent[prop]
                }
                if (args)
                    $.extend(event, args);
                return fixHook.filter ? fixHook.filter(event, originalEvent) : event
            };
        var fireEvent = function(props) {
                var event = createEvent(props.originalEvent, props);
                eventNS.trigger(event, null, props.delegateTarget || event.target);
                return event
            };
        var addNamespace = function(eventNames, namespace) {
                if (!namespace)
                    throw DX.Error("E0017");
                if (typeof eventNames === "string")
                    return addNamespace(eventNames.split(/\s+/g), namespace);
                $.each(eventNames, function(index, eventName) {
                    eventNames[index] = eventName + "." + namespace
                });
                return eventNames.join(" ")
            };
        var dxEventHook = {props: eventNS.mouseHooks.props.concat(["pointerType", "pointerId", "pointers"])};
        var registerEvent = function(eventName, eventObject) {
                var strategy = {};
                if ("noBubble" in eventObject)
                    strategy.noBubble = eventObject.noBubble;
                if ("bindType" in eventObject)
                    strategy.bindType = eventObject.bindType;
                if ("delegateType" in eventObject)
                    strategy.delegateType = eventObject.delegateType;
                $.each(["setup", "teardown", "add", "remove", "trigger", "handle", "_default", "dispose"], function(_, methodName) {
                    if (!eventObject[methodName])
                        return;
                    strategy[methodName] = function() {
                        var args = $.makeArray(arguments);
                        args.unshift(this);
                        return eventObject[methodName].apply(eventObject, args)
                    }
                });
                hooksNS[eventName] = dxEventHook;
                specialNS[eventName] = strategy
            };
        ui.events = {
            eventSource: eventSource,
            isPointerEvent: isPointerEvent,
            isMouseEvent: isMouseEvent,
            isTouchEvent: isTouchEvent,
            isKeyboardEvent: isKeyboardEvent,
            hasTouches: hasTouches,
            eventData: eventData,
            eventDelta: eventDelta,
            needSkipEvent: needSkipEvent,
            createEvent: createEvent,
            fireEvent: fireEvent,
            addNamespace: addNamespace,
            registerEvent: registerEvent
        }
    })(jQuery, DevExpress);
    /*! Module core, file ko.events.js */
    (function($, DX, undefined) {
        if (!DX.support.hasKo)
            return;
        var ko = window.ko,
            events = DX.ui.events;
        var originalRegisterEvent = events.registerEvent;
        var registerKoEvent = function(eventName, eventObject) {
                originalRegisterEvent(eventName, eventObject);
                var koBindingEventName = events.addNamespace(eventName, eventName + "Binding");
                ko.bindingHandlers[eventName] = {update: function(element, valueAccessor, allBindingsAccessor, viewModel) {
                        var $element = $(element),
                            unwrappedValue = ko.utils.unwrapObservable(valueAccessor()),
                            eventSource = unwrappedValue.execute ? unwrappedValue.execute : unwrappedValue;
                        $element.off(koBindingEventName).on(koBindingEventName, $.isPlainObject(unwrappedValue) ? unwrappedValue : {}, function(e) {
                            eventSource.call(viewModel, viewModel, e)
                        })
                    }}
            };
        $.extend(events, {registerEvent: registerKoEvent})
    })(jQuery, DevExpress);
    /*! Module core, file ng.events.js */
    (function($, DX, undefined) {
        if (!DX.support.hasNg)
            return;
        var events = DX.ui.events;
        var originalRegisterEvent = events.registerEvent;
        var registerNgEvent = function(eventName, eventObject) {
                originalRegisterEvent(eventName, eventObject);
                var ngEventName = eventName.slice(0, 2) + eventName.charAt(2).toUpperCase() + eventName.slice(3);
                DX.ng.module.directive(ngEventName, ['$parse', function($parse) {
                        return function(scope, element, attr) {
                                var attrValue = $.trim(attr[ngEventName]),
                                    handler,
                                    eventOptions = {};
                                if (attrValue.charAt(0) === "{") {
                                    eventOptions = scope.$eval(attrValue);
                                    handler = $parse(eventOptions.execute)
                                }
                                else
                                    handler = $parse(attr[ngEventName]);
                                element.on(eventName, eventOptions, function(e) {
                                    scope.$apply(function() {
                                        handler(scope, {$event: e})
                                    })
                                })
                            }
                    }])
            };
        $.extend(events, {registerEvent: registerNgEvent})
    })(jQuery, DevExpress);
    /*! Module core, file ui.keyboardProcessor.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        ui.KeyboardProcessor = DX.Class.inherit({
            _keydown: events.addNamespace("keydown", "KeyboardProcessor"),
            codes: {
                "8": "backspace",
                "9": "tab",
                "13": "enter",
                "27": "escape",
                "33": "pageUp",
                "34": "pageDown",
                "35": "end",
                "36": "home",
                "37": "leftArrow",
                "38": "upArrow",
                "39": "rightArrow",
                "40": "downArrow",
                "32": "space",
                "70": "F",
                "65": "A"
            },
            ctor: function(options) {
                var _this = this;
                options = options || {};
                if (options.element)
                    this._element = $(options.element);
                this._handler = options.handler;
                this._context = options.context;
                this._childProcessors = [];
                if (this._element)
                    this._element.on(this._keydown, function(e) {
                        _this.process(e)
                    })
            },
            dispose: function() {
                if (this._element)
                    this._element.off(this._keydown);
                this._element = undefined;
                this._handler = undefined;
                this._context = undefined;
                this._childProcessors = undefined
            },
            push: function(child) {
                if (!this._childProcessors)
                    this._childProcessors = [];
                this._childProcessors.push(child);
                return child
            },
            attachChildProcessor: function() {
                var childProcessor = new ui.KeyboardProcessor;
                this._childProcessors.push(childProcessor);
                return childProcessor
            },
            reinitialize: function(childHandler, childContext) {
                this._context = childContext;
                this._handler = childHandler;
                return this
            },
            process: function(e) {
                var args = {
                        key: this.codes[e.which],
                        ctrl: e.ctrlKey,
                        shift: e.shiftKey,
                        alt: e.altKey,
                        originalEvent: e
                    };
                if (this.codes[e.which] && this._handler && this._handler.call(this._context, args) && this._childProcessors)
                    $.each(this._childProcessors, function(index, childProcessor) {
                        childProcessor.process(e)
                    })
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.dialog.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils;
        var DEFAULT_BUTTON = {
                text: "OK",
                onClick: function() {
                    return true
                }
            };
        var DX_DIALOG_CLASSNAME = "dx-dialog",
            DX_DIALOG_WRAPPER_CLASSNAME = DX_DIALOG_CLASSNAME + "-wrapper",
            DX_DIALOG_ROOT_CLASSNAME = DX_DIALOG_CLASSNAME + "-root",
            DX_DIALOG_CONTENT_CLASSNAME = DX_DIALOG_CLASSNAME + "-content",
            DX_DIALOG_MESSAGE_CLASSNAME = DX_DIALOG_CLASSNAME + "-message",
            DX_DIALOG_BUTTONS_CLASSNAME = DX_DIALOG_CLASSNAME + "-buttons",
            DX_DIALOG_BUTTON_CLASSNAME = DX_DIALOG_CLASSNAME + "-button";
        var FakeDialogComponent = DX.Component.inherit({
                NAME: "dxDialog",
                ctor: function(element, options) {
                    this.callBase(options)
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: {platform: "ios"},
                                options: {width: 276}
                            }, {
                                device: {platform: "android"},
                                options: {
                                    lWidth: "60%",
                                    pWidth: "80%"
                                }
                            }, {
                                device: {
                                    platform: "win8",
                                    phone: false
                                },
                                options: {width: function() {
                                        return $(window).width()
                                    }}
                            }, {
                                device: {
                                    platform: "win8",
                                    phone: true
                                },
                                options: {position: {
                                        my: "top center",
                                        at: "top center",
                                        of: window,
                                        offset: "0 0"
                                    }}
                            }])
                }
            });
        var dialog = function(options) {
                if (!ui.dxPopup)
                    throw DX.Error("E0018");
                var deferred = $.Deferred();
                var defaultOptions = (new FakeDialogComponent).option();
                options = $.extend(defaultOptions, options);
                var $element = $("<div>").addClass(DX_DIALOG_CLASSNAME).appendTo(DX.viewPort());
                var $message = $("<div>").addClass(DX_DIALOG_MESSAGE_CLASSNAME).html(String(options.message));
                var $buttons = $("<div>").addClass(DX_DIALOG_BUTTONS_CLASSNAME);
                var popupInstance = $element.dxPopup({
                        title: options.title || this.title,
                        height: "auto",
                        width: function() {
                            var isPortrait = $(window).height() > $(window).width(),
                                key = (isPortrait ? "p" : "l") + "Width",
                                widthOption = options.hasOwnProperty(key) ? options[key] : options["width"];
                            return $.isFunction(widthOption) ? widthOption() : widthOption
                        },
                        focusStateEnabled: false,
                        onContentReady: function(args) {
                            args.component.content().addClass(DX_DIALOG_CONTENT_CLASSNAME).append($message).append($buttons)
                        },
                        onShown: function() {
                            $buttons.children().first().focus()
                        },
                        animation: {
                            show: {
                                type: "pop",
                                duration: 400
                            },
                            hide: {
                                type: "pop",
                                duration: 400,
                                to: {
                                    opacity: 0,
                                    scale: 0
                                },
                                from: {
                                    opacity: 1,
                                    scale: 1
                                }
                            }
                        },
                        rtlEnabled: DX.rtlEnabled
                    }).dxPopup("instance");
                popupInstance._wrapper().addClass(DX_DIALOG_WRAPPER_CLASSNAME);
                if (options.position)
                    popupInstance.option("position", options.position);
                $.each(options.buttons || [$.extend({}, DEFAULT_BUTTON)], function(_, buttonConfig) {
                    var $button = $("<div>").addClass(DX_DIALOG_BUTTON_CLASSNAME).appendTo($buttons);
                    if (buttonConfig.clickAction) {
                        DX.log("W0001", "Dialog", "clickAction", "14.2", "Use 'onClick' option instead");
                        buttonConfig.onClick = buttonConfig.clickAction
                    }
                    var clickHandler = buttonConfig.onClick;
                    $button.dxButton($.extend(buttonConfig, {onClick: function() {
                            var action = new DX.Action(clickHandler, {context: popupInstance});
                            var result = action.execute(arguments);
                            hide(result)
                        }}))
                });
                popupInstance._wrapper().addClass(DX_DIALOG_ROOT_CLASSNAME);
                function show() {
                    popupInstance.show();
                    utils.resetActiveElement();
                    return deferred.promise()
                }
                function hide(value) {
                    popupInstance.hide().done(function() {
                        popupInstance.element().remove()
                    });
                    deferred.resolve(value)
                }
                return {
                        show: show,
                        hide: hide
                    }
            };
        var alert = function(message, title) {
                var dialogInstance,
                    options = $.isPlainObject(message) ? message : {
                        title: title,
                        message: message
                    };
                dialogInstance = ui.dialog.custom(options);
                return dialogInstance.show()
            };
        var confirm = function(message, title) {
                var dialogInstance,
                    options = $.isPlainObject(message) ? message : {
                        title: title,
                        message: message,
                        buttons: [{
                                text: Globalize.localize("Yes"),
                                onClick: function() {
                                    return true
                                }
                            }, {
                                text: Globalize.localize("No"),
                                onClick: function() {
                                    return false
                                }
                            }]
                    };
                dialogInstance = ui.dialog.custom(options);
                return dialogInstance.show()
            };
        var $notify = null;
        var notify = function(message, type, displayTime) {
                var options = $.isPlainObject(message) ? message : {message: message};
                if (!ui.dxToast) {
                    alert(options.message);
                    return
                }
                if (options.hiddenAction) {
                    DX.log("W0001", "Dialog", "hiddenAction", "14.2", "Use 'onHidden' option instead");
                    options.onHidden = options.hiddenAction
                }
                var userHiddenAction = options.onHidden;
                $.extend(options, {
                    type: type,
                    displayTime: displayTime,
                    onHidden: function(args) {
                        args.element.remove();
                        $notify = null;
                        new DX.Action(userHiddenAction, {context: args.model}).execute(arguments)
                    }
                });
                if ($notify) {
                    $notify.remove();
                    $notify = null
                }
                $notify = $("<div>").appendTo(DX.viewPort()).dxToast(options);
                $notify.dxToast("instance").show()
            };
        $.extend(ui, {
            notify: notify,
            dialog: {
                custom: dialog,
                alert: alert,
                confirm: confirm,
                FakeDialogComponent: FakeDialogComponent
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.dataHelper.js */
    (function($, DX, undefined) {
        var data = DX.data;
        var DATA_SOURCE_OPTIONS_METHOD = "_dataSourceOptions",
            DATA_SOURCE_CHANGED_METHOD = "_dataSourceChangedHandler",
            DATA_SOURCE_LOAD_ERROR_METHOD = "_dataSourceLoadErrorHandler",
            DATA_SOURCE_LOADING_CHANGED_METHOD = "_dataSourceLoadingChangedHandler";
        DX.ui.DataHelperMixin = {
            postCtor: function() {
                this.on("disposing", function() {
                    this._disposeDataSource()
                })
            },
            _refreshDataSource: function() {
                this._initDataSource();
                this._loadDataSource()
            },
            _initDataSource: function() {
                var dataSourceOptions = this.option("dataSource"),
                    widgetDataSourceOptions,
                    dataSourceType;
                this._disposeDataSource();
                if (dataSourceOptions) {
                    if (dataSourceOptions instanceof data.DataSource) {
                        this._isSharedDataSource = true;
                        this._dataSource = dataSourceOptions
                    }
                    else {
                        widgetDataSourceOptions = DATA_SOURCE_OPTIONS_METHOD in this ? this[DATA_SOURCE_OPTIONS_METHOD]() : {};
                        dataSourceType = this._dataSourceType ? this._dataSourceType() : data.DataSource;
                        this._dataSource = new dataSourceType($.extend(true, {}, widgetDataSourceOptions, data.utils.normalizeDataSourceOptions(dataSourceOptions)))
                    }
                    this._addDataSourceHandlers()
                }
            },
            _addDataSourceHandlers: function() {
                if (DATA_SOURCE_CHANGED_METHOD in this)
                    this._addDataSourceChangeHandler();
                if (DATA_SOURCE_LOAD_ERROR_METHOD in this)
                    this._addDataSourceLoadErrorHandler();
                if (DATA_SOURCE_LOADING_CHANGED_METHOD in this)
                    this._addDataSourceLoadingChangedHandler()
            },
            _addDataSourceChangeHandler: function() {
                var dataSource = this._dataSource;
                this._proxiedDataSourceChangedHandler = $.proxy(function() {
                    this[DATA_SOURCE_CHANGED_METHOD](dataSource.items())
                }, this);
                dataSource.on("changed", this._proxiedDataSourceChangedHandler)
            },
            _addDataSourceLoadErrorHandler: function() {
                this._proxiedDataSourceLoadErrorHandler = $.proxy(this[DATA_SOURCE_LOAD_ERROR_METHOD], this);
                this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler)
            },
            _addDataSourceLoadingChangedHandler: function() {
                this._proxiedDataSourceLoadingChangedHandler = $.proxy(this[DATA_SOURCE_LOADING_CHANGED_METHOD], this);
                this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler)
            },
            _loadDataSource: function() {
                if (this._dataSource) {
                    var dataSource = this._dataSource;
                    if (dataSource.isLoaded())
                        this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler();
                    else
                        dataSource.load()
                }
            },
            _loadSingle: function(key, value) {
                key = key === "this" ? this._dataSource.key() || "this" : key;
                return this._dataSource.loadSingle(key, value)
            },
            _disposeDataSource: function() {
                if (this._dataSource) {
                    if (this._isSharedDataSource) {
                        delete this._isSharedDataSource;
                        this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
                        this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
                        this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler)
                    }
                    else
                        this._dataSource.dispose();
                    delete this._dataSource;
                    delete this._proxiedDataSourceChangedHandler;
                    delete this._proxiedDataSourceLoadErrorHandler;
                    delete this._proxiedDataSourceLoadingChangedHandler
                }
            }
        }
    })(jQuery, DevExpress);
    /*! Module core, file ui.dataExpression.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils;
        ui.DataExpressionMixin = $.extend(ui.DataHelperMixin, {
            _dataExpressionDeprecatedOptions: function() {
                return {itemRender: {
                            since: "14.2",
                            alias: "itemTemplate"
                        }}
            },
            _dataExpressionDefaultOptions: function() {
                return {
                        items: [],
                        dataSource: null,
                        itemTemplate: "item",
                        value: undefined,
                        valueExpr: "this",
                        displayExpr: undefined
                    }
            },
            _initDataExpressions: function() {
                this._compileValueGetter();
                this._compileDisplayGetter();
                this._initDynamicTemplates();
                this._initDataSource();
                this._itemsToDataSource()
            },
            _itemsToDataSource: function() {
                if (!this.option("dataSource"))
                    this._dataSource = new DevExpress.data.DataSource({
                        store: new DevExpress.data.ArrayStore(this.option("items")),
                        pageSize: 0
                    })
            },
            _compileDisplayGetter: function() {
                this._displayGetter = DX.data.utils.compileGetter(this.option("displayExpr"))
            },
            _compileValueGetter: function() {
                this._valueGetter = DX.data.utils.compileGetter(this._valueGetterExpr())
            },
            _valueGetterExpr: function() {
                return this.option("valueExpr") || "this"
            },
            _loadValue: function(value) {
                var deferred = $.Deferred();
                value = this._unwrappedValue(value);
                if (!utils.isDefined(value))
                    return deferred.reject().promise();
                this._loadSingle(this._valueGetterExpr(), value).done($.proxy(function(item) {
                    this._valueEquals(this._valueGetter(item), value) ? deferred.resolve(item) : deferred.reject()
                }, this)).fail(function() {
                    deferred.reject()
                });
                return deferred.promise()
            },
            _unwrappedValue: function(value) {
                value = DX.utils.isDefined(value) ? value : this.option("value");
                if (this._dataSource && this._valueGetterExpr() === "this") {
                    var key = this._dataSource.key();
                    if (key && typeof value === "object")
                        value = value[key]
                }
                return utils.unwrapObservable(value)
            },
            _valueEquals: function(value1, value2) {
                var dataSourceKey = this._dataSource && this._dataSource.key();
                var result = value1 === value2;
                if (!result && value1 && value2 && dataSourceKey) {
                    var valueKey1 = utils.unwrapObservable(value1[dataSourceKey]) || value1;
                    var valueKey2 = utils.unwrapObservable(value2[dataSourceKey]) || value2;
                    result = valueKey1 === valueKey2
                }
                return result
            },
            _initDynamicTemplates: function() {
                if (this.option("displayExpr"))
                    this._dynamicTemplates["item"] = new ui.DefaultTemplate($.proxy(function(data) {
                        return this._displayGetter(data)
                    }, this));
                else
                    delete this._dynamicTemplates["item"]
            },
            _setCollectionWidgetItemTemplate: function() {
                this._initDynamicTemplates();
                this._setCollectionWidgetOption("itemTemplate", this._getTemplateByOption("itemTemplate"))
            },
            _dataExpressionOptionChanged: function(args) {
                switch (args.name) {
                    case"items":
                        this._itemsToDataSource();
                        this._setCollectionWidgetOption("items");
                        break;
                    case"dataSource":
                        this._initDataSource();
                        break;
                    case"itemTemplate":
                        this._setCollectionWidgetItemTemplate();
                        break;
                    case"valueExpr":
                        this._compileValueGetter();
                        break;
                    case"displayExpr":
                        this._compileDisplayGetter();
                        this._setCollectionWidgetItemTemplate();
                        break
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.pointer.touchHooks.js */
    (function($, DX, undefined) {
        var touchEventHook = {
                filter: function(event, originalEvent) {
                    var touches = originalEvent.touches.length ? originalEvent.touches : originalEvent.changedTouches;
                    $.each(["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"], function() {
                        event[this] = touches[0][this]
                    });
                    return event
                },
                props: $.event.mouseHooks.props.concat(["touches", "changedTouches", "targetTouches", "detail", "result", "originalTarget", "charCode", "prevValue"])
            };
        $.each(["touchstart", "touchmove", "touchend", "touchcancel"], function() {
            $.event.fixHooks[this] = touchEventHook
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.pointer.mspointerHooks.js */
    (function($, DX, undefined) {
        var POINTER_TYPE_MAP = {
                2: "touch",
                3: "pen",
                4: "mouse"
            };
        var pointerEventHook = {
                filter: function(event, originalEvent) {
                    var pointerType = originalEvent.pointerType;
                    if ($.isNumeric(pointerType))
                        event.pointerType = POINTER_TYPE_MAP[pointerType];
                    return event
                },
                props: $.event.mouseHooks.props.concat(["pointerId", "pointerType", "originalTarget", "width", "height", "pressure", "result", "tiltX", "charCode", "tiltY", "detail", "isPrimary", "prevValue"])
            };
        $.each(["MSPointerDown", "MSPointerMove", "MSPointerUp", "MSPointerCancel", "MSPointerOver", "MSPointerOut", "mouseenter", "mouseleave", "pointerdown", "pointermove", "pointerup", "pointercancel", "pointerover", "pointerout", "pointerenter", "pointerleave"], function() {
            $.event.fixHooks[this] = pointerEventHook
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.pointer.base.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var POINTER_EVENTS_NAMESPACE = "dxPointerEvents";
        var BaseStrategy = DX.Class.inherit({
                ctor: function(eventName, originalEvents) {
                    this._eventName = eventName;
                    this._eventNamespace = [POINTER_EVENTS_NAMESPACE, ".", this._eventName].join("");
                    this._originalEvents = originalEvents;
                    this._handlerCount = 0;
                    this.noBubble = this._isNoBubble()
                },
                _isNoBubble: function() {
                    var eventName = this._eventName;
                    return eventName === "dxpointerenter" || eventName === "dxpointerleave"
                },
                _handler: function(e) {
                    var delegateTarget = this._getDelegateTarget(e);
                    return this._fireEvent({
                            type: this._eventName,
                            pointerType: e.pointerType || events.eventSource(e),
                            originalEvent: e,
                            delegateTarget: delegateTarget
                        })
                },
                _getDelegateTarget: function(e) {
                    var delegateTarget = undefined;
                    if (this.noBubble)
                        delegateTarget = e.delegateTarget;
                    return delegateTarget
                },
                _fireEvent: function(args) {
                    return events.fireEvent(args)
                },
                add: function(element, handleObj) {
                    if (this._handlerCount <= 0 || this.noBubble) {
                        this._selector = handleObj.selector;
                        element = this.noBubble ? element : document;
                        $(element).on(events.addNamespace(this._originalEvents, this._eventNamespace), this._selector, $.proxy(this._handler, this))
                    }
                    if (!this.noBubble)
                        this._handlerCount++
                },
                remove: function(element) {
                    if (!this.noBubble)
                        this._handlerCount--
                },
                teardown: function(element) {
                    if (this._handlerCount && !this.noBubble)
                        return;
                    element = this.noBubble ? element : document;
                    $(element).off("." + this._eventNamespace, this._selector)
                },
                dispose: function(element) {
                    element = this.noBubble ? element : document;
                    $(element).off("." + this._eventNamespace)
                }
            });
        events.pointer = {};
        events.pointer.BaseStrategy = BaseStrategy
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.pointer.mouse.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            pointer = events.pointer;
        var MouseStrategyEventMap = {
                dxpointerdown: "mousedown",
                dxpointermove: "mousemove",
                dxpointerup: "mouseup",
                dxpointercancel: "",
                dxpointerover: "mouseover",
                dxpointerout: "mouseout",
                dxpointerenter: "mouseenter",
                dxpointerleave: "mouseleave"
            };
        var normalizeMouseEvent = function(e) {
                var pointers = [];
                e.pointerId = 1;
                if (e.type !== "mouseup")
                    pointers.push(e);
                return {
                        pointers: pointers,
                        pointerId: 1
                    }
            };
        var MouseStrategy = pointer.BaseStrategy.inherit({_fireEvent: function(args) {
                    return this.callBase($.extend(normalizeMouseEvent(args.originalEvent), args))
                }});
        pointer.mouse = {
            strategy: MouseStrategy,
            map: MouseStrategyEventMap,
            normalize: normalizeMouseEvent
        }
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.pointer.touch.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            device = $.proxy(DX.devices.real, DX.devices),
            events = ui.events,
            pointer = events.pointer;
        var TouchStrategyEventMap = {
                dxpointerdown: "touchstart",
                dxpointermove: "touchmove",
                dxpointerup: "touchend",
                dxpointercancel: "touchcancel"
            };
        var normalizeTouchEvent = function(e) {
                var pointers = [];
                $.each(e.touches, function(_, touch) {
                    pointers.push($.extend({pointerId: touch.identifier}, touch))
                });
                return {
                        pointers: pointers,
                        pointerId: e.changedTouches[0].identifier
                    }
            };
        var skipTouchWithSameIdentifier = function(pointerEvent) {
                return device().platform === "ios" && (pointerEvent === "dxpointerdown" || pointerEvent === "dxpointerup")
            };
        var TouchStrategy = pointer.BaseStrategy.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    this._pointerId = 0
                },
                _handler: function(e) {
                    if (skipTouchWithSameIdentifier(this._eventName)) {
                        var touch = e.changedTouches[0];
                        if (this._pointerId === touch.identifier && this._pointerId !== 0)
                            return;
                        this._pointerId = touch.identifier
                    }
                    return this.callBase.apply(this, arguments)
                },
                _fireEvent: function(args) {
                    return this.callBase($.extend(normalizeTouchEvent(args.originalEvent), args))
                }
            });
        pointer.touch = {
            strategy: TouchStrategy,
            map: TouchStrategyEventMap,
            normalize: normalizeTouchEvent
        }
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.pointer.mouseAndTouch.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            pointer = events.pointer;
        var MouseAndTouchStrategyEventMap = {
                dxpointerdown: "touchstart mousedown",
                dxpointermove: "touchmove mousemove",
                dxpointerup: "touchend mouseup",
                dxpointercancel: "touchcancel",
                dxpointerover: "mouseover",
                dxpointerout: "mouseout",
                dxpointerenter: "mouseenter",
                dxpointerleave: "mouseleave"
            };
        var MouseAndTouchStrategy = pointer.BaseStrategy.inherit({
                EVENT_LOCK_TIMEOUT: 100,
                _handler: function(e) {
                    var isMouseEvent = events.isMouseEvent(e);
                    if (!isMouseEvent)
                        this._skipNextEvents = true;
                    if (isMouseEvent && this._mouseLocked)
                        return;
                    if (isMouseEvent && this._skipNextEvents) {
                        this._skipNextEvents = false;
                        this._mouseLocked = true;
                        clearTimeout(this._unlockMouseTimer);
                        this._unlockMouseTimer = setTimeout($.proxy(function() {
                            this._mouseLocked = false
                        }, this), this.EVENT_LOCK_TIMEOUT);
                        return
                    }
                    return this.callBase(e)
                },
                _fireEvent: function(args) {
                    var isMouseEvent = events.isMouseEvent(args.originalEvent),
                        normalizer = isMouseEvent ? pointer.mouse.normalize : pointer.touch.normalize;
                    return this.callBase($.extend(normalizer(args.originalEvent), args))
                },
                dispose: function() {
                    this.callBase();
                    this._skipNextEvents = false;
                    this._mouseLocked = false;
                    clearTimeout(this._unlockMouseTimer)
                }
            });
        pointer.mouseAndTouch = {
            strategy: MouseAndTouchStrategy,
            map: MouseAndTouchStrategyEventMap
        }
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.pointer.mspointer.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            support = DX.support,
            events = ui.events,
            pointer = events.pointer;
        var MsPointerStrategyEventMap = {
                dxpointerdown: "MSPointerDown pointerdown",
                dxpointermove: "MSPointerMove pointermove",
                dxpointerup: "MSPointerUp pointerup",
                dxpointercancel: "MSPointerCancel pointercancel",
                dxpointerover: "MSPointerOver pointerover",
                dxpointerout: "MSPointerOut pointerout",
                dxpointerenter: "mouseenter pointerenter",
                dxpointerleave: "mouseleave pointerleave"
            };
        var pointers = [];
        var getPointerIndex = function(e) {
                var index = -1;
                $.each(pointers, function(i, pointer) {
                    if (e.pointerId == pointer.pointerId) {
                        index = i;
                        return true
                    }
                });
                return index
            };
        var addPointer = function(e) {
                if (getPointerIndex(e) === -1)
                    pointers.push(e)
            };
        var removePointer = function(e) {
                pointers.splice(getPointerIndex(e), 1)
            };
        var updatePointer = function(e) {
                pointers[getPointerIndex(e)] = e
            };
        var addEventsListner = function(events, handler) {
                events = events.split(" ");
                $.each(events, function(_, event) {
                    document.addEventListener(event, handler, true)
                })
            };
        var activateMspointerStrategy = function() {
                var eventMap = MsPointerStrategyEventMap;
                addEventsListner(eventMap.dxpointerdown, addPointer);
                addEventsListner(eventMap.dxpointermove, updatePointer);
                addEventsListner(eventMap.dxpointerup, removePointer);
                addEventsListner(eventMap.dxpointercancel, removePointer);
                activateMspointerStrategy = $.noop
            };
        var MsPointerStrategy = pointer.BaseStrategy.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    activateMspointerStrategy()
                },
                _fireEvent: function(args) {
                    return this.callBase($.extend({
                            pointers: pointers,
                            pointerId: args.originalEvent.pointerId
                        }, args))
                }
            });
        pointer.msPointer = {
            strategy: MsPointerStrategy,
            map: MsPointerStrategyEventMap
        };
        DX.ui.events.__internals = DX.ui.events.__internals || {};
        $.extend(DX.ui.events.__internals, {cleanMsPointers: function() {
                pointers = []
            }})
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.pointer.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            support = DX.support,
            device = $.proxy(DX.devices.real, DX.devices),
            events = ui.events,
            pointer = events.pointer;
        var eventType = function() {
                if (support.touch && !(device().tablet || device().phone))
                    return pointer.mouseAndTouch;
                if (support.pointer)
                    return pointer.msPointer;
                if (support.touch)
                    return pointer.touch;
                return pointer.mouse
            }();
        $.each(eventType.map, function(pointerEvent, originalEvents) {
            events.registerEvent(pointerEvent, new eventType.strategy(pointerEvent, originalEvents))
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.wheel.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var EVENT_NAME = "dxmousewheel",
            EVENT_NAMESPACE = "dxWheel";
        var WHEEL_DISTANCE = 10;
        $.event.fixHooks["wheel"] = $.event.mouseHooks;
        var wheelEvent = document.onmousewheel !== undefined ? "mousewheel" : "wheel";
        var wheel = {
                setup: function(element, data) {
                    var $element = $(element);
                    $element.on(events.addNamespace(wheelEvent, EVENT_NAMESPACE), $.proxy(wheel._wheelHandler, wheel))
                },
                teardown: function(element) {
                    var $element = $(element);
                    $element.off("." + EVENT_NAMESPACE)
                },
                _wheelHandler: function(e) {
                    var delta = this._getWheelDelta(e.originalEvent);
                    events.fireEvent({
                        type: EVENT_NAME,
                        originalEvent: e,
                        delta: delta
                    });
                    e.stopPropagation()
                },
                _getWheelDelta: function(event) {
                    return event.wheelDelta / 60 || -event.deltaY
                }
            };
        events.registerEvent(EVENT_NAME, wheel)
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.hover.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var HOVERSTART_NAMESPACE = "dxHoverStart",
            HOVERSTART = "dxhoverstart",
            POINTERENTER_NAMESPACED_EVENT_NAME = events.addNamespace("dxpointerenter", HOVERSTART_NAMESPACE),
            HOVEREND_NAMESPACE = "dxHoverEnd",
            HOVEREND = "dxhoverend",
            POINTERLEAVE_NAMESPACED_EVENT_NAME = events.addNamespace("dxpointerleave", HOVEREND_NAMESPACE);
        var Hover = DX.Class.inherit({
                noBubble: true,
                add: function(element, handleObj) {
                    var $element = $(element);
                    $element.off("." + this._namespace).on(this._originalEventName, handleObj.selector, $.proxy(this._handler, this))
                },
                _handler: function(e) {
                    if (events.isTouchEvent(e))
                        return;
                    events.fireEvent({
                        type: this._eventName,
                        originalEvent: e,
                        delegateTarget: e.delegateTarget
                    })
                },
                teardown: function(element) {
                    $(element).off("." + this._namespace)
                }
            });
        var HoverStart = Hover.inherit({ctor: function() {
                    this._eventName = HOVERSTART;
                    this._originalEventName = POINTERENTER_NAMESPACED_EVENT_NAME;
                    this._namespace = HOVERSTART_NAMESPACE
                }});
        var HoverEnd = Hover.inherit({ctor: function() {
                    this._eventName = HOVEREND;
                    this._originalEventName = POINTERLEAVE_NAMESPACED_EVENT_NAME;
                    this._namespace = HOVEREND_NAMESPACE
                }});
        events.registerEvent(HOVERSTART, new HoverStart);
        events.registerEvent(HOVEREND, new HoverEnd)
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.manager.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            utils = DX.utils,
            abs = Math.abs;
        var MANAGER_EVENT = "dxEventManager",
            EMITTER_DATA = "dxEmitter";
        var EventManager = DX.Class.inherit({
                ctor: function() {
                    this._attachHandlers();
                    this.reset()
                },
                _attachHandlers: function() {
                    $(document).on(events.addNamespace("dxpointerdown", MANAGER_EVENT), $.proxy(this._pointerDownHandler, this)).on(events.addNamespace("dxpointermove", MANAGER_EVENT), $.proxy(this._pointerMoveHandler, this)).on(events.addNamespace("dxpointerup dxpointercancel", MANAGER_EVENT), $.proxy(this._pointerUpHandler, this)).on(events.addNamespace("dxmousewheel", MANAGER_EVENT), $.proxy(this._mouseWheelHandler, this))
                },
                _eachEmitter: function(callback) {
                    var activeEmitters = this._activeEmitters || [];
                    var i = 0;
                    while (activeEmitters.length > i) {
                        var emitter = activeEmitters[i];
                        if (callback(emitter) === false)
                            break;
                        if (activeEmitters[i] === emitter)
                            i++
                    }
                },
                _applyToEmitters: function(method) {
                    var args = $.makeArray(arguments).slice(1);
                    this._eachEmitter(function(emitter) {
                        emitter[method].apply(emitter, args)
                    })
                },
                reset: function() {
                    this._eachEmitter($.proxy(this._cancelEmitter, this));
                    this._activeEmitters = []
                },
                _pointerDownHandler: function(e) {
                    if (events.isMouseEvent(e) && e.which > 1)
                        return;
                    this._updateEmitters(e)
                },
                _updateEmitters: function(e) {
                    if (!this._isSetChanged(e))
                        return;
                    this._cleanEmitters(e);
                    this._fetchEmitters(e)
                },
                _isSetChanged: function(e) {
                    var currentSet = this._closestEmitter(e);
                    var previousSet = this._emittersSet || [];
                    var setChanged = currentSet.length !== previousSet.length;
                    $.each(currentSet, function(index, emitter) {
                        setChanged = setChanged || previousSet[index] !== emitter;
                        return !setChanged
                    });
                    this._emittersSet = currentSet;
                    return setChanged
                },
                _closestEmitter: function(e) {
                    var result = [],
                        $element = $(e.target),
                        touchesCount = events.hasTouches(e);
                    while ($element.length) {
                        var emitters = $element.data(EMITTER_DATA) || [];
                        $.each(emitters, $.proxy(function(_, emitter) {
                            if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
                                emitter.addCancelCallback($.proxy(this._cancelHandler, this, emitter));
                                emitter.addAcceptCallback($.proxy(this._acceptHandler, this, emitter));
                                result.push(emitter)
                            }
                        }, this));
                        $element = $element.parent()
                    }
                    return result
                },
                _acceptHandler: function(acceptedEmitter, e) {
                    var that = this;
                    this._eachEmitter(function(emitter) {
                        if (emitter !== acceptedEmitter)
                            that._cancelEmitter(emitter, e)
                    })
                },
                _cancelHandler: function(canceledEmitter, e) {
                    this._cancelEmitter(canceledEmitter, e)
                },
                _cancelEmitter: function(emitter, event) {
                    var activeEmitters = this._activeEmitters;
                    emitter.removeCancelCallback();
                    emitter.removeAcceptCallback();
                    if (event)
                        emitter.cancel(event);
                    activeEmitters.splice($.inArray(emitter, activeEmitters), 1)
                },
                _cleanEmitters: function(e) {
                    this._applyToEmitters("end", e);
                    this.reset(e)
                },
                _fetchEmitters: function(e) {
                    this._activeEmitters = this._emittersSet.slice();
                    this._applyToEmitters("start", e)
                },
                _pointerMoveHandler: function(e) {
                    this._applyToEmitters("move", e)
                },
                _pointerUpHandler: function(e) {
                    this._updateEmitters(e)
                },
                _mouseWheelHandler: function(e) {
                    e.pointers = [null];
                    this._pointerDownHandler(e);
                    this._eachEmitter(function(emitter) {
                        var direction = emitter.getDirection ? emitter.getDirection(e) : "",
                            prop = direction !== "horizontal" ? "pageY" : "pageX";
                        if (direction)
                            e[prop] += e.delta;
                        return !direction
                    });
                    this._pointerMoveHandler(e);
                    e.pointers = [];
                    this._pointerUpHandler(e)
                },
                isActive: function(element) {
                    var result = false;
                    this._eachEmitter(function(emitter) {
                        result = result || emitter.getElement().is(element)
                    });
                    return result
                }
            });
        var EMITTER_SUBSCRIPTION_DATA = "dxEmitterSubscription";
        var eventManager = new EventManager;
        var registerEmitter = function(emitterConfig) {
                var emitterClass = emitterConfig.emitter,
                    emitterName = emitterConfig.events[0],
                    emitterEvents = emitterConfig.events;
                $.each(emitterEvents, function(_, eventName) {
                    events.registerEvent(eventName, {
                        noBubble: !emitterConfig.bubble,
                        setup: function(element, data) {
                            var $element = $(element),
                                subscriptions = $element.data(EMITTER_SUBSCRIPTION_DATA) || {},
                                emitters = $element.data(EMITTER_DATA) || {},
                                emitter = emitters[emitterName] || new emitterClass(element);
                            subscriptions[eventName] = true;
                            emitters[emitterName] = emitter;
                            $element.data(EMITTER_DATA, emitters);
                            $element.data(EMITTER_SUBSCRIPTION_DATA, subscriptions)
                        },
                        add: function(element, handleObj) {
                            var $element = $(element),
                                emitters = $element.data(EMITTER_DATA),
                                emitter = emitters[emitterName];
                            emitter.configurate($.extend({delegateSelector: handleObj.selector}, handleObj.data), handleObj.type)
                        },
                        teardown: function(element) {
                            var $element = $(element),
                                subscriptions = $element.data(EMITTER_SUBSCRIPTION_DATA),
                                emitters = $element.data(EMITTER_DATA),
                                emitter = emitters[emitterName];
                            delete subscriptions[eventName];
                            var disposeEmitter = true;
                            $.each(emitterEvents, function(_, eventName) {
                                disposeEmitter = disposeEmitter && !subscriptions[eventName];
                                return disposeEmitter
                            });
                            if (disposeEmitter) {
                                if (eventManager.isActive(element))
                                    eventManager.reset();
                                emitter && emitter.dispose();
                                delete emitters[emitterName]
                            }
                        }
                    })
                })
            };
        $.extend(events, {registerEmitter: registerEmitter})
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.emitter.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var Emitter = DX.Class.inherit({
                ctor: function(element) {
                    this._$element = $(element);
                    this._cancelCallback = $.Callbacks();
                    this._acceptCallback = $.Callbacks()
                },
                getElement: function() {
                    return this._$element
                },
                validate: function(e) {
                    return e.type !== "dxmousewheel"
                },
                validatePointers: function(e) {
                    return events.hasTouches(e) === 1
                },
                configurate: function(data) {
                    $.extend(this, data)
                },
                addCancelCallback: function(callback) {
                    this._cancelCallback.add(callback)
                },
                removeCancelCallback: function() {
                    this._cancelCallback.empty()
                },
                _cancel: function(e) {
                    this._cancelCallback.fire(e)
                },
                addAcceptCallback: function(callback) {
                    this._acceptCallback.add(callback)
                },
                removeAcceptCallback: function() {
                    this._acceptCallback.empty()
                },
                _accept: function(e) {
                    this._acceptCallback.fire(e)
                },
                start: $.noop,
                move: $.noop,
                end: $.noop,
                cancel: $.noop,
                _fireEvent: function(eventName, e, params) {
                    var eventData = $.extend({
                            type: eventName,
                            originalEvent: e,
                            target: this._getEmitterTarget(e),
                            delegateTarget: this.getElement().get(0)
                        }, params);
                    e = events.fireEvent(eventData);
                    if (e.cancel)
                        this._cancel(e);
                    return e
                },
                _getEmitterTarget: function(e) {
                    return (this.delegateSelector ? $(e.target).closest(this.delegateSelector) : this.getElement()).get(0)
                },
                dispose: $.noop
            });
        $.extend(events, {Emitter: Emitter})
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.emitter.feedback.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            ACTIVE_EVENT_NAME = "dxactive",
            INACTIVE_EVENT_NAME = "dxinactive",
            ACTIVE_TIMEOUT = 30,
            INACTIVE_TIMEOUT = 400;
        var activeEmitter;
        var FeedbackEmitter = events.Emitter.inherit({
                configurate: function(data, eventName) {
                    switch (eventName) {
                        case ACTIVE_EVENT_NAME:
                            data.activeTimeout = data.timeout;
                            break;
                        case INACTIVE_EVENT_NAME:
                            data.inactiveTimeout = data.timeout;
                            break
                    }
                    this.callBase(data)
                },
                start: function(e) {
                    var element = this.getElement().get(0),
                        activeElement = activeEmitter && activeEmitter.getElement().get(0);
                    if ($.contains(element, activeElement))
                        this._cancel(e);
                    else {
                        if (activeEmitter)
                            activeEmitter._forceInctiveTimer();
                        activeEmitter = this;
                        this._startActiveTimer(e)
                    }
                    this._eventTarget = this._getEmitterTarget(e)
                },
                cancel: function(e) {
                    this.end(e)
                },
                end: function(e) {
                    var skipTimers = e.type !== "dxpointerup";
                    if (skipTimers)
                        this._stopActiveTimer();
                    else
                        this._forceActiveTimer();
                    this._startInactiveTimer(e);
                    if (skipTimers)
                        this._forceInctiveTimer()
                },
                _startActiveTimer: function(e) {
                    var activeTimeout = "activeTimeout" in this ? this.activeTimeout : ACTIVE_TIMEOUT;
                    this._forceActiveTimer = $.proxy(this._fireActive, this, e);
                    this._activeTimer = window.setTimeout(this._forceActiveTimer, activeTimeout)
                },
                _fireActive: function(e) {
                    if (this._activeTimer) {
                        this._stopActiveTimer();
                        this._fireEvent(ACTIVE_EVENT_NAME, e, {target: this._eventTarget})
                    }
                },
                _stopActiveTimer: function() {
                    clearTimeout(this._activeTimer);
                    delete this._activeTimer
                },
                _forceActiveTimer: $.noop,
                _startInactiveTimer: function(e) {
                    var inactiveTimeout = "inactiveTimeout" in this ? this.inactiveTimeout : INACTIVE_TIMEOUT;
                    this._forceInctiveTimer = $.proxy(this._fireInctive, this, e);
                    this._inactiveTimer = window.setTimeout(this._forceInctiveTimer, inactiveTimeout)
                },
                _fireInctive: function(e) {
                    if (this._inactiveTimer) {
                        this._stopInactiveTimer();
                        this._fireEvent(INACTIVE_EVENT_NAME, e, {target: this._eventTarget})
                    }
                },
                _stopInactiveTimer: function() {
                    clearTimeout(this._inactiveTimer);
                    delete this._inactiveTimer;
                    activeEmitter = null
                },
                _forceInctiveTimer: $.noop
            });
        events.registerEmitter({
            emitter: FeedbackEmitter,
            events: [ACTIVE_EVENT_NAME, INACTIVE_EVENT_NAME]
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.emitter.click.js */
    (function($, DX, wnd, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            abs = Math.abs,
            CLICK_EVENT_NAME = "dxclick",
            TOUCH_BOUNDARY = 10;
        var isInput = function(element) {
                return $(element).is("input, textarea, select, button, :focus, :focus *")
            };
        var ClickEmitter = events.Emitter.inherit({
                ctor: function(element) {
                    this.callBase(element);
                    this._makeElementClickable($(element))
                },
                _makeElementClickable: function($element) {
                    if (!$element.attr("onclick"))
                        $element.attr("onclick", "void(0)")
                },
                start: function(e) {
                    this._$startTarget = $(e.target);
                    this._startEventData = events.eventData(e)
                },
                end: function(e) {
                    if (this._eventOutOfElement(e, this.getElement().get(0)) || e.type === "dxpointercancel") {
                        this._cancel(e);
                        return
                    }
                    this._accept(e);
                    this._fireClickEvent(e)
                },
                _eventOutOfElement: function(e, element) {
                    var target = e.target,
                        targetChanged = !$.contains(element, target) && element !== target,
                        gestureDelta = events.eventDelta(events.eventData(e), this._startEventData),
                        boundsExceeded = abs(gestureDelta.x) > TOUCH_BOUNDARY || abs(gestureDelta.y) > TOUCH_BOUNDARY;
                    return targetChanged || boundsExceeded
                },
                _fireClickEvent: function(e) {
                    e = this._fireEvent(CLICK_EVENT_NAME, e, {target: this._getClickTarget(this._$startTarget, $(e.target))});
                    if (!isInput(e.target) && !e.dxPreventBlur)
                        utils.resetActiveElement()
                },
                _getClickTarget: function($startTarget, $endTarget) {
                    var $startParents = $startTarget.parents().addBack(),
                        $endParents = $endTarget.parents().addBack(),
                        startingParent = Math.min($startParents.length, $endParents.length) - 1;
                    for (var i = startingParent; i >= 0; i--)
                        if ($startParents.eq(i).is($endParents.eq(i)))
                            return $startParents.get(i)
                }
            });
        (function() {
            var useNativeClick = DX.devices.real().generic;
            if (useNativeClick) {
                var passed = null,
                    prevented = null;
                ClickEmitter = ClickEmitter.inherit({
                    start: function() {
                        passed = null;
                        prevented = null
                    },
                    end: $.noop,
                    _fireClickEvent: function() {
                        passed = true
                    },
                    cancel: function() {
                        prevented = true
                    }
                });
                var clickHandler = function(e) {
                        if ((!e.which || e.which == 1) && (!prevented || passed))
                            events.fireEvent({
                                type: CLICK_EVENT_NAME,
                                originalEvent: e
                            })
                    };
                $(document).on(events.addNamespace("click", "NATIVE_DXCLICK_STRATEGY"), clickHandler)
            }
            $.extend(events.__internals, {useNativeClick: useNativeClick})
        })();
        (function() {
            var fixBuggyInertia = function() {
                    var device = DX.devices.real(),
                        iOS7 = device.platform === "ios" && device.version[0] === 7;
                    return iOS7
                }();
            if (fixBuggyInertia)
                ClickEmitter = ClickEmitter.inherit({_fireClickEvent: function(e) {
                        var $element = $(e.target),
                            callBase = this.callBase,
                            args = arguments;
                        DX.requestAnimationFrame($.proxy(function() {
                            while ($element.length) {
                                if ($element.data("dxGestureLock"))
                                    return;
                                $element = $element.parent()
                            }
                            callBase.apply(this, args)
                        }, this))
                    }});
            $.extend(events.__internals, {fixBuggyInertia: fixBuggyInertia})
        })();
        (function() {
            var startTarget = null;
            var pointerDownHandler = function(e) {
                    startTarget = e.target
                };
            var clickHandler = function(e) {
                    var $target = $(e.target);
                    if (startTarget && !$target.is(startTarget) && !$(startTarget).is("label") && isInput($target))
                        utils.resetActiveElement();
                    startTarget = null
                };
            var NATIVE_CLICK_FIXER_NAMESPACE = "NATIVE_CLICK_FIXER";
            $(document).on(events.addNamespace("dxpointerdown", NATIVE_CLICK_FIXER_NAMESPACE), pointerDownHandler).on(events.addNamespace("click", NATIVE_CLICK_FIXER_NAMESPACE), clickHandler)
        })();
        events.registerEmitter({
            emitter: ClickEmitter,
            bubble: true,
            events: [CLICK_EVENT_NAME]
        });
        $.extend(events.__internals, {useFastClick: !events.__internals.useNativeClick && !events.__internals.fixBuggyInertia})
    })(jQuery, DevExpress, window);
    /*! Module core, file ui.events.emitter.hold.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            abs = Math.abs,
            HOLD_EVENT_NAME = "dxhold",
            HOLD_TIMEOUT = 750,
            TOUCH_BOUNDARY = 5;
        var HoldEmitter = events.Emitter.inherit({
                start: function(e) {
                    this._startEventData = events.eventData(e);
                    this._startTimer(e)
                },
                _startTimer: function(e) {
                    var holdTimeout = "timeout" in this ? this.timeout : HOLD_TIMEOUT;
                    this._holdTimer = setTimeout($.proxy(function() {
                        this._accept(e);
                        events.fireEvent({
                            type: HOLD_EVENT_NAME,
                            originalEvent: e
                        })
                    }, this), holdTimeout)
                },
                move: function(e) {
                    if (this._touchWasMoved(e))
                        this._cancel(e)
                },
                _touchWasMoved: function(e) {
                    var delta = events.eventDelta(this._startEventData, events.eventData(e));
                    return abs(delta.x) > TOUCH_BOUNDARY || abs(delta.y) > TOUCH_BOUNDARY
                },
                end: function() {
                    this._stopTimer()
                },
                _stopTimer: function() {
                    clearTimeout(this._holdTimer)
                },
                cancel: function() {
                    this._stopTimer()
                }
            });
        events.registerEmitter({
            emitter: HoldEmitter,
            bubble: true,
            events: [HOLD_EVENT_NAME]
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.emitter.gesture.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            devices = DX.devices,
            abs = Math.abs;
        var SLEEP = 0,
            INITED = 1,
            STARTED = 2,
            TOUCH_BOUNDARY = 10,
            IMMEDIATE_TOUCH_BOUNDARY = 0,
            IMMEDIATE_TIMEOUT = 180;
        var GestureEmitter = events.Emitter.inherit({
                getDirection: function() {
                    return this.direction
                },
                _cancel: function(e) {
                    this.callBase(e);
                    this._togglePointerEvents(true);
                    this._stage = SLEEP
                },
                start: function(e) {
                    if (events.needSkipEvent(e)) {
                        this._cancel(e);
                        return
                    }
                    this._startEvent = events.createEvent(e);
                    this._startEventData = events.eventData(e);
                    this._prevEventData = this._startEventData;
                    this._stage = INITED;
                    this._init(e);
                    this._setupImmediateTimer()
                },
                _setupImmediateTimer: function() {
                    clearTimeout(this._immediateTimer);
                    this._immedeateAccepted = false;
                    if (!this.immediate)
                        return;
                    this._immediateTimer = setTimeout($.proxy(function() {
                        this._immedeateAccepted = true
                    }, this), IMMEDIATE_TIMEOUT)
                },
                move: function(e) {
                    if (this._stage === INITED && this._directionConfirmed(e)) {
                        this._accept(e);
                        this._resetActiveElement();
                        this._togglePointerEvents(false);
                        this._clearSelection(e);
                        this._stage = STARTED;
                        this._adjustStartEvent(e);
                        this._start(this._startEvent);
                        this._prevEventData = events.eventData(this._startEvent)
                    }
                    if (this._stage === STARTED)
                        this._move(e);
                    this._prevEventData = events.eventData(e)
                },
                _directionConfirmed: function(e) {
                    var touchBoundary = this._getTouchBoundary(e),
                        delta = events.eventDelta(this._startEventData, events.eventData(e)),
                        deltaX = abs(delta.x),
                        deltaY = abs(delta.y);
                    var horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY),
                        verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);
                    var direction = this.getDirection(e),
                        bothAccepted = direction === "both" && (horizontalMove || verticalMove),
                        horizontalAccepted = direction === "horizontal" && horizontalMove,
                        verticalAccepted = direction === "vertical" && verticalMove;
                    return bothAccepted || horizontalAccepted || verticalAccepted || this._immedeateAccepted
                },
                _validateMove: function(touchBoundary, mainAxis, crossAxis) {
                    return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true)
                },
                _getTouchBoundary: function(e) {
                    return this.immediate || e.type === "dxmousewheel" ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY
                },
                _adjustStartEvent: function(e) {
                    var touchBoundary = this._getTouchBoundary(e),
                        delta = events.eventDelta(this._startEventData, events.eventData(e));
                    this._startEvent.pageX += utils.sign(delta.x) * touchBoundary;
                    this._startEvent.pageY += utils.sign(delta.y) * touchBoundary
                },
                _resetActiveElement: function() {
                    if (devices.real().platform === "ios" && $(":focus", this.getElement()).length)
                        utils.resetActiveElement()
                },
                _togglePointerEvents: function(toggle) {
                    if (devices.real().platform === "generic")
                        $("body").css("pointer-events", toggle ? "" : "none")
                },
                _clearSelection: function(e) {
                    if (e.type === "dxmousewheel" || events.isTouchEvent(e))
                        return;
                    utils.clearSelection()
                },
                end: function(e) {
                    this._togglePointerEvents(true);
                    if (this._stage === STARTED)
                        this._end(e);
                    else if (this._stage === INITED)
                        this._stop(e);
                    this._stage = SLEEP
                },
                _init: $.noop,
                _start: $.noop,
                _move: $.noop,
                _stop: $.noop,
                _end: $.noop
            });
        $.extend(events, {GestureEmitter: GestureEmitter});
        var ORIG_TOUCH_BOUNDARY = TOUCH_BOUNDARY;
        $.extend(DX.ui.events.__internals, {
            GESTURE_TOUCH_BOUNDARY: ORIG_TOUCH_BOUNDARY,
            resetTouchBoundary: function() {
                TOUCH_BOUNDARY = ORIG_TOUCH_BOUNDARY;
                events.__internals.GESTURE_TOUCH_BOUNDARY = ORIG_TOUCH_BOUNDARY
            },
            cleanTouchBoundary: function() {
                TOUCH_BOUNDARY = 0
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.emitter.gesture.scroll.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var SCROLL_INIT_EVENT = "dxscrollinit",
            SCROLL_START_EVENT = "dxscrollstart",
            SCROLL_MOVE_EVENT = "dxscroll",
            SCROLL_END_EVENT = "dxscrollend",
            SCROLL_STOP_EVENT = "dxscrollstop",
            SCROLL_CANCEL_EVENT = "dxscrollcancel",
            INERTIA_TIMEOUT = 100,
            VELOCITY_CALC_TIMEOUT = 200,
            FRAME_DURATION = Math.round(1000 / 60),
            GESTURE_LOCK_KEY = "dxGestureLock",
            GESTURE_LOCK_TIMEOUT = 200;
        var ScrollEmitter = events.GestureEmitter.inherit({
                ctor: function(element) {
                    this.callBase(element);
                    this.direction = "both";
                    $(element).on("scroll", $.proxy(this._treatScroll, this))
                },
                _treatScroll: function() {
                    this._prepareGesture();
                    this._forgetGesture()
                },
                _prepareGesture: function() {
                    if (this._gestureEndTimer) {
                        clearTimeout(this._gestureEndTimer);
                        this._gestureEndTimer = null
                    }
                    else
                        this.getElement().data(GESTURE_LOCK_KEY, true)
                },
                _forgetGesture: function() {
                    this._gestureEndTimer = setTimeout($.proxy(function() {
                        this.getElement().data(GESTURE_LOCK_KEY, false);
                        this._gestureEndTimer = null
                    }, this), GESTURE_LOCK_TIMEOUT)
                },
                _init: function(e) {
                    if (this.getElement().data(GESTURE_LOCK_KEY))
                        this._accept(e);
                    this._fireEvent(SCROLL_INIT_EVENT, e)
                },
                move: function(e) {
                    this.callBase.apply(this, arguments);
                    e.isScrollingEvent = this.isNative
                },
                _start: function(e) {
                    this._savedEventData = events.eventData(e);
                    this._fireEvent(SCROLL_START_EVENT, e, {delta: events.eventDelta(this._savedEventData, events.eventData(e))})
                },
                _move: function(e) {
                    var currentEventData = events.eventData(e);
                    this._fireEvent(SCROLL_MOVE_EVENT, e, {delta: events.eventDelta(this._prevEventData, currentEventData)});
                    var eventDelta = events.eventDelta(this._savedEventData, currentEventData);
                    if (eventDelta.time > VELOCITY_CALC_TIMEOUT)
                        this._savedEventData = this._prevEventData
                },
                _end: function(e) {
                    var endEventDelta = events.eventDelta(this._prevEventData, events.eventData(e));
                    var velocity = {
                            x: 0,
                            y: 0
                        };
                    if (endEventDelta.time < INERTIA_TIMEOUT) {
                        var deltaEventData = events.eventDelta(this._savedEventData, this._prevEventData);
                        velocity = {
                            x: deltaEventData.x * FRAME_DURATION / deltaEventData.time,
                            y: deltaEventData.y * FRAME_DURATION / deltaEventData.time
                        }
                    }
                    this._fireEvent(SCROLL_END_EVENT, e, {velocity: velocity})
                },
                _stop: function(e) {
                    this._fireEvent(SCROLL_STOP_EVENT, e)
                },
                cancel: function(e) {
                    this._fireEvent(SCROLL_CANCEL_EVENT, e)
                },
                dispose: function() {
                    this.getElement().off("scroll")
                }
            });
        events.registerEmitter({
            emitter: ScrollEmitter,
            events: [SCROLL_INIT_EVENT, SCROLL_START_EVENT, SCROLL_MOVE_EVENT, SCROLL_END_EVENT, SCROLL_STOP_EVENT, SCROLL_CANCEL_EVENT]
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.emitter.gesture.swipe.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            SWIPE_START_EVENT = "dxswipestart",
            SWIPE_EVENT = "dxswipe",
            SWIPE_END_EVENT = "dxswipeend";
        var HorizontalStrategy = {
                defaultItemSizeFunc: function() {
                    return this.getElement().width()
                },
                getBounds: function() {
                    return [this._maxLeftOffset, this._maxRightOffset]
                },
                calcOffsetRatio: function(e) {
                    var endEventData = events.eventData(e);
                    return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e)
                },
                isFastSwipe: function(e) {
                    var endEventData = events.eventData(e);
                    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time
                }
            };
        var VerticalStrategy = {
                defaultItemSizeFunc: function() {
                    return this.getElement().height()
                },
                getBounds: function() {
                    return [this._maxTopOffset, this._maxBottomOffset]
                },
                calcOffsetRatio: function(e) {
                    var endEventData = events.eventData(e);
                    return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e)
                },
                isFastSwipe: function(e) {
                    var endEventData = events.eventData(e);
                    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time
                }
            };
        var STRATEGIES = {
                horizontal: HorizontalStrategy,
                vertical: VerticalStrategy
            };
        var SwipeEmitter = events.GestureEmitter.inherit({
                TICK_INTERVAL: 300,
                FAST_SWIPE_SPEED_LIMIT: 5,
                ctor: function(element) {
                    this.callBase(element);
                    this.direction = "horizontal";
                    this.elastic = true
                },
                _getStrategy: function() {
                    return STRATEGIES[this.direction]
                },
                _defaultItemSizeFunc: function() {
                    return this._getStrategy().defaultItemSizeFunc.call(this)
                },
                _itemSizeFunc: function() {
                    return this.itemSizeFunc || this._defaultItemSizeFunc
                },
                _start: function(e) {
                    this._savedEventData = events.eventData(e);
                    this._tickData = {time: 0};
                    e = this._fireEvent(SWIPE_START_EVENT, e);
                    if (!e.cancel) {
                        this._maxLeftOffset = e.maxLeftOffset;
                        this._maxRightOffset = e.maxRightOffset;
                        this._maxTopOffset = e.maxTopOffset;
                        this._maxBottomOffset = e.maxBottomOffset
                    }
                },
                _move: function(e) {
                    var strategy = this._getStrategy(),
                        moveEventData = events.eventData(e),
                        offset = strategy.calcOffsetRatio.call(this, e);
                    offset = this._fitOffset(offset, this.elastic);
                    if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL)
                        this._tickData = moveEventData;
                    this._fireEvent(SWIPE_EVENT, e, {offset: offset});
                    e.preventDefault()
                },
                _end: function(e) {
                    var strategy = this._getStrategy(),
                        offsetRatio = strategy.calcOffsetRatio.call(this, e),
                        isFast = strategy.isFastSwipe.call(this, e),
                        startOffset = offsetRatio,
                        targetOffset = this._calcTargetOffset(offsetRatio, isFast);
                    startOffset = this._fitOffset(startOffset, this.elastic);
                    targetOffset = this._fitOffset(targetOffset, false);
                    this._fireEvent(SWIPE_END_EVENT, e, {
                        offset: startOffset,
                        targetOffset: targetOffset
                    })
                },
                _fitOffset: function(offset, elastic) {
                    var strategy = this._getStrategy(),
                        bounds = strategy.getBounds.call(this);
                    if (offset < -bounds[0])
                        return elastic ? (-2 * bounds[0] + offset) / 3 : -bounds[0];
                    if (offset > bounds[1])
                        return elastic ? (2 * bounds[1] + offset) / 3 : bounds[1];
                    return offset
                },
                _calcTargetOffset: function(offsetRatio, isFast) {
                    var result;
                    if (isFast) {
                        result = Math.ceil(Math.abs(offsetRatio));
                        if (offsetRatio < 0)
                            result = -result
                    }
                    else
                        result = Math.round(offsetRatio);
                    return result
                }
            });
        events.registerEmitter({
            emitter: SwipeEmitter,
            events: [SWIPE_START_EVENT, SWIPE_EVENT, SWIPE_END_EVENT]
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.emitter.gesture.drag.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            wrapToArray = utils.wrapToArray;
        var DRAG_START_EVENT = "dxdragstart",
            DRAG_EVENT = "dxdrag",
            DRAG_END_EVENT = "dxdragend",
            DRAG_ENTER_EVENT = "dxdragenter",
            DRAG_LEAVE_EVENT = "dxdragleave",
            DROP_EVENT = "dxdrop";
        var knownDropTargets = [],
            knownDropTargetConfigs = [];
        var dropTargetRegistration = {
                setup: function(element, data) {
                    var knownDropTarget = $.inArray(element, knownDropTargets) !== -1;
                    if (!knownDropTarget) {
                        knownDropTargets.push(element);
                        knownDropTargetConfigs.push(data || {})
                    }
                },
                teardown: function(element, data) {
                    var elementEvents = $._data(element, "events"),
                        handlersCount = 0;
                    $.each([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT], function(_, eventName) {
                        var eventHandlers = elementEvents[eventName];
                        if (eventHandlers)
                            handlersCount += eventHandlers.length
                    });
                    if (!handlersCount) {
                        var index = $.inArray(element, knownDropTargets);
                        knownDropTargets.splice(index, 1);
                        knownDropTargetConfigs.splice(index, 1)
                    }
                }
            };
        events.registerEvent(DRAG_ENTER_EVENT, dropTargetRegistration);
        events.registerEvent(DRAG_LEAVE_EVENT, dropTargetRegistration);
        events.registerEvent(DROP_EVENT, dropTargetRegistration);
        var getItemConfig = function($element) {
                var dropTargetIndex = $.inArray($element.get(0), knownDropTargets);
                return knownDropTargetConfigs[dropTargetIndex]
            };
        var getItemPosition = function($element) {
                var dropTargetConfig = getItemConfig($element);
                if (dropTargetConfig.itemPositionFunc)
                    return dropTargetConfig.itemPositionFunc();
                else
                    return $element.offset()
            };
        var getItemSize = function($element) {
                var dropTargetConfig = getItemConfig($element);
                if (dropTargetConfig.itemSizeFunc)
                    return dropTargetConfig.itemSizeFunc();
                else
                    return {
                            width: $element.width(),
                            height: $element.height()
                        }
            };
        var DragEmitter = events.GestureEmitter.inherit({
                ctor: function(element) {
                    this.callBase(element);
                    this.direction = "both"
                },
                _init: function(e) {
                    this._initEvent = e
                },
                _start: function(e) {
                    e = this._fireEvent(DRAG_START_EVENT, this._initEvent);
                    this._maxLeftOffset = e.maxLeftOffset;
                    this._maxRightOffset = e.maxRightOffset;
                    this._maxTopOffset = e.maxTopOffset;
                    this._maxBottomOffset = e.maxBottomOffset;
                    var dropTargets = wrapToArray(e.targetElements || knownDropTargets);
                    this._$dropTargetElements = $.map(dropTargets, function(element) {
                        return $(element)
                    })
                },
                _move: function(e) {
                    var eventData = events.eventData(e),
                        dragOffset = this._calculateOffset(eventData);
                    this._fireEvent(DRAG_EVENT, e, {offset: dragOffset});
                    this._processDropTargets(e, dragOffset);
                    e.preventDefault()
                },
                _calculateOffset: function(eventData) {
                    return {
                            x: this._calculateXOffset(eventData),
                            y: this._calculateYOffset(eventData)
                        }
                },
                _calculateXOffset: function(eventData) {
                    if (this.direction !== "vertical") {
                        var offset = eventData.x - this._startEventData.x;
                        return this._fitOffset(offset, this._maxLeftOffset, this._maxRightOffset)
                    }
                    return 0
                },
                _calculateYOffset: function(eventData) {
                    if (this.direction !== "horizontal") {
                        var offset = eventData.y - this._startEventData.y;
                        return this._fitOffset(offset, this._maxTopOffset, this._maxBottomOffset)
                    }
                    return 0
                },
                _fitOffset: function(offset, minOffset, maxOffset) {
                    if (minOffset != null)
                        offset = Math.max(offset, -minOffset);
                    if (maxOffset != null)
                        offset = Math.min(offset, maxOffset);
                    return offset
                },
                _processDropTargets: function(e, dragOffset) {
                    var target = this._findDropTarget(e),
                        sameTarget = target === this._$currentDropTarget;
                    if (!sameTarget) {
                        this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);
                        this._$currentDropTarget = target;
                        this._fireDropTargetEvent(e, DRAG_ENTER_EVENT)
                    }
                },
                _fireDropTargetEvent: function(event, eventName) {
                    if (!this._$currentDropTarget)
                        return;
                    var eventData = {
                            type: eventName,
                            originalEvent: event,
                            draggingElement: this._$element.get(0),
                            target: this._$currentDropTarget.get(0)
                        };
                    events.fireEvent(eventData)
                },
                _findDropTarget: function(e) {
                    var that = this,
                        $result;
                    $.each(this._$dropTargetElements, function(_, $target) {
                        if (that._checkDropTarget($target, e)) {
                            $result = $target;
                            return false
                        }
                    });
                    return $result
                },
                _checkDropTarget: function($target, e) {
                    var isDraggingElement = $target.get(0) === this._$element.get(0);
                    if (isDraggingElement)
                        return false;
                    var targetPosition = getItemPosition($target);
                    if (e.pageX < targetPosition.left)
                        return false;
                    if (e.pageY < targetPosition.top)
                        return false;
                    var targetSize = getItemSize($target);
                    if (e.pageX > targetPosition.left + targetSize.width)
                        return false;
                    if (e.pageY > targetPosition.top + targetSize.height)
                        return false;
                    return $target
                },
                _end: function(e) {
                    var eventData = events.eventData(e);
                    this._fireEvent(DRAG_END_EVENT, e, {offset: this._calculateOffset(eventData)});
                    this._fireDropTargetEvent(e, DROP_EVENT);
                    delete this._$currentDropTarget
                }
            });
        events.registerEmitter({
            emitter: DragEmitter,
            events: [DRAG_START_EVENT, DRAG_EVENT, DRAG_END_EVENT]
        });
        DX.ui.events.__internals = DX.ui.events.__internals || {};
        $.extend(DX.ui.events.__internals, {dropTargets: knownDropTargets})
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.emitter.transform.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            fitIntoRange = utils.fitIntoRange;
        var DX_PREFIX = "dx",
            TRANSFORM = "transform",
            TRANSLATE = "translate",
            ZOOM = "zoom",
            ROTATE = "rotate",
            START_POSTFIX = "start",
            UPDATE_POSTFIX = "",
            END_POSTFIX = "end";
        var eventAliases = [];
        var addAlias = function(eventName, eventArgs) {
                eventAliases.push({
                    name: eventName,
                    args: eventArgs
                })
            };
        addAlias(TRANSFORM, {
            scale: true,
            deltaScale: true,
            rotation: true,
            deltaRotation: true,
            translation: true,
            deltaTranslation: true
        });
        addAlias(TRANSLATE, {
            translation: true,
            deltaTranslation: true
        });
        addAlias(ZOOM, {
            scale: true,
            deltaScale: true
        });
        addAlias(ROTATE, {
            rotation: true,
            deltaRotation: true
        });
        var getVector = function(first, second) {
                return {
                        x: second.pageX - first.pageX,
                        y: -second.pageY + first.pageY,
                        centerX: (second.pageX + first.pageX) * 0.5,
                        centerY: (second.pageY + first.pageY) * 0.5
                    }
            };
        var getEventVector = function(e) {
                var pointers = e.pointers;
                return getVector(pointers[0], pointers[1])
            };
        var getDistance = function(vector) {
                return Math.sqrt(vector.x * vector.x + vector.y * vector.y)
            };
        var getScale = function(firstVector, secondVector) {
                return getDistance(firstVector) / getDistance(secondVector)
            };
        var getRotation = function(firstVector, secondVector) {
                var scalarProduct = firstVector.x * secondVector.x + firstVector.y * secondVector.y;
                var distanceProduct = getDistance(firstVector) * getDistance(secondVector);
                if (distanceProduct === 0)
                    return 0;
                var sign = utils.sign(firstVector.x * secondVector.y - secondVector.x * firstVector.y);
                var angle = Math.acos(fitIntoRange(scalarProduct / distanceProduct, -1, 1));
                return sign * angle
            };
        var getTranslation = function(firstVector, secondVector) {
                return {
                        x: firstVector.centerX - secondVector.centerX,
                        y: firstVector.centerY - secondVector.centerY
                    }
            };
        var TransformEmitter = events.Emitter.inherit({
                ctor: function(element) {
                    this.callBase(element)
                },
                validatePointers: function(e) {
                    return events.hasTouches(e) > 1
                },
                start: function(e) {
                    this._accept();
                    var startVector = getEventVector(e);
                    this._startVector = startVector;
                    this._prevVector = startVector;
                    this._fireEventAliases(START_POSTFIX, e)
                },
                move: function(e) {
                    var currentVector = getEventVector(e),
                        eventArgs = this._getEventArgs(currentVector);
                    this._fireEventAliases(UPDATE_POSTFIX, e, eventArgs);
                    this._prevVector = currentVector
                },
                end: function(e) {
                    var eventArgs = this._getEventArgs(this._prevVector);
                    this._fireEventAliases(END_POSTFIX, e, eventArgs)
                },
                _getEventArgs: function(vector) {
                    return {
                            scale: getScale(vector, this._startVector),
                            deltaScale: getScale(vector, this._prevVector),
                            rotation: getRotation(vector, this._startVector),
                            deltaRotation: getRotation(vector, this._prevVector),
                            translation: getTranslation(vector, this._startVector),
                            deltaTranslation: getTranslation(vector, this._prevVector)
                        }
                },
                _fireEventAliases: function(eventPostfix, originalEvent, eventArgs) {
                    eventArgs = eventArgs || {};
                    $.each(eventAliases, $.proxy(function(_, eventAlias) {
                        var args = {};
                        $.each(eventAlias.args, function(name) {
                            if (name in eventArgs)
                                args[name] = eventArgs[name]
                        });
                        this._fireEvent(DX_PREFIX + eventAlias.name + eventPostfix, originalEvent, args)
                    }, this))
                }
            });
        events.registerEmitter({
            emitter: TransformEmitter,
            events: $.map(eventAliases, function(eventAlias) {
                var eventNames = [];
                $.each([START_POSTFIX, UPDATE_POSTFIX, END_POSTFIX], function(_, eventPostfix) {
                    eventNames.push(DX_PREFIX + eventAlias.name + eventPostfix)
                });
                return eventNames
            })
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.contextmenu.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            support = DX.support,
            CONTEXTMENU_NAMESPACE = "dxContexMenu",
            CONTEXTMENU_NAMESPACED_EVENT_NAME = events.addNamespace("contextmenu", CONTEXTMENU_NAMESPACE),
            HOLD_NAMESPACED_EVENT_NAME = events.addNamespace("dxhold", CONTEXTMENU_NAMESPACE),
            CONTEXTMENU_EVENT_NAME = "dxcontextmenu";
        var ContextMenu = DX.Class.inherit({
                setup: function(element, data) {
                    var $element = $(element);
                    $element.on(CONTEXTMENU_NAMESPACED_EVENT_NAME, $.proxy(this._contextMenuHandler, this));
                    if (support.touch || DX.devices.isSimulator())
                        $element.on(HOLD_NAMESPACED_EVENT_NAME, $.proxy(this._holdHandler, this))
                },
                _holdHandler: function(e) {
                    if (events.isMouseEvent(e) && !DX.devices.isSimulator())
                        return;
                    this._fireContextMenu(e)
                },
                _contextMenuHandler: function(e) {
                    e.preventDefault();
                    this._fireContextMenu(e)
                },
                _fireContextMenu: function(e) {
                    events.fireEvent({
                        type: CONTEXTMENU_EVENT_NAME,
                        originalEvent: e
                    })
                },
                teardown: function(element) {
                    $(element).off("." + CONTEXTMENU_NAMESPACE)
                }
            });
        events.registerEvent(CONTEXTMENU_EVENT_NAME, new ContextMenu)
    })(jQuery, DevExpress);
    /*! Module core, file ui.widget.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            UI_FEEDBACK = "UIFeedback",
            WIDGET_CLASS = "dx-widget",
            ACTIVE_STATE_CLASS = "dx-state-active",
            DISABLED_STATE_CLASS = "dx-state-disabled",
            INVISIBLE_STATE_CLASS = "dx-state-invisible",
            HOVER_STATE_CLASS = "dx-state-hover",
            FOCUSED_STATE_CLASS = "dx-state-focused",
            FEEDBACK_SHOW_TIMEOUT = 30,
            FEEDBACK_HIDE_TIMEOUT = 400,
            HOVER_START = "dxhoverstart",
            HOVER_END = "dxhoverend",
            ANONYMOUS_TEMPLATE_NAME = "template",
            TEMPLATE_SELECTOR = "[data-options*='dxTemplate']",
            TEMPLATES_DATA_KEY = "dxTemplates";
        var DynamicTemplate = ui.TemplateBase.inherit({
                ctor: function(compile, owner) {
                    this.callBase($("<div>"), owner);
                    this._compile = compile
                },
                _renderCore: function(data, index, container) {
                    if (data === undefined && index === undefined) {
                        data = container;
                        container = undefined
                    }
                    var compiled = index == undefined ? this._compile(data, container) : this._compile(data, index, container);
                    return compiled.render(data, container, index)
                },
                _shouldAppend: false
            });
        var EmptyTemplate = ui.TemplateBase.inherit({
                ctor: function() {
                    this.callBase($("<div>"))
                },
                _renderCore: function(data, index, container) {
                    return $()
                }
            });
        ui.Widget = DX.DOMComponent.inherit({
            NAME: "Widget",
            _supportedKeys: function() {
                return {}
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {contentReadyAction: {
                        since: "14.2",
                        alias: "onContentReady"
                    }})
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    disabled: false,
                    visible: true,
                    hint: undefined,
                    activeStateEnabled: false,
                    width: undefined,
                    height: undefined,
                    onContentReady: null,
                    hoverStateEnabled: false,
                    focusStateEnabled: false,
                    tabIndex: 0,
                    _keyboardProcessor: undefined,
                    _focusEventPropagation: false
                })
            },
            _init: function() {
                this.callBase();
                this._feedbackShowTimeout = FEEDBACK_SHOW_TIMEOUT;
                this._feedbackHideTimeout = FEEDBACK_HIDE_TIMEOUT;
                if (this._templatesSupported()) {
                    this._initTemplates();
                    this._dynamicTemplates = {};
                    this._initContentReadyAction()
                }
            },
            _eventBindingTarget: function() {
                return this.element()
            },
            _templatesSupported: function() {
                return this._renderContentImpl !== DX.abstract
            },
            _initTemplates: function() {
                var templates = {},
                    dataTemplateElements = this.element().data(TEMPLATES_DATA_KEY),
                    templateElements = dataTemplateElements || this.element().contents().filter(TEMPLATE_SELECTOR);
                this._templateProvider = this.option("templateProvider") || new ui.TemplateProvider;
                if (templateElements.length) {
                    var templatesMap = {};
                    templateElements.each(function() {
                        var templateOptions = utils.getElementOptions(this).dxTemplate;
                        if (!templateOptions)
                            return;
                        if (!templateOptions.name)
                            throw DX.Error("E0023");
                        templatesMap[templateOptions.name] = templatesMap[templateOptions.name] || [];
                        templatesMap[templateOptions.name].push(this)
                    });
                    $.each(templatesMap, $.proxy(function(templateName, value) {
                        var deviceTemplate = this._findTemplateByDevice(value);
                        if (deviceTemplate)
                            templates[templateName] = this._createTemplate(deviceTemplate)
                    }, this))
                }
                else
                    templates[this._getAnonimousTemplateName()] = this._createTemplate(this.element().contents());
                this.option("_templates", templates)
            },
            _getAnonimousTemplateName: function() {
                return ANONYMOUS_TEMPLATE_NAME
            },
            _getTemplateByOption: function(optionName) {
                return this._getTemplate(this.option(optionName))
            },
            _getTemplate: function(templateSource) {
                if ($.isFunction(templateSource))
                    return new DynamicTemplate($.proxy(function() {
                            var templateSourceResult = templateSource.apply(this, arguments);
                            if (utils.isDefined(templateSourceResult))
                                return this._acquireTemplate(templateSourceResult);
                            else
                                return new EmptyTemplate
                        }, this));
                return this._acquireTemplate(templateSource)
            },
            _acquireTemplate: function(templateSource) {
                if (templateSource == null)
                    return this._createTemplate(utils.stringToJquery(templateSource));
                if (templateSource instanceof ui.TemplateBase)
                    return templateSource;
                if (templateSource.nodeType || templateSource.jquery) {
                    templateSource = $(templateSource);
                    return this._createTemplate(templateSource)
                }
                if (typeof templateSource === "string") {
                    var userTemplate = this.option("_templates")[templateSource];
                    if (userTemplate)
                        return userTemplate;
                    var dynamicTemplate = this._dynamicTemplates[templateSource];
                    if (dynamicTemplate)
                        return dynamicTemplate;
                    var defaultTemplate = this._templateProvider.getTemplates(this)[templateSource];
                    if (defaultTemplate)
                        return defaultTemplate;
                    return this._createTemplate(utils.stringToJquery(templateSource))
                }
                return this._acquireTemplate(templateSource.toString())
            },
            _createTemplate: function(element) {
                return this._templateProvider.createTemplate(element, this)
            },
            _findTemplateByDevice: function(templates) {
                var suitableTemplate = DX.utils.findBestMatches(DX.devices.current(), templates, function(template) {
                        return utils.getElementOptions(template).dxTemplate
                    })[0];
                $.each(templates, function(index, template) {
                    if (template !== suitableTemplate)
                        $(template).remove()
                });
                return suitableTemplate
            },
            _cleanTemplates: function() {
                var that = this;
                $.each(this.option("_templates"), function(templateName, template) {
                    if (that === template.owner())
                        template.dispose()
                })
            },
            _initContentReadyAction: function() {
                this._contentReadyAction = this._createActionByOption("onContentReady", {excludeValidators: ["designMode", "disabled"]})
            },
            _render: function() {
                this.callBase();
                this.element().addClass(WIDGET_CLASS);
                this._toggleDisabledState(this.option("disabled"));
                this._toggleVisibility(this.option("visible"));
                this._renderHint();
                this._renderDimensions();
                if (this._templatesSupported())
                    this._renderContent();
                this._renderFocusState();
                this._attachFeedbackEvents();
                this._attachHoverEvents()
            },
            _renderHint: function() {
                if (this.option("hint"))
                    this.element().attr("title", this.option("hint"));
                else
                    this.element().removeAttr("title")
            },
            _renderContent: function() {
                this._renderContentImpl();
                this._fireContentReadyAction()
            },
            _renderContentImpl: DX.abstract,
            _fireContentReadyAction: function() {
                this._contentReadyAction({excludeValidators: ["disabled"]})
            },
            _dispose: function() {
                if (this._templatesSupported())
                    this._cleanTemplates();
                this._contentReadyAction = null;
                this.callBase()
            },
            _clean: function() {
                this._cleanFocusState();
                this.callBase();
                this.element().empty()
            },
            _toggleVisibility: function(visible) {
                this.element().toggleClass(INVISIBLE_STATE_CLASS, !visible)
            },
            _renderFocusState: function() {
                if (!this.option("focusStateEnabled") || this.option("disabled"))
                    return;
                this._renderFocusTarget();
                this._attachFocusEvents();
                this._attachKeyboardEvents()
            },
            _focusTarget: function() {
                return this._getActiveElement()
            },
            _getActiveElement: function() {
                var activeElement = this._eventBindingTarget();
                if (this._activeStateUnit)
                    activeElement = activeElement.find(this._activeStateUnit).not("." + DISABLED_STATE_CLASS);
                return activeElement
            },
            _renderFocusTarget: function() {
                this._focusTarget().attr("tabindex", this.option("tabIndex"))
            },
            _attachFocusEvents: function() {
                var $element = this._focusTarget(),
                    that = this;
                var focusAction = new DX.Action(function(args) {
                        var value = args.value;
                        var event = args.event;
                        value ? that._focusInHandler(event) : that._focusOutHandler(event)
                    });
                $element.on("focusin", function(e) {
                    focusAction.execute({
                        element: $(e.target),
                        event: e,
                        value: true
                    })
                }).on("focusout", function(e) {
                    focusAction.execute({
                        element: $(e.target),
                        event: e,
                        value: false
                    })
                })
            },
            _focusInHandler: function(e) {
                if (!this.option("_focusEventPropagation"))
                    e.stopPropagation();
                $(e.currentTarget).addClass(FOCUSED_STATE_CLASS)
            },
            _focusOutHandler: function(e) {
                if (!this.option("_focusEventPropagation"))
                    e.stopPropagation();
                $(e.currentTarget).removeClass(FOCUSED_STATE_CLASS)
            },
            _attachKeyboardEvents: function() {
                var processor = this.option("_keyboardProcessor") || new ui.KeyboardProcessor({element: this._eventBindingTarget()});
                this._keyboardProcessor = processor.reinitialize(this._keyboardHandler, this)
            },
            _keyboardHandler: function(options) {
                var e = options.originalEvent,
                    key = options.key;
                var keys = this._supportedKeys(),
                    func = keys[key];
                if (func !== undefined) {
                    var handler = $.proxy(func, this);
                    return handler(e) || false
                }
                else
                    return true
            },
            _refreshFocusState: function() {
                this._cleanFocusState();
                this._renderFocusState()
            },
            _cleanFocusState: function() {
                var $element = this._focusTarget();
                $element.off("focusin").off("focusout");
                $element.removeClass(FOCUSED_STATE_CLASS);
                $element.removeAttr("tabindex");
                if (this._keyboardProcessor)
                    this._keyboardProcessor.dispose()
            },
            _attachHoverEvents: function() {
                var that = this,
                    hoverableSelector = that._activeStateUnit,
                    nameStart = events.addNamespace(HOVER_START, UI_FEEDBACK),
                    nameEnd = events.addNamespace(HOVER_END, UI_FEEDBACK);
                that._eventBindingTarget().off(nameStart, hoverableSelector).off(nameEnd, hoverableSelector);
                if (that.option("hoverStateEnabled")) {
                    var startAction = new DX.Action(function(args) {
                            var $target = args.element;
                            that._refreshHoveredElement($target)
                        });
                    that._eventBindingTarget().on(nameStart, hoverableSelector, function(e) {
                        startAction.execute({element: $(e.target)})
                    }).on(nameEnd, hoverableSelector, function(e) {
                        that._forgetHoveredElement()
                    })
                }
                else
                    that._toggleHoverClass(false)
            },
            _attachFeedbackEvents: function() {
                var that = this,
                    feedbackSelector = that._activeStateUnit,
                    activeEventName = events.addNamespace("dxactive", UI_FEEDBACK),
                    inactiveEventName = events.addNamespace("dxinactive", UI_FEEDBACK);
                that._eventBindingTarget().off(activeEventName, feedbackSelector).off(inactiveEventName, feedbackSelector);
                if (that.option("activeStateEnabled")) {
                    var feedbackActionHandler = function(args) {
                            var $element = args.element,
                                value = args.value;
                            that._toggleActiveState($element, value)
                        };
                    var feedbackAction = new DX.Action(function(args) {
                            feedbackActionHandler(args)
                        }),
                        feedbackActionDisabled = new DX.Action(function(args) {
                            feedbackActionHandler(args)
                        }, {excludeValidators: ["disabled"]});
                    that._eventBindingTarget().on(activeEventName, feedbackSelector, {timeout: that._feedbackShowTimeout}, function(e) {
                        feedbackAction.execute({
                            element: $(e.currentTarget),
                            value: true
                        })
                    }).on(inactiveEventName, feedbackSelector, {timeout: that._feedbackHideTimeout}, function(e) {
                        feedbackActionDisabled.execute({
                            element: $(e.currentTarget),
                            value: false
                        })
                    })
                }
            },
            _toggleActiveState: function($element, value) {
                this._toggleHoverClass(!value);
                $element.toggleClass(ACTIVE_STATE_CLASS, value)
            },
            _refreshHoveredElement: function(hoveredElement) {
                var selector = this._activeStateUnit || this.element();
                this._forgetHoveredElement();
                this._hoveredElement = hoveredElement.closest(selector);
                this._toggleHoverClass(true)
            },
            _forgetHoveredElement: function() {
                this._toggleHoverClass(false);
                delete this._hoveredElement
            },
            _toggleHoverClass: function(value) {
                if (this._hoveredElement)
                    this._hoveredElement.toggleClass(HOVER_STATE_CLASS, value && this.option("hoverStateEnabled"))
            },
            _renderDimensions: function() {
                var width = this.option("width"),
                    height = this.option("height"),
                    $element = this.element();
                $element.outerWidth(width);
                $element.outerHeight(height)
            },
            _toggleDisabledState: function(value) {
                this.element().toggleClass(DISABLED_STATE_CLASS, Boolean(value));
                this._toggleHoverClass(!value)
            },
            _setWidgetOption: function(widgetName, args) {
                if (!this[widgetName])
                    return;
                if ($.isPlainObject(args[0])) {
                    $.each(args[0], $.proxy(function(option, value) {
                        this._setWidgetOption(widgetName, [option, value])
                    }, this));
                    return
                }
                var optionName = args[0];
                var value = args[1];
                if (args.length === 1)
                    value = this.option(optionName);
                var widgetOptionMap = this[widgetName + "OptionMap"];
                this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"disabled":
                        this._toggleDisabledState(args.value);
                        this._attachFeedbackEvents();
                        this._refreshFocusState();
                        break;
                    case"hint":
                        this._renderHint();
                        break;
                    case"activeStateEnabled":
                        this._attachFeedbackEvents();
                        break;
                    case"hoverStateEnabled":
                        this._attachHoverEvents();
                        break;
                    case"tabIndex":
                    case"_keyboardProcessor":
                    case"focusStateEnabled":
                        this._refreshFocusState();
                        break;
                    case"visible":
                        this._toggleVisibility(args.value);
                        break;
                    case"width":
                    case"height":
                        this._renderDimensions();
                        break;
                    case"onContentReady":
                        this._initContentReadyAction();
                        break;
                    case"_templates":
                        this._refresh();
                        break;
                    case"_focusEventPropagation":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            repaint: function() {
                this._refresh()
            },
            focus: function() {
                this._focusTarget().focus()
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.editor.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            READONLY_STATE_CLASS = "dx-state-readonly",
            INVALID_CLASS = "dx-invalid",
            INVALID_MESSAGE = "dx-invalid-message",
            INVALID_MESSAGE_AUTO = "dx-invalid-message-auto",
            INVALID_MESSAGE_ALWAYS = "dx-invalid-message-always";
        ui.validation = ui.validation || {};
        ui.validation.findGroup = function() {
            var group = this.option("validationGroup"),
                $dxGroup;
            if (!group) {
                $dxGroup = this.element().parents(".dx-validation-group:first");
                if ($dxGroup.length)
                    group = $dxGroup.dxValidationGroup("instance");
                else
                    group = this._modelByElement(this.element())
            }
            return group
        };
        ui.Editor = ui.Widget.inherit({
            _init: function() {
                this.callBase();
                this.validationRequest = $.Callbacks();
                var $element = this.element();
                if ($element) {
                    $element.data("dx-validation-target", this);
                    this.on("disposing", function() {
                        $element.data("dx-validation-target", null)
                    })
                }
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {valueChangeAction: {
                        since: "14.2",
                        alias: "onValueChanged"
                    }})
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    value: undefined,
                    onValueChanged: null,
                    activeStateEnabled: true,
                    readOnly: false,
                    isValid: true,
                    validationError: undefined,
                    validationMessageMode: "auto",
                    validationTooltipOffset: {
                        h: 9,
                        v: -1
                    }
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return device.platform === "android" && device.version[0] > 4
                            },
                            options: {invalidTooltipOffset: {
                                    h: 9,
                                    v: -7
                                }}
                        }, {
                            device: {platform: "win8"},
                            options: {invalidTooltipOffset: {
                                    h: 9,
                                    v: -4
                                }}
                        }])
            },
            _createValueChangeAction: function() {
                this._valueChangeAction = this._createActionByOption("onValueChanged")
            },
            _suppressValueChangeAction: function() {
                this._valueChangeActionSuppressed = true
            },
            _resumeValueChangeAction: function() {
                this._valueChangeActionSuppressed = false
            },
            _render: function() {
                this._createValueChangeAction();
                this._renderValidationState();
                this._toggleReadOnlyState();
                this.callBase()
            },
            _raiseValueChangeAction: function(value, previousValue, extraArguments) {
                this._valueChangeAction(this._valueChangeArgs(value, previousValue))
            },
            _valueChangeArgs: function(value, previousValue) {
                return {
                        value: value,
                        previousValue: previousValue,
                        jQueryEvent: this._valueChangeEventInstance
                    }
            },
            _renderValidationState: function() {
                var isValid = this.option("isValid"),
                    validationError = this.option("validationError"),
                    validationMessageMode = this.option("validationMessageMode"),
                    $element = this.element();
                $element.toggleClass(INVALID_CLASS, !isValid);
                if (this._$validationMessage) {
                    this._$validationMessage.remove();
                    this._$validationMessage = null
                }
                if (!isValid && validationError) {
                    this._$validationMessage = $("<div/>", {"class": INVALID_MESSAGE}).text(validationError.message).appendTo($element).dxTooltip({
                        target: $element,
                        container: $element,
                        position: this._getValidationTooltipPosition("below"),
                        closeOnOutsideClick: false,
                        closeOnTargetScroll: false,
                        animation: null,
                        visible: true,
                        rtlEnabled: this.option("rtlEnabled")
                    });
                    this._$validationMessage.toggleClass(INVALID_MESSAGE_AUTO, validationMessageMode === "auto").toggleClass(INVALID_MESSAGE_ALWAYS, validationMessageMode === "always")
                }
            },
            _getValidationTooltipPosition: function(positionRequest) {
                var rtlEnabled = this.option("rtlEnabled"),
                    tooltipPositionSide = rtlEnabled ? "right" : "left",
                    tooltipOriginalOffset = this.option("validationTooltipOffset"),
                    tooltipOffset = {
                        h: tooltipOriginalOffset.h,
                        v: tooltipOriginalOffset.v
                    },
                    verticalPositions = positionRequest === "below" ? [" top", " bottom"] : [" bottom", " top"];
                if (rtlEnabled)
                    tooltipOffset.h = -tooltipOffset.h;
                if (positionRequest !== "below")
                    tooltipOffset.v = -tooltipOffset.v;
                return {
                        offset: tooltipOffset,
                        my: tooltipPositionSide + verticalPositions[0],
                        at: tooltipPositionSide + verticalPositions[1]
                    }
            },
            _toggleReadOnlyState: function() {
                this.element().toggleClass(READONLY_STATE_CLASS, this.option("readOnly"))
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"onValueChanged":
                        this._createValueChangeAction();
                        break;
                    case"isValid":
                    case"validationError":
                    case"validationMessageMode":
                        this._renderValidationState();
                        break;
                    case"readOnly":
                        this._toggleReadOnlyState();
                        break;
                    case"value":
                        if (!this._valueChangeActionSuppressed)
                            this._raiseValueChangeAction(args.value, args.previousValue);
                        this._valueChangeEventInstance = undefined;
                        if (this.validationRequest)
                            this.validationRequest.fire({
                                value: args.value,
                                editor: this
                            });
                        break;
                    default:
                        this.callBase(args)
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.CollectionWidget.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events;
        var COLLECTION_CLASS = "dx-collection",
            ITEM_CLASS = "dx-item",
            CONTENT_CLASS_POSTFIX = "-content",
            ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder",
            ITEM_DATA_KEY = "dxItemData",
            ITEM_TEMPLATE_ID_PREFIX = "tmpl-",
            ITEMS_SELECTOR = "[data-options*='dxItem']",
            SELECTED_ITEM_CLASS = "dx-item-selected",
            FOCUSED_STATE_CLASS = "dx-state-focused",
            ITEM_RESPONSE_WAIT_CLASS = "dx-item-response-wait",
            EMPTY_COLLECTION = "dx-empty-collection";
        var FOCUS_UP = "up",
            FOCUS_DOWN = "down",
            FOCUS_LEFT = "left",
            FOCUS_RIGHT = "right",
            FOCUS_PAGE_UP = "pageup",
            FOCUS_PAGE_DOWN = "pagedown",
            FOCUS_LAST = "last",
            FOCUS_FIRST = "first";
        var CollectionWidget = ui.Widget.inherit({
                NAME: "CollectionWidget",
                _activeStateUnit: "." + ITEM_CLASS,
                _supportedKeys: function() {
                    var click = function(e) {
                            var $itemElement = this._$focusedItem;
                            if (!$itemElement)
                                return;
                            e.target = $itemElement;
                            e.currentTarget = $itemElement;
                            this._itemClickHandler(e)
                        },
                        move = function(location, e) {
                            e.preventDefault();
                            e.stopPropagation();
                            this._moveFocus(location)
                        };
                    return $.extend(this.callBase(), {
                            space: click,
                            enter: click,
                            leftArrow: $.proxy(move, this, FOCUS_LEFT),
                            rightArrow: $.proxy(move, this, FOCUS_RIGHT),
                            upArrow: $.proxy(move, this, FOCUS_UP),
                            downArrow: $.proxy(move, this, FOCUS_DOWN),
                            pageUp: $.proxy(move, this, FOCUS_UP),
                            pageDown: $.proxy(move, this, FOCUS_DOWN),
                            home: $.proxy(move, this, FOCUS_FIRST),
                            end: $.proxy(move, this, FOCUS_LAST)
                        })
                },
                _setDeprecatedOptions: function() {
                    this.callBase();
                    $.extend(this._deprecatedOptions, {
                        itemClickAction: {
                            since: "14.2",
                            alias: "onItemClick"
                        },
                        itemHoldAction: {
                            since: "14.2",
                            alias: "onItemHold"
                        },
                        itemRenderedAction: {
                            since: "14.2",
                            alias: "onItemRendered"
                        },
                        itemRender: {
                            since: "14.2",
                            alias: "itemTemplate"
                        }
                    })
                },
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        selectOnFocus: false,
                        loopItemFocus: true,
                        items: [],
                        itemTemplate: "item",
                        onItemRendered: null,
                        onItemClick: null,
                        onItemHold: null,
                        itemHoldTimeout: 750,
                        onItemContextMenu: null,
                        noDataText: Globalize.localize("dxCollectionWidget-noDataText"),
                        dataSource: null,
                        itemTemplateProperty: "template"
                    })
                },
                _init: function() {
                    this.callBase();
                    this._cleanRenderedItems();
                    this._refreshDataSource()
                },
                _initTemplates: function() {
                    this._initItemsFromMarkup();
                    this.callBase()
                },
                _initItemsFromMarkup: function() {
                    var $items = this.element().contents().filter(ITEMS_SELECTOR);
                    if (!$items.length || this.option("items").length)
                        return;
                    var items = $.map($items, $.proxy(function(item) {
                            var $item = $(item);
                            var result = utils.getElementOptions(item).dxItem;
                            var isTemplateRequired = $.trim($item.html()) && !result.template;
                            if (isTemplateRequired)
                                result.template = this._prepareItemTemplate($item);
                            else
                                $item.remove();
                            return result
                        }, this));
                    this.option("items", items)
                },
                _prepareItemTemplate: function($item) {
                    var templateId = ITEM_TEMPLATE_ID_PREFIX + new DX.data.Guid;
                    var templateOptions = "dxTemplate: { name: '" + templateId + "' }";
                    $item.attr("data-options", templateOptions).data("options", templateOptions);
                    return templateId
                },
                _dataSourceOptions: function() {
                    var options = {
                            paginate: false,
                            _preferSync: false
                        };
                    if ($.isArray(this.option("dataSource")))
                        options._preferSync = true;
                    return options
                },
                _cleanRenderedItems: function() {
                    this._renderedItemsCount = 0
                },
                _focusTarget: function() {
                    return this.element()
                },
                _focusElementClass: function() {
                    return this._itemClass()
                },
                _focusInHandler: function(e) {
                    this.callBase.apply(this, arguments);
                    var elementClass = this._focusElementClass(),
                        $target = $(e.target).closest("." + elementClass);
                    if ($target.hasClass(elementClass)) {
                        this._resetFocusedItem($target);
                        return
                    }
                    var $activeItem = this._getActiveItem();
                    this._setFocusedItem($activeItem.closest("." + elementClass))
                },
                _focusOutHandler: function(e) {
                    this.callBase.apply(this, arguments);
                    var $target = this._$focusedItem;
                    if ($target)
                        $target.removeClass(FOCUSED_STATE_CLASS)
                },
                _getActiveItem: function(last) {
                    var index = this.option("selectedIndex"),
                        activeElements = this._getActiveElement(),
                        lastIndex = activeElements.length - 1;
                    if (index < 0)
                        index = last ? lastIndex : 0;
                    return this._$focusedItem || activeElements.eq(index)
                },
                _renderFocusTarget: function() {
                    this.callBase.apply(this, arguments);
                    var activeElements = this._getActiveElement();
                    activeElements.attr('tabindex', -1);
                    this.element().attr('aria-activedescendant', 'active')
                },
                _moveFocus: function(location) {
                    var $items = this._itemElements().filter(':visible').not(".dx-state-disabled"),
                        $newTarget;
                    switch (location) {
                        case FOCUS_PAGE_UP:
                        case FOCUS_UP:
                            $newTarget = this._prevItem($items);
                            break;
                        case FOCUS_PAGE_DOWN:
                        case FOCUS_DOWN:
                            $newTarget = this._nextItem($items);
                            break;
                        case FOCUS_RIGHT:
                            $newTarget = this.option("rtlEnabled") ? this._prevItem($items) : this._nextItem($items);
                            break;
                        case FOCUS_LEFT:
                            $newTarget = this.option("rtlEnabled") ? this._nextItem($items) : this._prevItem($items);
                            break;
                        case FOCUS_FIRST:
                            $newTarget = $items.first();
                            break;
                        case FOCUS_LAST:
                            $newTarget = $items.last();
                            break;
                        default:
                            return false
                    }
                    this._resetFocusedItem($newTarget, true)
                },
                _prevItem: function($items) {
                    var $target = this._getActiveItem(),
                        targetIndex = $items.index($target),
                        $last = $items.last(),
                        $item = $($items[targetIndex - 1]),
                        loop = this.option("loopItemFocus");
                    if ($item.length === 0 && loop)
                        $item = $last;
                    return $item
                },
                _nextItem: function($items) {
                    var $target = this._getActiveItem(true),
                        targetIndex = $items.index($target),
                        $first = $items.first(),
                        $item = $($items[targetIndex + 1]),
                        loop = this.option("loopItemFocus");
                    if ($item.length === 0 && loop)
                        $item = $first;
                    return $item
                },
                _setFocusedItem: function($target, isKeyboard) {
                    if (!$target || !$target.length)
                        return;
                    this._$focusedItem = $target;
                    $target.attr('id', 'active');
                    $target.addClass(FOCUSED_STATE_CLASS);
                    if (this.option("selectOnFocus") && isKeyboard)
                        this._selectFocusedItem($target)
                },
                _selectFocusedItem: function($target) {
                    this.selectItem($target)
                },
                _removeFocusedItem: function() {
                    var $target = this._$focusedItem;
                    if ($target) {
                        $target.removeClass(FOCUSED_STATE_CLASS);
                        $target.removeAttr('id')
                    }
                },
                _resetFocusedItem: function($target, isKeyboard) {
                    if ($target.length) {
                        this._removeFocusedItem();
                        this._setFocusedItem($target, isKeyboard)
                    }
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"items":
                        case"itemTemplateProperty":
                            this._cleanRenderedItems();
                            this._invalidate();
                            break;
                        case"dataSource":
                            this._refreshDataSource();
                            if (!this._dataSource)
                                this.option("items", []);
                            this._renderEmptyMessage();
                            break;
                        case"noDataText":
                            this._renderEmptyMessage();
                            break;
                        case"itemTemplate":
                            this._invalidate();
                            break;
                        case"onItemRendered":
                            this._createItemRenderAction();
                            break;
                        case"onItemClick":
                            break;
                        case"onItemHold":
                        case"itemHoldTimeout":
                            this._attachHoldEvent();
                            break;
                        case"onItemContextMenu":
                            this._attachContextMenuEvent();
                            break;
                        case"selectOnFocus":
                        case"loopItemFocus":
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _expectNextPageLoading: function() {
                    this._startIndexForAppendedItems = 0
                },
                _expectLastItemLoading: function() {
                    this._startIndexForAppendedItems = -1
                },
                _forgetNextPageLoading: function() {
                    this._startIndexForAppendedItems = null
                },
                _dataSourceChangedHandler: function(newItems) {
                    var items = this.option("items");
                    if (this._initialized && items && this._shouldAppendItems()) {
                        this._renderedItemsCount = items.length;
                        if (!this._dataSource.isLastPage() || this._startIndexForAppendedItems !== -1)
                            this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems));
                        this._renderContent();
                        this._renderFocusTarget()
                    }
                    else
                        this.option("items", newItems)
                },
                _dataSourceLoadErrorHandler: function() {
                    this._forgetNextPageLoading()
                },
                _shouldAppendItems: function() {
                    return this._startIndexForAppendedItems != null && this._allowDinamicItemsAppend()
                },
                _allowDinamicItemsAppend: function() {
                    return false
                },
                _clean: function() {
                    this._cleanFocusState();
                    this._itemContainer().empty()
                },
                _refresh: function() {
                    this._cleanRenderedItems();
                    this.callBase.apply(this, arguments)
                },
                _itemContainer: function() {
                    return this.element()
                },
                _itemClass: function() {
                    return ITEM_CLASS
                },
                _selectedItemClass: function() {
                    return SELECTED_ITEM_CLASS
                },
                _itemResponseWaitClass: function() {
                    return ITEM_RESPONSE_WAIT_CLASS
                },
                _itemSelector: function() {
                    return "." + this._itemClass()
                },
                _itemDataKey: function() {
                    return ITEM_DATA_KEY
                },
                _itemElements: function() {
                    return this._itemContainer().find(this._itemSelector())
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(COLLECTION_CLASS);
                    this._attachClickEvent();
                    this._attachHoldEvent();
                    this._attachContextMenuEvent()
                },
                _attachClickEvent: function() {
                    var itemSelector = this._itemSelector(),
                        eventName = events.addNamespace("dxclick", this.NAME);
                    this._itemContainer().off(eventName, itemSelector).on(eventName, itemSelector, $.proxy(this._itemClickHandler, this))
                },
                _itemClickHandler: function(e) {
                    this._itemJQueryEventHandler(e, "onItemClick")
                },
                _attachHoldEvent: function() {
                    var $itemContainer = this._itemContainer(),
                        itemSelector = this._itemSelector(),
                        eventName = events.addNamespace("dxhold", this.NAME);
                    $itemContainer.off(eventName, itemSelector);
                    if (this._shouldAttachHoldEvent())
                        $itemContainer.on(eventName, itemSelector, {timeout: this._getHoldTimeout()}, $.proxy(this._itemHoldHandler, this))
                },
                _getHoldTimeout: function() {
                    return this.option("itemHoldTimeout")
                },
                _shouldAttachHoldEvent: function() {
                    return this.option("onItemHold")
                },
                _itemHoldHandler: function(e) {
                    this._itemJQueryEventHandler(e, "onItemHold")
                },
                _attachContextMenuEvent: function() {
                    var $itemContainer = this._itemContainer(),
                        itemSelector = this._itemSelector(),
                        eventName = events.addNamespace("dxcontextmenu", this.NAME);
                    $itemContainer.off(eventName, itemSelector);
                    if (this._shouldAttachContextMenuEvent())
                        $itemContainer.on(eventName, itemSelector, $.proxy(this._itemContextMenuHandler, this))
                },
                _shouldAttachContextMenuEvent: function() {
                    return this.option("onItemContextMenu")
                },
                _itemContextMenuHandler: function(e) {
                    this._itemJQueryEventHandler(e, "onItemContextMenu")
                },
                _renderContentImpl: function() {
                    var items = this.option("items") || [];
                    if (this._renderedItemsCount)
                        this._renderItems(items.slice(this._renderedItemsCount));
                    else
                        this._renderItems(items)
                },
                _renderItems: function(items) {
                    if (items.length)
                        $.each(items, $.proxy(this._renderItem, this));
                    this._renderEmptyMessage()
                },
                _renderItem: function(index, itemData, $container) {
                    $container = $container || this._itemContainer();
                    var $itemFrame = this._renderItemFrame(index, itemData, $container);
                    this._setElementData($itemFrame, itemData);
                    var $itemContent = $itemFrame.find("." + ITEM_CONTENT_PLACEHOLDER_CLASS);
                    $itemContent.removeClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
                    $itemContent = this._renderItemContent(index, itemData, $itemContent);
                    this._postprocessRenderItem({
                        itemElement: $itemFrame,
                        itemContent: $itemContent,
                        itemData: itemData,
                        itemIndex: index
                    });
                    this._executeItemRenderAction(itemData, $itemFrame);
                    return $itemFrame
                },
                _renderItemContent: function(index, itemData, $container) {
                    var $itemNode = itemData && itemData.node;
                    var itemTemplateName = this._getItemTemplateName(itemData);
                    var itemTemplate = this._getTemplate(itemTemplateName, itemData, index, $container);
                    var renderArgs = {
                            index: index,
                            item: itemData,
                            container: $container
                        };
                    if ($itemNode) {
                        $container.replaceWith($itemNode);
                        $container = $itemNode;
                        this._addItemContentClasses($container, itemData)
                    }
                    else {
                        this._addItemContentClasses($container, itemData);
                        var $result = this._createItemByTemplate(itemTemplate, renderArgs);
                        if ($result.length) {
                            $container.replaceWith($result);
                            $container = $result;
                            this._addItemContentClasses($container, itemData)
                        }
                    }
                    return $container
                },
                _addItemContentClasses: function($container) {
                    $container.addClass(ITEM_CLASS + CONTENT_CLASS_POSTFIX);
                    $container.addClass(this._itemClass() + CONTENT_CLASS_POSTFIX)
                },
                _renderItemFrame: function(index, itemData, $container) {
                    var itemFrameTemplate = this._templateProvider.getTemplates(this)["itemFrame"],
                        $itemFrame = itemFrameTemplate.render(utils.isDefined(itemData) ? itemData : {}, $container, index);
                    $itemFrame.appendTo($container);
                    return $itemFrame
                },
                _postprocessRenderItem: $.noop,
                _executeItemRenderAction: function(itemData, itemElement) {
                    this._getItemRenderAction()({
                        itemElement: itemElement,
                        itemData: itemData
                    })
                },
                _setElementData: function(element, data) {
                    element.addClass(ITEM_CLASS).addClass(this._itemClass()).data(this._itemDataKey(), data)
                },
                _createItemRenderAction: function() {
                    return this._itemRenderAction = this._createActionByOption("onItemRendered", {
                            element: this.element(),
                            excludeValidators: ["designMode", "disabled"]
                        })
                },
                _getItemRenderAction: function() {
                    return this._itemRenderAction || this._createItemRenderAction()
                },
                _getItemTemplateName: function(itemData) {
                    var templateProperty = this.option("itemTemplateProperty");
                    return itemData && itemData[templateProperty] || this.option("itemTemplate")
                },
                _createItemByTemplate: function(itemTemplate, renderArgs) {
                    var result = itemTemplate.render(renderArgs.item, renderArgs.container, renderArgs.index, "ignoreTarget");
                    if (typeof result === "string")
                        result = DX.utils.htmlToJQuery(result);
                    return result
                },
                _renderEmptyMessage: function() {
                    var noDataText = this.option("noDataText"),
                        items = this.option("items"),
                        dataSourceLoading = this._dataSource && this._dataSource.isLoading(),
                        hideNoData = !noDataText || items && items.length || dataSourceLoading;
                    if (hideNoData && this._$nodata) {
                        this._$nodata.remove();
                        this._$nodata = null
                    }
                    if (!hideNoData) {
                        this._$nodata = this._$nodata || $("<div>").addClass("dx-empty-message");
                        this._$nodata.appendTo(this._itemContainer()).html(noDataText)
                    }
                    this.element().toggleClass(EMPTY_COLLECTION, !hideNoData)
                },
                _itemJQueryEventHandler: function(jQueryEvent, handlerOptionName, actionArgs, actionConfig) {
                    this._itemEventHandler(jQueryEvent.target, handlerOptionName, $.extend(actionArgs, {jQueryEvent: jQueryEvent}), actionConfig)
                },
                _itemEventHandler: function(initiator, handlerOptionName, actionArgs, actionConfig) {
                    var action = this._createActionByOption(handlerOptionName, $.extend({validatingTargetName: "itemElement"}, actionConfig));
                    return this._itemEventHandlerImpl(initiator, action, actionArgs)
                },
                _itemEventHandlerByHandler: function(initiator, handler, actionArgs, actionConfig) {
                    var action = this._createAction(handler, $.extend({validatingTargetName: "itemElement"}, actionConfig));
                    return this._itemEventHandlerImpl(initiator, action, actionArgs)
                },
                _itemEventHandlerImpl: function(initiator, action, actionArgs) {
                    var $itemElement = this._closestItemElement($(initiator));
                    return action($.extend(this._extendActionArgs($itemElement), actionArgs))
                },
                _extendActionArgs: function($itemElement) {
                    return {
                            itemElement: $itemElement,
                            itemIndex: $itemElement.index(this._itemSelector()),
                            itemData: this._getItemData($itemElement)
                        }
                },
                _closestItemElement: function($element) {
                    return $($element).closest(this._itemSelector())
                },
                _getItemData: function(itemElement) {
                    return $(itemElement).data(this._itemDataKey())
                },
                _isLastPage: function() {
                    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize
                },
                itemElements: function() {
                    return this._itemElements()
                },
                itemsContainer: function() {
                    return this._itemContainer()
                }
            }).include(ui.DataHelperMixin);
        ui.CollectionWidget = CollectionWidget
    })(jQuery, DevExpress);
    /*! Module core, file ui.CollectionWidget.edit.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events;
        var ITEM_DELETING_DATA_KEY = "dxItemDeleting";
        var CollectionWidget = ui.CollectionWidget.inherit({
                _setOptionsByReference: function() {
                    this.callBase();
                    $.extend(this._optionsByReference, {selectedItem: true})
                },
                _setDeprecatedOptions: function() {
                    this.callBase();
                    $.extend(this._deprecatedOptions, {itemSelectAction: {
                            since: "14.2",
                            message: "Use the 'onSelectionChanged' option instead"
                        }})
                },
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        selectionMode: 'none',
                        selectionRequired: false,
                        selectionByClick: true,
                        selectedItems: [],
                        selectedIndex: -1,
                        selectedItem: null,
                        onSelectionChanged: null,
                        onItemReordered: null,
                        onItemDeleting: null,
                        onItemDeleted: null
                    })
                },
                _init: function() {
                    this.callBase();
                    this._initEditStrategy();
                    this._selectedItemIndices = []
                },
                _initEditStrategy: function() {
                    var strategy = ui.CollectionWidget.PlainEditStrategy;
                    this._editStrategy = new strategy(this)
                },
                _render: function() {
                    this._syncSelectionOptions();
                    this._normalizeSelectedItems();
                    this._initSelectedItems();
                    this.callBase();
                    this._renderSelection(this._selectedItemIndices, [])
                },
                _syncSelectionOptions: function(byOption) {
                    var items = this.option("items") || [],
                        selectedItems = this.option("selectedItems") || [],
                        selectedItem = this.option("selectedItem"),
                        selectedIndex = this.option("selectedIndex");
                    byOption = byOption || this._chooseSelectOption();
                    switch (byOption) {
                        case"selectedItems":
                            this._setOptionSilent("selectedItem", selectedItems[0]);
                            this._setOptionSilent("selectedIndex", $.inArray(selectedItems[0], items));
                            break;
                        case"selectedItem":
                            if (utils.isDefined(selectedItem)) {
                                this._setOptionSilent("selectedItems", [selectedItem]);
                                this._setOptionSilent("selectedIndex", $.inArray(selectedItem, items))
                            }
                            else {
                                this._setOptionSilent("selectedItems", []);
                                this._setOptionSilent("selectedIndex", -1)
                            }
                            break;
                        case"selectedIndex":
                            if (utils.isDefined(items[selectedIndex])) {
                                this._setOptionSilent("selectedItems", [items[selectedIndex]]);
                                this._setOptionSilent("selectedItem", items[selectedIndex])
                            }
                            else {
                                this._setOptionSilent("selectedItems", []);
                                this._setOptionSilent("selectedItem", null)
                            }
                            break
                    }
                },
                _chooseSelectOption: function() {
                    var optionName = "selectedIndex";
                    if (this.option("selectedItems").length)
                        optionName = "selectedItems";
                    else if (utils.isDefined(this.option("selectedItem")))
                        optionName = "selectedItem";
                    return optionName
                },
                _normalizeSelectedItems: function() {
                    if (this.option("selectionMode") === "none") {
                        this._setOptionSilent("selectedItems", []);
                        this._syncSelectionOptions("selectedItems")
                    }
                    else if (this.option("selectionMode") === "single") {
                        var newSelection = this._editStrategy.selectedItemIndices(this.option("selectedItems"));
                        if (newSelection.length > 1 || !newSelection.length && this.option("selectionRequired") && this.option("items") && this.option("items").length) {
                            var normalizedSelection = [newSelection[0] || this._selectedItemIndices[0] || 0];
                            this._setOptionSilent("selectedItems", this._editStrategy.fetchSelectedItems(normalizedSelection));
                            this._syncSelectionOptions("selectedItems")
                        }
                    }
                },
                _initSelectedItems: function() {
                    this._selectedItemIndices = this._editStrategy.selectedItemIndices(this.option("selectedItems"))
                },
                _renderSelection: $.noop,
                _itemClickHandler: function(e) {
                    this._createAction($.proxy(function(e) {
                        this._itemSelectHandler(e.jQueryEvent)
                    }, this), {validatingTargetName: "itemElement"})({
                        itemElement: $(e.currentTarget),
                        jQueryEvent: e
                    });
                    this.callBase.apply(this, arguments)
                },
                _itemSelectHandler: function(e) {
                    if (!this.option("selectionByClick"))
                        return;
                    var $itemElement = e.currentTarget;
                    if (this.isItemSelected($itemElement))
                        this.unselectItem(e.currentTarget);
                    else
                        this.selectItem(e.currentTarget)
                },
                _selectedItemElement: function(index) {
                    return this._itemElements().eq(index)
                },
                _postprocessRenderItem: function(args) {
                    var $itemElement = $(args.itemElement);
                    if (this._isItemSelected(this._editStrategy.getNormalizedIndex($itemElement)))
                        $itemElement.addClass(this._selectedItemClass())
                },
                _updateSelectedItems: function() {
                    var oldSelection = this._selectedItemIndices.slice(),
                        newSelection = this._editStrategy.selectedItemIndices(),
                        addedSelection = utils.removeDublicates(newSelection, oldSelection),
                        removedSelection = utils.removeDublicates(oldSelection, newSelection);
                    $.each(removedSelection, $.proxy(function(_, normalizedIndex) {
                        this._removeSelection(normalizedIndex)
                    }, this));
                    $.each(addedSelection, $.proxy(function(_, normalizedIndex) {
                        this._addSelection(normalizedIndex)
                    }, this));
                    if (removedSelection.length || addedSelection.length) {
                        var selectionChangePromise = this._selectionChangePromise;
                        this._updateSelection(addedSelection, removedSelection);
                        $.when(selectionChangePromise).done($.proxy(function() {
                            this._fireSelectItemEvent(addedSelection, removedSelection);
                            this._fireSelectionChangeEvent(addedSelection, removedSelection)
                        }, this))
                    }
                },
                _fireSelectionChangeEvent: function(addedSelection, removedSelection) {
                    this._createActionByOption("onSelectionChanged", {excludeValidators: ["disabled"]})({
                        addedItems: this._editStrategy.fetchSelectedItems(addedSelection),
                        removedItems: this._editStrategy.fetchSelectedItems(removedSelection)
                    })
                },
                _fireSelectItemEvent: function(addedSelection, removedSelection) {
                    if (this.NAME === "dxList" && this.option("selectionMode") !== "single")
                        return;
                    this._itemEventHandler(this._selectedItemElement(addedSelection[0]), "itemSelectAction", {
                        selectedIndex: addedSelection[0],
                        previousIndex: removedSelection[0]
                    }, {excludeValidators: ["disabled"]})
                },
                _updateSelection: function() {
                    this._renderSelection.apply(this, arguments)
                },
                _removeSelection: function(normalizedIndex) {
                    var $itemElement = this._editStrategy.getItemElement(normalizedIndex),
                        itemSelectionIndex = $.inArray(normalizedIndex, this._selectedItemIndices);
                    if (itemSelectionIndex > -1) {
                        $itemElement.removeClass(this._selectedItemClass());
                        this._selectedItemIndices.splice(itemSelectionIndex, 1);
                        $itemElement.triggerHandler("stateChanged");
                        if (this.NAME === "dxList")
                            this._itemEventHandler($itemElement, "itemUnselectAction", {}, {excludeValidators: ["disabled"]})
                    }
                },
                _addSelection: function(normalizedIndex) {
                    var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
                    if (normalizedIndex > -1 && !this._isItemSelected(normalizedIndex)) {
                        $itemElement.addClass(this._selectedItemClass());
                        this._selectedItemIndices.push(normalizedIndex);
                        $itemElement.triggerHandler("stateChanged");
                        if (this.NAME === "dxList")
                            this._itemEventHandler($itemElement, "itemSelectAction", {}, {excludeValidators: ["disabled"]})
                    }
                },
                _isItemSelected: function(index) {
                    return $.inArray(index, this._selectedItemIndices) > -1
                },
                _selectAllItems: function() {
                    this.option("selectedItems", this.option("items").slice())
                },
                _unselectAllItems: function() {
                    this.option("selectedItems", [])
                },
                _optionChanged: function(args) {
                    if (this._cancelOptionChange)
                        return;
                    switch (args.name) {
                        case"items":
                            if (args.previousValue && args.previousValue.length > 0)
                                this._clearSelectedItems();
                            this.callBase(args);
                            break;
                        case"selectionMode":
                            this._invalidate();
                            break;
                        case"selectedIndex":
                        case"selectedItem":
                        case"selectedItems":
                            this._syncSelectionOptions(args.name);
                            this._normalizeSelectedItems();
                            this._updateSelectedItems();
                            break;
                        case"selectionByClick":
                        case"selectionRequired":
                        case"onSelectionChanged":
                        case"onItemDeleting":
                        case"onItemDeleted":
                        case"onItemReordered":
                        case"itemSelectAction":
                        case"itemUnselectAction":
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _clearSelectedItems: function() {
                    this._selectedItemIndices = [];
                    this.option("selectedItems", [])
                },
                _setOptionSilent: function(name, value) {
                    this._cancelOptionChange = true;
                    this.option(name, value);
                    this._cancelOptionChange = false
                },
                _waitDeletingPrepare: function($itemElement) {
                    if ($itemElement.data(ITEM_DELETING_DATA_KEY))
                        return $.Deferred().resolve().promise();
                    $itemElement.data(ITEM_DELETING_DATA_KEY, true);
                    var deferred = $.Deferred(),
                        deletePromise = this._itemEventHandler($itemElement, "onItemDeleting", {}, {excludeValidators: ["disabled"]});
                    $.when(deletePromise).always($.proxy(function(value) {
                        var deletePromiseExists = !deletePromise,
                            deletePromiseResolved = !deletePromiseExists && deletePromise.state() === "resolved",
                            argumentsSpecified = !!arguments.length,
                            shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value;
                        $itemElement.data(ITEM_DELETING_DATA_KEY, false);
                        shouldDelete ? deferred.resolve() : deferred.reject()
                    }, this));
                    return deferred.promise()
                },
                _deleteItemFromDS: function($item) {
                    if (!this._dataSource)
                        return $.Deferred().resolve().promise();
                    var that = this,
                        deferred = $.Deferred(),
                        disabledState = this.option("disabled"),
                        dataStore = this._dataSource.store();
                    this.option("disabled", true);
                    if (!dataStore.remove)
                        throw DX.Error("E1011");
                    dataStore.remove(dataStore.keyOf(this._getItemData($item))).done(function(key) {
                        if (key !== undefined)
                            deferred.resolve();
                        else
                            deferred.reject()
                    }).fail(function() {
                        deferred.reject()
                    });
                    deferred.always($.proxy(function() {
                        this.option("disabled", disabledState)
                    }, this));
                    return deferred
                },
                _tryRefreshLastPage: function() {
                    var deferred = $.Deferred();
                    if (this._isLastPage() || this.option("grouped"))
                        deferred.resolve();
                    else
                        this._refreshLastPage().done(function() {
                            deferred.resolve()
                        });
                    return deferred.promise()
                },
                _refreshLastPage: function() {
                    this._expectLastItemLoading();
                    return this._dataSource.load()
                },
                _updateSelectionAfterDelete: function(fromIndex) {
                    var itemIndex = $.inArray(fromIndex, this._selectedItemIndices);
                    if (itemIndex > -1)
                        this._selectedItemIndices.splice(itemIndex, 1);
                    this._editStrategy.updateSelectionAfterDelete(fromIndex);
                    this.option("selectedItems", this._editStrategy.fetchSelectedItems())
                },
                _simulateOptionChange: function(optionName) {
                    var optionValue = this.option(optionName);
                    if (optionValue instanceof DX.data.DataSource)
                        return;
                    this.fireEvent("optionChanged", [{
                            name: optionName,
                            fullName: optionName,
                            value: optionValue
                        }])
                },
                isItemSelected: function(itemElement) {
                    return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement))
                },
                selectItem: function(itemElement) {
                    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
                    if (itemIndex === -1)
                        return;
                    var itemSelectionIndex = $.inArray(itemIndex, this._selectedItemIndices);
                    if (itemSelectionIndex !== -1)
                        return;
                    if (this.option("selectionMode") === "single")
                        this.option("selectedItems", this._editStrategy.fetchSelectedItems([itemIndex]));
                    else {
                        var newSelectedIndices = this._selectedItemIndices.slice();
                        newSelectedIndices.push(itemIndex);
                        this.option("selectedItems", this._editStrategy.fetchSelectedItems(newSelectedIndices))
                    }
                },
                unselectItem: function(itemElement) {
                    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
                    if (itemIndex === -1)
                        return;
                    var itemSelectionIndex = $.inArray(itemIndex, this._selectedItemIndices);
                    if (itemSelectionIndex === -1)
                        return;
                    var newSelectedIndices = this._selectedItemIndices.slice();
                    newSelectedIndices.splice(itemSelectionIndex, 1);
                    if (this.option("selectionRequired") && newSelectedIndices.length === 0)
                        return;
                    this.option("selectedItems", this._editStrategy.fetchSelectedItems(newSelectedIndices))
                },
                deleteItem: function(itemElement) {
                    var that = this,
                        deferred = $.Deferred(),
                        $item = this._editStrategy.getItemElement(itemElement),
                        index = this._editStrategy.getNormalizedIndex(itemElement),
                        changingOption = this._dataSource ? "dataSource" : "items",
                        itemResponseWaitClass = this._itemResponseWaitClass();
                    if (index > -1)
                        this._waitDeletingPrepare($item).done(function() {
                            $item.addClass(itemResponseWaitClass);
                            that._deleteItemFromDS($item).done(function() {
                                $item.detach();
                                that._editStrategy.deleteItemAtIndex(index);
                                that._simulateOptionChange(changingOption);
                                that._updateSelectionAfterDelete(index);
                                that._itemEventHandler($item, "onItemDeleted", {}, {excludeValidators: ["disabled"]});
                                that._renderEmptyMessage();
                                that._tryRefreshLastPage().done(function() {
                                    deferred.resolveWith(that)
                                })
                            }).fail(function() {
                                $item.removeClass(itemResponseWaitClass);
                                deferred.rejectWith(that)
                            })
                        }).fail(function() {
                            deferred.rejectWith(that)
                        });
                    else
                        deferred.rejectWith(that);
                    return deferred.promise()
                },
                reorderItem: function(itemElement, toItemElement) {
                    var deferred = $.Deferred(),
                        that = this,
                        strategy = this._editStrategy,
                        $movingItem = strategy.getItemElement(itemElement),
                        $destinationItem = strategy.getItemElement(toItemElement),
                        movingIndex = strategy.getNormalizedIndex(itemElement),
                        destinationIndex = strategy.getNormalizedIndex(toItemElement),
                        changingOption;
                    var canMoveItems = movingIndex > -1 && destinationIndex > -1 && movingIndex !== destinationIndex;
                    if (canMoveItems)
                        if (this._dataSource) {
                            changingOption = "dataSource";
                            deferred.resolveWith(this)
                        }
                        else {
                            changingOption = "items";
                            deferred.resolveWith(this)
                        }
                    else
                        deferred.rejectWith(this);
                    return deferred.promise().done(function() {
                            $destinationItem[strategy.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
                            var newSelectedItems = strategy.getSelectedItemsAfterReorderItem(movingIndex, destinationIndex);
                            strategy.moveItemAtIndexToIndex(movingIndex, destinationIndex);
                            that._selectedItemIndices = strategy.selectedItemIndices(newSelectedItems);
                            that.option("selectedItems", strategy.fetchSelectedItems());
                            that._simulateOptionChange(changingOption);
                            that._itemEventHandler($movingItem, "onItemReordered", {
                                fromIndex: strategy.getIndex(movingIndex),
                                toIndex: strategy.getIndex(destinationIndex)
                            }, {excludeValidators: ["disabled"]})
                        })
                }
            });
        ui.CollectionWidget = CollectionWidget
    })(jQuery, DevExpress);
    /*! Module core, file ui.collectionWidget.edit.strategy.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        ui.CollectionWidget.EditStrategy = DX.Class.inherit({
            ctor: function(collectionWidget) {
                this._collectionWidget = collectionWidget
            },
            getNormalizedIndex: function(value) {
                if (this._isNormalisedItemIndex(value))
                    return value;
                if (this._isItemIndex(value))
                    return this._normalizeItemIndex(value);
                return this._getNormalizedItemIndex(value)
            },
            getIndex: function(value) {
                if (this._isNormalisedItemIndex(value))
                    return this._denormalizeItemIndex(value);
                if (this._isItemIndex(value))
                    return value;
                return this._denormalizeItemIndex(this._getNormalizedItemIndex(value))
            },
            getItemElement: function(value) {
                if (this._isNormalisedItemIndex(value))
                    return this._getItemByNormalizedIndex(value);
                if (this._isItemIndex(value))
                    return this._getItemByNormalizedIndex(this._normalizeItemIndex(value));
                return $(value)
            },
            deleteItemAtIndex: DX.abstract,
            updateSelectionAfterDelete: DX.abstract,
            fetchSelectedItems: DX.abstract,
            selectedItemIndices: DX.abstract,
            itemPlacementFunc: function(movingIndex, destinationIndex) {
                return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? "after" : "before"
            },
            moveItemAtIndexToIndex: DX.abstract,
            getSelectedItemsAfterReorderItem: function() {
                return this._collectionWidget.option("selectedItems")
            },
            _isNormalisedItemIndex: function(index) {
                return $.isNumeric(index)
            },
            _isItemIndex: DX.abstract,
            _getNormalizedItemIndex: DX.abstract,
            _normalizeItemIndex: DX.abstract,
            _denormalizeItemIndex: DX.abstract,
            _getItemByNormalizedIndex: DX.abstract,
            _itemsFromSameParent: DX.abstract
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.collectionWidget.edit.strategy.plain.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        ui.CollectionWidget.PlainEditStrategy = ui.CollectionWidget.EditStrategy.inherit({
            deleteItemAtIndex: function(index) {
                this._collectionWidget.option("items").splice(index, 1)
            },
            updateSelectionAfterDelete: function(fromIndex) {
                var selectedItemIndices = this._collectionWidget._selectedItemIndices;
                $.each(selectedItemIndices, function(i, index) {
                    if (index > fromIndex)
                        selectedItemIndices[i] -= 1
                })
            },
            fetchSelectedItems: function(indices) {
                indices = indices || this._collectionWidget._selectedItemIndices;
                var items = this._collectionWidget.option("items"),
                    selectedItems = [];
                $.each(indices, function(_, index) {
                    selectedItems.push(items[index])
                });
                return selectedItems
            },
            selectedItemIndices: function() {
                var selectedIndices = [],
                    items = this._collectionWidget.option("items"),
                    selected = this._collectionWidget.option("selectedItems");
                $.each(selected, function(_, selectedItem) {
                    var index = $.inArray(selectedItem, items);
                    if (index !== -1)
                        selectedIndices.push(index);
                    else
                        DX.log("W1002", selectedItem)
                });
                return selectedIndices
            },
            moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
                var items = this._collectionWidget.option("items"),
                    movedItemData = items[movingIndex];
                items.splice(movingIndex, 1);
                items.splice(destinationIndex, 0, movedItemData)
            },
            _isItemIndex: function(index) {
                return $.isNumeric(index)
            },
            _getNormalizedItemIndex: function(itemElement) {
                return this._collectionWidget._itemElements().index(itemElement)
            },
            _normalizeItemIndex: function(index) {
                return index
            },
            _denormalizeItemIndex: function(index) {
                return index
            },
            _getItemByNormalizedIndex: function(index) {
                return this._collectionWidget._itemElements().eq(index)
            },
            _itemsFromSameParent: function() {
                return true
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.tooltip.js */
    (function($, DX, undefined) {
        var $tooltip = null;
        var createTooltip = function(options) {
                options = $.extend({position: "top"}, options);
                var content = options.content;
                delete options.content;
                return $("<div />").html(content).appendTo(DX.viewPort()).dxTooltip(options)
            };
        var removeTooltip = function() {
                if (!$tooltip)
                    return;
                $tooltip.remove();
                $tooltip = null
            };
        var tooltip = {
                show: function(options) {
                    removeTooltip();
                    $tooltip = createTooltip(options);
                    return $tooltip.dxTooltip("show")
                },
                hide: function() {
                    if (!$tooltip)
                        return $.when();
                    return $tooltip.dxTooltip("hide").done(removeTooltip).promise()
                }
            };
        DX.ui.tooltip = tooltip
    })(jQuery, DevExpress)
}
if (!DevExpress.MOD_WIDGETS_BASE) {
    if (!window.DevExpress)
        throw Error('Required module is not referenced: core');
    /*! Module widgets-base, file ui.errors.js */
    (function($, DX) {
        $.extend(DX.ERROR_MESSAGES, {
            E1001: "Module '{0}'. Controller '{1}' is already registered",
            E1002: "Module '{0}'. Controller '{1}' must be inheritor of DevExpress.ui.dxDataGrid.Controller",
            E1003: "Module '{0}'. View '{1}' is already registered",
            E1004: "Module '{0}'. View '{1}' must be inheritor of DevExpress.ui.dxDataGrid.View",
            E1005: "Public method '{0}' is already registered",
            E1006: "Public method '{0}.{1}' is not exists",
            E1007: "State storing can not be provided due to the restrictions of your browser",
            E1010: "A template should contain dxTextBox widget",
            E1011: "You have to implement 'remove' method in dataStore used by dxList to be able to delete items",
            E1012: "Editing type '{0}' with name '{1}' not supported",
            E1016: "Unexpected type of data source is provided for a lookup column",
            E1018: "The 'collapseAll' method cannot be called when using a remote data source",
            E1019: "Search mode '{0}' is unavailable",
            E1020: "Type can not be changed after initialization",
            E1021: "{0} '{1}' you are trying to remove does not exist",
            E1022: "Markers option should be an array",
            E1023: "Routes option should be an array",
            E1024: "Google provider cannot be used in WinJS application",
            E1025: "This layout is too complex to render",
            E1026: "The 'custom' value is set to a summary item's summaryType option, but a function for calculating the custom summary is not assigned to the grid's calculateCustomSummary option",
            E1030: "Unknown dxScrollView refresh strategy: '{0}'",
            W1001: "Key option can not be modified after initialization",
            W1002: "Item '{0}' you are trying to select does not exist",
            W1003: "Group with key '{0}' in which you are trying to select items does not exist",
            W1004: "Item '{0}' you are trying to select in group '{1}' does not exist",
            W1005: "Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns."
        })
    })($, DevExpress);
    /*! Module widgets-base, file ui.scrollable.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var SCROLLABLE = "dxScrollable",
            SCROLLABLE_STRATEGY = "dxScrollableStrategy",
            SCROLLABLE_CLASS = "dx-scrollable",
            SCROLLABLE_DISABLED_CLASS = "dx-scrollable-disabled",
            SCROLLABLE_CONTAINER_CLASS = "dx-scrollable-container",
            SCROLLABLE_CONTENT_CLASS = "dx-scrollable-content",
            VERTICAL = "vertical",
            HORIZONTAL = "horizontal",
            BOTH = "both";
        DX.registerComponent(SCROLLABLE, ui, DX.DOMComponent.inherit({
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    updateAction: {
                        since: "14.2",
                        alias: "onUpdated"
                    },
                    scrollAction: {
                        since: "14.2",
                        alias: "onScroll"
                    },
                    startAction: {
                        since: "14.2",
                        alias: "onStart"
                    },
                    stopAction: {
                        since: "14.2",
                        alias: "onStop"
                    },
                    endAction: {
                        since: "14.2",
                        alias: "onEnd"
                    }
                })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    disabled: false,
                    onScroll: null,
                    direction: VERTICAL,
                    showScrollbar: 'onScroll',
                    useNative: true,
                    onUpdated: null,
                    useSimulatedScrollbar: false,
                    useKeyboard: true,
                    inertiaEnabled: true,
                    bounceEnabled: true,
                    scrollByContent: true,
                    scrollByThumb: false,
                    onStart: null,
                    onEnd: null,
                    onBounce: null,
                    onStop: null,
                    pushBackValue: 0
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return !DX.support.nativeScrolling
                            },
                            options: {
                                useNative: false,
                                useSimulatedScrollbar: true
                            }
                        }, {
                            device: function(device) {
                                return !DX.support.nativeScrolling && !DX.devices.isSimulator() && DX.devices.real().platform === "generic" && device.platform === "generic"
                            },
                            options: {
                                scrollByThumb: true,
                                scrollByContent: DX.support.touch,
                                showScrollbar: "onHover",
                                bounceEnabled: false
                            }
                        }, {
                            device: function(device) {
                                return DX.support.nativeScrolling && DX.devices.real().platform === "android"
                            },
                            options: {useSimulatedScrollbar: true}
                        }, {
                            device: function(device) {
                                return DX.devices.real().platform === "ios"
                            },
                            options: {pushBackValue: 1}
                        }])
            },
            _init: function() {
                this.callBase();
                this._initMarkup();
                this._attachNativeScrollbarsCustomizationCss();
                this._locked = false
            },
            _visibilityChanged: function(visible) {
                if (visible) {
                    this.update();
                    this._savedScrollOffset && this.scrollTo(this._savedScrollOffset)
                }
                else
                    this._savedScrollOffset = this.scrollOffset()
            },
            _initMarkup: function() {
                var $element = this.element().addClass(SCROLLABLE_CLASS),
                    $container = this._$container = $("<div>").addClass(SCROLLABLE_CONTAINER_CLASS),
                    $content = this._$content = $("<div>").addClass(SCROLLABLE_CONTENT_CLASS);
                $content.append($element.contents()).appendTo($container);
                $container.appendTo($element)
            },
            _dimensionChanged: function() {
                this.update()
            },
            _attachNativeScrollbarsCustomizationCss: function() {
                if (!(navigator.platform.indexOf('Mac') > -1 && DevExpress.browser['webkit']))
                    this.element().addClass("dx-scrollable-customizable-scrollbars")
            },
            _render: function() {
                this._renderDirection();
                this._renderStrategy();
                this._attachEventHandlers();
                this._renderDisabledState();
                this._createActions();
                this.update();
                this.callBase()
            },
            _toggleRTLDirection: function(rtl) {
                this.callBase(rtl);
                if (rtl)
                    this.scrollTo({left: this.scrollWidth() - this.clientWidth()})
            },
            _attachEventHandlers: function() {
                var strategy = this._strategy;
                var initEventData = {
                        getDirection: $.proxy(strategy.getDirection, strategy),
                        validate: $.proxy(this._validate, this),
                        isNative: this.option("useNative")
                    };
                this._$container.off("." + SCROLLABLE).on(events.addNamespace("scroll", SCROLLABLE), $.proxy(strategy.handleScroll, strategy)).on(events.addNamespace("dxscrollinit", SCROLLABLE), initEventData, $.proxy(this._initHandler, this)).on(events.addNamespace("dxscrollstart", SCROLLABLE), $.proxy(strategy.handleStart, strategy)).on(events.addNamespace("dxscroll", SCROLLABLE), $.proxy(strategy.handleMove, strategy)).on(events.addNamespace("dxscrollend", SCROLLABLE), $.proxy(strategy.handleEnd, strategy)).on(events.addNamespace("dxscrollcancel", SCROLLABLE), $.proxy(strategy.handleCancel, strategy)).on(events.addNamespace("dxscrollstop", SCROLLABLE), $.proxy(strategy.handleStop, strategy))
            },
            _validate: function(e) {
                if (this.option("useNative"))
                    this._updateAllowedDirection();
                else
                    this.update();
                return this._strategy.validate(e)
            },
            _initHandler: function() {
                var strategy = this._strategy;
                strategy.handleInit.apply(strategy, arguments)
            },
            _renderDisabledState: function() {
                this.element().toggleClass(SCROLLABLE_DISABLED_CLASS, this.option("disabled"));
                if (this.option("disabled"))
                    this._lock();
                else
                    this._unlock()
            },
            _renderDirection: function() {
                this.element().removeClass("dx-scrollable-" + HORIZONTAL).removeClass("dx-scrollable-" + VERTICAL).removeClass("dx-scrollable-" + BOTH).addClass("dx-scrollable-" + this.option("direction"))
            },
            _renderStrategy: function() {
                this._createStrategy();
                this._strategy.render();
                this.element().data(SCROLLABLE_STRATEGY, this._strategy)
            },
            _createStrategy: function() {
                this._strategy = this.option("useNative") ? new ui.dxScrollable.NativeStrategy(this) : new ui.dxScrollable.SimulatedStrategy(this)
            },
            _createActions: function() {
                this._strategy.createActions()
            },
            _clean: function() {
                this._strategy.dispose()
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"onStart":
                    case"onEnd":
                    case"onStop":
                    case"onUpdated":
                    case"onScroll":
                    case"onBounce":
                        this._createActions();
                        break;
                    case"direction":
                        this._resetInactiveDirection();
                        this._invalidate();
                        break;
                    case"inertiaEnabled":
                    case"bounceEnabled":
                    case"scrollByContent":
                    case"scrollByThumb":
                    case"bounceEnabled":
                    case"useNative":
                    case"useKeyboard":
                    case"showScrollbar":
                    case"useSimulatedScrollbar":
                    case"pushBackValue":
                        this._invalidate();
                        break;
                    case"disabled":
                        this._renderDisabledState();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _resetInactiveDirection: function() {
                var inactiveProp = this._getInactiveProp();
                if (!inactiveProp)
                    return;
                var scrollOffset = this.scrollOffset();
                scrollOffset[inactiveProp] = 0;
                this.scrollTo(scrollOffset)
            },
            _getInactiveProp: function() {
                var direction = this.option("direction");
                if (direction === VERTICAL)
                    return "left";
                if (direction === HORIZONTAL)
                    return "top"
            },
            _location: function() {
                return this._strategy.location()
            },
            _normalizeLocation: function(location) {
                var direction = this.option("direction");
                return {
                        left: $.isPlainObject(location) ? -(location.left || location.x || 0) : direction !== VERTICAL ? -location : 0,
                        top: $.isPlainObject(location) ? -(location.top || location.y || 0) : direction !== HORIZONTAL ? -location : 0
                    }
            },
            _isLocked: function() {
                return this._locked
            },
            _lock: function() {
                this._locked = true
            },
            _unlock: function() {
                this._locked = false
            },
            _isDirection: function(direction) {
                var current = this.option("direction");
                if (direction === VERTICAL)
                    return current !== HORIZONTAL;
                if (direction === HORIZONTAL)
                    return current !== VERTICAL;
                return current === direction
            },
            _updateAllowedDirection: function() {
                var allowedDirections = this._strategy._allowedDirections();
                if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal)
                    this._allowedDirectionValue = BOTH;
                else if (this._isDirection(HORIZONTAL) && allowedDirections.horizontal)
                    this._allowedDirectionValue = HORIZONTAL;
                else if (this._isDirection(VERTICAL) && allowedDirections.vertical)
                    this._allowedDirectionValue = VERTICAL;
                else
                    this._allowedDirectionValue = null
            },
            _allowedDirection: function() {
                return this._allowedDirectionValue
            },
            content: function() {
                return this._$content
            },
            scrollOffset: function() {
                var location = this._location();
                return {
                        top: -location.top,
                        left: -location.left
                    }
            },
            scrollTop: function() {
                return this.scrollOffset().top
            },
            scrollLeft: function() {
                return this.scrollOffset().left
            },
            clientHeight: function() {
                return this._$container.height()
            },
            scrollHeight: function() {
                return this.content().height()
            },
            clientWidth: function() {
                return this._$container.width()
            },
            scrollWidth: function() {
                return this.content().width()
            },
            update: function() {
                this._strategy.update();
                this._updateAllowedDirection();
                return $.Deferred().resolve().promise()
            },
            scrollBy: function(distance) {
                distance = this._normalizeLocation(distance);
                if (!distance.top && !distance.left)
                    return;
                this._strategy.scrollBy(distance)
            },
            scrollTo: function(targetLocation) {
                targetLocation = this._normalizeLocation(targetLocation);
                var location = this._location();
                this.scrollBy({
                    left: location.left - targetLocation.left,
                    top: location.top - targetLocation.top
                })
            },
            scrollToElement: function(element) {
                var $element = $(element);
                if (!$element.length || !this.element().find($element).length)
                    return;
                var position = {
                        top: 0,
                        left: 0
                    };
                var direction = this.option("direction");
                if (direction !== VERTICAL)
                    position.left = this._elementPosition($element, HORIZONTAL);
                if (direction !== HORIZONTAL)
                    position.top = this._elementPosition($element, VERTICAL);
                this.scrollTo(position)
            },
            _elementPosition: function($element, direction) {
                var elementPosition = this._elementPositionRelativeToContent($element, direction === VERTICAL ? 'top' : 'left');
                var elementSize = $element[direction === VERTICAL ? 'outerHeight' : 'outerWidth']();
                var elementBottom = elementPosition + elementSize;
                var scrollLocation = direction === VERTICAL ? this.scrollTop() : this.scrollLeft();
                var clientSize = direction === VERTICAL ? this.clientHeight() : this.clientWidth();
                var isAlreadyVisible = scrollLocation <= elementPosition && elementBottom <= scrollLocation + clientSize;
                var isElementBelowScrollLocation = scrollLocation > elementPosition;
                return isAlreadyVisible ? scrollLocation : elementPosition + (isElementBelowScrollLocation ? 0 : elementSize - clientSize)
            },
            _elementPositionRelativeToContent: function($element, prop) {
                var result = 0;
                while (this._hasScrollContent($element)) {
                    result += $element.position()[prop];
                    $element = $element.offsetParent()
                }
                return result
            },
            _hasScrollContent: function($element) {
                var $content = this.content();
                return $element.closest($content).length && !$element.is($content)
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollbar.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var SCROLLBAR = "dxScrollbar",
            SCROLLABLE_SCROLLBAR_CLASS = "dx-scrollable-scrollbar",
            SCROLLABLE_SCROLLBAR_ACTIVE_CLASS = SCROLLABLE_SCROLLBAR_CLASS + "-active",
            SCROLLABLE_SCROLL_CLASS = "dx-scrollable-scroll",
            SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden",
            HOVER_ENABLED_STATE = "dx-scrollbar-hoverable",
            VERTICAL = "vertical",
            HORIZONTAL = "horizontal",
            THUMB_MIN_SIZE = 15;
        var SCROLLBAR_VISIBLE = {
                onScroll: "onScroll",
                onHover: "onHover",
                always: "always",
                never: "never"
            };
        DX.registerComponent(SCROLLBAR, ui.dxScrollable, ui.Widget.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    direction: null,
                    visible: false,
                    activeStateEnabled: false,
                    visibilityMode: SCROLLBAR_VISIBLE.onScroll,
                    containerSize: 0,
                    contentSize: 0
                })
            },
            _init: function() {
                this.callBase();
                this._isHovered = false
            },
            _render: function() {
                this._renderThumb();
                this.callBase();
                this._renderDirection();
                this._update();
                this._attachPointerDownHandler();
                this.option("hoverStateEnabled", this._isHoverMode());
                this.element().toggleClass(HOVER_ENABLED_STATE, this.option("hoverStateEnabled"))
            },
            _renderThumb: function() {
                this._$thumb = $("<div>").addClass(SCROLLABLE_SCROLL_CLASS);
                this.element().addClass(SCROLLABLE_SCROLLBAR_CLASS).append(this._$thumb)
            },
            isThumb: function($element) {
                return !!this.element().find($element).length
            },
            _isHoverMode: function() {
                return this.option("visibilityMode") === SCROLLBAR_VISIBLE.onHover
            },
            _renderDirection: function() {
                var direction = this.option("direction");
                this.element().addClass("dx-scrollbar-" + direction);
                this._dimension = direction === HORIZONTAL ? "width" : "height";
                this._prop = direction === HORIZONTAL ? "left" : "top"
            },
            _attachPointerDownHandler: function() {
                this._$thumb.on(events.addNamespace("dxpointerdown", SCROLLBAR), $.proxy(this.feedbackOn, this))
            },
            feedbackOn: function() {
                this.element().addClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
                activeScrollbar = this
            },
            feedbackOff: function() {
                this.element().removeClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
                activeScrollbar = null
            },
            cursorEnter: function() {
                this._isHovered = true;
                this.option("visible", true)
            },
            cursorLeave: function() {
                this._isHovered = false;
                this.option("visible", false)
            },
            _renderDimensions: function() {
                this._$thumb.height(this.option("height"));
                this._$thumb.width(this.option("width"))
            },
            _toggleVisibility: function(visible) {
                visible = this._adjustVisibility(visible);
                this.option().visible = visible;
                this._$thumb.toggleClass("dx-state-invisible", !visible)
            },
            _adjustVisibility: function(visible) {
                if (this.containerToContentRatio() && !this._needScrollbar())
                    return false;
                switch (this.option("visibilityMode")) {
                    case SCROLLBAR_VISIBLE.onScroll:
                        break;
                    case SCROLLBAR_VISIBLE.onHover:
                        visible = visible || !!this._isHovered;
                        break;
                    case SCROLLBAR_VISIBLE.never:
                        visible = false;
                        break;
                    case SCROLLBAR_VISIBLE.always:
                        visible = true;
                        break
                }
                return visible
            },
            moveTo: function(location) {
                if (this._isHidden())
                    return;
                if ($.isPlainObject(location))
                    location = location[this._prop] || 0;
                var scrollBarLocation = {};
                scrollBarLocation[this._prop] = this._calculateScrollBarPosition(location);
                DX.translator.move(this._$thumb, scrollBarLocation)
            },
            _calculateScrollBarPosition: function(location) {
                return -location * this._thumbRatio
            },
            _update: function() {
                var containerSize = this.option("containerSize"),
                    contentSize = this.option("contentSize");
                this._containerToContentRatio = containerSize / contentSize;
                var thumbSize = Math.round(Math.max(Math.round(containerSize * this._containerToContentRatio), THUMB_MIN_SIZE));
                this._thumbRatio = (containerSize - thumbSize) / (contentSize - containerSize);
                this.option(this._dimension, thumbSize);
                this.element().toggle(this._needScrollbar())
            },
            _isHidden: function() {
                return this.option("visibilityMode") === SCROLLBAR_VISIBLE.never
            },
            _needScrollbar: function() {
                return !this._isHidden() && this._containerToContentRatio < 1
            },
            containerToContentRatio: function() {
                return this._containerToContentRatio
            },
            _normalizeSize: function(size) {
                return $.isPlainObject(size) ? size[this._dimension] || 0 : size
            },
            _clean: function() {
                this.callBase();
                if (this === activeScrollbar)
                    activeScrollbar = null;
                this._$thumb.off("." + SCROLLBAR)
            },
            _optionChanged: function(args) {
                if (this._isHidden())
                    return;
                switch (args.name) {
                    case"containerSize":
                    case"contentSize":
                        this.option()[args.name] = this._normalizeSize(args.value);
                        this._update();
                        break;
                    case"visibilityMode":
                    case"direction":
                        this._invalidate();
                        break;
                    default:
                        this.callBase.apply(this, arguments)
                }
            }
        }));
        var activeScrollbar = null;
        $(document).on(events.addNamespace("dxpointerup", SCROLLBAR), function() {
            if (activeScrollbar)
                activeScrollbar.feedbackOff()
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollable.native.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            utils = DX.utils,
            devices = DX.devices,
            abs = Math.abs;
        var SCROLLABLE_NATIVE = "dxNativeScrollable",
            SCROLLABLE_NATIVE_CLASS = "dx-scrollable-native",
            SCROLLABLE_SCROLLBAR_SIMULATED = "dx-scrollable-scrollbar-simulated",
            SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden",
            VERTICAL = "vertical",
            HORIZONTAL = "horizontal",
            HIDE_SCROLLBAR_TIMOUT = 500;
        ui.dxScrollable.NativeStrategy = DX.Class.inherit({
            ctor: function(scrollable) {
                this._init(scrollable)
            },
            _init: function(scrollable) {
                this._component = scrollable;
                this._$element = scrollable.element();
                this._$container = scrollable._$container;
                this._$content = scrollable._$content;
                this._direction = scrollable.option("direction");
                this._useSimulatedScrollbar = scrollable.option("useSimulatedScrollbar");
                this._showScrollbar = scrollable.option("showScrollbar");
                this.option = $.proxy(scrollable.option, scrollable);
                this._createActionByOption = $.proxy(scrollable._createActionByOption, scrollable);
                this._isLocked = $.proxy(scrollable._isLocked, scrollable);
                this._isDirection = $.proxy(scrollable._isDirection, scrollable);
                this._allowedDirection = $.proxy(scrollable._allowedDirection, scrollable)
            },
            render: function() {
                this._$element.addClass(SCROLLABLE_NATIVE_CLASS).addClass(SCROLLABLE_NATIVE_CLASS + "-" + devices.real().platform).toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this._showScrollbar);
                if (this._showScrollbar && this._useSimulatedScrollbar)
                    this._renderScrollbars()
            },
            _renderScrollbars: function() {
                this._scrollbars = {};
                this._hideScrollbarTimeout = 0;
                this._$element.addClass(SCROLLABLE_SCROLLBAR_SIMULATED);
                this._renderScrollbar(VERTICAL);
                this._renderScrollbar(HORIZONTAL)
            },
            _renderScrollbar: function(direction) {
                if (!this._isDirection(direction))
                    return;
                var $scrollbar = $("<div>").dxScrollbar({direction: direction}).appendTo(this._$element);
                this._scrollbars[direction] = $scrollbar.dxScrollbar("instance")
            },
            handleInit: $.noop,
            handleStart: $.noop,
            handleMove: function(e) {
                if (this._isLocked()) {
                    e.cancel = true;
                    return
                }
                if (this._allowedDirection())
                    e.originalEvent.isScrollingEvent = true
            },
            handleEnd: $.noop,
            handleStop: $.noop,
            _eachScrollbar: function(callback) {
                callback = $.proxy(callback, this);
                $.each(this._scrollbars || {}, function(direction, scrollbar) {
                    callback(scrollbar, direction)
                })
            },
            createActions: function() {
                this._scrollAction = this._createActionByOption("onScroll");
                this._updateAction = this._createActionByOption("onUpdated")
            },
            _createActionArgs: function() {
                var location = this.location();
                return {
                        jQueryEvent: this._eventForUserAction,
                        scrollOffset: {
                            top: -location.top,
                            left: -location.left
                        },
                        reachedLeft: this._isDirection(HORIZONTAL) ? location.left >= 0 : undefined,
                        reachedRight: this._isDirection(HORIZONTAL) ? location.left <= this._containerSize.width - this._componentContentSize.width : undefined,
                        reachedTop: this._isDirection(VERTICAL) ? location.top >= 0 : undefined,
                        reachedBottom: this._isDirection(VERTICAL) ? location.top <= this._containerSize.height - this._componentContentSize.height : undefined
                    }
            },
            handleScroll: function(e) {
                if (!this._isScrollLocationChanged()) {
                    e.stopImmediatePropagation();
                    return
                }
                this._eventForUserAction = e;
                this._moveScrollbars();
                this._scrollAction(this._createActionArgs());
                this._lastLocation = this.location();
                this._pushBackFromBoundary()
            },
            _pushBackFromBoundary: function() {
                var pushBackValue = this.option("pushBackValue");
                if (!pushBackValue)
                    return;
                var scrollOffset = this._containerSize.height - this._contentSize.height,
                    scrollTopPos = this._$container.scrollTop(),
                    scrollBottomPos = scrollOffset + scrollTopPos - pushBackValue * 2;
                if (!scrollTopPos)
                    this._$container.scrollTop(pushBackValue);
                else if (!scrollBottomPos)
                    this._$container.scrollTop(pushBackValue - scrollOffset)
            },
            _isScrollLocationChanged: function() {
                var currentLocation = this.location(),
                    lastLocation = this._lastLocation || {},
                    isTopChanged = lastLocation.top !== currentLocation.top,
                    isLeftChanged = lastLocation.left !== currentLocation.left;
                return isTopChanged || isLeftChanged
            },
            _moveScrollbars: function() {
                this._eachScrollbar(function(scrollbar) {
                    scrollbar.moveTo(this.location());
                    scrollbar.option("visible", true)
                });
                this._hideScrollbars()
            },
            _hideScrollbars: function() {
                clearTimeout(this._hideScrollbarTimeout);
                this._hideScrollbarTimeout = setTimeout($.proxy(function() {
                    this._eachScrollbar(function(scrollbar) {
                        scrollbar.option("visible", false)
                    })
                }, this), HIDE_SCROLLBAR_TIMOUT)
            },
            location: function() {
                return {
                        left: -this._$container.scrollLeft(),
                        top: this.option("pushBackValue") - this._$container.scrollTop()
                    }
            },
            disabledChanged: $.noop,
            update: function() {
                this._update();
                this._updateAction(this._createActionArgs())
            },
            _update: function() {
                this._updateDimensions();
                this._updateScrollbars()
            },
            _updateDimensions: function() {
                this._containerSize = {
                    height: this._$container.height(),
                    width: this._$container.width()
                };
                this._componentContentSize = {
                    height: this._component.content().height(),
                    width: this._component.content().width()
                };
                this._contentSize = {
                    height: this._$content.height(),
                    width: this._$content.width()
                };
                this._pushBackFromBoundary()
            },
            _updateScrollbars: function() {
                this._eachScrollbar(function(scrollbar, direction) {
                    var dimension = direction === VERTICAL ? "height" : "width";
                    scrollbar.option({
                        containerSize: this._containerSize[dimension],
                        contentSize: this._componentContentSize[dimension]
                    })
                })
            },
            _allowedDirections: function() {
                return {
                        vertical: this._isDirection(VERTICAL) && this._contentSize.height > this._containerSize.height,
                        horizontal: this._isDirection(HORIZONTAL) && this._contentSize.width > this._containerSize.width
                    }
            },
            dispose: function() {
                this._$element.removeClass(function(index, className) {
                    var scrollableNativeRegexp = new RegExp(SCROLLABLE_NATIVE_CLASS + "\\S*", "g");
                    if (scrollableNativeRegexp.test(className))
                        return className.match(scrollableNativeRegexp).join(" ")
                });
                this._$element.off("." + SCROLLABLE_NATIVE);
                this._$container.off("." + SCROLLABLE_NATIVE);
                this._removeScrollbars();
                clearTimeout(this._gestureEndTimer)
            },
            _removeScrollbars: function() {
                this._eachScrollbar(function(scrollbar) {
                    scrollbar.element().remove()
                })
            },
            scrollBy: function(distance) {
                var location = this.location();
                this._$container.scrollTop(-location.top - distance.top + this.option("pushBackValue"));
                this._$container.scrollLeft(-location.left - distance.left)
            },
            validate: function() {
                return !this.option("disabled") && this._allowedDirection()
            },
            getDirection: function() {
                return this._allowedDirection()
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollable.simulated.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            math = Math;
        var realDevice = DX.devices.real;
        var isSluggishPlatform = realDevice.platform === "win8" || realDevice.platform === "android";
        var SCROLLABLE_SIMULATED = "dxSimulatedScrollable",
            SCROLLABLE_STRATEGY = "dxScrollableStrategy",
            SCROLLABLE_SIMULATED_CURSOR = SCROLLABLE_SIMULATED + "Cursor",
            SCROLLABLE_SIMULATED_KEYBOARD = SCROLLABLE_SIMULATED + "Keyboard",
            SCROLLABLE_SIMULATED_CLASS = "dx-scrollable-simulated",
            SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden",
            SCROLLABLE_SCROLLBAR_CLASS = "dx-scrollable-scrollbar",
            VERTICAL = "vertical",
            HORIZONTAL = "horizontal",
            ACCELERATION = isSluggishPlatform ? 0.95 : 0.92,
            OUT_BOUNDS_ACCELERATION = 0.5,
            MIN_VELOCITY_LIMIT = 1,
            FRAME_DURATION = math.round(1000 / 60),
            SCROLL_LINE_HEIGHT = 20,
            BOUNCE_MIN_VELOCITY_LIMIT = MIN_VELOCITY_LIMIT / 5,
            BOUNCE_DURATION = isSluggishPlatform ? 300 : 400,
            BOUNCE_FRAMES = BOUNCE_DURATION / FRAME_DURATION,
            BOUNCE_ACCELERATION_SUM = (1 - math.pow(ACCELERATION, BOUNCE_FRAMES)) / (1 - ACCELERATION);
        var KEY_CODES = {
                PAGE_UP: 33,
                PAGE_DOWN: 34,
                END: 35,
                HOME: 36,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40
            };
        var InertiaAnimator = DX.Animator.inherit({
                ctor: function(scroller) {
                    this.callBase();
                    this.scroller = scroller
                },
                VELOCITY_LIMIT: MIN_VELOCITY_LIMIT,
                _isFinished: function() {
                    return math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT
                },
                _step: function() {
                    this.scroller._scrollStep(this.scroller._velocity);
                    this.scroller._velocity *= this._acceleration()
                },
                _acceleration: function() {
                    return this.scroller._inBounds() ? ACCELERATION : OUT_BOUNDS_ACCELERATION
                },
                _complete: function() {
                    this.scroller._scrollComplete()
                },
                _stop: function() {
                    this.scroller._stopComplete()
                }
            });
        var BounceAnimator = InertiaAnimator.inherit({
                VELOCITY_LIMIT: BOUNCE_MIN_VELOCITY_LIMIT,
                _isFinished: function() {
                    return this.scroller._crossBoundOnNextStep() || this.callBase()
                },
                _acceleration: function() {
                    return ACCELERATION
                },
                _complete: function() {
                    this.scroller._move(this.scroller._bounceLocation);
                    this.callBase()
                }
            });
        var isWheelEvent = function(e) {
                return e.type === "dxmousewheel"
            };
        var Scroller = ui.dxScrollable.Scroller = DX.Class.inherit({
                ctor: function(options) {
                    this._initOptions(options);
                    this._initAnimators();
                    this._initScrollbar()
                },
                _initOptions: function(options) {
                    this._location = 0;
                    this._topReached = false;
                    this._bottomReached = false;
                    this._axis = options.direction === HORIZONTAL ? "x" : "y";
                    this._prop = options.direction === HORIZONTAL ? "left" : "top";
                    this._dimension = options.direction === HORIZONTAL ? "width" : "height";
                    this._scrollProp = options.direction === HORIZONTAL ? "scrollLeft" : "scrollTop";
                    $.each(options, $.proxy(function(optionName, optionValue) {
                        this["_" + optionName] = optionValue
                    }, this))
                },
                _initAnimators: function() {
                    this._inertiaAnimator = new InertiaAnimator(this);
                    this._bounceAnimator = new BounceAnimator(this)
                },
                _initScrollbar: function() {
                    this._$scrollbar = $("<div>").dxScrollbar({
                        direction: this._direction,
                        visible: this._scrollByThumb,
                        visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),
                        containerSize: this._containerSize(),
                        contentSize: this._contentSize()
                    }).appendTo(this._$container);
                    this._scrollbar = this._$scrollbar.dxScrollbar("instance")
                },
                _visibilityModeNormalize: function(mode) {
                    return mode === true ? "onScroll" : mode === false ? "never" : mode
                },
                _scrollStep: function(delta) {
                    var prevLocation = this._location;
                    this._location += delta;
                    this._suppressBounce();
                    this._move();
                    if (prevLocation !== this._location) {
                        this._scrollAction();
                        this._$container.triggerHandler("scroll")
                    }
                },
                _suppressBounce: function() {
                    if (this._bounceEnabled || this._inBounds(this._location))
                        return;
                    this._velocity = 0;
                    this._location = this._boundLocation()
                },
                _boundLocation: function() {
                    var location = math.min(this._location, this._maxOffset);
                    return math.max(location, this._minOffset)
                },
                _move: function(location) {
                    this._location = location !== undefined ? location : this._location;
                    this._moveContent();
                    this._moveScrollbar()
                },
                _moveContent: function() {
                    var targetLocation = {};
                    targetLocation[this._prop] = this._location;
                    DX.translator.move(this._$content, targetLocation)
                },
                _moveScrollbar: function() {
                    this._scrollbar.moveTo(this._location)
                },
                _scrollComplete: function() {
                    if (this._inBounds()) {
                        this._hideScrollbar();
                        this._correctLocation();
                        if (this._completeDeferred)
                            this._completeDeferred.resolve()
                    }
                    this._scrollToBounds()
                },
                _correctLocation: function() {
                    this._location = math.round(this._location);
                    this._move()
                },
                _scrollToBounds: function() {
                    if (this._inBounds())
                        return;
                    this._bounceAction();
                    this._setupBounce();
                    this._bounceAnimator.start()
                },
                _setupBounce: function() {
                    var boundLocation = this._bounceLocation = this._boundLocation(),
                        bounceDistance = boundLocation - this._location;
                    this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM
                },
                _inBounds: function(location) {
                    location = location !== undefined ? location : this._location;
                    return location >= this._minOffset && location <= this._maxOffset
                },
                _crossBoundOnNextStep: function() {
                    var location = this._location,
                        nextLocation = location + this._velocity;
                    return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset
                },
                _initHandler: function(e) {
                    this._stopDeferred = $.Deferred();
                    this._stopScrolling();
                    this._prepareThumbScrolling(e);
                    return this._stopDeferred.promise()
                },
                _stopScrolling: function() {
                    this._hideScrollbar();
                    this._inertiaAnimator.stop();
                    this._bounceAnimator.stop()
                },
                _prepareThumbScrolling: function(e) {
                    if (isWheelEvent(e.originalEvent))
                        return;
                    var $target = $(e.originalEvent.target);
                    var scrollbarClicked = this._isScrollbar($target);
                    if (scrollbarClicked)
                        this._moveToMouseLocation(e);
                    this._thumbScrolling = scrollbarClicked || this._isThumb($target);
                    if (this._thumbScrolling)
                        this._scrollbar.feedbackOn()
                },
                _moveToMouseLocation: function(e) {
                    var mouseLocation = e["page" + this._axis.toUpperCase()] - this._$element.offset()[this._prop];
                    var location = this._location + mouseLocation / this._containerToContentRatio() - this._$container.height() / 2;
                    this._scrollStep(-location)
                },
                _stopComplete: function() {
                    if (this._stopDeferred)
                        this._stopDeferred.resolve()
                },
                _startHandler: function() {
                    this._showScrollbar()
                },
                _moveHandler: function(delta) {
                    delta = delta[this._axis];
                    if (this._thumbScrolling)
                        delta = -delta / this._containerToContentRatio();
                    if (!this._inBounds())
                        delta *= OUT_BOUNDS_ACCELERATION;
                    this._scrollStep(delta)
                },
                _containerToContentRatio: function() {
                    return this._scrollbar.containerToContentRatio()
                },
                _endHandler: function(velocity) {
                    this._completeDeferred = $.Deferred();
                    this._velocity = velocity[this._axis];
                    this._inertiaHandler();
                    this._resetThumbScrolling();
                    return this._completeDeferred.promise()
                },
                _inertiaHandler: function() {
                    this._suppressIntertia();
                    this._inertiaAnimator.start()
                },
                _suppressIntertia: function() {
                    if (!this._inertiaEnabled || this._thumbScrolling)
                        this._velocity = 0
                },
                _resetThumbScrolling: function() {
                    this._thumbScrolling = false
                },
                _stopHandler: function() {
                    this._resetThumbScrolling();
                    this._scrollToBounds()
                },
                _disposeHandler: function() {
                    this._stopScrolling();
                    this._$scrollbar.remove()
                },
                _updateHandler: function() {
                    this._update();
                    this._moveToBounds()
                },
                _update: function() {
                    this._stopScrolling();
                    this._updateLocation();
                    this._updateBounds();
                    this._updateScrollbar();
                    this._moveScrollbar();
                    this._updateScrollbarVisibility()
                },
                _updateLocation: function() {
                    this._location = DX.translator.locate(this._$content)[this._prop]
                },
                _updateBounds: function() {
                    this._maxOffset = 0;
                    this._minOffset = math.min(this._containerSize() - this._contentSize(), 0)
                },
                _updateScrollbar: function() {
                    this._scrollbar.option({
                        containerSize: this._containerSize(),
                        contentSize: this._contentSize()
                    })
                },
                _updateScrollbarVisibility: function() {
                    this._showScrollbar();
                    this._hideScrollbar()
                },
                _moveToBounds: function() {
                    this._location = this._boundLocation();
                    this._move()
                },
                _createActionsHandler: function(actions) {
                    this._scrollAction = actions.scroll;
                    this._bounceAction = actions.bounce
                },
                _showScrollbar: function() {
                    this._scrollbar.option("visible", true)
                },
                _hideScrollbar: function() {
                    this._scrollbar.option("visible", false)
                },
                _containerSize: function() {
                    return this._$container[this._dimension]()
                },
                _contentSize: function() {
                    return this._$content[this._dimension]()
                },
                _validateEvent: function(e) {
                    var $target = $(e.originalEvent.target);
                    if (this._isThumb($target) || this._isScrollbar($target)) {
                        e.preventDefault();
                        return true
                    }
                    return this._isContent($target)
                },
                _isThumb: function($element) {
                    return this._scrollByThumb && this._scrollbar.isThumb($element)
                },
                _isScrollbar: function($element) {
                    return this._scrollByThumb && $element && $element.is(this._$scrollbar)
                },
                _isContent: function($element) {
                    return this._scrollByContent && !!$element.closest(this._$element).length
                },
                _reachedMin: function() {
                    return this._location <= this._minOffset
                },
                _reachedMax: function() {
                    return this._location >= this._maxOffset
                },
                _cursorEnterHandler: function() {
                    this._scrollbar.cursorEnter()
                },
                _cursorLeaveHandler: function() {
                    this._scrollbar.cursorLeave()
                }
            });
        var hoveredScrollable,
            activeScrollable;
        ui.dxScrollable.SimulatedStrategy = DX.Class.inherit({
            ctor: function(scrollable) {
                this._init(scrollable)
            },
            _init: function(scrollable) {
                this._component = scrollable;
                this._$element = scrollable.element();
                this._$container = scrollable._$container;
                this._$content = scrollable._$content;
                this.option = $.proxy(scrollable.option, scrollable);
                this._createActionByOption = $.proxy(scrollable._createActionByOption, scrollable);
                this._isLocked = $.proxy(scrollable._isLocked, scrollable);
                this._isDirection = $.proxy(scrollable._isDirection, scrollable);
                this._allowedDirection = $.proxy(scrollable._allowedDirection, scrollable)
            },
            render: function() {
                this._$element.addClass(SCROLLABLE_SIMULATED_CLASS);
                this._createScrollers();
                if (this.option("useKeyboard"))
                    this._$container.prop("tabindex", 0);
                this._attachKeyboardHandler();
                this._attachCursorHandlers()
            },
            _createScrollers: function() {
                this._scrollers = {};
                if (this._isDirection(HORIZONTAL))
                    this._createScroller(HORIZONTAL);
                if (this._isDirection(VERTICAL))
                    this._createScroller(VERTICAL);
                this._$element.toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this.option("showScrollbar"))
            },
            _createScroller: function(direction) {
                this._scrollers[direction] = new Scroller(this._scrollerOptions(direction))
            },
            _scrollerOptions: function(direction) {
                return {
                        direction: direction,
                        $content: this._$content,
                        $container: this._$container,
                        $element: this._$element,
                        scrollByContent: this.option("scrollByContent"),
                        scrollByThumb: this.option("scrollByThumb"),
                        scrollbarVisible: this.option("showScrollbar"),
                        bounceEnabled: this.option("bounceEnabled"),
                        inertiaEnabled: this.option("inertiaEnabled")
                    }
            },
            handleInit: function(e) {
                this._supressDirections(e);
                this._eventForUserAction = e;
                this._eventHandler("init", e).done(this._stopAction)
            },
            _supressDirections: function(e) {
                if (isWheelEvent(e.originalEvent)) {
                    this._prepareDirections(true);
                    return
                }
                this._prepareDirections();
                this._eachScroller(function(scroller, direction) {
                    var isValid = scroller._validateEvent(e);
                    this._validDirections[direction] = isValid
                })
            },
            _prepareDirections: function(value) {
                value = value || false;
                this._validDirections = {};
                this._validDirections[HORIZONTAL] = value;
                this._validDirections[VERTICAL] = value
            },
            _eachScroller: function(callback) {
                callback = $.proxy(callback, this);
                $.each(this._scrollers, function(direction, scroller) {
                    callback(scroller, direction)
                })
            },
            handleStart: function(e) {
                this._saveActive();
                this._eventHandler("start").done(this._startAction)
            },
            _saveActive: function() {
                activeScrollable = this
            },
            _resetActive: function() {
                activeScrollable = null
            },
            _validateDirection: function(delta) {
                var result = false;
                this._eachScroller(function(scroller) {
                    result = result || scroller._validateDirection(delta)
                });
                return result
            },
            handleMove: function(e) {
                if (this._isLocked()) {
                    e.cancel = true;
                    this._resetActive();
                    return
                }
                e.preventDefault && e.preventDefault();
                this._adjustDistance(e.delta);
                this._eventForUserAction = e;
                this._eventHandler("move", e.delta)
            },
            _adjustDistance: function(distance) {
                distance.x *= this._validDirections[HORIZONTAL];
                distance.y *= this._validDirections[VERTICAL]
            },
            handleEnd: function(e) {
                this._resetActive();
                this._refreshCursorState(e.originalEvent && e.originalEvent.target);
                this._adjustDistance(e.velocity);
                this._eventForUserAction = e;
                return this._eventHandler("end", e.velocity).done(this._endAction)
            },
            handleCancel: function(e) {
                this._resetActive();
                this._eventForUserAction = e;
                return this._eventHandler("end", {
                        x: 0,
                        y: 0
                    })
            },
            handleStop: function() {
                this._resetActive();
                this._eventHandler("stop")
            },
            handleScroll: function() {
                var distance = {
                        left: -this._$container.scrollLeft(),
                        top: -this._$container.scrollTop()
                    };
                this._$container.scrollLeft(0);
                this._$container.scrollTop(0);
                if (distance.left || distance.top)
                    this.scrollBy(distance)
            },
            _attachKeyboardHandler: function() {
                this._$element.off("." + SCROLLABLE_SIMULATED_KEYBOARD);
                if (!this.option("disabled") && this.option("useKeyboard"))
                    this._$element.on(events.addNamespace("keydown", SCROLLABLE_SIMULATED_KEYBOARD), $.proxy(this._keyDownHandler, this))
            },
            _keyDownHandler: function(e) {
                if (!this._$container.is(document.activeElement))
                    return;
                var handled = true;
                switch (e.keyCode) {
                    case KEY_CODES.DOWN:
                        this._scrollByLine({y: 1});
                        break;
                    case KEY_CODES.UP:
                        this._scrollByLine({y: -1});
                        break;
                    case KEY_CODES.RIGHT:
                        this._scrollByLine({x: 1});
                        break;
                    case KEY_CODES.LEFT:
                        this._scrollByLine({x: -1});
                        break;
                    case KEY_CODES.PAGE_DOWN:
                        this._scrollByPage(1);
                        break;
                    case KEY_CODES.PAGE_UP:
                        this._scrollByPage(-1);
                        break;
                    case KEY_CODES.HOME:
                        this._scrollToHome();
                        break;
                    case KEY_CODES.END:
                        this._scrollToEnd();
                        break;
                    default:
                        handled = false;
                        break
                }
                if (handled) {
                    e.stopPropagation();
                    e.preventDefault()
                }
            },
            _scrollByLine: function(lines) {
                this.scrollBy({
                    top: (lines.y || 0) * -SCROLL_LINE_HEIGHT,
                    left: (lines.x || 0) * -SCROLL_LINE_HEIGHT
                })
            },
            _scrollByPage: function(page) {
                var prop = this._wheelProp(),
                    dimension = this._dimensionByProp(prop);
                var distance = {};
                distance[prop] = page * -this._$container[dimension]();
                this.scrollBy(distance)
            },
            _dimensionByProp: function(prop) {
                return prop === "left" ? "width" : "height"
            },
            _scrollToHome: function() {
                var prop = this._wheelProp();
                var distance = {};
                distance[prop] = 0;
                this._component.scrollTo(distance)
            },
            _scrollToEnd: function() {
                var prop = this._wheelProp(),
                    dimension = this._dimensionByProp(prop);
                var distance = {};
                distance[prop] = this._$content[dimension]() - this._$container[dimension]();
                this._component.scrollTo(distance)
            },
            createActions: function() {
                this._startAction = this._createActionHandler("onStart");
                this._stopAction = this._createActionHandler("onStop");
                this._endAction = this._createActionHandler("onEnd");
                this._updateAction = this._createActionHandler("onUpdated");
                this._createScrollerActions()
            },
            _createScrollerActions: function() {
                this._eventHandler("createActions", {
                    scroll: this._createActionHandler("onScroll"),
                    bounce: this._createActionHandler("onBounce")
                })
            },
            _createActionHandler: function(optionName) {
                var that = this,
                    actionHandler = that._createActionByOption(optionName);
                return function() {
                        actionHandler($.extend(that._createActionArgs(), arguments))
                    }
            },
            _createActionArgs: function() {
                var scrollerX = this._scrollers[HORIZONTAL],
                    scrollerY = this._scrollers[VERTICAL];
                return {
                        jQueryEvent: this._eventForUserAction,
                        scrollOffset: {
                            top: scrollerY && -scrollerY._location,
                            left: scrollerX && -scrollerX._location
                        },
                        reachedLeft: scrollerX && scrollerX._reachedMax(),
                        reachedRight: scrollerX && scrollerX._reachedMin(),
                        reachedTop: scrollerY && scrollerY._reachedMax(),
                        reachedBottom: scrollerY && scrollerY._reachedMin()
                    }
            },
            _eventHandler: function(eventName) {
                var args = $.makeArray(arguments).slice(1),
                    deferreds = $.map(this._scrollers, function(scroller) {
                        return scroller["_" + eventName + "Handler"].apply(scroller, args)
                    });
                return $.when.apply($, deferreds).promise()
            },
            location: function() {
                return DX.translator.locate(this._$content)
            },
            disabledChanged: function() {
                this._attachCursorHandlers()
            },
            _attachCursorHandlers: function() {
                this._$element.off("." + SCROLLABLE_SIMULATED_CURSOR);
                if (!this.option("disabled") && this._isHoverMode())
                    this._$element.on(events.addNamespace("mouseenter", SCROLLABLE_SIMULATED_CURSOR), $.proxy(this._cursorEnterHandler, this)).on(events.addNamespace("mouseleave", SCROLLABLE_SIMULATED_CURSOR), $.proxy(this._cursorLeaveHandler, this))
            },
            _isHoverMode: function() {
                return this.option("showScrollbar") === "onHover"
            },
            _cursorEnterHandler: function(e) {
                e = e || {};
                e.originalEvent = e.originalEvent || {};
                if (activeScrollable || e.originalEvent._hoverHandled)
                    return;
                if (hoveredScrollable)
                    hoveredScrollable._cursorLeaveHandler();
                hoveredScrollable = this;
                this._eventHandler("cursorEnter");
                e.originalEvent._hoverHandled = true
            },
            _cursorLeaveHandler: function(e) {
                if (hoveredScrollable !== this || activeScrollable === hoveredScrollable)
                    return;
                this._eventHandler("cursorLeave");
                hoveredScrollable = null;
                this._refreshCursorState(e && e.relatedTarget)
            },
            _refreshCursorState: function(target) {
                if (!this._isHoverMode() && (!target || activeScrollable))
                    return;
                var $target = $(target);
                var $scrollable = $target.closest("." + SCROLLABLE_SIMULATED_CLASS + ":not(.dx-state-disabled)");
                var targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);
                if (hoveredScrollable && hoveredScrollable !== targetScrollable)
                    hoveredScrollable._cursorLeaveHandler();
                if (targetScrollable)
                    targetScrollable._cursorEnterHandler()
            },
            update: function() {
                return this._eventHandler("update").done(this._updateAction)
            },
            _allowedDirections: function() {
                var bounceEnabled = this.option("bounceEnabled");
                return {
                        vertical: this._isDirection(VERTICAL) && (this._scrollers[VERTICAL]._minOffset < 0 || bounceEnabled),
                        horizontal: this._isDirection(HORIZONTAL) && (this._scrollers[HORIZONTAL]._minOffset < 0 || bounceEnabled)
                    }
            },
            scrollBy: function(distance) {
                this._prepareDirections(true);
                this._eventHandler("start").done(this._startAction);
                this._eventHandler("move", {
                    x: distance.left,
                    y: distance.top
                });
                this._eventHandler("end", {
                    x: 0,
                    y: 0
                }).done(this._endAction)
            },
            validate: function(e) {
                if (this.option("disabled"))
                    return false;
                if (this.option("bounceEnabled"))
                    return true;
                return isWheelEvent(e) ? this._validateWheel(e) : this._validateMove(e)
            },
            _validateWheel: function(e) {
                var scroller = this._scrollers[this._wheelDirection()];
                var reachedMin = scroller._reachedMin();
                var reachedMax = scroller._reachedMax();
                var contentGreaterThanContainer = !reachedMin || !reachedMax;
                var locatedNotAtBound = !reachedMin && !reachedMax;
                var scrollFromMin = reachedMin && e.delta > 0;
                var scrollFromMax = reachedMax && e.delta < 0;
                return contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax)
            },
            _validateMove: function(e) {
                if (!this.option("scrollByContent") && !$(e.target).closest("." + SCROLLABLE_SCROLLBAR_CLASS).length)
                    return false;
                return this._allowedDirection()
            },
            getDirection: function(e) {
                return isWheelEvent(e) ? this._wheelDirection() : this._allowedDirection()
            },
            _wheelProp: function() {
                return this._wheelDirection() === HORIZONTAL ? "left" : "top"
            },
            _wheelDirection: function() {
                switch (this.option("direction")) {
                    case HORIZONTAL:
                        return HORIZONTAL;
                    case VERTICAL:
                        return VERTICAL;
                    default:
                        return this._scrollers[VERTICAL]._containerToContentRatio() >= 1 ? HORIZONTAL : VERTICAL
                }
            },
            dispose: function() {
                if (activeScrollable === this)
                    activeScrollable = null;
                if (hoveredScrollable === this)
                    hoveredScrollable = null;
                this._eventHandler("dispose");
                this._detachEventHandlers();
                this._$element.removeClass(SCROLLABLE_SIMULATED_CLASS);
                this._eventForUserAction = null;
                clearTimeout(this._gestureEndTimer)
            },
            _detachEventHandlers: function() {
                this._$element.off("." + SCROLLABLE_SIMULATED_CURSOR);
                this._$container.off("." + SCROLLABLE_SIMULATED_KEYBOARD)
            }
        });
        ui.dxScrollable.__internals = $.extend(ui.dxScrollable.__internals || {}, {
            ACCELERATION: ACCELERATION,
            MIN_VELOCITY_LIMIT: MIN_VELOCITY_LIMIT,
            FRAME_DURATION: FRAME_DURATION,
            SCROLL_LINE_HEIGHT: SCROLL_LINE_HEIGHT
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollView.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var SCROLLVIEW_CLASS = "dx-scrollview",
            SCROLLVIEW_CONTENT_CLASS = SCROLLVIEW_CLASS + "-content",
            SCROLLVIEW_TOP_POCKET_CLASS = SCROLLVIEW_CLASS + "-top-pocket",
            SCROLLVIEW_BOTTOM_POCKET_CLASS = SCROLLVIEW_CLASS + "-bottom-pocket",
            SCROLLVIEW_PULLDOWN_CLASS = SCROLLVIEW_CLASS + "-pull-down",
            SCROLLVIEW_PULLDOWN_IMAGE_CLASS = SCROLLVIEW_PULLDOWN_CLASS + "-image",
            SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = SCROLLVIEW_PULLDOWN_CLASS + "-indicator",
            SCROLLVIEW_PULLDOWN_TEXT_CLASS = SCROLLVIEW_PULLDOWN_CLASS + "-text",
            SCROLLVIEW_REACHBOTTOM_CLASS = SCROLLVIEW_CLASS + "-scrollbottom",
            SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + "-indicator",
            SCROLLVIEW_REACHBOTTOM_TEXT_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + "-text",
            SCROLLVIEW_LOADPANEL = SCROLLVIEW_CLASS + "-loadpanel";
        DX.registerComponent("dxScrollView", ui, ui.dxScrollable.inherit({
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    pullDownAction: {
                        since: "14.2",
                        alias: "onPullDown"
                    },
                    reachBottomAction: {
                        since: "14.2",
                        alias: "onReachBottom"
                    }
                })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    pullingDownText: Globalize.localize("dxScrollView-pullingDownText"),
                    pulledDownText: Globalize.localize("dxScrollView-pulledDownText"),
                    refreshingText: Globalize.localize("dxScrollView-refreshingText"),
                    reachBottomText: Globalize.localize("dxScrollView-reachBottomText"),
                    onPullDown: null,
                    onReachBottom: null,
                    refreshStrategy: "pullDown"
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DevExpress.devices.real().platform === "android"
                            },
                            options: {refreshStrategy: "swipeDown"}
                        }, {
                            device: function(device) {
                                return DevExpress.devices.real().platform === "win8"
                            },
                            options: {refreshStrategy: "slideDown"}
                        }])
            },
            _init: function() {
                this.callBase();
                this._loadingIndicatorEnabled = true
            },
            _initMarkup: function() {
                this.callBase();
                this.element().addClass(SCROLLVIEW_CLASS);
                this._initContent();
                this._initTopPocket();
                this._initBottomPocket();
                this._initLoadPanel()
            },
            _initContent: function() {
                var $content = $("<div>").addClass(SCROLLVIEW_CONTENT_CLASS);
                this._$content.wrapInner($content)
            },
            _initTopPocket: function() {
                var $topPocket = this._$topPocket = $("<div>").addClass(SCROLLVIEW_TOP_POCKET_CLASS),
                    $pullDown = this._$pullDown = $("<div>").addClass(SCROLLVIEW_PULLDOWN_CLASS);
                $topPocket.append($pullDown);
                this._$content.prepend($topPocket)
            },
            _initBottomPocket: function() {
                var $bottomPocket = this._$bottomPocket = $("<div>").addClass(SCROLLVIEW_BOTTOM_POCKET_CLASS),
                    $reachBottom = this._$reachBottom = $("<div>").addClass(SCROLLVIEW_REACHBOTTOM_CLASS),
                    $loadContainer = $("<div>").addClass(SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS),
                    $loadIndicator = $("<div>").dxLoadIndicator(),
                    $text = this._$reachBottomText = $("<div>").addClass(SCROLLVIEW_REACHBOTTOM_TEXT_CLASS);
                this._updateReachBottomText();
                $reachBottom.append($loadContainer.append($loadIndicator)).append($text);
                $bottomPocket.append($reachBottom);
                this._$content.append($bottomPocket)
            },
            _initLoadPanel: function() {
                this._loadPanel = $("<div>").addClass(SCROLLVIEW_LOADPANEL).appendTo(this.element()).dxLoadPanel({
                    shading: false,
                    delay: 400,
                    position: {of: this.element()}
                }).dxLoadPanel("instance")
            },
            _updateReachBottomText: function() {
                this._$reachBottomText.text(this.option("reachBottomText"))
            },
            _createStrategy: function() {
                var strategyName = this.option("useNative") ? this.option("refreshStrategy") : "simulated";
                var strategyClass = ui.dxScrollView.refreshStrategies[strategyName];
                if (!strategyClass)
                    throw Error("E1030", this.option("refreshStrategy"));
                this._strategy = new strategyClass(this);
                this._strategy.pullDownCallbacks.add($.proxy(this._pullDownHandler, this));
                this._strategy.releaseCallbacks.add($.proxy(this._releaseHandler, this));
                this._strategy.reachBottomCallbacks.add($.proxy(this._reachBottomHandler, this))
            },
            _createActions: function() {
                this.callBase();
                this._pullDownAction = this._createActionByOption("onPullDown");
                this._reachBottomAction = this._createActionByOption("onReachBottom");
                this._pullDownEnable(!!this.option("onPullDown") && !DX.designMode);
                this._reachBottomEnable(!!this.option("onReachBottom") && !DX.designMode)
            },
            _pullDownEnable: function(enabled) {
                if (arguments.length === 0)
                    return this._pullDownEnabled;
                this._$pullDown.toggle(enabled);
                this._strategy.pullDownEnable(enabled);
                this._pullDownEnabled = enabled
            },
            _reachBottomEnable: function(enabled) {
                if (arguments.length === 0)
                    return this._reachBottomEnabled;
                this._$reachBottom.toggle(enabled);
                this._strategy.reachBottomEnable(enabled);
                this._reachBottomEnabled = enabled
            },
            _pullDownHandler: function() {
                this._loadingIndicator(false);
                this._pullDownLoading()
            },
            _loadingIndicator: function(value) {
                if (arguments.length < 1)
                    return this._loadingIndicatorEnabled;
                this._loadingIndicatorEnabled = value
            },
            _pullDownLoading: function() {
                this.startLoading();
                this._pullDownAction()
            },
            _reachBottomHandler: function() {
                this._loadingIndicator(false);
                this._reachBottomLoading()
            },
            _reachBottomLoading: function() {
                this.startLoading();
                this._reachBottomAction()
            },
            _releaseHandler: function() {
                this.finishLoading();
                this._loadingIndicator(true)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"onPullDown":
                    case"onReachBottom":
                        this._createActions();
                        break;
                    case"pullingDownText":
                    case"pulledDownText":
                    case"refreshingText":
                    case"refreshStrategy":
                        this._invalidate();
                        break;
                    case"reachBottomText":
                        this._updateReachBottomText();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            content: function() {
                return this._$content.children().eq(1)
            },
            release: function(preventReachBottom) {
                if (preventReachBottom !== undefined)
                    this.toggleLoading(!preventReachBottom);
                return this._strategy.release()
            },
            toggleLoading: function(showOrHide) {
                this._reachBottomEnable(showOrHide)
            },
            isFull: function() {
                return this.content().height() >= this._$container.height()
            },
            refresh: function() {
                if (!this.option("onPullDown"))
                    return;
                this._strategy.pendingRelease();
                this._pullDownLoading()
            },
            startLoading: function() {
                if (this._loadingIndicator() && this.element().is(":visible"))
                    this._loadPanel.show();
                this.toggleLoading(this.isFull() && this._reachBottomEnable());
                this._lock()
            },
            finishLoading: function() {
                this._loadPanel.hide();
                this.toggleLoading(this.isFull() && this._reachBottomEnable());
                this._unlock()
            },
            _dispose: function() {
                this.callBase();
                if (this._loadPanel)
                    this._loadPanel.element().remove()
            }
        }));
        ui.dxScrollView.refreshStrategies = {}
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollView.native.pullDown.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            math = Math;
        var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-loading",
            SCROLLVIEW_PULLDOWN_READY_CLASS = "dx-scrollview-pull-down-ready",
            SCROLLVIEW_PULLDOWN_IMAGE_CLASS = "dx-scrollview-pull-down-image",
            SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator",
            SCROLLVIEW_PULLDOWN_TEXT_CLASS = "dx-scrollview-pull-down-text",
            STATE_RELEASED = 0,
            STATE_READY = 1,
            STATE_REFRESHING = 2,
            STATE_LOADING = 3;
        var PullDownNativeScrollViewStrategy = ui.dxScrollable.NativeStrategy.inherit({
                _init: function(scrollView) {
                    this.callBase(scrollView);
                    this._$topPocket = scrollView._$topPocket;
                    this._$pullDown = scrollView._$pullDown;
                    this._$bottomPocket = scrollView._$bottomPocket;
                    this._$refreshingText = scrollView._$refreshingText;
                    this._$scrollViewContent = scrollView.content();
                    this._initCallbacks()
                },
                _initCallbacks: function() {
                    this.pullDownCallbacks = $.Callbacks();
                    this.releaseCallbacks = $.Callbacks();
                    this.reachBottomCallbacks = $.Callbacks()
                },
                render: function() {
                    this.callBase();
                    this._renderPullDown();
                    this._releaseState()
                },
                _renderPullDown: function() {
                    var $image = $("<div>").addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS),
                        $loadContainer = $("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS),
                        $loadIndicator = $("<div>").dxLoadIndicator(),
                        $text = this._$pullDownText = $("<div>").addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
                    this._$pullingDownText = $("<div>").text(this.option("pullingDownText")).appendTo($text);
                    this._$pulledDownText = $("<div>").text(this.option("pulledDownText")).appendTo($text);
                    this._$refreshingText = $("<div>").text(this.option("refreshingText")).appendTo($text);
                    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text)
                },
                _releaseState: function() {
                    this._state = STATE_RELEASED;
                    this._refreshPullDownText()
                },
                _refreshPullDownText: function() {
                    this._$pullingDownText.css("opacity", this._state === STATE_RELEASED ? 1 : 0);
                    this._$pulledDownText.css("opacity", this._state === STATE_READY ? 1 : 0);
                    this._$refreshingText.css("opacity", this._state === STATE_REFRESHING ? 1 : 0)
                },
                update: function() {
                    this.callBase();
                    this._setTopPocketOffset()
                },
                _updateDimensions: function() {
                    this.callBase();
                    this._topPocketSize = this._$topPocket.height();
                    this._bottomPocketSize = this._$bottomPocket.height();
                    this._scrollOffset = this._$container.height() - this._$content.height()
                },
                _allowedDirections: function() {
                    var allowedDirections = this.callBase();
                    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
                    return allowedDirections
                },
                _setTopPocketOffset: function() {
                    this._$topPocket.css({top: -this._topPocketSize})
                },
                handleEnd: function() {
                    this._complete()
                },
                handleStop: function() {
                    this._complete()
                },
                _complete: function() {
                    if (this._state === STATE_READY) {
                        this._setPullDownOffset(this._topPocketSize);
                        clearTimeout(this._pullDownRefreshTimeout);
                        this._pullDownRefreshTimeout = setTimeout($.proxy(function() {
                            this._pullDownRefreshing()
                        }, this), 400)
                    }
                },
                _setPullDownOffset: function(offset) {
                    DX.translator.move(this._$topPocket, {top: offset});
                    DX.translator.move(this._$scrollViewContent, {top: offset})
                },
                handleScroll: function(e) {
                    this.callBase(e);
                    if (this._state === STATE_REFRESHING)
                        return;
                    this._location = this.location().top;
                    if (this._isPullDown())
                        this._pullDownReady();
                    else if (this._isReachBottom())
                        this._reachBottom();
                    else
                        this._stateReleased()
                },
                _isPullDown: function() {
                    return this._pullDownEnabled && this._location >= this._topPocketSize
                },
                _isReachBottom: function() {
                    return this._reachBottomEnabled && this._location <= this._scrollOffset + this._bottomPocketSize
                },
                _reachBottom: function() {
                    if (this._state === STATE_LOADING)
                        return;
                    this._state = STATE_LOADING;
                    this.reachBottomCallbacks.fire()
                },
                _pullDownReady: function() {
                    if (this._state === STATE_READY)
                        return;
                    this._state = STATE_READY;
                    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
                    this._refreshPullDownText()
                },
                _stateReleased: function() {
                    if (this._state === STATE_RELEASED)
                        return;
                    this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
                    this._releaseState()
                },
                _pullDownRefreshing: function() {
                    if (this._state === STATE_REFRESHING)
                        return;
                    this._state = STATE_REFRESHING;
                    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
                    this._refreshPullDownText();
                    this.pullDownCallbacks.fire()
                },
                pullDownEnable: function(enabled) {
                    this._pullDownEnabled = enabled
                },
                reachBottomEnable: function(enabled) {
                    this._reachBottomEnabled = enabled
                },
                pendingRelease: function() {
                    this._state = STATE_READY
                },
                release: function() {
                    var deferred = $.Deferred();
                    this._updateDimensions();
                    clearTimeout(this._releaseTimeout);
                    this._releaseTimeout = setTimeout($.proxy(function() {
                        this._setPullDownOffset(0);
                        this._stateReleased();
                        this.releaseCallbacks.fire();
                        this._updateAction();
                        deferred.resolve()
                    }, this), 400);
                    return deferred.promise()
                },
                dispose: function() {
                    clearTimeout(this._pullDownRefreshTimeout);
                    clearTimeout(this._releaseTimeout);
                    this.callBase()
                }
            });
        ui.dxScrollView.refreshStrategies.pullDown = PullDownNativeScrollViewStrategy
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollView.native.swipeDown.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            math = Math;
        var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-loading",
            SCROLLVIEW_OBSOLETE_ANDROID_CLASS = "dx-scrollview-obsolete-android-browser",
            PULLDOWN_HEIGHT = 160,
            STATE_RELEASED = 0,
            STATE_READY = 1,
            STATE_REFRESHING = 2,
            STATE_LOADING = 3,
            STATE_TOUCHED = 4,
            STATE_PULLED = 5;
        var SwipeDownNativeScrollViewStrategy = ui.dxScrollable.NativeStrategy.inherit({
                _init: function(scrollView) {
                    this.callBase(scrollView);
                    this._$topPocket = scrollView._$topPocket;
                    this._$bottomPocket = scrollView._$bottomPocket;
                    this._$pullDown = scrollView._$pullDown;
                    this._$scrollViewContent = scrollView.content();
                    this._initCallbacks();
                    this._releaseState();
                    this._location = 0
                },
                _initCallbacks: function() {
                    this.pullDownCallbacks = $.Callbacks();
                    this.releaseCallbacks = $.Callbacks();
                    this.reachBottomCallbacks = $.Callbacks()
                },
                render: function() {
                    this.callBase();
                    this._renderPullDown()
                },
                _renderPullDown: function() {
                    this._$pullDown.empty().append($("<div class='dx-scrollview-pulldown-pointer1'>")).append($("<div class='dx-scrollview-pulldown-pointer2'>")).append($("<div class='dx-scrollview-pulldown-pointer3'>")).append($("<div class='dx-scrollview-pulldown-pointer4'>"))
                },
                _releaseState: function() {
                    this._state = STATE_RELEASED;
                    this._$pullDown.css({
                        width: "0%",
                        opacity: 0
                    });
                    this._updateDimensions()
                },
                _updateDimensions: function() {
                    this.callBase();
                    this._topPocketSize = this._$topPocket.height();
                    this._bottomPocketSize = this._$bottomPocket.height();
                    this._scrollOffset = this._$container.height() - this._$content.height()
                },
                _allowedDirections: function() {
                    var allowedDirections = this.callBase();
                    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
                    return allowedDirections
                },
                handleInit: function(e) {
                    this.callBase(e);
                    if (this._state === STATE_RELEASED && this._location === 0) {
                        this._startClientY = events.eventData(e.originalEvent).y;
                        this._state = STATE_TOUCHED
                    }
                },
                handleMove: function(e) {
                    this.callBase(e);
                    this._deltaY = events.eventData(e.originalEvent).y - this._startClientY;
                    if (this._state === STATE_TOUCHED)
                        if (this._pullDownEnabled && this._deltaY > 0) {
                            e.preventDefault();
                            this._state = STATE_PULLED
                        }
                        else
                            this._complete();
                    if (this._state === STATE_PULLED) {
                        if (this._deltaY < 0) {
                            this._complete();
                            return
                        }
                        this._$pullDown.css({
                            opacity: 1,
                            width: math.min(math.abs(this._deltaY * 100 / PULLDOWN_HEIGHT), 100) + "%"
                        });
                        if (this._isPullDown())
                            this._pullDownRefreshing()
                    }
                },
                _isPullDown: function() {
                    return this._pullDownEnabled && this._deltaY >= PULLDOWN_HEIGHT
                },
                handleEnd: function() {
                    this._complete()
                },
                handleStop: function() {
                    this._complete()
                },
                _complete: function() {
                    if (this._state === STATE_TOUCHED || this._state === STATE_PULLED)
                        this._releaseState()
                },
                handleScroll: function(e) {
                    this.callBase(e);
                    if (this._state === STATE_REFRESHING)
                        return;
                    var currentLocation = this.location().top,
                        scrollDelta = this._location - currentLocation;
                    this._location = currentLocation;
                    if (scrollDelta > 0 && this._isReachBottom())
                        this._reachBottom();
                    else
                        this._stateReleased()
                },
                _isReachBottom: function() {
                    return this._reachBottomEnabled && this._location <= this._scrollOffset + this._bottomPocketSize
                },
                _reachBottom: function() {
                    this.reachBottomCallbacks.fire()
                },
                _stateReleased: function() {
                    if (this._state === STATE_RELEASED)
                        return;
                    this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS);
                    this._releaseState()
                },
                _pullDownRefreshing: function() {
                    if (this._state === STATE_REFRESHING)
                        return;
                    this._state = STATE_REFRESHING;
                    clearTimeout(this._pullDownRefreshTimeout);
                    this._pullDownRefreshTimeout = setTimeout($.proxy(function() {
                        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS);
                        this.pullDownCallbacks.fire()
                    }, this), 400)
                },
                pullDownEnable: function(enabled) {
                    this._$topPocket.toggle(enabled);
                    this._pullDownEnabled = enabled
                },
                reachBottomEnable: function(enabled) {
                    this._reachBottomEnabled = enabled
                },
                pendingRelease: function() {
                    this._state = STATE_READY
                },
                release: function() {
                    var deferred = $.Deferred();
                    this._updateDimensions();
                    clearTimeout(this._releaseTimeout);
                    this._releaseTimeout = setTimeout($.proxy(function() {
                        this._stateReleased();
                        this.releaseCallbacks.fire();
                        this._updateAction();
                        deferred.resolve()
                    }, this), 800);
                    return deferred.promise()
                },
                dispose: function() {
                    clearTimeout(this._pullDownRefreshTimeout);
                    clearTimeout(this._releaseTimeout);
                    this.callBase()
                }
            });
        ui.dxScrollView.refreshStrategies.swipeDown = SwipeDownNativeScrollViewStrategy
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollView.native.slideDown.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var DX_SLIDE_DOWN_NATIVE_SCROLLVIEW_STRATEGY = "dxSlideDownNativeScrollViewStrategy",
            STATE_RELEASED = 0,
            STATE_READY = 1,
            STATE_LOADING = 2,
            LOADING_HEIGHT = 80;
        var SlideDownNativeScrollViewStrategy = ui.dxScrollable.NativeStrategy.inherit({
                _init: function(scrollView) {
                    this.callBase(scrollView);
                    this._$topPocket = scrollView._$topPocket;
                    this._$bottomPocket = scrollView._$bottomPocket;
                    this._initCallbacks()
                },
                _initCallbacks: function() {
                    this.pullDownCallbacks = $.Callbacks();
                    this.releaseCallbacks = $.Callbacks();
                    this.reachBottomCallbacks = $.Callbacks()
                },
                render: function() {
                    this.callBase();
                    this._renderPullDown();
                    this._renderBottom();
                    this._releaseState();
                    this._updateDimensions()
                },
                _renderPullDown: function() {
                    this._$topPocket.empty()
                },
                _renderBottom: function() {
                    this._$bottomPocket.empty().append("<progress>")
                },
                _releaseState: function() {
                    if (this._state === STATE_RELEASED)
                        return;
                    this._state = STATE_RELEASED
                },
                _updateDimensions: function() {
                    this._scrollOffset = this._$container.prop("scrollHeight") - this._$container.prop("clientHeight");
                    this._containerSize = {
                        height: this._$container.prop("clientHeight"),
                        width: this._$container.prop("clientWidth")
                    };
                    this._contentSize = this._componentContentSize = {
                        height: this._$container.prop("scrollHeight"),
                        width: this._$container.prop("scrollWidth")
                    }
                },
                handleScroll: function(e) {
                    this.callBase(e);
                    if (this._isReachBottom(this._lastLocation.top))
                        this._reachBottom()
                },
                _isReachBottom: function(location) {
                    this._scrollContent = this._$container.prop("scrollHeight") - this._$container.prop("clientHeight");
                    return this._reachBottomEnabled && location < -this._scrollContent + LOADING_HEIGHT
                },
                _reachBottom: function() {
                    if (this._state === STATE_LOADING)
                        return;
                    this._state = STATE_LOADING;
                    this.reachBottomCallbacks.fire()
                },
                pullDownEnable: function(enabled) {
                    this._pullDownEnabled = enabled
                },
                reachBottomEnable: function(enabled) {
                    this._reachBottomEnabled = enabled;
                    this._$bottomPocket.toggle(enabled)
                },
                pendingRelease: function() {
                    this._state = STATE_READY
                },
                release: function() {
                    var deferred = $.Deferred();
                    this._state = STATE_RELEASED;
                    this.releaseCallbacks.fire();
                    this.update();
                    return deferred.resolve().promise()
                }
            });
        ui.dxScrollView.refreshStrategies.slideDown = SlideDownNativeScrollViewStrategy
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollView.simulated.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            math = Math;
        var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-loading",
            SCROLLVIEW_PULLDOWN_READY_CLASS = "dx-scrollview-pull-down-ready",
            SCROLLVIEW_PULLDOWN_IMAGE_CLASS = "dx-scrollview-pull-down-image",
            SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator",
            SCROLLVIEW_PULLDOWN_TEXT_CLASS = "dx-scrollview-pull-down-text",
            STATE_RELEASED = 0,
            STATE_READY = 1,
            STATE_REFRESHING = 2,
            STATE_LOADING = 3;
        var ScrollViewScroller = ui.dxScrollView.Scroller = ui.dxScrollable.Scroller.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    this._initCallbacks();
                    this._releaseState()
                },
                _releaseState: function() {
                    this._state = STATE_RELEASED;
                    this._refreshPullDownText()
                },
                _refreshPullDownText: function() {
                    this._$pullingDownText.css("opacity", this._state === STATE_RELEASED ? 1 : 0);
                    this._$pulledDownText.css("opacity", this._state === STATE_READY ? 1 : 0);
                    this._$refreshingText.css("opacity", this._state === STATE_REFRESHING ? 1 : 0)
                },
                _initCallbacks: function() {
                    this.pullDownCallbacks = $.Callbacks();
                    this.releaseCallbacks = $.Callbacks();
                    this.reachBottomCallbacks = $.Callbacks()
                },
                _updateBounds: function() {
                    var considerPockets = this._direction !== "horizontal";
                    this._topPocketSize = considerPockets ? this._$topPocket[this._dimension]() : 0;
                    this._bottomPocketSize = considerPockets ? this._$bottomPocket[this._dimension]() : 0;
                    this._updateOffsets()
                },
                _updateOffsets: function() {
                    this._minOffset = math.min(this._containerSize() - this._contentSize(), -this._topPocketSize);
                    this._maxOffset = -this._topPocketSize;
                    this._bottomBound = this._minOffset
                },
                _updateScrollbar: function() {
                    this._scrollbar.option({
                        containerSize: this._containerSize(),
                        contentSize: this._contentSize() - this._topPocketSize - this._bottomPocketSize
                    })
                },
                _moveContent: function() {
                    this.callBase();
                    if (this._isPullDown())
                        this._pullDownReady();
                    else if (this._isReachBottom())
                        this._reachBottomReady();
                    else if (this._state !== STATE_RELEASED)
                        this._stateReleased()
                },
                _moveScrollbar: function() {
                    this._scrollbar.moveTo(this._topPocketSize + this._location)
                },
                _isPullDown: function() {
                    return this._pullDownEnabled && this._location >= 0
                },
                _isReachBottom: function() {
                    return this._reachBottomEnabled && this._location <= this._bottomBound
                },
                _scrollComplete: function() {
                    if (this._inBounds() && this._state === STATE_READY)
                        this._pullDownRefreshing();
                    else if (this._inBounds() && this._state === STATE_LOADING)
                        this._reachBottomLoading();
                    else
                        this.callBase()
                },
                _reachBottomReady: function() {
                    if (this._state === STATE_LOADING)
                        return;
                    this._state = STATE_LOADING;
                    this._minOffset = math.min(this._containerSize() - this._contentSize(), 0)
                },
                _reachBottomLoading: function() {
                    this.reachBottomCallbacks.fire()
                },
                _pullDownReady: function() {
                    if (this._state === STATE_READY)
                        return;
                    this._state = STATE_READY;
                    this._maxOffset = 0;
                    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
                    this._refreshPullDownText()
                },
                _stateReleased: function() {
                    if (this._state === STATE_RELEASED)
                        return;
                    this._releaseState();
                    this._updateOffsets();
                    this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
                    this.releaseCallbacks.fire()
                },
                _pullDownRefreshing: function() {
                    if (this._state === STATE_REFRESHING)
                        return;
                    this._state = STATE_REFRESHING;
                    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
                    this._refreshPullDownText();
                    this.pullDownCallbacks.fire()
                },
                _releaseHandler: function() {
                    if (this._state === STATE_RELEASED)
                        this._moveToBounds();
                    this._update();
                    return DX.utils.executeAsync($.proxy(this._release, this))
                },
                _release: function() {
                    this._stateReleased();
                    this._scrollComplete()
                },
                _reachBottomEnablingHandler: function(enabled) {
                    if (this._reachBottomEnabled === enabled)
                        return;
                    this._reachBottomEnabled = enabled;
                    this._updateBounds()
                },
                _pullDownEnablingHandler: function(enabled) {
                    if (this._pullDownEnabled === enabled)
                        return;
                    this._pullDownEnabled = enabled;
                    this._considerTopPocketChange();
                    this._updateHandler()
                },
                _considerTopPocketChange: function() {
                    this._location -= this._$topPocket.height() || -this._topPocketSize;
                    this._move()
                },
                _pendingReleaseHandler: function() {
                    this._state = STATE_READY
                }
            });
        var SimulatedScrollViewStrategy = ui.dxScrollable.SimulatedStrategy.inherit({
                _init: function(scrollView) {
                    this.callBase(scrollView);
                    this._$pullDown = scrollView._$pullDown;
                    this._$topPocket = scrollView._$topPocket;
                    this._$bottomPocket = scrollView._$bottomPocket;
                    this._initCallbacks()
                },
                _initCallbacks: function() {
                    this.pullDownCallbacks = $.Callbacks();
                    this.releaseCallbacks = $.Callbacks();
                    this.reachBottomCallbacks = $.Callbacks()
                },
                render: function() {
                    this._renderPullDown();
                    this.callBase()
                },
                _renderPullDown: function() {
                    var $image = $("<div>").addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS),
                        $loadContainer = $("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS),
                        $loadIndicator = $("<div>").dxLoadIndicator(),
                        $text = this._$pullDownText = $("<div>").addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
                    this._$pullingDownText = $("<div>").text(this.option("pullingDownText")).appendTo($text);
                    this._$pulledDownText = $("<div>").text(this.option("pulledDownText")).appendTo($text);
                    this._$refreshingText = $("<div>").text(this.option("refreshingText")).appendTo($text);
                    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text)
                },
                pullDownEnable: function(enabled) {
                    this._eventHandler("pullDownEnabling", enabled)
                },
                reachBottomEnable: function(enabled) {
                    this._eventHandler("reachBottomEnabling", enabled)
                },
                _createScroller: function(direction) {
                    var that = this;
                    var scroller = that._scrollers[direction] = new ScrollViewScroller(that._scrollerOptions(direction));
                    scroller.pullDownCallbacks.add(function() {
                        that.pullDownCallbacks.fire()
                    });
                    scroller.releaseCallbacks.add(function() {
                        that.releaseCallbacks.fire()
                    });
                    scroller.reachBottomCallbacks.add(function() {
                        that.reachBottomCallbacks.fire()
                    })
                },
                _scrollerOptions: function(direction) {
                    return $.extend(this.callBase(direction), {
                            $topPocket: this._$topPocket,
                            $bottomPocket: this._$bottomPocket,
                            $pullDown: this._$pullDown,
                            $pullDownText: this._$pullDownText,
                            $pullingDownText: this._$pullingDownText,
                            $pulledDownText: this._$pulledDownText,
                            $refreshingText: this._$refreshingText
                        })
                },
                pendingRelease: function() {
                    this._eventHandler("pendingRelease")
                },
                release: function() {
                    return this._eventHandler("release").done(this._updateAction)
                },
                location: function() {
                    var location = this.callBase();
                    location.top += this._$topPocket.height();
                    return location
                }
            });
        ui.dxScrollView.refreshStrategies.simulated = SimulatedScrollViewStrategy
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.map.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            utils = DX.utils,
            winJS = DX.support.winJS,
            wrapToArray = utils.wrapToArray,
            removeDublicates = utils.removeDublicates,
            titleize = DX.inflector.titleize;
        var MAP_CLASS = "dx-map",
            MAP_CONTAINER_CLASS = "dx-map-container",
            MAP_SHIELD_CLASS = "dx-map-shield";
        DX.registerComponent("dxMap", ui, ui.Widget.inherit({
            ctor: function() {
                this.callBase.apply(this, arguments);
                this.addMarker = $.proxy(this._addFunction, this, "markers");
                this.removeMarker = $.proxy(this._removeFunction, this, "markers");
                this.addRoute = $.proxy(this._addFunction, this, "routes");
                this.removeRoute = $.proxy(this._removeFunction, this, "routes")
            },
            _addFunction: function(optionName, addingValue) {
                var deferred = $.Deferred(),
                    that = this,
                    providerDeffered = $.Deferred(),
                    optionValue = this.option(optionName),
                    addingValues = wrapToArray(addingValue);
                optionValue.push.apply(optionValue, addingValues);
                this._notificationDeffered = providerDeffered;
                this.option(optionName, optionValue);
                providerDeffered.done(function(instance) {
                    deferred.resolveWith(that, instance && instance.length > 1 ? [instance] : instance)
                });
                return deferred.promise()
            },
            _removeFunction: function(optionName, removingValue) {
                var deferred = $.Deferred(),
                    that = this,
                    providerDeffered = $.Deferred(),
                    optionValue = this.option(optionName),
                    removingValues = wrapToArray(removingValue);
                $.each(removingValues, function(_, removingValue) {
                    var index = $.isNumeric(removingValue) ? removingValue : $.inArray(removingValue, optionValue);
                    if (index !== -1)
                        optionValue.splice(index, 1);
                    else
                        throw DX.log("E1021", titleize(optionName.substring(0, optionName.length - 1)), removingValue);
                });
                this._notificationDeffered = providerDeffered;
                this.option(optionName, optionValue);
                providerDeffered.done(function() {
                    deferred.resolveWith(that)
                });
                return deferred.promise()
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    updateAction: {
                        since: "14.1",
                        alias: "onUpdated"
                    },
                    location: {
                        since: "14.1",
                        alias: "center"
                    },
                    markerAddedAction: {
                        since: "14.2",
                        alias: "onMarkerAdded"
                    },
                    markerRemovedAction: {
                        since: "14.2",
                        alias: "onMarkerRemoved"
                    },
                    readyAction: {
                        since: "14.2",
                        alias: "onReady"
                    },
                    routeAddedAction: {
                        since: "14.2",
                        alias: "onRouteAdded"
                    },
                    routeRemovedAction: {
                        since: "14.2",
                        alias: "onRouteRemoved"
                    },
                    clickAction: {
                        since: "14.2",
                        alias: "onClick"
                    }
                })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    bounds: {
                        northEast: null,
                        southWest: null
                    },
                    center: {
                        lat: 0,
                        lng: 0
                    },
                    zoom: 1,
                    width: 300,
                    height: 300,
                    type: "roadmap",
                    provider: "google",
                    autoAdjust: true,
                    markers: [],
                    markerIconSrc: null,
                    onMarkerAdded: null,
                    onMarkerRemoved: null,
                    routes: [],
                    onRouteAdded: null,
                    onRouteRemoved: null,
                    key: {
                        bing: "",
                        google: "",
                        googleStatic: ""
                    },
                    controls: false,
                    onReady: null,
                    onUpdated: null,
                    onClick: null
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }])
            },
            _init: function() {
                this.callBase();
                this._asyncQueue = [];
                this._checkProvider();
                this._checkMarkersOption(this.option("markers"));
                this._checkRoutesOption(this.option("routes"));
                this.callBase();
                this._initContainer();
                this._grabEvents();
                this._cleanRenderedMarkers();
                this._cleanRenderedRoutes()
            },
            _checkProvider: function() {
                if (winJS && this.option("provider") === "google")
                    throw DX.Error("E1024");
            },
            _checkMarkersOption: function(markers) {
                if (!$.isArray(markers))
                    throw DX.Error("E1022");
            },
            _checkRoutesOption: function(routes) {
                if (!$.isArray(routes))
                    throw DX.Error("E1023");
            },
            _initContainer: function() {
                this._$container = $("<div />").addClass(MAP_CONTAINER_CLASS);
                this.element().append(this._$container)
            },
            _grabEvents: function() {
                var eventName = events.addNamespace("dxpointerdown", this.NAME);
                this.element().on(eventName, $.proxy(this._cancelEvent, this))
            },
            _cancelEvent: function(e) {
                var cancelByProvider = this._provider.cancelEvents && !this.option("disabled");
                if (!DX.designMode && cancelByProvider)
                    e.stopPropagation()
            },
            _cleanRenderedMarkers: function() {
                this._renderedMarkers = []
            },
            _cleanRenderedRoutes: function(routes) {
                this._renderedRoutes = []
            },
            _render: function() {
                this.callBase();
                this.element().addClass(MAP_CLASS);
                this._renderShield();
                this._queueAsyncAction("render", this.option("markers"), this.option("routes"));
                this._saveRenderedMarkers();
                this._saveRenderedRoutes()
            },
            _saveRenderedMarkers: function(markers) {
                markers = markers || this.option("markers");
                this._renderedMarkers = markers.slice()
            },
            _saveRenderedRoutes: function(routes) {
                routes = routes || this.option("routes");
                this._renderedRoutes = routes.slice()
            },
            _renderShield: function() {
                if (DX.designMode || this.option("disabled")) {
                    var $shield = $("<div/>").addClass(MAP_SHIELD_CLASS);
                    this.element().append($shield)
                }
                else {
                    var $shield = this.element().find("." + MAP_SHIELD_CLASS);
                    $shield.remove()
                }
            },
            _clean: function() {
                this._cleanFocusState();
                if (!this._provider)
                    return;
                this._queueAsyncAction("clean");
                this._cleanRenderedMarkers();
                this._cleanRenderedRoutes()
            },
            _optionChanged: function(args) {
                var value = args.value;
                var previousValue = args.previousValue;
                if (this._cancelOptionChange)
                    return;
                var notificationDeffered = this._notificationDeffered;
                delete this._notificationDeffered;
                switch (args.name) {
                    case"disabled":
                        this._renderShield();
                        this.callBase(args);
                        break;
                    case"width":
                    case"height":
                        this.callBase(args);
                        this._dimensionChanged();
                        break;
                    case"provider":
                        this._invalidate();
                        break;
                    case"key":
                        DX.log("W1001");
                        break;
                    case"bounds":
                        this._queueAsyncAction("updateBounds");
                        break;
                    case"center":
                        this._queueAsyncAction("updateCenter");
                        break;
                    case"zoom":
                        this._queueAsyncAction("updateZoom");
                        break;
                    case"type":
                        this._queueAsyncAction("updateMapType");
                        break;
                    case"controls":
                        this._queueAsyncAction("updateControls", this.option("markers"), this.option("routes"));
                        break;
                    case"autoAdjust":
                        this._queueAsyncAction("adjustViewport");
                        break;
                    case"markers":
                        this._checkMarkersOption(value);
                        this._queueAsyncAction("updateMarkers", notificationDeffered ? removeDublicates(this._renderedMarkers, value) : this._renderedMarkers, notificationDeffered ? removeDublicates(value, this._renderedMarkers) : value).done($.proxy(function() {
                            if (notificationDeffered)
                                notificationDeffered.resolve.apply(notificationDeffered, arguments)
                        }, this));
                        this._saveRenderedMarkers(value);
                        break;
                    case"markerIconSrc":
                        this._queueAsyncAction("updateMarkers", this._renderedMarkers, this._renderedMarkers);
                        break;
                    case"routes":
                        this._checkRoutesOption(value);
                        this._queueAsyncAction("updateRoutes", notificationDeffered ? removeDublicates(this._renderedRoutes, value) : this._renderedRoutes, notificationDeffered ? removeDublicates(value, this._renderedRoutes) : value).done($.proxy(function() {
                            if (notificationDeffered)
                                notificationDeffered.resolve.apply(notificationDeffered, arguments)
                        }, this));
                        this._saveRenderedRoutes(value);
                        break;
                    case"onReady":
                    case"onUpdated":
                    case"onMarkerAdded":
                    case"onMarkerRemoved":
                    case"onRouteAdded":
                    case"onRouteRemoved":
                    case"onClick":
                        break;
                    default:
                        this.callBase.apply(this, arguments)
                }
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._dimensionChanged()
            },
            _dimensionChanged: function() {
                this._queueAsyncAction("updateDimensions")
            },
            _queueAsyncAction: function(name) {
                var deferred = $.Deferred(),
                    emptyQueue = !this._asyncQueue.length;
                this._asyncQueue.push({
                    name: name,
                    options: $.makeArray(arguments).slice(1),
                    deferred: deferred
                });
                if (emptyQueue)
                    this._enqueueAsyncAction();
                return deferred.promise()
            },
            _enqueueAsyncAction: function() {
                var emptyQueue = !this._asyncQueue.length;
                if (emptyQueue)
                    return;
                this._execAsyncAction(this._asyncQueue[0]).done($.proxy(function() {
                    this._asyncQueue.shift();
                    this._enqueueAsyncAction()
                }, this))
            },
            _execAsyncAction: function(action) {
                var deferred = $.Deferred(),
                    actionName = action.name,
                    actionOptions = action.options,
                    actionDeferred = action.deferred,
                    provider = this._getProvider(actionName);
                provider[actionName].apply(provider, actionOptions).done($.proxy(function(mapRefreshed) {
                    actionDeferred.resolve.apply(actionDeferred, $.makeArray(arguments).slice(1));
                    if (mapRefreshed)
                        this._triggerReadyAction();
                    else if (actionName !== "clean")
                        this._triggerUpdateAction();
                    deferred.resolve()
                }, this));
                return deferred.promise()
            },
            _getProvider: function(actionName) {
                var currentProvider = this.option("provider");
                if (actionName !== "clean" && this._usedProvider !== currentProvider) {
                    this._provider = new providers[currentProvider](this, this._$container);
                    this._usedProvider = currentProvider
                }
                return this._provider
            },
            _triggerReadyAction: function() {
                this._createActionByOption("onReady")({originalMap: this._provider.map()})
            },
            _triggerUpdateAction: function() {
                this._createActionByOption("onUpdated")()
            },
            setOptionSilent: function(name, value) {
                this._cancelOptionChange = true;
                this.option(name, value);
                this._cancelOptionChange = false
            }
        }));
        var providers = {};
        ui.dxMap.registerProvider = function(name, provider) {
            providers[name] = provider
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.map.provider.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        ui.dxMap.Provider = DX.Class.inherit({
            _defaultRouteWeight: function() {
                return 5
            },
            _defaultRouteOpacity: function() {
                return .5
            },
            _defaultRouteColor: function() {
                return "#0000FF"
            },
            cancelEvents: false,
            ctor: function(map, $container) {
                this._mapWidget = map;
                this._$container = $container
            },
            render: function(markerOptions, routeOptions) {
                var deferred = $.Deferred();
                this._renderImpl().done($.proxy(function() {
                    var markersPromise = this.addMarkers(markerOptions);
                    var routesPromise = this.addRoutes(routeOptions);
                    $.when(markersPromise, routesPromise).done(function() {
                        deferred.resolve(true)
                    })
                }, this));
                return deferred.promise()
            },
            _renderImpl: DX.abstract,
            updateDimensions: DX.abstract,
            updateMapType: DX.abstract,
            updateBounds: DX.abstract,
            updateCenter: DX.abstract,
            updateZoom: DX.abstract,
            updateControls: DX.abstract,
            updateMarkers: function(markerOptionsToRemove, markerOptionsToAdd) {
                var deferred = $.Deferred(),
                    that = this;
                this.removeMarkers(markerOptionsToRemove).done(function() {
                    that.addMarkers(markerOptionsToAdd).done(function() {
                        deferred.resolve.apply(deferred, arguments)
                    })
                });
                return deferred.promise()
            },
            addMarkers: DX.abstract,
            removeMarkers: DX.abstract,
            adjustViewport: DX.abstract,
            updateRoutes: function(routeOptionsToRemove, routeOptionsToAdd) {
                var deferred = $.Deferred(),
                    that = this;
                this.removeRoutes(routeOptionsToRemove).done(function() {
                    that.addRoutes(routeOptionsToAdd).done(function() {
                        deferred.resolve.apply(deferred, arguments)
                    })
                });
                return deferred.promise()
            },
            addRoutes: DX.abstract,
            removeRoutes: DX.abstract,
            clean: DX.abstract,
            map: function() {
                return this._map
            },
            _option: function(name, value) {
                if (value === undefined)
                    return this._mapWidget.option(name);
                this._mapWidget.setOptionSilent(name, value)
            },
            _keyOption: function(providerName) {
                var key = this._option("key");
                return key[providerName] === undefined ? key : key[providerName]
            },
            _parseTooltipOptions: function(option) {
                return {
                        text: option.text || option,
                        visible: option.isShown || false
                    }
            },
            _isBoundsSetted: function() {
                return this._option("bounds.northEast") && this._option("bounds.southWest")
            },
            _addEventNamespace: function(name) {
                return events.addNamespace(name, this._mapWidget.NAME)
            },
            _createAction: function() {
                var mapWidget = this._mapWidget;
                return mapWidget._createAction.apply(mapWidget, arguments)
            },
            _fireAction: function(name, actionArguments) {
                var option = this._option(name);
                if (option)
                    this._createAction(option)(actionArguments)
            },
            _fireClickAction: function(actionArguments) {
                this._fireAction("onClick", actionArguments)
            },
            _fireMarkerAddedAction: function(actionArguments) {
                this._fireAction("onMarkerAdded", actionArguments)
            },
            _fireMarkerRemovedAction: function(actionArguments) {
                this._fireAction("onMarkerRemoved", actionArguments)
            },
            _fireRouteAddedAction: function(actionArguments) {
                this._fireAction("onRouteAdded", actionArguments)
            },
            _fireRouteRemovedAction: function(actionArguments) {
                this._fireAction("onRouteRemoved", actionArguments)
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.map.provider.googleStatic.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var GOOGLE_STATIC_URL = "https://maps.google.com/maps/api/staticmap?";
        ui.dxMap.registerProvider("googleStatic", ui.dxMap.Provider.inherit({
            _locationToString: function(location) {
                return !$.isPlainObject(location) ? location.toString().replace(/ /g, "+") : location.lat + "," + location.lng
            },
            _renderImpl: function() {
                return this._updateMap()
            },
            updateDimensions: function() {
                return this._updateMap()
            },
            updateMapType: function() {
                return this._updateMap()
            },
            updateBounds: function() {
                return $.Deferred().resolve().promise()
            },
            updateCenter: function() {
                return this._updateMap()
            },
            updateZoom: function() {
                return this._updateMap()
            },
            updateControls: function() {
                return $.Deferred().resolve().promise()
            },
            addMarkers: function(options) {
                var that = this;
                return this._updateMap().done(function() {
                        $.each(options, function(_, options) {
                            that._fireMarkerAddedAction({options: options})
                        })
                    })
            },
            removeMarkers: function(options) {
                var that = this;
                return this._updateMap().done(function() {
                        $.each(options, function(_, options) {
                            that._fireMarkerRemovedAction({options: options})
                        })
                    })
            },
            adjustViewport: function() {
                return $.Deferred().resolve().promise()
            },
            addRoutes: function(options) {
                var that = this;
                return this._updateMap().done(function() {
                        $.each(options, function(_, options) {
                            that._fireRouteAddedAction({options: options})
                        })
                    })
            },
            removeRoutes: function(options) {
                var that = this;
                return this._updateMap().done(function() {
                        $.each(options, function(_, options) {
                            that._fireRouteRemovedAction({options: options})
                        })
                    })
            },
            clean: function() {
                this._$container.css("background-image", "none");
                this._$container.off(this._addEventNamespace("dxclick"));
                return $.Deferred().resolve().promise()
            },
            mapRendered: function() {
                return true
            },
            _updateMap: function() {
                var key = this._keyOption("googleStatic"),
                    $container = this._$container;
                var requestOptions = ["sensor=false", "size=" + $container.width() + "x" + $container.height(), "maptype=" + this._option("type"), "center=" + this._locationToString(this._option("center")), "zoom=" + this._option("zoom"), this._markersSubstring()];
                requestOptions.push.apply(requestOptions, this._routeSubstrings());
                if (key)
                    requestOptions.push("key=" + key);
                var request = GOOGLE_STATIC_URL + requestOptions.join("&");
                this._$container.css("background", "url(\"" + request + "\") no-repeat 0 0");
                this._attachClickEvent();
                return $.Deferred().resolve(true).promise()
            },
            _markersSubstring: function() {
                var that = this,
                    markers = [],
                    markerIcon = this._option("markerIconSrc");
                if (markerIcon)
                    markers.push("icon:" + markerIcon);
                $.each(this._option("markers"), function(_, marker) {
                    markers.push(that._locationToString(marker.location))
                });
                return "markers=" + markers.join("|")
            },
            _routeSubstrings: function() {
                var that = this,
                    routes = [];
                $.each(this._option("routes"), function(_, route) {
                    var color = new DX.Color(route.color || that._defaultRouteColor()).toHex().replace('#', '0x'),
                        opacity = Math.round((route.opacity || that._defaultRouteOpacity()) * 255).toString(16),
                        width = route.weight || that._defaultRouteWeight(),
                        locations = [];
                    $.each(route.locations, function(_, routePoint) {
                        locations.push(that._locationToString(routePoint))
                    });
                    routes.push("path=color:" + color + opacity + "|weight:" + width + "|" + locations.join("|"))
                });
                return routes
            },
            _attachClickEvent: function() {
                var that = this,
                    eventName = this._addEventNamespace("dxclick");
                this._$container.off(eventName).on(eventName, function(e) {
                    that._fireClickAction({jQueryEvent: e})
                })
            }
        }));
        ui.dxMap.__internals = $.extend(ui.dxMap.__internals, {remapGoogleStaticConstant: function(newValue) {
                GOOGLE_STATIC_URL = newValue
            }})
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.map.provider.dynamic.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        ui.dxMap.DynamicProvider = ui.dxMap.Provider.inherit({
            cancelEvents: true,
            _renderImpl: function(markerOptions, routeOptions) {
                var deferred = $.Deferred();
                this._load().done($.proxy(function() {
                    this._init().done($.proxy(function() {
                        var mapTypePromise = this.updateMapType(),
                            boundsPromise = this._isBoundsSetted() ? this.updateBounds() : this.updateCenter();
                        $.when(mapTypePromise, boundsPromise).done($.proxy(function() {
                            this._attachHandlers();
                            setTimeout(function() {
                                deferred.resolve()
                            })
                        }, this))
                    }, this))
                }, this));
                return deferred.promise()
            },
            _load: function() {
                if (!this._mapsLoader) {
                    this._mapsLoader = $.Deferred();
                    this._loadImpl().done($.proxy(function() {
                        this._mapsLoader.resolve()
                    }, this))
                }
                this._markers = [];
                this._routes = [];
                return this._mapsLoader.promise()
            },
            _loadImpl: DX.abstract,
            _init: DX.abstract,
            _attachHandlers: DX.abstract,
            addMarkers: function(options) {
                var deferred = $.Deferred(),
                    that = this;
                var markerPromises = $.map(options, function(options) {
                        return that._addMarker(options)
                    });
                $.when.apply($, markerPromises).done(function() {
                    var instances = $.map($.makeArray(arguments), function(markerObject) {
                            return markerObject.marker
                        });
                    deferred.resolve(false, instances)
                });
                return deferred.promise()
            },
            _addMarker: function(options) {
                var that = this;
                return this._renderMarker(options).done(function(markerObject) {
                        that._markers.push($.extend({options: options}, markerObject));
                        that._fitBounds();
                        that._fireMarkerAddedAction({
                            options: options,
                            originalMarker: markerObject.marker
                        })
                    })
            },
            _renderMarker: DX.abstract,
            removeMarkers: function(markersOptionsToRemove) {
                var that = this;
                $.each(markersOptionsToRemove, function(_, markerOptionToRemove) {
                    that._removeMarker(markerOptionToRemove)
                });
                return $.Deferred().resolve().promise()
            },
            _removeMarker: function(markersOptionToRemove) {
                var that = this;
                $.each(this._markers, function(markerIndex, markerObject) {
                    if (markerObject.options !== markersOptionToRemove)
                        return true;
                    that._destroyMarker(markerObject);
                    that._markers.splice(markerIndex, 1);
                    that._fireMarkerRemovedAction({options: markerObject.options});
                    return false
                })
            },
            _destroyMarker: DX.abstract,
            _clearMarkers: function() {
                for (var i = 0; this._markers.length > 0; )
                    this._removeMarker(this._markers[0].options)
            },
            addRoutes: function(options) {
                var deferred = $.Deferred(),
                    that = this;
                var routePromises = $.map(options, function(options) {
                        return that._addRoute(options)
                    });
                $.when.apply($, routePromises).done(function() {
                    var instances = $.map($.makeArray(arguments), function(routeObject) {
                            return routeObject.instance
                        });
                    deferred.resolve(false, instances)
                });
                return deferred.promise()
            },
            _addRoute: function(options) {
                var that = this;
                return this._renderRoute(options).done(function(routeObject) {
                        that._routes.push($.extend({options: options}, routeObject));
                        that._fitBounds();
                        that._fireRouteAddedAction({
                            options: options,
                            originalRoute: routeObject.instance
                        })
                    })
            },
            _renderRoute: DX.abstract,
            removeRoutes: function(options) {
                var that = this;
                $.each(options, function(routeIndex, options) {
                    that._removeRoute(options)
                });
                return $.Deferred().resolve().promise()
            },
            _removeRoute: function(options) {
                var that = this;
                $.each(this._routes, function(routeIndex, routeObject) {
                    if (routeObject.options !== options)
                        return true;
                    that._destroyRoute(routeObject);
                    that._routes.splice(routeIndex, 1);
                    that._fireRouteRemovedAction({options: options});
                    return false
                })
            },
            _destroyRoute: DX.abstract,
            _clearRoutes: function() {
                for (var i = 0; this._routes.length > 0; )
                    this._removeRoute(this._routes[0].options)
            },
            adjustViewport: function() {
                return this._fitBounds()
            },
            _fitBounds: DX.abstract,
            _updateBounds: function() {
                var that = this;
                this._clearBounds();
                $.each(this._markers, function(_, markerObject) {
                    that._extendBounds(markerObject.location)
                });
                $.each(this._routes, function(_, routeObject) {
                    that._extendBounds(routeObject.northEast);
                    that._extendBounds(routeObject.southWest)
                })
            },
            _clearBounds: function() {
                this._bounds = null
            },
            _extendBounds: DX.abstract
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.map.provider.dynamic.bing.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            winJS = DX.support.winJS;
        var BING_MAP_READY = "_bingScriptReady",
            BING_URL = "https://ecn.dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=7.0&s=1&onScriptLoad=" + BING_MAP_READY,
            BING_LOCAL_FILES1 = "ms-appx:///Bing.Maps.JavaScript/js/veapicore.js",
            BING_LOCAL_FILES2 = "ms-appx:///Bing.Maps.JavaScript/js/veapiModules.js",
            BING_CREDENTIALS = "AhuxC0dQ1DBTNo8L-H9ToVMQStmizZzBJdraTSgCzDSWPsA1Qd8uIvFSflzxdaLH",
            MIN_LOCATION_RECT_LENGTH = 0.0000000000000001;
        var msMapsLoaded = function() {
                return window.Microsoft && window.Microsoft.Maps
            };
        var msMapsLoader;
        ui.dxMap.registerProvider("bing", ui.dxMap.DynamicProvider.inherit({
            _mapType: function(type) {
                var mapTypes = {
                        roadmap: Microsoft.Maps.MapTypeId.road,
                        hybrid: Microsoft.Maps.MapTypeId.aerial,
                        satellite: Microsoft.Maps.MapTypeId.aerial
                    };
                return mapTypes[type] || mapTypes.road
            },
            _movementMode: function(type) {
                var movementTypes = {
                        driving: Microsoft.Maps.Directions.RouteMode.driving,
                        walking: Microsoft.Maps.Directions.RouteMode.walking
                    };
                return movementTypes[type] || movementTypes.driving
            },
            _resolveLocation: function(location) {
                var d = $.Deferred();
                if (typeof location === "string") {
                    var searchManager = new Microsoft.Maps.Search.SearchManager(this._map);
                    var searchRequest = {
                            where: location,
                            count: 1,
                            callback: function(searchResponse) {
                                var boundsBox = searchResponse.results[0].location;
                                d.resolve(new Microsoft.Maps.Location(boundsBox.latitude, boundsBox.longitude))
                            }
                        };
                    searchManager.geocode(searchRequest)
                }
                else if ($.isPlainObject(location) && $.isNumeric(location.lat) && $.isNumeric(location.lng))
                    d.resolve(new Microsoft.Maps.Location(location.lat, location.lng));
                else if ($.isArray(location))
                    d.resolve(new Microsoft.Maps.Location(location[0], location[1]));
                return d.promise()
            },
            _normalizeLocation: function(location) {
                return {
                        lat: location.latitude,
                        lng: location.longitude
                    }
            },
            _normalizeLocationRect: function(locationRect) {
                var northWest = this._normalizeLocation(locationRect.getNorthwest()),
                    southEast = this._normalizeLocation(locationRect.getSoutheast());
                return {
                        northEast: {
                            lat: northWest.lat,
                            lng: southEast.lng
                        },
                        southWest: {
                            lat: southEast.lat,
                            lng: northWest.lng
                        }
                    }
            },
            _loadImpl: function() {
                this._msMapsLoader = $.Deferred();
                if (msMapsLoaded())
                    this._mapReady();
                else {
                    if (!msMapsLoader || msMapsLoader.state() == "resolved" && !msMapsLoaded()) {
                        msMapsLoader = $.Deferred();
                        window[BING_MAP_READY] = $.proxy(msMapsLoader.resolve, msMapsLoader);
                        if (winJS)
                            $.when($.getScript(BING_LOCAL_FILES1), $.getScript(BING_LOCAL_FILES2)).done(function() {
                                Microsoft.Maps.loadModule("Microsoft.Maps.Map", {callback: window[BING_MAP_READY]})
                            });
                        else
                            $.getScript(BING_URL)
                    }
                    msMapsLoader.done($.proxy(this._mapReady, this))
                }
                return this._msMapsLoader.promise()
            },
            _mapReady: function() {
                try {
                    delete window[BING_MAP_READY]
                }
                catch(e) {
                    window[BING_MAP_READY] = undefined
                }
                var searchModulePromise = $.Deferred();
                var directionsModulePromise = $.Deferred();
                Microsoft.Maps.loadModule('Microsoft.Maps.Search', {callback: $.proxy(searchModulePromise.resolve, searchModulePromise)});
                Microsoft.Maps.loadModule('Microsoft.Maps.Directions', {callback: $.proxy(directionsModulePromise.resolve, directionsModulePromise)});
                $.when(searchModulePromise, directionsModulePromise).done($.proxy(function() {
                    this._msMapsLoader.resolve()
                }, this))
            },
            _init: function() {
                var deferred = $.Deferred(),
                    initPromise = $.Deferred(),
                    controls = this._option("controls");
                this._map = new Microsoft.Maps.Map(this._$container[0], {
                    credentials: this._keyOption("bing") || BING_CREDENTIALS,
                    zoom: this._option("zoom"),
                    showDashboard: controls,
                    showMapTypeSelector: controls,
                    showScalebar: controls
                });
                var handler = Microsoft.Maps.Events.addHandler(this._map, 'tiledownloadcomplete', $.proxy(initPromise.resolve, initPromise));
                $.when(initPromise).done($.proxy(function() {
                    Microsoft.Maps.Events.removeHandler(handler);
                    deferred.resolve()
                }, this));
                return deferred.promise()
            },
            _attachHandlers: function() {
                this._providerViewChangeHandler = Microsoft.Maps.Events.addHandler(this._map, 'viewchange', $.proxy(this._viewChangeHandler, this));
                this._providerClickHandler = Microsoft.Maps.Events.addHandler(this._map, 'click', $.proxy(this._clickActionHandler, this))
            },
            _viewChangeHandler: function() {
                var bounds = this._map.getBounds();
                this._option("bounds", this._normalizeLocationRect(bounds));
                var center = this._map.getCenter();
                this._option("center", this._normalizeLocation(center));
                if (!this._preventZoomChangeEvent)
                    this._option("zoom", this._map.getZoom())
            },
            _clickActionHandler: function(e) {
                if (e.targetType == "map") {
                    var point = new Microsoft.Maps.Point(e.getX(), e.getY()),
                        location = e.target.tryPixelToLocation(point);
                    this._fireClickAction({location: this._normalizeLocation(location)})
                }
            },
            updateDimensions: function() {
                var $container = this._$container;
                this._map.setOptions({
                    width: $container.width(),
                    height: $container.height()
                });
                return $.Deferred().resolve().promise()
            },
            updateMapType: function() {
                var type = this._option("type"),
                    labelOverlay = Microsoft.Maps.LabelOverlay;
                this._map.setView({
                    animate: false,
                    mapTypeId: this._mapType(type),
                    labelOverlay: type == "satellite" ? labelOverlay.hidden : labelOverlay.visible
                });
                return $.Deferred().resolve().promise()
            },
            updateBounds: function() {
                var deferred = $.Deferred(),
                    that = this;
                var northEastPromise = this._resolveLocation(this._option("bounds.northEast")),
                    southWestPromise = this._resolveLocation(this._option("bounds.southWest"));
                $.when(northEastPromise, southWestPromise).done(function(northEast, southWest) {
                    var bounds = new Microsoft.Maps.LocationRect.fromLocations(northEast, southWest);
                    that._map.setView({
                        animate: false,
                        bounds: bounds
                    });
                    deferred.resolve()
                });
                return deferred.promise()
            },
            updateCenter: function() {
                var deferred = $.Deferred(),
                    that = this;
                this._resolveLocation(this._option("center")).done(function(location) {
                    that._map.setView({
                        animate: false,
                        center: location
                    });
                    deferred.resolve()
                });
                return deferred.promise()
            },
            updateZoom: function() {
                this._map.setView({
                    animate: false,
                    zoom: this._option("zoom")
                });
                return $.Deferred().resolve().promise()
            },
            updateControls: function() {
                this.clean();
                return this.render.apply(this, arguments)
            },
            _renderMarker: function(options) {
                var d = $.Deferred(),
                    that = this;
                this._resolveLocation(options.location).done(function(location) {
                    var pushpinOptions = {icon: options.iconSrc || that._option("markerIconSrc")};
                    if (options.html) {
                        $.extend(pushpinOptions, {
                            htmlContent: options.html,
                            width: null,
                            height: null
                        });
                        var htmlOffset = options.htmlOffset;
                        if (htmlOffset)
                            pushpinOptions.anchor = new Microsoft.Maps.Point(-htmlOffset.left, -htmlOffset.top)
                    }
                    var pushpin = new Microsoft.Maps.Pushpin(location, pushpinOptions);
                    that._map.entities.push(pushpin);
                    var infobox = that._renderTooltip(location, options.tooltip);
                    if (options.clickAction) {
                        DX.log("W0001", "dxMap", "marker.clickAction", "14.2", "Use 'onClick' option instead");
                        options.onClick = options.clickAction
                    }
                    var handler;
                    if (options.onClick || options.tooltip) {
                        var markerClickAction = that._createAction(options.onClick || $.noop),
                            markerNormalizedLocation = that._normalizeLocation(location);
                        handler = Microsoft.Maps.Events.addHandler(pushpin, "click", function() {
                            markerClickAction({location: markerNormalizedLocation});
                            if (infobox)
                                infobox.setOptions({visible: true})
                        })
                    }
                    d.resolve({
                        location: location,
                        marker: pushpin,
                        infobox: infobox,
                        handler: handler
                    })
                });
                return d.promise()
            },
            _renderTooltip: function(location, options) {
                if (!options)
                    return;
                options = this._parseTooltipOptions(options);
                var infobox = new Microsoft.Maps.Infobox(location, {
                        description: options.text,
                        offset: new Microsoft.Maps.Point(0, 33),
                        visible: options.visible
                    });
                this._map.entities.push(infobox, null);
                return infobox
            },
            _destroyMarker: function(marker) {
                this._map.entities.remove(marker.marker);
                if (marker.infobox)
                    this._map.entities.remove(marker.infobox);
                if (marker.handler)
                    Microsoft.Maps.Events.removeHandler(marker.handler)
            },
            _renderRoute: function(options) {
                var d = $.Deferred(),
                    that = this;
                var points = $.map(options.locations, function(point) {
                        return that._resolveLocation(point)
                    });
                $.when.apply($, points).done(function() {
                    var locations = $.makeArray(arguments),
                        direction = new Microsoft.Maps.Directions.DirectionsManager(that._map),
                        color = new DX.Color(options.color || that._defaultRouteColor()).toHex(),
                        routeColor = new Microsoft.Maps.Color.fromHex(color);
                    routeColor.a = (options.opacity || that._defaultRouteOpacity()) * 255;
                    direction.setRenderOptions({
                        autoUpdateMapView: false,
                        displayRouteSelector: false,
                        waypointPushpinOptions: {visible: false},
                        drivingPolylineOptions: {
                            strokeColor: routeColor,
                            strokeThickness: options.weight || that._defaultRouteWeight()
                        },
                        walkingPolylineOptions: {
                            strokeColor: routeColor,
                            strokeThickness: options.weight || that._defaultRouteWeight()
                        }
                    });
                    direction.setRequestOptions({
                        routeMode: that._movementMode(options.mode),
                        routeDraggable: false
                    });
                    $.each(locations, function(_, location) {
                        var waypoint = new Microsoft.Maps.Directions.Waypoint({location: location});
                        direction.addWaypoint(waypoint)
                    });
                    var handler = Microsoft.Maps.Events.addHandler(direction, 'directionsUpdated', function(args) {
                            Microsoft.Maps.Events.removeHandler(handler);
                            var routeSummary = args.routeSummary[0];
                            d.resolve({
                                instance: direction,
                                northEast: routeSummary.northEast,
                                southWest: routeSummary.southWest
                            })
                        });
                    direction.calculateDirections()
                });
                return d.promise()
            },
            _destroyRoute: function(routeObject) {
                routeObject.instance.dispose()
            },
            _fitBounds: function() {
                this._updateBounds();
                if (this._bounds && this._option("autoAdjust")) {
                    var zoomBeforeFitting = this._map.getZoom();
                    this._preventZoomChangeEvent = true;
                    var bounds = this._bounds.clone();
                    bounds.height = bounds.height * 1.1;
                    bounds.width = bounds.width * 1.1;
                    this._map.setView({
                        animate: false,
                        bounds: bounds,
                        zoom: zoomBeforeFitting
                    });
                    var zoomAfterFitting = this._map.getZoom();
                    if (zoomBeforeFitting < zoomAfterFitting)
                        this._map.setView({
                            animate: false,
                            zoom: zoomBeforeFitting
                        });
                    else
                        this._option("zoom", zoomAfterFitting);
                    delete this._preventZoomChangeEvent
                }
                return $.Deferred().resolve().promise()
            },
            _extendBounds: function(location) {
                if (this._bounds)
                    this._bounds = new Microsoft.Maps.LocationRect.fromLocations(this._bounds.getNorthwest(), this._bounds.getSoutheast(), location);
                else
                    this._bounds = new Microsoft.Maps.LocationRect(location, MIN_LOCATION_RECT_LENGTH, MIN_LOCATION_RECT_LENGTH)
            },
            clean: function() {
                if (this._map) {
                    Microsoft.Maps.Events.removeHandler(this._providerViewChangeHandler);
                    Microsoft.Maps.Events.removeHandler(this._providerClickHandler);
                    this._clearMarkers();
                    this._clearRoutes();
                    this._map.dispose()
                }
                return $.Deferred().resolve().promise()
            }
        }));
        ui.dxMap.__internals = $.extend(ui.dxMap.__internals, {remapBingConstant: function(newValue) {
                BING_URL = newValue
            }})
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.map.provider.dynamic.google.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var GOOGLE_MAP_READY = "_googleScriptReady",
            GOOGLE_URL = "https://maps.google.com/maps/api/js?v=3.9&sensor=false&callback=" + GOOGLE_MAP_READY;
        var CustomMarker;
        var initCustomMarkerClass = function() {
                CustomMarker = function(options) {
                    this._position = options.position;
                    this._offset = options.offset;
                    this._$overlayContainer = $("<div>").css({
                        position: "absolute",
                        display: "none",
                        cursor: "pointer"
                    }).append(options.html);
                    this.setMap(options.map)
                };
                CustomMarker.prototype = new google.maps.OverlayView;
                CustomMarker.prototype.onAdd = function() {
                    var $pane = $(this.getPanes().overlayMouseTarget);
                    $pane.append(this._$overlayContainer);
                    this._clickListner = google.maps.event.addDomListener(this._$overlayContainer.get(0), 'click', $.proxy(function(e) {
                        google.maps.event.trigger(this, 'click');
                        e.preventDefault()
                    }, this));
                    this.draw()
                };
                CustomMarker.prototype.onRemove = function() {
                    google.maps.event.removeListener(this._clickListner);
                    this._$overlayContainer.remove()
                };
                CustomMarker.prototype.draw = function() {
                    var position = this.getProjection().fromLatLngToDivPixel(this._position);
                    this._$overlayContainer.css({
                        left: position.x + this._offset.left,
                        top: position.y + this._offset.top,
                        display: 'block'
                    })
                }
            };
        var googleMapsLoaded = function() {
                return window.google && window.google.maps
            };
        var googleMapsLoader;
        ui.dxMap.registerProvider("google", ui.dxMap.DynamicProvider.inherit({
            _mapType: function(type) {
                var mapTypes = {
                        hybrid: google.maps.MapTypeId.HYBRID,
                        roadmap: google.maps.MapTypeId.ROADMAP,
                        satellite: google.maps.MapTypeId.SATELLITE
                    };
                return mapTypes[type] || mapTypes.hybrid
            },
            _movementMode: function(type) {
                var movementTypes = {
                        driving: google.maps.TravelMode.DRIVING,
                        walking: google.maps.TravelMode.WALKING
                    };
                return movementTypes[type] || movementTypes.driving
            },
            _resolveLocation: function(location) {
                var d = $.Deferred();
                if (typeof location === "string") {
                    var geocoder = new google.maps.Geocoder;
                    geocoder.geocode({address: location}, function(results, status) {
                        if (status === google.maps.GeocoderStatus.OK)
                            d.resolve(results[0].geometry.location)
                    })
                }
                else if ($.isArray(location))
                    d.resolve(new google.maps.LatLng(location[0], location[1]));
                else if ($.isPlainObject(location) && $.isNumeric(location.lat) && $.isNumeric(location.lng))
                    d.resolve(new google.maps.LatLng(location.lat, location.lng));
                return d.promise()
            },
            _normalizeLocation: function(location) {
                return {
                        lat: location.lat(),
                        lng: location.lng()
                    }
            },
            _normalizeLocationRect: function(locationRect) {
                return {
                        northEast: this._normalizeLocation(locationRect.getNorthEast()),
                        southWest: this._normalizeLocation(locationRect.getSouthWest())
                    }
            },
            _loadImpl: function() {
                this._googleMapsLoader = $.Deferred();
                if (googleMapsLoaded())
                    this._mapReady();
                else {
                    if (!googleMapsLoader || googleMapsLoader.state() == "resolved" && !googleMapsLoaded()) {
                        googleMapsLoader = $.Deferred();
                        var key = this._keyOption("google");
                        window[GOOGLE_MAP_READY] = $.proxy(googleMapsLoader.resolve, googleMapsLoader);
                        $.getScript(GOOGLE_URL + (key ? "&key=" + key : ""))
                    }
                    googleMapsLoader.done($.proxy(this._mapReady, this))
                }
                return this._googleMapsLoader.promise()
            },
            _mapReady: function() {
                try {
                    delete window[GOOGLE_MAP_READY]
                }
                catch(e) {
                    window[GOOGLE_MAP_READY] = undefined
                }
                initCustomMarkerClass();
                this._googleMapsLoader.resolve()
            },
            _init: function() {
                var deferred = $.Deferred(),
                    initPromise = $.Deferred(),
                    controls = this._option("controls");
                this._map = new google.maps.Map(this._$container[0], {
                    zoom: this._option("zoom"),
                    panControl: controls,
                    zoomControl: controls,
                    mapTypeControl: controls,
                    streetViewControl: controls
                });
                var listner = google.maps.event.addListener(this._map, 'idle', $.proxy(initPromise.resolve, initPromise));
                $.when(initPromise).done($.proxy(function() {
                    google.maps.event.removeListener(listner);
                    deferred.resolve()
                }, this));
                return deferred.promise()
            },
            _attachHandlers: function() {
                this._boundsChangeListener = google.maps.event.addListener(this._map, 'bounds_changed', $.proxy(this._boundsChangeHandler, this));
                this._clickListener = google.maps.event.addListener(this._map, 'click', $.proxy(this._clickActionHandler, this))
            },
            _boundsChangeHandler: function() {
                var bounds = this._map.getBounds();
                this._option("bounds", this._normalizeLocationRect(bounds));
                var center = this._map.getCenter();
                this._option("center", this._normalizeLocation(center));
                if (!this._preventZoomChangeEvent)
                    this._option("zoom", this._map.getZoom())
            },
            _clickActionHandler: function(e) {
                this._fireClickAction({location: this._normalizeLocation(e.latLng)})
            },
            updateDimensions: function() {
                var center = this._option("center");
                google.maps.event.trigger(this._map, 'resize');
                this._option("center", center);
                return this.updateCenter()
            },
            updateMapType: function() {
                this._map.setMapTypeId(this._mapType(this._option("type")));
                return $.Deferred().resolve().promise()
            },
            updateBounds: function() {
                var deferred = $.Deferred(),
                    that = this;
                var northEastPromise = this._resolveLocation(this._option("bounds.northEast")),
                    southWestPromise = this._resolveLocation(this._option("bounds.southWest"));
                $.when(northEastPromise, southWestPromise).done(function(northEast, southWest) {
                    var bounds = new google.maps.LatLngBounds;
                    bounds.extend(northEast);
                    bounds.extend(southWest);
                    that._map.fitBounds(bounds);
                    deferred.resolve()
                });
                return deferred.promise()
            },
            updateCenter: function() {
                var deferred = $.Deferred(),
                    that = this;
                this._resolveLocation(this._option("center")).done(function(location) {
                    that._map.setCenter(location);
                    deferred.resolve()
                });
                return deferred.promise()
            },
            updateZoom: function() {
                this._map.setZoom(this._option("zoom"));
                return $.Deferred().resolve().promise()
            },
            updateControls: function() {
                var controls = this._option("controls");
                this._map.setOptions({
                    panControl: controls,
                    zoomControl: controls,
                    mapTypeControl: controls,
                    streetViewControl: controls
                });
                return $.Deferred().resolve().promise()
            },
            _renderMarker: function(options) {
                var d = $.Deferred(),
                    that = this;
                this._resolveLocation(options.location).done(function(location) {
                    var marker;
                    if (options.html)
                        marker = new CustomMarker({
                            map: that._map,
                            position: location,
                            html: options.html,
                            offset: $.extend({
                                top: 0,
                                left: 0
                            }, options.htmlOffset)
                        });
                    else
                        marker = new google.maps.Marker({
                            position: location,
                            map: that._map,
                            icon: options.iconSrc || that._option("markerIconSrc")
                        });
                    var infoWindow = that._renderTooltip(marker, options.tooltip);
                    if (options.clickAction) {
                        DX.log("W0001", "dxMap", "marker.clickAction", "14.2", "Use 'onClick' option instead");
                        options.onClick = options.clickAction
                    }
                    var listner;
                    if (options.onClick || options.tooltip) {
                        var markerClickAction = that._createAction(options.onClick || $.noop),
                            markerNormalizedLocation = that._normalizeLocation(location);
                        listner = google.maps.event.addListener(marker, "click", function() {
                            markerClickAction({location: markerNormalizedLocation});
                            if (infoWindow)
                                infoWindow.open(that._map, marker)
                        })
                    }
                    d.resolve({
                        location: location,
                        marker: marker,
                        listner: listner
                    })
                });
                return d.promise()
            },
            _renderTooltip: function(marker, options) {
                if (!options)
                    return;
                options = this._parseTooltipOptions(options);
                var infoWindow = new google.maps.InfoWindow({content: options.text});
                if (options.visible)
                    infoWindow.open(this._map, marker);
                return infoWindow
            },
            _destroyMarker: function(marker) {
                marker.marker.setMap(null);
                if (marker.listner)
                    google.maps.event.removeListener(marker.listner)
            },
            _renderRoute: function(options) {
                var d = $.Deferred(),
                    that = this,
                    directionsService = new google.maps.DirectionsService;
                var points = $.map(options.locations, function(point) {
                        return that._resolveLocation(point)
                    });
                $.when.apply($, points).done(function() {
                    var locations = $.makeArray(arguments),
                        origin = locations.shift(),
                        destination = locations.pop(),
                        waypoints = $.map(locations, function(location) {
                            return {
                                    location: location,
                                    stopover: true
                                }
                        });
                    var request = {
                            origin: origin,
                            destination: destination,
                            waypoints: waypoints,
                            optimizeWaypoints: true,
                            travelMode: that._movementMode(options.mode)
                        };
                    directionsService.route(request, function(response, status) {
                        if (status === google.maps.DirectionsStatus.OK) {
                            var color = new DX.Color(options.color || that._defaultRouteColor()).toHex(),
                                directionOptions = {
                                    directions: response,
                                    map: that._map,
                                    suppressMarkers: true,
                                    preserveViewport: true,
                                    polylineOptions: {
                                        strokeWeight: options.weight || that._defaultRouteWeight(),
                                        strokeOpacity: options.opacity || that._defaultRouteOpacity(),
                                        strokeColor: color
                                    }
                                };
                            var route = new google.maps.DirectionsRenderer(directionOptions),
                                bounds = response.routes[0].bounds;
                            d.resolve({
                                instance: route,
                                northEast: bounds.getNorthEast(),
                                southWest: bounds.getSouthWest()
                            })
                        }
                    })
                });
                return d.promise()
            },
            _destroyRoute: function(routeObject) {
                routeObject.instance.setMap(null)
            },
            _fitBounds: function() {
                this._updateBounds();
                if (this._bounds && this._option("autoAdjust")) {
                    var zoomBeforeFitting = this._map.getZoom();
                    this._preventZoomChangeEvent = true;
                    this._map.fitBounds(this._bounds);
                    var zoomAfterFitting = this._map.getZoom();
                    if (zoomBeforeFitting < zoomAfterFitting)
                        this._map.setZoom(zoomBeforeFitting);
                    else
                        this._option("zoom", zoomAfterFitting);
                    delete this._preventZoomChangeEvent
                }
                return $.Deferred().resolve().promise()
            },
            _extendBounds: function(location) {
                if (this._bounds)
                    this._bounds.extend(location);
                else {
                    this._bounds = new google.maps.LatLngBounds;
                    this._bounds.extend(location)
                }
            },
            clean: function() {
                if (this._map) {
                    google.maps.event.removeListener(this._boundsChangeListener);
                    google.maps.event.removeListener(this._clickListener);
                    this._clearMarkers();
                    this._clearRoutes();
                    delete this._map;
                    this._$container.empty()
                }
                return $.Deferred().resolve().promise()
            }
        }));
        ui.dxMap.__internals = $.extend(ui.dxMap.__internals, {remapGoogleConstant: function(newValue) {
                GOOGLE_URL = newValue
            }})
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.swipeable.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            DX_SWIPEABLE = "dxSwipeable",
            SWIPEABLE_CLASS = "dx-swipeable",
            ACTION_TO_EVENT_MAP = {
                onStart: "dxswipestart",
                onUpdated: "dxswipe",
                onEnd: "dxswipeend",
                onCancel: "dxswipecancel"
            };
        DX.registerComponent(DX_SWIPEABLE, ui, DX.DOMComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    elastic: true,
                    immediate: false,
                    direction: "horizontal",
                    itemSizeFunc: null,
                    onStart: null,
                    onUpdated: null,
                    onEnd: null,
                    onCancel: null
                })
            },
            _render: function() {
                this.callBase();
                this.element().addClass(SWIPEABLE_CLASS);
                this._attachEventHandlers()
            },
            _attachEventHandlers: function() {
                this._detachEventHanlers();
                if (this.option("disabled"))
                    return;
                var NAME = this.NAME;
                this._createEventData();
                $.each(ACTION_TO_EVENT_MAP, $.proxy(function(actionName, eventName) {
                    var action = this._createActionByOption(actionName, {context: this});
                    eventName = events.addNamespace(eventName, NAME);
                    this.element().on(eventName, this._eventData, function(e) {
                        return action({jQueryEvent: e})
                    })
                }, this))
            },
            _createEventData: function() {
                this._eventData = {
                    elastic: this.option("elastic"),
                    itemSizeFunc: this.option("itemSizeFunc"),
                    direction: this.option("direction"),
                    immediate: this.option("immediate")
                }
            },
            _detachEventHanlers: function() {
                this.element().off("." + DX_SWIPEABLE)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"disabled":
                    case"onStart":
                    case"onUpdated":
                    case"onEnd":
                    case"onCancel":
                    case"elastic":
                    case"immediate":
                    case"itemSizeFunc":
                    case"direction":
                        this._detachEventHanlers();
                        this._attachEventHandlers();
                        break;
                    case"rtlEnabled":
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.draggable.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            translator = DX.translator,
            inflector = DX.inflector,
            events = ui.events,
            DRAGGABLE = "dxDraggable",
            DRAGSTART_EVENT_NAME = events.addNamespace("dxdragstart", DRAGGABLE),
            DRAG_EVENT_NAME = events.addNamespace("dxdrag", DRAGGABLE),
            DRAGEND_EVENT_NAME = events.addNamespace("dxdragend", DRAGGABLE),
            POINTERDOWN_EVENT_NAME = events.addNamespace("dxpointerdown", DRAGGABLE),
            DRAGGABLE_CLASS = inflector.dasherize(DRAGGABLE);
        DX.registerComponent(DRAGGABLE, ui, DX.DOMComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    onDragStart: $.noop,
                    onDrag: $.noop,
                    onDragEnd: $.noop,
                    direction: "both",
                    area: window,
                    boundOffset: 0,
                    allowMoveByClick: false
                })
            },
            _init: function() {
                this.callBase();
                this._attachEventHandlers()
            },
            _attachEventHandlers: function() {
                var $element = this.element().css("position", "absolute"),
                    eventHandlers = {},
                    allowMoveByClick = this.option("allowMoveByClick");
                eventHandlers[DRAGSTART_EVENT_NAME] = $.proxy(this._dragStartHandler, this);
                eventHandlers[DRAG_EVENT_NAME] = $.proxy(this._dragHandler, this);
                eventHandlers[DRAGEND_EVENT_NAME] = $.proxy(this._dragEndHandler, this);
                if (allowMoveByClick) {
                    eventHandlers[POINTERDOWN_EVENT_NAME] = $.proxy(this._pointerDownHandler, this);
                    $element = this._getArea()
                }
                $element.on(eventHandlers, {direction: this.option("direction")})
            },
            _detachEventHandlers: function() {
                this.element().off("." + DRAGGABLE);
                this._getArea().off("." + DRAGGABLE)
            },
            _move: function(position) {
                translator.move(this.element(), position)
            },
            _pointerDownHandler: function(e) {
                var $area = $(e.currentTarget),
                    areaOffset = $.isWindow($area.get(0)) ? {
                        left: 0,
                        top: 0
                    } : $area.offset(),
                    direction = this.option("direction"),
                    position = {};
                if (direction === "horizontal" || direction === "both")
                    position.left = e.pageX - this.element().width() / 2 - areaOffset.left;
                if (direction === "vertical" || direction === "both")
                    position.top = e.pageY - this.element().height() / 2 - areaOffset.top;
                this._move(position);
                this._getAction("onDrag")({jQueryEvent: e})
            },
            _dragStartHandler: function(e) {
                var $element = this.element(),
                    $area = this._getArea(),
                    boundOffset = this._getBoundOffset(),
                    areaWidth = $area.outerWidth(),
                    areaHeight = $area.outerHeight(),
                    elementWidth = $element.width(),
                    elementHeight = $element.height();
                this._startPosition = translator.locate($element);
                e.maxLeftOffset = this._startPosition.left - boundOffset.h;
                e.maxRightOffset = areaWidth - this._startPosition.left - elementWidth - boundOffset.h;
                e.maxTopOffset = this._startPosition.top - boundOffset.v;
                e.maxBottomOffset = areaHeight - this._startPosition.top - elementHeight - boundOffset.v;
                this._getAction("onDragStart")({jQueryEvent: e})
            },
            _getBoundOffset: function() {
                var boundOffset = this.option("boundOffset");
                if ($.isFunction(boundOffset))
                    boundOffset = boundOffset.call(this);
                return DX.utils.stringPairToObject(boundOffset)
            },
            _getArea: function() {
                var area = this.option("area");
                if ($.isFunction(area))
                    area = area.call(this);
                return $(area)
            },
            _dragHandler: function(e) {
                var offset = e.offset,
                    startPosition = this._startPosition;
                this._move({
                    left: startPosition.left + offset.x,
                    top: startPosition.top + offset.y
                });
                this._getAction("onDrag")({jQueryEvent: e})
            },
            _dragEndHandler: function(e) {
                this._getAction("onDragEnd")({jQueryEvent: e})
            },
            _getAction: function(name) {
                return this["_" + name + "Action"] || this._createActionByOption(name)
            },
            _render: function() {
                this.callBase();
                this.element().addClass(DRAGGABLE_CLASS)
            },
            _optionChanged: function(args) {
                var name = args.name;
                switch (name) {
                    case"onDragStart":
                    case"onDrag":
                    case"onDragEnd":
                        this["_" + name + "Action"] = this._createActionByOption(name);
                        break;
                    case"allowMoveByClick":
                    case"direction":
                        this._detachEventHandlers();
                        this._attachEventHandlers();
                        break;
                    case"boundOffset":
                    case"area":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _dispose: function() {
                this.callBase();
                this._detachEventHandlers()
            }
        }));
        ui.dxDraggable.__internals = {DRAGGABLE_CLASS: DRAGGABLE_CLASS}
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.box.js */
    (function($, DX, undefined) {
        var ui = DevExpress.ui;
        var BOX_CLASS = "dx-box",
            BOX_SELECTOR = ".dx-box",
            BOX_ITEM_CLASS = "dx-box-item",
            BOX_ITEM_DATA_KEY = "dxBoxItemData";
        var MINSIZE_MAP = {
                row: "minWidth",
                col: "minHeight"
            };
        var MAXSIZE_MAP = {
                row: "maxWidth",
                col: "maxHeight"
            };
        var SHRINK = 1;
        var FLEX_JUSTIFY_CONTENT_MAP = {
                start: "flex-start",
                end: "flex-end",
                center: "center",
                "space-between": "space-between",
                "space-around": "space-around"
            };
        var FLEX_ALIGN_ITEMS_MAP = {
                start: "flex-start",
                end: "flex-end",
                center: "center",
                stretch: "stretch"
            };
        var FLEX_DIRECTION_MAP = {
                row: "row",
                col: "column"
            };
        var FlexLayoutStrategy = DX.Class.inherit({
                ctor: function($element, option) {
                    this._$element = $element;
                    this._option = option
                },
                renderBox: function() {
                    this._$element.css({
                        display: DX.support.stylePropPrefix("flexDirection") + "flex",
                        flexDirection: FLEX_DIRECTION_MAP[this._option("direction")]
                    })
                },
                renderAlign: function() {
                    this._$element.css({justifyContent: this._normalizedAlign()})
                },
                _normalizedAlign: function() {
                    var align = this._option("align");
                    return align in FLEX_JUSTIFY_CONTENT_MAP ? FLEX_JUSTIFY_CONTENT_MAP[align] : align
                },
                renderCrossAlign: function() {
                    this._$element.css({alignItems: this._normalizedCrossAlign()})
                },
                _normalizedCrossAlign: function() {
                    var crossAlign = this._option("crossAlign");
                    return crossAlign in FLEX_ALIGN_ITEMS_MAP ? FLEX_ALIGN_ITEMS_MAP[crossAlign] : crossAlign
                },
                renderItems: function($items) {
                    var direction = this._option("direction");
                    $.each($items, function() {
                        var $item = $(this);
                        var item = $item.data(BOX_ITEM_DATA_KEY);
                        $item.css({
                            display: DX.support.stylePropPrefix("flexDirection") + "flex",
                            flexGrow: item.ratio,
                            flexShrink: item.shrink || SHRINK,
                            flexBasis: item.baseSize || 0
                        }).css(MAXSIZE_MAP[direction], item.maxSize || "none").css(MINSIZE_MAP[direction], item.minSize || "none");
                        $item.children().css({
                            width: "auto",
                            height: "auto",
                            display: DX.support.stylePropPrefix("flexDirection") + "flex",
                            flexGrow: "1",
                            flexDirection: $item.children().css("flexDirection") || "column"
                        })
                    })
                },
                update: $.noop
            });
        var BOX_EVENTNAMESPACE = "dxBox",
            UPDATE_EVENT = "dxupdate." + BOX_EVENTNAMESPACE,
            FALLBACK_BOX_ITEM = "dx-box-fallback-item";
        var FALLBACK_WRAP_MAP = {
                row: "nowrap",
                col: "normal"
            };
        var FALLBACK_MAIN_SIZE_MAP = {
                row: "width",
                col: "height"
            };
        var FALLBACK_CROSS_SIZE_MAP = {
                row: "height",
                col: "width"
            };
        var FALLBACK_PRE_MARGIN_MAP = {
                row: "marginLeft",
                col: "marginTop"
            };
        var FALLBACK_POST_MARGIN_MAP = {
                row: "marginRight",
                col: "marginBottom"
            };
        var FALLBACK_CROSS_PRE_MARGIN_MAP = {
                row: "marginTop",
                col: "marginLeft"
            };
        var FALLBACK_CROSS_POST_MARGIN_MAP = {
                row: "marginBottom",
                col: "marginRight"
            };
        var FallbackLayoutStrategy = DX.Class.inherit({
                ctor: function($element, option) {
                    this._$element = $element;
                    this._option = option
                },
                renderBox: function() {
                    this._$element.css({
                        fontSize: 0,
                        whiteSpace: FALLBACK_WRAP_MAP[this._option("direction")],
                        verticalAlign: "top"
                    });
                    this._$element.off(UPDATE_EVENT).on(UPDATE_EVENT, $.proxy(this.update, this))
                },
                renderAlign: function() {
                    var $items = this._$items;
                    if (!$items)
                        return;
                    var align = this._option("align"),
                        shift = 0,
                        totalItemSize = this.totalItemSize,
                        direction = this._option("direction"),
                        boxSize = this._$element[FALLBACK_MAIN_SIZE_MAP[direction]](),
                        freeSpace = boxSize - totalItemSize;
                    switch (align) {
                        case"start":
                            break;
                        case"end":
                            shift = freeSpace;
                            $items.first().css(FALLBACK_PRE_MARGIN_MAP[direction], shift);
                            break;
                        case"center":
                            shift = 0.5 * freeSpace;
                            $items.first().css(FALLBACK_PRE_MARGIN_MAP[direction], shift);
                            $items.last().css(FALLBACK_POST_MARGIN_MAP[direction], shift);
                            break;
                        case"space-between":
                            shift = 0.5 * freeSpace / ($items.length - 1);
                            $items.css(FALLBACK_PRE_MARGIN_MAP[direction], shift).css(FALLBACK_POST_MARGIN_MAP[direction], shift);
                            $items.first().css(FALLBACK_PRE_MARGIN_MAP[direction], 0);
                            $items.last().css(FALLBACK_POST_MARGIN_MAP[direction], 0);
                            break;
                        case"space-around":
                            shift = 0.5 * freeSpace / $items.length;
                            $items.css(FALLBACK_PRE_MARGIN_MAP[direction], shift).css(FALLBACK_POST_MARGIN_MAP[direction], shift);
                            break
                    }
                },
                renderCrossAlign: function() {
                    var $items = this._$items;
                    if (!$items)
                        return;
                    var crossAlign = this._option("crossAlign"),
                        direction = this._option("direction"),
                        size = this._$element[FALLBACK_CROSS_SIZE_MAP[direction]]();
                    switch (crossAlign) {
                        case"start":
                            break;
                        case"end":
                            $.each($items, function() {
                                var $item = $(this),
                                    itemSize = $item[FALLBACK_CROSS_SIZE_MAP[direction]](),
                                    shift = size - itemSize;
                                $item.css(FALLBACK_CROSS_PRE_MARGIN_MAP[direction], shift)
                            });
                            break;
                        case"center":
                            $.each($items, function() {
                                var $item = $(this),
                                    itemSize = $item[FALLBACK_CROSS_SIZE_MAP[direction]](),
                                    shift = 0.5 * (size - itemSize);
                                $item.css(FALLBACK_CROSS_PRE_MARGIN_MAP[direction], shift).css(FALLBACK_CROSS_POST_MARGIN_MAP[direction], shift)
                            });
                            break;
                        case"stretch":
                            $items.css(FALLBACK_CROSS_PRE_MARGIN_MAP[direction], 0).css(FALLBACK_CROSS_POST_MARGIN_MAP[direction], 0).css(FALLBACK_CROSS_SIZE_MAP[direction], "100%");
                            break
                    }
                },
                renderItems: function($items) {
                    this._$items = $items;
                    var direction = this._option("direction"),
                        totalRatio = 0,
                        totalWeightedShrink = 0,
                        totalBaseSize = 0,
                        boxSize = this._$element[FALLBACK_MAIN_SIZE_MAP[direction]](),
                        parseSize = function(size) {
                            return String(size).match(/.+%$/) ? 0.01 * parseFloat(size) * boxSize : size
                        },
                        contentSize = function($item) {
                            return $item[FALLBACK_MAIN_SIZE_MAP[direction]]()
                        },
                        baseSize = function($item) {
                            var item = $item.data(BOX_ITEM_DATA_KEY);
                            return item.baseSize == null ? 0 : item.baseSize === "auto" ? contentSize($item) : parseSize(item.baseSize)
                        };
                    $.each($items, function() {
                        var $item = $(this);
                        $item.css("display", "inline-block").css("vertical-align", "top");
                        $item[FALLBACK_MAIN_SIZE_MAP[direction]]("auto");
                        $item.removeClass(FALLBACK_BOX_ITEM);
                        var item = $item.data(BOX_ITEM_DATA_KEY),
                            ratio = item.ratio || 0,
                            size = baseSize($item),
                            shrink = item.shrink || SHRINK;
                        totalRatio += ratio;
                        totalWeightedShrink += shrink * size;
                        totalBaseSize += size
                    });
                    boxSize = this._$element[FALLBACK_MAIN_SIZE_MAP[direction]]();
                    var freeSpaceSize = boxSize - totalBaseSize;
                    var itemSize = function($item) {
                            var item = $item.data(BOX_ITEM_DATA_KEY),
                                size = baseSize($item),
                                factor = freeSpaceSize >= 0 ? item.ratio || 0 : (item.shrink || SHRINK) * size,
                                totalFactor = freeSpaceSize >= 0 ? totalRatio : totalWeightedShrink,
                                shift = totalFactor ? Math.round(freeSpaceSize * factor / totalFactor) : 0;
                            return size + shift
                        };
                    var totalItemSize = 0;
                    $.each($items, function() {
                        var $item = $(this),
                            item = $item.data(BOX_ITEM_DATA_KEY),
                            size = itemSize($item);
                        totalItemSize += size;
                        $item.css(MAXSIZE_MAP[direction], item.maxSize || "auto").css(MINSIZE_MAP[direction], item.minSize || "auto").css(FALLBACK_MAIN_SIZE_MAP[direction], size);
                        $item.addClass(FALLBACK_BOX_ITEM)
                    });
                    this.totalItemSize = totalItemSize
                },
                update: function() {
                    if (!this._$items || this._$element.is(":hidden"))
                        return;
                    this.renderItems(this._$items);
                    this.renderAlign();
                    this.renderCrossAlign();
                    var element = this._$element.get(0);
                    this._$items.find(BOX_SELECTOR).each(function() {
                        if (element === $(this).parent().closest(BOX_SELECTOR).get(0))
                            $(this).triggerHandler(UPDATE_EVENT)
                    })
                }
            });
        DX.registerComponent("dxBox", ui, ui.CollectionWidget.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    direction: "row",
                    align: "start",
                    crossAlign: "stretch",
                    activeStateEnabled: false,
                    focusStateEnabled: false,
                    _layoutStrategy: "flex"
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                var isOldAndroid = device.platform === "android" && (device.version[0] < 4 || device.version[0] === 4 && device.version[1] < 4),
                                    isOldIos = device.platform === "ios" && device.version[0] < 7;
                                return DX.browser["msie"] || isOldAndroid || isOldIos
                            },
                            options: {_layoutStrategy: "fallback"}
                        }])
            },
            _itemClass: function() {
                return BOX_ITEM_CLASS
            },
            _itemDataKey: function() {
                return BOX_ITEM_DATA_KEY
            },
            _itemElements: function() {
                return this._itemContainer().children(this._itemSelector())
            },
            _init: function() {
                this.callBase();
                this.element().addClass(BOX_CLASS + "-" + this.option("_layoutStrategy"));
                this._initLayout()
            },
            _initLayout: function() {
                this._layout = this.option("_layoutStrategy") === "fallback" ? new FallbackLayoutStrategy(this.element(), $.proxy(this.option, this)) : new FlexLayoutStrategy(this.element(), $.proxy(this.option, this))
            },
            _render: function() {
                this.callBase();
                this.element().addClass(BOX_CLASS);
                this._renderBox()
            },
            _renderBox: function() {
                this._layout.renderBox();
                this._layout.renderAlign();
                this._layout.renderCrossAlign()
            },
            _renderItems: function(items) {
                this.callBase(items);
                this._layout.renderItems(this._itemElements());
                this._updateTimer = setTimeout($.proxy(function() {
                    if (!this._isUpdated)
                        this._layout.update();
                    this._isUpdated = false
                }, this))
            },
            _postprocessRenderItem: function(args) {
                var boxConfig = args.itemData.box;
                if (boxConfig)
                    $(args.itemContent).dxBox($.extend(boxConfig, {_templates: this.option("_templates")}))
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._dimensionChanged()
            },
            _dimensionChanged: function() {
                this._isUpdated = true;
                this._layout.update()
            },
            _dispose: function() {
                delete this._updateTimer;
                this.callBase.apply(this, arguments)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"_layoutStrategy":
                    case"direction":
                        this._invalidate();
                        break;
                    case"align":
                        this._layout.renderAlign();
                        break;
                    case"crossAlign":
                        this._layout.renderCrossAlign();
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.responsiveBox.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var RESPONSIVE_BOX_CLASS = "dx-responsive-box",
            BOX_ITEM_CLASS = "dx-box-item",
            BOX_ITEM_DATA_KEY = "dxBoxItemData";
        var DEFAULT_SCREEN_FACTOR_FUNC = function(width) {
                if (width < 768)
                    return "xs";
                else if (width < 992)
                    return "sm";
                else if (width < 1200)
                    return "md";
                else
                    return "lg"
            };
        DX.registerComponent("dxResponsiveBox", ui, ui.CollectionWidget.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    rows: [],
                    cols: [],
                    screenByWidth: DEFAULT_SCREEN_FACTOR_FUNC,
                    singleColumnScreen: "xs",
                    activeStateEnabled: false,
                    focusStateEnabled: false
                })
            },
            _initOptions: function(options) {
                if (options.screenByWidth)
                    this.option("singleColumnScreen", options.screenByWidth(0));
                this.callBase(options)
            },
            _itemClass: function() {
                return BOX_ITEM_CLASS
            },
            _itemDataKey: function() {
                return BOX_ITEM_DATA_KEY
            },
            _render: function() {
                this.callBase();
                this.element().addClass(RESPONSIVE_BOX_CLASS);
                this._updateRootBox()
            },
            _updateRootBox: function() {
                this._updateTimer = setTimeout($.proxy(function() {
                    if (this._$root)
                        this._$root.trigger("dxupdate")
                }, this))
            },
            _renderItems: function() {
                this._screenItems = this._itemsByScreen();
                this._prepareGrid();
                this._spreadItems();
                this._layoutItems();
                this._linkNodeToItem()
            },
            _prepareGrid: function() {
                var grid = this._grid = [];
                this._prepareRowsAndCols();
                $.each(this._rows, $.proxy(function() {
                    var row = [];
                    grid.push(row);
                    $.each(this._cols, $.proxy(function() {
                        row.push(this._createEmptyCell())
                    }, this))
                }, this))
            },
            _prepareRowsAndCols: function() {
                if (this._isSingleColumnScreen()) {
                    this._prepareSingleColumnScreenItems();
                    this._rows = this._defaultSizeConfig(this._screenItems.length);
                    this._cols = this._defaultSizeConfig(1)
                }
                else {
                    this._rows = this._sizesByScreen(this.option("rows"));
                    this._cols = this._sizesByScreen(this.option("cols"))
                }
            },
            _isSingleColumnScreen: function() {
                return this._screenRegExp().test(this.option("singleColumnScreen"))
            },
            _prepareSingleColumnScreenItems: function() {
                this._screenItems.sort(function(item1, item2) {
                    return item1.location.row - item2.location.row || item1.location.col - item2.location.col
                });
                $.each(this._screenItems, function(index, item) {
                    $.extend(item.location, {
                        row: index,
                        col: 0,
                        rowspan: 1,
                        colspan: 1
                    })
                })
            },
            _sizesByScreen: function(sizeConfigs) {
                return $.map(this._filterByScreen(sizeConfigs), $.proxy(function(sizeConfig) {
                        return $.extend(this._defaultSizeConfig(), sizeConfig)
                    }, this))
            },
            _defaultSizeConfig: function(size) {
                var defaultSizeConfig = {
                        ratio: 1,
                        baseSize: 0,
                        minSize: 0,
                        maxSize: 0
                    };
                if (!arguments.length)
                    return defaultSizeConfig;
                var result = [];
                for (var i = 0; i < size; i++)
                    result.push(defaultSizeConfig);
                return result
            },
            _filterByScreen: function(items) {
                var screenRegExp = this._screenRegExp();
                return $.grep(items, function(item) {
                        return !item.screen || screenRegExp.test(item.screen)
                    })
            },
            _screenRegExp: function() {
                var width = this._screenWidth();
                var screen = this.option("screenByWidth")(width);
                return new RegExp("(^|\\s)" + screen + "($|\\s)", "i")
            },
            _screenWidth: function() {
                return $(window).width()
            },
            _createEmptyCell: function() {
                return {
                        item: {},
                        location: {
                            colspan: 1,
                            rowspan: 1
                        }
                    }
            },
            _spreadItems: function() {
                var cols = this.option("cols");
                $.each(this._screenItems, $.proxy(function(_, itemInfo) {
                    var location = itemInfo.location || {};
                    var itemCol = location.col;
                    var itemRow = location.row;
                    var row = this._grid[itemRow];
                    var itemCell = row && row[itemCol];
                    this._occupyCells(itemCell, itemInfo)
                }, this))
            },
            _itemsByScreen: function() {
                return $.map(this.option("items"), $.proxy(function(item) {
                        var locations = item.location || {};
                        locations = $.isPlainObject(locations) ? [locations] : locations;
                        return $.map(this._filterByScreen(locations), function(location) {
                                return {
                                        item: item,
                                        location: $.extend({
                                            rowspan: 1,
                                            colspan: 1
                                        }, location)
                                    }
                            })
                    }, this))
            },
            _occupyCells: function(itemCell, itemInfo) {
                if (!itemCell || this._isItemCellOccupied(itemCell, itemInfo))
                    return;
                $.extend(itemCell, itemInfo);
                this._markSpanningCell(itemCell)
            },
            _isItemCellOccupied: function(itemCell, itemInfo) {
                if (!$.isEmptyObject(itemCell.item))
                    return true;
                var result = false;
                this._loopOverSpanning(itemInfo.location, function(cell) {
                    result = result || !$.isEmptyObject(cell.item)
                });
                return result
            },
            _loopOverSpanning: function(location, callback) {
                var rowEnd = location.row + location.rowspan - 1;
                var colEnd = location.col + location.colspan - 1;
                var boundRowEnd = Math.min(rowEnd, this._rows.length - 1);
                var boundColEnd = Math.min(colEnd, this._cols.length - 1);
                location.rowspan -= rowEnd - boundRowEnd;
                location.colspan -= colEnd - boundColEnd;
                for (var rowIndex = location.row; rowIndex <= boundRowEnd; rowIndex++)
                    for (var colIndex = location.col; colIndex <= boundColEnd; colIndex++)
                        if (rowIndex !== location.row || colIndex !== location.col)
                            callback(this._grid[rowIndex][colIndex])
            },
            _markSpanningCell: function(itemCell) {
                this._loopOverSpanning(itemCell.location, function(cell) {
                    $.extend(cell, {
                        item: itemCell.item,
                        spanningCell: itemCell
                    })
                })
            },
            _linkNodeToItem: function() {
                $.each(this._itemElements(), function(_, itemNode) {
                    var $item = $(itemNode),
                        item = $item.data(BOX_ITEM_DATA_KEY);
                    if (!item.box)
                        item.node = $item.children()
                })
            },
            _layoutItems: function() {
                var rowsCount = this._grid.length;
                var colsCount = rowsCount && this._grid[0].length;
                if (!rowsCount && !colsCount)
                    return;
                var result = this._layoutBlock({
                        direction: "col",
                        row: {
                            start: 0,
                            end: rowsCount - 1
                        },
                        col: {
                            start: 0,
                            end: colsCount - 1
                        }
                    });
                var rootBox = this._prepareBoxConfig(result.box || {
                        direction: "col",
                        items: [result]
                    });
                $.extend(rootBox, {
                    width: "100%",
                    height: "100%",
                    _templates: this.option("_templates")
                });
                this._$root = $("<div>").appendTo(this._itemContainer()).dxBox(rootBox)
            },
            _prepareBoxConfig: function(config) {
                return $.extend(config || {}, {crossAlign: "stretch"})
            },
            _layoutBlock: function(options) {
                if (this._isSingleItem(options))
                    return this._itemByCell(options.row.start, options.col.start);
                return this._layoutDirection(options)
            },
            _isSingleItem: function(options) {
                var firstCellLocation = this._grid[options.row.start][options.col.start].location;
                var isItemRowSpanned = options.row.end - options.row.start === firstCellLocation.rowspan - 1;
                var isItemColSpanned = options.col.end - options.col.start === firstCellLocation.colspan - 1;
                return isItemRowSpanned && isItemColSpanned
            },
            _itemByCell: function(rowIndex, colIndex) {
                var itemCell = this._grid[rowIndex][colIndex];
                return itemCell.spanningCell ? null : itemCell.item
            },
            _layoutDirection: function(options) {
                var items = [];
                var direction = options.direction;
                var crossDirection = this._crossDirection(direction);
                var block;
                while (block = this._nextBlock(options)) {
                    if (this._isBlockIndivisible(options.prevBlockOptions, block))
                        throw DX.Error("E1025");
                    var item = this._layoutBlock({
                            direction: crossDirection,
                            row: block.row,
                            col: block.col,
                            prevBlockOptions: options
                        });
                    if (item) {
                        $.extend(item, this._blockSize(block, crossDirection));
                        items.push(item)
                    }
                    options[crossDirection].start = block[crossDirection].end + 1
                }
                return {box: this._prepareBoxConfig({
                            direction: direction,
                            items: items
                        })}
            },
            _isBlockIndivisible: function(options, block) {
                return options && options.col.start === block.col.start && options.col.end === block.col.end && options.row.start === block.row.start && options.row.end === block.row.end
            },
            _crossDirection: function(direction) {
                return direction === "col" ? "row" : "col"
            },
            _nextBlock: function(options) {
                var direction = options.direction;
                var crossDirection = this._crossDirection(direction);
                var startIndex = options[direction].start;
                var endIndex = options[direction].end;
                var crossStartIndex = options[crossDirection].start;
                if (crossStartIndex > options[crossDirection].end)
                    return null;
                var crossSpan = 1;
                for (var crossIndex = crossStartIndex; crossIndex < crossStartIndex + crossSpan; crossIndex++) {
                    var lineCrossSpan = 1;
                    for (var index = startIndex; index <= endIndex; index++) {
                        var cell = this._cellByDirection(direction, index, crossIndex);
                        lineCrossSpan = Math.max(lineCrossSpan, cell.location[crossDirection + "span"])
                    }
                    var lineCrossEndIndex = crossIndex + lineCrossSpan;
                    var crossEndIndex = crossStartIndex + crossSpan;
                    if (lineCrossEndIndex > crossEndIndex)
                        crossSpan += lineCrossEndIndex - crossEndIndex
                }
                var result = {};
                result[direction] = {
                    start: startIndex,
                    end: endIndex
                };
                result[crossDirection] = {
                    start: crossStartIndex,
                    end: crossStartIndex + crossSpan - 1
                };
                return result
            },
            _cellByDirection: function(direction, index, crossIndex) {
                return direction === "col" ? this._grid[crossIndex][index] : this._grid[index][crossIndex]
            },
            _blockSize: function(block, direction) {
                var sizeConfigs = direction === "row" ? this._rows : this._cols;
                var result = {
                        ratio: 0,
                        baseSize: 0,
                        minSize: 0,
                        maxSize: 0
                    };
                for (var index = block[direction].start; index <= block[direction].end; index++) {
                    var sizeConfig = sizeConfigs[index];
                    result.ratio += sizeConfig.ratio;
                    result.baseSize += sizeConfig.baseSize;
                    result.minSize += sizeConfig.minSize;
                    result.maxSize += sizeConfig.maxSize
                }
                result.minSize = result.minSize ? result.minSize : "auto";
                result.maxSize = result.maxSize ? result.maxSize : "auto";
                return result
            },
            _update: function() {
                var $existingRoot = this._$root;
                this._renderItems();
                $existingRoot.remove()
            },
            _dispose: function() {
                delete this._updateTimer;
                this.callBase.apply(this, arguments)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"rows":
                    case"cols":
                    case"screenByWidth":
                    case"singleColumnScreen":
                        this._invalidate();
                        break;
                    case"width":
                    case"height":
                        this.callBase(args);
                        this._update();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _dimensionChanged: function() {
                this._update()
            },
            update: function() {
                this._update()
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.button.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var BUTTON_CLASS = "dx-button",
            BUTTON_CONTENT_CLASS = "dx-button-content",
            BUTTON_CONTENT_SELECTOR = ".dx-button-content",
            BUTTON_TEXT_CLASS = "dx-button-text",
            BUTTON_HAS_TEXT_CLASS = "dx-button-has-text",
            BUTTON_HAS_ICON_CLASS = "dx-button-has-icon",
            BUTTON_TEXT_SELECTOR = ".dx-button-text",
            BUTTON_BACK_ARROW_CLASS = "dx-button-back-arrow",
            ICON_CLASS = "dx-icon",
            ICON_SELECTOR = ".dx-icon",
            BUTTON_FEEDBACK_HIDE_TIMEOUT = 100;
        DX.registerComponent("dxButton", ui, ui.Widget.inherit({
            _supportedKeys: function() {
                var that = this,
                    click = function(e) {
                        that._executeClickAction(e)
                    };
                return $.extend(this.callBase(), {
                        space: click,
                        enter: click
                    })
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {clickAction: {
                        since: "14.2",
                        alias: "onClick"
                    }})
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    onClick: null,
                    type: "normal",
                    text: "",
                    icon: "",
                    iconSrc: "",
                    validationGroup: undefined,
                    activeStateEnabled: true
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {
                                hoverStateEnabled: true,
                                focusStateEnabled: true
                            }
                        }])
            },
            _init: function() {
                this.callBase();
                this._feedbackHideTimeout = BUTTON_FEEDBACK_HIDE_TIMEOUT
            },
            _render: function() {
                this.callBase();
                this.element().addClass(BUTTON_CLASS).append($("<div>").addClass(BUTTON_CONTENT_CLASS));
                this._renderClick();
                this._renderIcon();
                this._renderType();
                this._renderText()
            },
            _renderClick: function() {
                var that = this,
                    eventName = events.addNamespace("dxclick", this.NAME);
                this._clickAction = this._createActionByOption("onClick");
                this.element().off(eventName).on(eventName, function(e) {
                    that._executeClickAction(e)
                })
            },
            _executeClickAction: function(e) {
                this._clickAction({
                    jQueryEvent: e,
                    validationGroup: DX.validationEngine.getGroupConfig(this._findGroup())
                })
            },
            _removeTypesCss: function() {
                var css = this.element().attr("class");
                css = css.replace(/\bdx-button-[-a-z0-9]+\b/gi, "");
                this.element().attr("class", css)
            },
            _renderIcon: function() {
                var contentElement = this.element().find(BUTTON_CONTENT_SELECTOR),
                    iconElement = contentElement.find(ICON_SELECTOR),
                    icon = this.option("icon"),
                    iconSrc = this.option("iconSrc");
                iconElement.remove();
                if (this.option("type") === "back" && !icon)
                    icon = "back";
                if (!icon && !iconSrc)
                    return;
                if (icon)
                    iconElement = $("<span>").addClass("dx-icon-" + icon);
                else if (iconSrc)
                    iconElement = $("<img>").attr("src", iconSrc);
                contentElement.prepend(iconElement.addClass(ICON_CLASS));
                this.element().addClass(BUTTON_HAS_ICON_CLASS)
            },
            _renderType: function() {
                var type = this.option("type");
                if (type)
                    this.element().addClass("dx-button-" + type);
                var contentElement = this.element().find(BUTTON_CONTENT_SELECTOR);
                if (type === "back")
                    contentElement.prepend($("<span>").addClass(BUTTON_BACK_ARROW_CLASS))
            },
            _renderText: function() {
                var text = this.option("text"),
                    contentElement = this.element().find(BUTTON_CONTENT_SELECTOR),
                    back = this.option("type") === "back";
                var textElement = contentElement.find(BUTTON_TEXT_SELECTOR);
                if (!text && !back) {
                    textElement.remove();
                    return
                }
                if (!textElement.length)
                    textElement = $('<span>').addClass(BUTTON_TEXT_CLASS).appendTo(contentElement);
                textElement.text(text || DX.localization.localizeString("@Back"));
                this.element().addClass(BUTTON_HAS_TEXT_CLASS)
            },
            _clean: function() {
                this.callBase();
                this._removeTypesCss()
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"onClick":
                        this._renderClick();
                        break;
                    case"icon":
                    case"iconSrc":
                        this._renderIcon();
                        break;
                    case"text":
                        this._renderText();
                        break;
                    case"type":
                        this._invalidate();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _findGroup: DX.ui.validation.findGroup
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.checkBox.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var CHECKBOX_CLASS = "dx-checkbox",
            CHECKBOX_ICON_CLASS = "dx-checkbox-icon",
            CHECKBOX_CHECKED_CLASS = "dx-checkbox-checked",
            CHECKBOX_CONTAINER_CLASS = "dx-checkbox-container",
            CHECKBOX_CONTAINER_SELECTOR = ".dx-checkbox-container",
            CHECKBOX_TEXT_CLASS = "dx-checkbox-text",
            CHECKBOX_TEXT_SELECTOR = ".dx-checkbox-text",
            CHECKBOX_HAS_TEXT_CLASS = "dx-checkbox-has-text",
            CHECKBOX_INDETERMINATE_CLASS = "dx-checkbox-indeterminate",
            CHECKBOX_FEEDBACK_HIDE_TIMEOUT = 100,
            CHECKBOX_DXCLICK_EVENT_NAME = events.addNamespace("dxclick", "dxCheckBox");
        DX.registerComponent("dxCheckBox", ui, ui.Editor.inherit({
            _supportedKeys: function() {
                var click = function(e) {
                        this._clickAction({jQueryEvent: e})
                    };
                return $.extend(this.callBase(), {
                        space: click,
                        enter: click
                    })
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {checked: {
                        since: "14.1",
                        alias: "value"
                    }})
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    value: false,
                    text: ""
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {
                                hoverStateEnabled: true,
                                focusStateEnabled: true
                            }
                        }])
            },
            _init: function() {
                this.callBase();
                this._feedbackHideTimeout = CHECKBOX_FEEDBACK_HIDE_TIMEOUT
            },
            _render: function() {
                this.callBase();
                this.element().addClass(CHECKBOX_CLASS).append($("<div>").addClass(CHECKBOX_CONTAINER_CLASS));
                this._$container = this.element().find(CHECKBOX_CONTAINER_SELECTOR);
                this._renderClick();
                this._renderValue();
                this._renderIcon();
                this._renderText()
            },
            _renderDimensions: function() {
                this.callBase()
            },
            _renderIcon: function() {
                this._$icon = $("<span>").addClass(CHECKBOX_ICON_CLASS).prependTo(this._$container)
            },
            _renderText: function() {
                this._$text = this._$container.find(CHECKBOX_TEXT_SELECTOR);
                if (!this.option("text")) {
                    if (this._$text) {
                        this._$text.remove();
                        this.element().removeClass(CHECKBOX_HAS_TEXT_CLASS)
                    }
                    return
                }
                if (!this._$text.length)
                    this._$text = $("<span>").addClass(CHECKBOX_TEXT_CLASS);
                this._$text.text(this.option("text"));
                this._$container.append(this._$text);
                this.element().addClass(CHECKBOX_HAS_TEXT_CLASS)
            },
            _renderClick: function() {
                this._clickAction = this._createAction(this._clickHandler);
                this.element().off(CHECKBOX_DXCLICK_EVENT_NAME).on(CHECKBOX_DXCLICK_EVENT_NAME, $.proxy(function(e) {
                    this._clickAction({jQueryEvent: e})
                }, this))
            },
            _clickHandler: function(args) {
                var that = args.component;
                that._valueChangeEventInstance = args.jQueryEvent;
                that.option("value", !that.option("value"))
            },
            _renderValue: function() {
                var $element = this.element(),
                    checked = this.option("value"),
                    indeterminate = checked === undefined;
                $element.toggleClass(CHECKBOX_CHECKED_CLASS, Boolean(checked));
                $element.toggleClass(CHECKBOX_INDETERMINATE_CLASS, indeterminate)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"value":
                        this._renderValue();
                        this.callBase(args);
                        break;
                    case"text":
                        this._renderText();
                        this._renderDimensions();
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.switch.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            fx = DX.fx;
        var SWITCH_CLASS = "dx-switch",
            SWITCH_WRAPPER_CLASS = SWITCH_CLASS + "-wrapper",
            SWITCH_CONTAINER_CLASS = SWITCH_CLASS + "-container",
            SWITCH_INNER_CLASS = SWITCH_CLASS + "-inner",
            SWITCH_HANDLE_CLASS = SWITCH_CLASS + "-handle",
            SWITCH_ON_VALUE_CLASS = SWITCH_CLASS + "-on-value",
            SWITCH_ON_CLASS = SWITCH_CLASS + "-on",
            SWITCH_OFF_CLASS = SWITCH_CLASS + "-off",
            SWITCH_ANIMATION_DURATION = 100;
        DX.registerComponent("dxSwitch", ui, ui.Editor.inherit({
            _supportedKeys: function() {
                var click = function(e) {
                        this._clickAction({jQueryEvent: e})
                    },
                    move = function(value, e) {
                        e.preventDefault();
                        e.stopPropagation();
                        this._animateValue(value)
                    };
                return $.extend(this.callBase(), {
                        space: click,
                        enter: click,
                        leftArrow: $.proxy(move, this, false),
                        rightArrow: $.proxy(move, this, true)
                    })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    onText: Globalize.localize("dxSwitch-onText"),
                    offText: Globalize.localize("dxSwitch-offText"),
                    value: false
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {
                                hoverStateEnabled: true,
                                focusStateEnabled: true
                            }
                        }])
            },
            _init: function() {
                this.callBase();
                this._animating = false;
                this._animationDuration = SWITCH_ANIMATION_DURATION
            },
            _createValueChangeAction: function() {
                this._valueChangeAction = this._createActionByOption("onValueChanged")
            },
            _render: function() {
                var element = this.element();
                this._$switchInner = $("<div>").addClass(SWITCH_INNER_CLASS);
                this._$handle = $("<div>").addClass(SWITCH_HANDLE_CLASS).appendTo(this._$switchInner);
                this._$labelOn = $("<div>").addClass(SWITCH_ON_CLASS).prependTo(this._$switchInner);
                this._$labelOff = $("<div>").addClass(SWITCH_OFF_CLASS).appendTo(this._$switchInner);
                this._$switchContainer = $("<div>").addClass(SWITCH_CONTAINER_CLASS).append(this._$switchInner);
                this._$switchWrapper = $("<div>").addClass(SWITCH_WRAPPER_CLASS).append(this._$switchContainer);
                element.addClass(SWITCH_CLASS).append(this._$switchWrapper);
                element.dxSwipeable({
                    elastic: false,
                    immediate: true,
                    onStart: $.proxy(this._swipeStartHandler, this),
                    onUpdated: $.proxy(this._swipeUpdateHandler, this),
                    onEnd: $.proxy(this._swipeEndHandler, this)
                });
                this._renderLabels();
                this.callBase();
                this._updateMarginBound();
                this._renderValue();
                this._renderClick()
            },
            _updateMarginBound: function() {
                this._marginBound = this._$switchContainer.outerWidth(true) - this._$handle.outerWidth()
            },
            _marginDirection: function() {
                return this.option("rtlEnabled") ? "Right" : "Left"
            },
            _offsetDirection: function() {
                return this.option("rtlEnabled") ? -1 : 1
            },
            _renderPosition: function(state, swipeOffset) {
                var stateInt = state ? 1 : 0,
                    marginDirection = this._marginDirection(),
                    resetMarginDirection = marginDirection === "Left" ? "Right" : "Left";
                this._$switchInner.css("margin" + marginDirection, this._marginBound * (stateInt + swipeOffset - 1));
                this._$switchInner.css("margin" + resetMarginDirection, 0)
            },
            _validateValue: function() {
                var check = this.option("value");
                if (typeof check !== "boolean")
                    this._options["value"] = !!check
            },
            _renderClick: function() {
                var eventName = events.addNamespace("dxclick", this.NAME);
                this._clickAction = this._createAction($.proxy(this._clickHandler, this));
                this.element().off(eventName).on(eventName, $.proxy(function(e) {
                    this._clickAction({jQueryEvent: e})
                }, this))
            },
            _clickHandler: function(args) {
                var e = args.jQueryEvent;
                this._valueChangeEventInstance = e;
                if (this._animating || this._swiping)
                    return;
                this._animateValue(!this.option("value"))
            },
            _animateValue: function(value) {
                var startValue = this.option("value"),
                    endValue = value;
                if (startValue == endValue)
                    return;
                this._animating = true;
                var that = this,
                    marginDirection = this._marginDirection(),
                    resetMarginDirection = marginDirection === "Left" ? "Right" : "Left",
                    fromConfig = {},
                    toConfig = {};
                this._$switchInner.css("margin" + resetMarginDirection, 0);
                fromConfig["margin" + marginDirection] = (Number(startValue) - 1) * this._marginBound;
                toConfig["margin" + marginDirection] = (Number(endValue) - 1) * this._marginBound;
                fx.animate(this._$switchInner, {
                    from: fromConfig,
                    to: toConfig,
                    duration: this._animationDuration,
                    complete: function() {
                        that._animating = false;
                        that.option("value", endValue)
                    }
                })
            },
            _swipeStartHandler: function(e) {
                var state = this.option("value"),
                    rtlEnabled = this.option("rtlEnabled"),
                    maxOffOffset = rtlEnabled ? 0 : 1,
                    maxOnOffset = rtlEnabled ? 1 : 0;
                e.jQueryEvent.maxLeftOffset = state ? maxOffOffset : maxOnOffset;
                e.jQueryEvent.maxRightOffset = state ? maxOnOffset : maxOffOffset;
                this._swiping = true;
                this._toggleActiveState(this.element(), true)
            },
            _swipeUpdateHandler: function(e) {
                this._renderPosition(this.option("value"), this._offsetDirection() * e.jQueryEvent.offset)
            },
            _swipeEndHandler: function(e) {
                var that = this,
                    offsetDirection = this._offsetDirection(),
                    toConfig = {};
                toConfig["margin" + this._marginDirection()] = this._marginBound * (that.option("value") + offsetDirection * e.jQueryEvent.targetOffset - 1);
                fx.animate(this._$switchInner, {
                    to: toConfig,
                    duration: that._animationDuration,
                    complete: function() {
                        that._swiping = false;
                        var pos = that.option("value") + offsetDirection * e.jQueryEvent.targetOffset;
                        that.option("value", Boolean(pos));
                        that._toggleActiveState(that.element(), false)
                    }
                })
            },
            _renderValue: function() {
                this._validateValue();
                var val = this.option("value");
                this._renderPosition(val, 0);
                this.element().toggleClass(SWITCH_ON_VALUE_CLASS, val)
            },
            _renderLabels: function() {
                this._$labelOn.text(this.option("onText"));
                this._$labelOff.text(this.option("offText"))
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this.repaint()
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"visible":
                    case"width":
                        this._refresh();
                        break;
                    case"onText":
                    case"offText":
                        this._renderLabels();
                        break;
                    case"value":
                        this._renderValue();
                        this.callBase(args);
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.textEditor.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            inflector = DX.inflector;
        var TEXTEDITOR_CLASS = "dx-texteditor",
            TEXTEDITOR_INPUT_CLASS = "dx-texteditor-input",
            TEXTEDITOR_INPUT_SELECTOR = "." + TEXTEDITOR_INPUT_CLASS,
            TEXTEDITOR_CONTAINER_CLASS = "dx-texteditor-container",
            TEXTEDITOR_BUTTONS_CONTAINER_CLASS = "dx-texteditor-buttons-container",
            TEXTEDITOR_PLACEHOLDER_CLASS = "dx-placeholder",
            TEXTEDITOR_SHOW_CLEAR_BUTTON_CLASS = "dx-show-clear-button",
            TEXTEDITOR_CLEAR_ICON_CLASS = "dx-icon-clear",
            TEXTEDITOR_CLEAR_BUTTON_CLASS = "dx-clear-button-area",
            TEXTEDITOR_EMPTY_INPUT_CLASS = "dx-texteditor-empty",
            TEXTEDITOR_STATE_FOCUSED_CLASS = "dx-state-focused",
            EVENTS_LIST = ["focusIn", "focusOut", "keyDown", "keyPress", "keyUp", "change", "cut", "copy", "paste", "input"];
        var nativeClearButtonCancelSupport = function() {
                return DX.browser["msie"] && DX.browser.version > 9 || !DX.browser["msie"]
            }();
        DX.registerComponent("dxTextEditor", ui, ui.Editor.inherit({
            _supportedKeys: function() {
                var stop = function(e) {
                        e.stopPropagation()
                    };
                return {
                        leftArrow: stop,
                        rightArrow: stop
                    }
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    valueUpdateEvent: {
                        since: "14.1",
                        alias: "valueChangeEvent"
                    },
                    valueUpdateAction: {
                        since: "14.1",
                        message: "'onValueChanged' option instead"
                    },
                    valueChangeAction: {
                        since: "14.2",
                        alias: "onValueChanged"
                    },
                    keyDownAction: {
                        since: "14.2",
                        alias: "onKeyDown"
                    },
                    keyPressAction: {
                        since: "14.2",
                        alias: "onKeyPress"
                    },
                    keyUpAction: {
                        since: "14.2",
                        alias: "onKeyUp"
                    },
                    cutAction: {
                        since: "14.2",
                        alias: "onCut"
                    },
                    copyAction: {
                        since: "14.2",
                        alias: "onCopy"
                    },
                    pasteAction: {
                        since: "14.2",
                        alias: "onPaste"
                    },
                    changeAction: {
                        since: "14.2",
                        alias: "onChange"
                    },
                    inputAction: {
                        since: "14.2",
                        alias: "onInput"
                    },
                    focusInAction: {
                        since: "14.2",
                        alias: "onFocusIn"
                    },
                    focusOutAction: {
                        since: "14.2",
                        alias: "onFocusOut"
                    },
                    enterKeyAction: {
                        since: "14.2",
                        alias: "onEnterKey"
                    }
                })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    value: "",
                    spellcheck: false,
                    showClearButton: false,
                    valueChangeEvent: "change",
                    placeholder: "",
                    onFocusIn: null,
                    onFocusOut: null,
                    onKeyDown: null,
                    onKeyPress: null,
                    onKeyUp: null,
                    onChange: null,
                    onInput: null,
                    onCut: null,
                    onCopy: null,
                    onPaste: null,
                    onEnterKey: null,
                    mode: "text",
                    activeStateEnabled: false,
                    hoverStateEnabled: true,
                    focusStateEnabled: true
                })
            },
            _input: function() {
                return this.element().find(TEXTEDITOR_INPUT_SELECTOR).first()
            },
            _inputWrapper: function() {
                return this.element()
            },
            _buttonsContainer: function() {
                return this._inputWrapper().find("." + TEXTEDITOR_BUTTONS_CONTAINER_CLASS)
            },
            _init: function() {
                this.callBase();
                this._initValueUpdateAction()
            },
            _initValueUpdateAction: function() {
                this._valueUpdateAction = this._createActionByOption("valueUpdateAction")
            },
            _render: function() {
                this.element().addClass(TEXTEDITOR_CLASS);
                this._renderInput();
                this._renderInputType();
                this._renderValue();
                this._renderProps();
                this._renderPlaceholder();
                this._renderEvents();
                this._renderEnterKeyAction();
                this._renderEmptinessEvent();
                this.callBase()
            },
            _renderInput: function() {
                $("<div>").addClass(TEXTEDITOR_CONTAINER_CLASS).append(this._createInput()).append($("<div>").addClass(TEXTEDITOR_BUTTONS_CONTAINER_CLASS)).appendTo(this.element())
            },
            _createInput: function() {
                return $("<input>").addClass(TEXTEDITOR_INPUT_CLASS)
            },
            _renderValue: function(formattedValue) {
                var text = formattedValue || this.option("value");
                if (this._input().val() !== text) {
                    this._input().val(text);
                    this._toggleEmptinessEventHandler()
                }
                this._renderInputAddons()
            },
            _isValueValid: function() {
                var validity = this._input().get(0).validity;
                if (validity)
                    return validity.valid;
                return true
            },
            _toggleEmptiness: function(isEmpty) {
                this.element().toggleClass(TEXTEDITOR_EMPTY_INPUT_CLASS, isEmpty);
                this._togglePlaceholder(isEmpty)
            },
            _togglePlaceholder: function(isEmpty) {
                if (!this._$placeholder)
                    return;
                if (DX.browser["msie"])
                    this._$placeholder.toggle(!this._input().is(":focus") && isEmpty);
                else
                    this._$placeholder.toggle(isEmpty)
            },
            _renderProps: function() {
                this._toggleDisabledState(this.option("disabled"));
                this._toggleReadOnlyState(this._readOnlyPropValue());
                this._toggleSpellcheckState()
            },
            _toggleDisabledState: function() {
                this.callBase.apply(this, arguments);
                this._input().prop("disabled", this.option("disabled"))
            },
            _toggleReadOnlyState: function(value) {
                this._input().prop("readOnly", value);
                this.callBase()
            },
            _readOnlyPropValue: function() {
                return this.option("readOnly")
            },
            _toggleSpellcheckState: function() {
                this._input().prop("spellcheck", this.option("spellcheck"))
            },
            _renderPlaceholder: function() {
                if (this._$placeholder) {
                    this._$placeholder.remove();
                    this._$placeholder = null
                }
                var that = this,
                    $input = that._input(),
                    placeholderText = that.option("placeholder"),
                    $placeholder = this._$placeholder = $('<div>').attr("data-dx_placeholder", placeholderText),
                    startEvent = events.addNamespace("dxclick", this.NAME);
                $placeholder.on(startEvent, function() {
                    $input.focus()
                });
                $placeholder.insertAfter($input);
                $placeholder.addClass(TEXTEDITOR_PLACEHOLDER_CLASS)
            },
            _placeholder: function() {
                return this._$placeholder || $()
            },
            _renderInputAddons: function() {
                this._renderClearButton()
            },
            _renderClearButton: function() {
                if (!nativeClearButtonCancelSupport)
                    return;
                var clearButtonVisible = this.option("showClearButton") && !this.option("readOnly");
                this.element().toggleClass(TEXTEDITOR_SHOW_CLEAR_BUTTON_CLASS, clearButtonVisible);
                if (!clearButtonVisible) {
                    this._$clearButton && this._$clearButton.remove();
                    this._$clearButton = null;
                    return
                }
                if (this._$clearButton)
                    return;
                this._$clearButton = this._createClearButton()
            },
            _createClearButton: function() {
                return $("<span>").addClass(TEXTEDITOR_CLEAR_BUTTON_CLASS).append($("<span>").addClass(TEXTEDITOR_CLEAR_ICON_CLASS)).prependTo(this._buttonsContainer()).on(events.addNamespace("dxpointerup", this.NAME), $.proxy(this._clearValueHandler, this))
            },
            _clearValueHandler: function(e) {
                var $input = this._input();
                this.option("value", "");
                if ($input.is(":focus")) {
                    $input.val("");
                    this._toggleEmptinessEventHandler()
                }
                else
                    $input.trigger("focus")
            },
            _renderEvents: function() {
                var that = this,
                    $input = that._input();
                that._renderValueChangeEvent();
                $.each(EVENTS_LIST, function(_, event) {
                    var eventName = events.addNamespace(event.toLowerCase(), that.NAME),
                        action = that._createActionByOption("on" + inflector.camelize(event, true));
                    $input.off(eventName).on(eventName, function(e) {
                        action({jQueryEvent: e})
                    })
                })
            },
            _renderValueChangeEvent: function() {
                var eventNamespace = this.NAME + "ValueChange";
                var valueChangeEvent = events.addNamespace(this.option("valueChangeEvent"), eventNamespace);
                this._input().off("." + eventNamespace).on(valueChangeEvent, $.proxy(this._valueChangeEventHandler, this))
            },
            _focusTarget: function() {
                return this._input()
            },
            _renderFocusTarget: $.noop,
            _focusInHandler: function(e) {
                e.stopPropagation();
                this.element().addClass(TEXTEDITOR_STATE_FOCUSED_CLASS)
            },
            _focusOutHandler: function(e) {
                e.stopPropagation();
                this.element().removeClass(TEXTEDITOR_STATE_FOCUSED_CLASS)
            },
            _renderEmptinessEvent: function() {
                var $input = this._input();
                $input.on("input blur", $.proxy(this._toggleEmptinessEventHandler, this));
                this._toggleEmptinessEventHandler()
            },
            _toggleEmptinessEventHandler: function(value) {
                var value = this._input().val(),
                    isEmpty = (value === "" || value === null) && this._isValueValid();
                this._toggleEmptiness(isEmpty)
            },
            _valueChangeEventHandler: function(e, formattedValue) {
                this._valueChangeEventInstance = e;
                this._suppressValueUpdateAction = true;
                this.option("value", arguments.length > 1 ? formattedValue : this._input().val());
                this._suppressValueUpdateAction = false;
                this._valueUpdateAction({
                    value: this.option("value"),
                    jQueryEvent: e
                })
            },
            _renderEnterKeyAction: function() {
                if (this.option("onEnterKey")) {
                    this._enterKeyAction = this._createActionByOption("onEnterKey", {excludeValidators: ["readOnly"]});
                    this._input().on("keyup.onEnterKey.dxTextEditor", $.proxy(this._enterKeyHandlerUp, this))
                }
                else {
                    this._input().off("keyup.onEnterKey.dxTextEditor");
                    this._enterKeyAction = undefined
                }
            },
            _enterKeyHandlerUp: function(e) {
                if (e.which === 13)
                    this._enterKeyAction({jQueryEvent: e})
            },
            _updateValue: function() {
                this._renderValue();
                if (!this._suppressValueUpdateAction)
                    this._valueUpdateAction({value: this.option("value")})
            },
            _suppressUpdateValue: function() {
                this._valueUpdateSuppressed = true
            },
            _resumeUpdateValue: function() {
                this._valueUpdateSuppressed = false
            },
            _clean: function() {
                if (this._$placeholder) {
                    this._$placeholder.remove();
                    delete this._$placeholder
                }
                delete this._$clearButton;
                this.callBase()
            },
            _optionChanged: function(args) {
                var name = args.name;
                if ($.inArray(inflector.camelize(name.replace("on", "")), EVENTS_LIST) > -1) {
                    this._renderEvents();
                    return
                }
                switch (name) {
                    case"valueChangeEvent":
                        this._renderValueChangeEvent();
                        break;
                    case"valueUpdateAction":
                        this._initValueUpdateAction();
                        break;
                    case"readOnly":
                        this._toggleReadOnlyState(args.value);
                        this._renderInputAddons();
                        break;
                    case"spellcheck":
                        this._toggleSpellcheckState();
                        break;
                    case"mode":
                        this._renderInputType();
                        break;
                    case"onEnterKey":
                        this._renderEnterKeyAction();
                        break;
                    case"placeholder":
                        this._invalidate();
                        break;
                    case"showClearButton":
                        this._renderInputAddons();
                        break;
                    case"value":
                        if (!this._valueUpdateSuppressed)
                            this._updateValue();
                    default:
                        this.callBase(args)
                }
            },
            _renderInputType: function() {
                this._setInputType(this.option("mode"))
            },
            _setInputType: function(type) {
                var input = this._input();
                if (type === "search")
                    type = "text";
                try {
                    input.prop("type", type)
                }
                catch(e) {
                    input.prop("type", "text")
                }
            },
            focus: function() {
                this._input().focus()
            },
            blur: function() {
                if (this._input().is(document.activeElement))
                    DX.utils.resetActiveElement()
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.textBox.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            devices = DX.devices,
            ua = window.navigator.userAgent,
            ignoreCode = [8, 9, 13, 33, 34, 35, 36, 37, 38, 39, 40, 46],
            TEXTBOX_CLASS = "dx-textbox",
            SEARCHBOX_CLASS = "dx-searchbox",
            SEARCH_ICON_CLASS = "dx-icon-search";
        DX.registerComponent("dxTextBox", ui, ui.dxTextEditor.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    mode: "text",
                    maxLength: null
                })
            },
            _render: function() {
                this.callBase();
                this.element().addClass(TEXTBOX_CLASS);
                this._renderMaxLengthHandlers();
                this._renderSearchMode()
            },
            _renderMaxLengthHandlers: function() {
                if (this._isAndroid())
                    this._input().on(events.addNamespace("keydown", this.NAME), $.proxy(this._onKeyDownAndroidHandler, this)).on(events.addNamespace("change", this.NAME), $.proxy(this._onChangeAndroidHandler, this))
            },
            _renderProps: function() {
                this.callBase();
                this._toggleMaxLengthProp()
            },
            _toggleMaxLengthProp: function() {
                if (this._isAndroid())
                    return;
                var maxLength = this.option("maxLength");
                if (maxLength > 0)
                    this._input().attr("maxLength", maxLength);
                else
                    this._input().removeAttr("maxLength")
            },
            _renderSearchMode: function() {
                var $element = this._$element;
                if (this.option("mode") === "search") {
                    this._renderSearchIcon();
                    $element.addClass(SEARCHBOX_CLASS);
                    this._showClearButton = this.option("showClearButton");
                    this.option("showClearButton", true)
                }
                else {
                    $element.removeClass(SEARCHBOX_CLASS);
                    this._$searchIcon && this._$searchIcon.remove();
                    this.option("showClearButton", this._showClearButton === undefined ? this.option("showClearButton") : this._showClearButton)
                }
            },
            _renderSearchIcon: function() {
                var $searchIcon = $("<div>").addClass(SEARCH_ICON_CLASS);
                $searchIcon.prependTo(this._input().parent());
                this._$searchIcon = $searchIcon
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"maxLength":
                        this._toggleMaxLengthProp();
                        this._renderMaxLengthHandlers();
                        break;
                    case"mode":
                        this._invalidate();
                    default:
                        this.callBase(args)
                }
            },
            _onKeyDownAndroidHandler: function(e) {
                var maxLength = this.option("maxLength");
                if (maxLength) {
                    var $input = $(e.target),
                        code = e.keyCode;
                    this._cutOffExtraChar($input);
                    return $input.val().length < maxLength || $.inArray(code, ignoreCode) !== -1 || window.getSelection().toString() !== ""
                }
                else
                    return true
            },
            _onChangeAndroidHandler: function(e) {
                var $input = $(e.target);
                if (this.option("maxLength"))
                    this._cutOffExtraChar($input)
            },
            _cutOffExtraChar: function($input) {
                var maxLength = this.option("maxLength"),
                    textInput = $input.val();
                if (textInput.length > maxLength)
                    $input.val(textInput.substr(0, maxLength))
            },
            _isAndroid: function() {
                var realDevice = devices.real();
                var version = realDevice.version.join(".");
                return realDevice.platform === "android" && version && /^(2\.|4\.1)/.test(version) && !/chrome/i.test(ua)
            }
        }));
        ui.dxTextBox.__internals = {
            uaAccessor: function(value) {
                if (!arguments.length)
                    return ui;
                ua = value
            },
            SEARCHBOX_CLASS: SEARCHBOX_CLASS,
            SEARCH_ICON_CLASS: SEARCH_ICON_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.dropDownEditor.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            DROP_DOWN_EDITOR_CLASS = "dx-dropdowneditor",
            DROP_DOWN_EDITOR_READONLY_CLASS = "dx-dropdowneditor-readonly",
            DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS = "dx-dropdowneditor-input-wrapper",
            DROP_DOWN_EDITOR_BUTTON_CLASS = "dx-dropdowneditor-button",
            DROP_DOWN_EDITOR_BUTTON_ICON = "dx-dropdowneditor-icon",
            DROP_DOWN_EDITOR_OVERLAY = "dx-dropdowneditor-overlay",
            DROP_DOWN_EDITOR_ACTIVE = "dx-dropdowneditor-active",
            DROP_DOWN_EDITOR_BUTTON_VISIBLE = "dx-dropdowneditor-button-visible",
            DROP_DOWN_EDITOR_FIELD_CLICKABLE = "dx-dropdowneditor-field-clickable",
            DROP_DOWN_EDITOR = "dxDropDownEditor",
            CLICK_EVENT_NAME = events.addNamespace("dxclick", DROP_DOWN_EDITOR),
            KEYDOWN_EVENT_NAME = events.addNamespace("keydown", DROP_DOWN_EDITOR),
            KEYUP_EVENT_NAME = events.addNamespace("keyup", DROP_DOWN_EDITOR),
            KEY_DOWN = 40,
            KEY_UP = 38;
        DX.registerComponent(DROP_DOWN_EDITOR, ui, ui.dxTextBox.inherit({
            _supportedKeys: function() {
                return $.extend(this.callBase(), {
                        escape: function(e) {
                            this.close()
                        },
                        space: function(e) {
                            this._validatedOpening()
                        },
                        upArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (e.altKey) {
                                this.close();
                                return false
                            }
                            return true
                        },
                        downArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (e.altKey) {
                                this._validatedOpening();
                                return false
                            }
                            return true
                        }
                    })
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    openAction: {
                        since: "14.2",
                        alias: "onOpened"
                    },
                    closeAction: {
                        since: "14.2",
                        alias: "onClosed"
                    },
                    shownAction: {
                        since: "14.2",
                        alias: "onOpened"
                    },
                    hiddenAction: {
                        since: "14.2",
                        alias: "onClosed"
                    }
                })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    onOpened: null,
                    onClosed: null,
                    opened: false,
                    fieldTemplate: null,
                    contentTemplate: null,
                    editEnabled: true,
                    openOnFieldClick: false,
                    deferRendering: true,
                    showDropButton: true,
                    dropPosition: {
                        offset: {
                            h: 0,
                            v: -1
                        },
                        my: "left top",
                        at: "left bottom",
                        collision: "flip flip"
                    },
                    focusStateEnabled: false
                })
            },
            _inputWrapper: function() {
                return this.element().find("." + DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS)
            },
            _init: function() {
                this.callBase();
                this._initVisibilityActions()
            },
            _initVisibilityActions: function() {
                this._openAction = this._createActionByOption("onOpened");
                this._closeAction = this._createActionByOption("onClosed")
            },
            _render: function() {
                this.callBase();
                this._renderOpenHandler();
                this.element().addClass(DROP_DOWN_EDITOR_CLASS);
                this._renderOpenedState()
            },
            _renderContentImpl: function() {
                if (!this.option("deferRendering"))
                    this._createPopup()
            },
            _renderInput: function() {
                this.callBase();
                this.element().wrapInner($("<div>").addClass(DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS));
                this._$container = this.element().children().eq(0)
            },
            _readOnlyPropValue: function() {
                return !this.option("editEnabled") || this.callBase()
            },
            _renderField: function() {
                var fieldTemplate = this._getTemplateByOption("fieldTemplate");
                if (!(fieldTemplate && this.option("fieldTemplate")))
                    return;
                var $container = this._$container;
                var data = this._fieldRenderData();
                $container.empty();
                this._$dropButton = null;
                this._$clearButton = null;
                fieldTemplate.render(data, $container);
                if (!this._input().length)
                    throw DX.Error("E1010");
            },
            _fieldRenderData: function() {
                return this.option("value")
            },
            _renderInputAddons: function() {
                this._renderField();
                this.callBase();
                this._renderDropButton()
            },
            _renderDropButton: function(hideButton) {
                var dropButtonVisible = this.option("showDropButton");
                this.element().toggleClass(DROP_DOWN_EDITOR_BUTTON_VISIBLE, dropButtonVisible);
                if (!dropButtonVisible) {
                    this._$dropButton && this._$dropButton.remove();
                    this._$dropButton = null;
                    return
                }
                if (!this._$dropButton)
                    this._$dropButton = this._createDropButton().addClass(DROP_DOWN_EDITOR_BUTTON_CLASS);
                this._$dropButton.prependTo(this._buttonsContainer())
            },
            _createDropButton: function() {
                var $buttonIcon = $("<div>").addClass(DROP_DOWN_EDITOR_BUTTON_ICON);
                var $button = $("<div>").dxButton({
                        focusStateEnabled: false,
                        disabled: this.option("readOnly")
                    }).removeClass("dx-button");
                $button.append($buttonIcon);
                $button.find(".dx-button-content").remove();
                $button.on("dxpointerdown", function(e) {
                    e.preventDefault()
                });
                return $button
            },
            _renderOpenHandler: function() {
                var $inputWrapper = this.element().find(".dx-dropdowneditor-input-wrapper");
                $inputWrapper.off(CLICK_EVENT_NAME);
                var openOnFieldClick = this.option("openOnFieldClick");
                this.element().toggleClass(DROP_DOWN_EDITOR_FIELD_CLICKABLE, openOnFieldClick);
                if (openOnFieldClick) {
                    $inputWrapper.on(CLICK_EVENT_NAME, $.proxy(this._openHandler, this));
                    return
                }
                if (this.option("showDropButton"))
                    this._$dropButton.dxButton("option", "onClick", $.proxy(this._openHandler, this))
            },
            _openHandler: function() {
                this._toggleOpenState()
            },
            _toggleOpenState: function(isVisible) {
                isVisible = arguments.length ? isVisible : !this.option("opened");
                if (this.option("disabled") || this.option("readOnly"))
                    return;
                this._input().focus();
                this.option("opened", isVisible)
            },
            _renderOpenedState: function() {
                var opened = this.option("opened");
                if (opened)
                    this._createPopup();
                this.element().toggleClass(DROP_DOWN_EDITOR_ACTIVE, opened);
                this._setPopupOption("visible", opened)
            },
            _createPopup: function() {
                if (this._$popup)
                    return;
                this._$popup = $("<div>").addClass(DROP_DOWN_EDITOR_OVERLAY).addClass(this.option("customOverlayCssClass")).appendTo(this.element());
                this._renderPopup();
                this._renderPopupContent()
            },
            _renderPopup: function() {
                this._popup = this._$popup.dxPopup(this._popupConfig()).dxPopup("instance");
                this._popup.on({
                    showing: $.proxy(this._popupShowingHandler, this),
                    shown: $.proxy(this._popupShownHandler, this),
                    hiding: $.proxy(this._popupHidingHandler, this),
                    hidden: $.proxy(this._popupHiddenHandler, this)
                });
                this._popup.option("onContentReady", $.proxy(this._contentReadyHandler, this));
                this._contentReadyHandler()
            },
            _contentReadyHandler: $.noop,
            _popupConfig: function() {
                return {
                        position: $.extend(this.option("dropPosition"), {of: this.element()}),
                        showTitle: false,
                        width: "auto",
                        height: "auto",
                        shading: false,
                        rtlEnabled: this.option("rtlEnabled"),
                        closeOnTargetScroll: true,
                        closeOnOutsideClick: $.proxy(this._closeOutsideDropDownHandler, this),
                        animation: {
                            show: {
                                type: "fade",
                                duration: 0,
                                from: 0,
                                to: 1
                            },
                            hide: {
                                type: "fade",
                                duration: 400,
                                from: 1,
                                to: 0
                            }
                        },
                        deferRendering: false,
                        focusStateEnabled: false
                    }
            },
            _popupShowingHandler: $.noop,
            _popupHidingHandler: function() {
                this.option("opened", false)
            },
            _popupShownHandler: function() {
                this._openAction();
                if (this._$validationMessage) {
                    var myTop = DX.position(this.element()).top,
                        popupTop = DX.position(this._popup.content()).top;
                    this._$validationMessage.dxTooltip("option", "position", this._getValidationTooltipPosition(myTop + this.option("dropPosition").offset.v > popupTop ? "below" : "above"))
                }
            },
            _popupHiddenHandler: function() {
                this._closeAction();
                if (this._$validationMessage)
                    this._$validationMessage.dxTooltip("option", "position", this._getValidationTooltipPosition("below"))
            },
            _renderPopupContent: function() {
                var contentTemplate = this._getTemplateByOption("contentTemplate");
                if (!(contentTemplate && this.option("contentTemplate")))
                    return;
                var $popupContent = this._popup.content();
                $popupContent.empty();
                contentTemplate.render($popupContent)
            },
            _closeOutsideDropDownHandler: function(e) {
                var $target = $(e.target);
                var isInputClicked = !!$target.closest(this.element()).length;
                var isDropButtonClicked = !!$target.closest(this._$dropButton).length;
                var isOutsideClick = !isInputClicked && !isDropButtonClicked;
                isOutsideClick && this._input().blur();
                return isOutsideClick
            },
            _clean: function() {
                delete this._$dropButton;
                if (this._$popup) {
                    this._$popup.remove();
                    delete this._$popup;
                    delete this._popup
                }
                this.callBase()
            },
            _setPopupOption: function(optionName, value) {
                this._setWidgetOption("_popup", arguments)
            },
            _validatedOpening: function() {
                if (!this.option("readOnly"))
                    this._toggleOpenState(true)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"opened":
                        this._renderOpenedState();
                        break;
                    case"onOpened":
                    case"onClosed":
                        this._initVisibilityActions();
                        break;
                    case"fieldTemplate":
                    case"fieldRender":
                        this._renderInputAddons();
                        break;
                    case"showDropButton":
                    case"contentTemplate":
                    case"contentRender":
                    case"editEnabled":
                    case"openOnFieldClick":
                        this._invalidate();
                        break;
                    case"dropPosition":
                    case"deferRendering":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            open: function() {
                this.option("opened", true)
            },
            close: function() {
                this.option("opened", false)
            }
        }));
        ui.dxDropDownEditor.__internals = {
            DROP_DOWN_EDITOR_CLASS: DROP_DOWN_EDITOR_CLASS,
            DROP_DOWN_EDITOR_READONLY_CLASS: DROP_DOWN_EDITOR_READONLY_CLASS,
            DROP_DOWN_EDITOR_BUTTON_ICON: DROP_DOWN_EDITOR_BUTTON_ICON,
            DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS: DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS,
            DROP_DOWN_EDITOR_BUTTON_CLASS: DROP_DOWN_EDITOR_BUTTON_CLASS,
            DROP_DOWN_EDITOR_OVERLAY: DROP_DOWN_EDITOR_OVERLAY,
            DROP_DOWN_EDITOR_ACTIVE: DROP_DOWN_EDITOR_ACTIVE,
            DROP_DOWN_EDITOR_BUTTON_VISIBLE: DROP_DOWN_EDITOR_BUTTON_VISIBLE
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.dropDownList.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var LIST_SELECTOR = ".dx-list",
            LIST_ITEM_SELECTOR = ".dx-list-item",
            LIST_ITEM_DATA_KEY = "dxListItemData",
            DROPDOWNLIST_SELECTED_CLASS = "dx-dropdownlist-selected",
            DROPDOWNLIST_POPUP_WRAPPER_CLASS = "dx-dropdownlist-popup-wrapper",
            SEARCH_MODES = ["startswith", "contains", "endwith", "notcontains"];
        DX.registerComponent("dxDropDownList", ui, ui.dxDropDownEditor.inherit({
            _supportedKeys: function() {
                return $.extend(this.callBase(), {
                        tab: function(e) {
                            if (this.option("opened") === true) {
                                var $selectedItem = this._listSelectedItemElements();
                                if (!$selectedItem.length) {
                                    this._changeSelectedItem($selectedItem, this._listItemElements().first());
                                    this.option("value", this._selectedItemValue())
                                }
                                this.close()
                            }
                            else
                                this._focusTarget().focusout()
                        },
                        space: $.noop,
                        home: $.noop,
                        end: $.noop
                    })
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, this._dataExpressionDeprecatedOptions())
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option($.extend(this._dataExpressionDefaultOptions(), {
                    displayValue: undefined,
                    searchEnabled: false,
                    searchMode: "contains",
                    searchTimeout: 500,
                    minSearchLength: 0,
                    searchExpr: null,
                    valueChangeEvent: "change keyup",
                    selectedItem: null,
                    pagingEnabled: false,
                    dropPosition: {
                        my: "left top",
                        at: "left bottom",
                        offset: {
                            h: 0,
                            v: 0
                        },
                        collision: "flip"
                    },
                    focusStateEnabled: true
                }))
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "win8"},
                            options: {dropPosition: {offset: {v: -6}}}
                        }, {
                            device: [{platform: "generic"}, {platform: "tizen"}],
                            options: {dropPosition: {offset: {v: -1}}}
                        }])
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {
                    value: true,
                    displayValue: true
                })
            },
            _init: function() {
                this.callBase();
                this._initDataExpressions();
                this._initContentReadyAction();
                this._setListDataSource();
                this._validateSearchMode();
                this._clearSelectedItem()
            },
            _renderContentImpl: function() {
                this.callBase();
                if (this.option("deferRendering"))
                    this._loadDataSource()
            },
            _renderField: function() {
                this.callBase();
                this._input().on("input", $.proxy(this._setFocusPolicy, this))
            },
            _createPopup: function() {
                this.callBase();
                this._popup._wrapper().addClass(this._popupWrapperClass())
            },
            _popupWrapperClass: function() {
                return DROPDOWNLIST_POPUP_WRAPPER_CLASS
            },
            _renderValue: function() {
                var callBase = $.proxy(this.callBase, this);
                return this._loadValue().always($.proxy(function(item) {
                        this._setSelectedItem(item);
                        this._refreshSelected();
                        callBase(this._displayValue(this.option("selectedItem")))
                    }, this))
            },
            _setSelectedItem: function(item) {
                var displayValue = this._displayValue(item);
                this.option().selectedItem = item;
                this.option("displayValue", displayValue || this.option("placeholder"))
            },
            _displayValue: function(item) {
                return this._displayGetter(item)
            },
            _refreshSelected: function() {
                this._listItemElements().each($.proxy(function(_, itemElement) {
                    var $itemElement = $(itemElement);
                    var itemValue = this._valueGetter($itemElement.data(LIST_ITEM_DATA_KEY));
                    var isItemSelected = this._isSelectedValue(itemValue);
                    $itemElement.toggleClass(this._selectedItemClass(), isItemSelected);
                    if (isItemSelected)
                        this._list.selectItem($itemElement);
                    else
                        this._list.unselectItem($itemElement)
                }, this))
            },
            _popupShownHandler: function() {
                this.callBase();
                this._setFocusPolicy()
            },
            _setFocusPolicy: function() {
                if (!this.option("focusStateEnabled") || !this._list)
                    return;
                this._list._removeFocusedItem();
                delete this._list._$focusedItem
            },
            _isSelectedValue: function(value) {
                return this._valueEquals(value, this.option("value"))
            },
            _validateSearchMode: function() {
                var searchMode = this.option("searchMode"),
                    normalizedSearchMode = searchMode.toLowerCase();
                if ($.inArray(normalizedSearchMode, SEARCH_MODES) == -1)
                    throw DX.Error("E1019", searchMode);
            },
            _clearSelectedItem: function() {
                this.option().selectedItem = null
            },
            _initContentReadyAction: function() {
                this._contentReadyAction = this._createActionByOption("onContentReady")
            },
            _selectedItemClass: function() {
                return DROPDOWNLIST_SELECTED_CLASS
            },
            _listItemElements: function() {
                return this._$list ? this._$list.find(LIST_ITEM_SELECTOR) : $()
            },
            _listSelectedItemElements: function() {
                return this._$list ? this._$list.find("." + this._selectedItemClass()) : $()
            },
            _popupConfig: function() {
                return $.extend(this.callBase(), {width: this.option("width")})
            },
            _renderPopupContent: function() {
                this._renderList()
            },
            _attachKeyboardEvents: function() {
                this.callBase.apply(this, arguments);
                this._attachChildKeyboardEvents()
            },
            _attachChildKeyboardEvents: function() {
                var child = this._keyboardProcessor.attachChildProcessor();
                if (this._list) {
                    this._list.option("_keyboardProcessor", child);
                    return
                }
                var config = this._listConfig();
                this._listConfig = function() {
                    return $.extend(config, {_keyboardProcessor: child})
                }
            },
            _renderList: function() {
                this._$list = $("<div>").appendTo(this._popup.content());
                this._list = this._$list.dxList(this._listConfig()).dxList("instance");
                this._refreshList()
            },
            _refreshList: function() {
                if (this._list && this._shouldRefreshDataSource())
                    this._setListDataSource()
            },
            _shouldRefreshDataSource: function() {
                var dataSourceProvided = !!this._list.option("dataSource");
                return dataSourceProvided !== this._isMinFilterLengthExceeded()
            },
            _listConfig: function() {
                return {
                        _templates: this.option("_templates"),
                        rtlEnabled: this.option("rtlEnabled"),
                        autoPagingEnabled: this.option("pagingEnabled"),
                        onContentReady: $.proxy(this._listContentReadyHandler, this),
                        itemTemplate: this._getTemplateByOption("itemTemplate"),
                        indicateLoading: false,
                        tabIndex: -1,
                        onItemClick: $.proxy(this._listItemClickHandler, this),
                        focusStateEnabled: this.option("focusStateEnabled")
                    }
            },
            _dataSourceOptions: function() {
                return {paginate: this.option("pagingEnabled")}
            },
            _listContentReadyHandler: function() {
                if (this._list)
                    this.option().items = this._list.option("items");
                this._refreshSelected();
                this._dimensionChanged();
                this._contentReadyAction()
            },
            _setListOption: function(optionName, value) {
                this._setWidgetOption("_list", arguments)
            },
            _listItemClickHandler: DX.abstract,
            _setListDataSource: function() {
                if (!this._list)
                    return;
                var isMinFilterLengthExceeded = this._isMinFilterLengthExceeded();
                this._setListOption("dataSource", isMinFilterLengthExceeded ? this._dataSource : null);
                if (!isMinFilterLengthExceeded)
                    this._setListOption("items", undefined)
            },
            _isMinFilterLengthExceeded: function() {
                return this._searchValue().toString().length >= this.option("minSearchLength")
            },
            _searchValue: function() {
                return this._input().val() || ""
            },
            _search: function() {
                if (!this._isMinFilterLengthExceeded()) {
                    this._searchCanceled();
                    return
                }
                var searchTimeout = this.option("searchTimeout");
                if (searchTimeout) {
                    if (!this._searchTimer)
                        this._searchTimer = setTimeout($.proxy(this._searchDataSource, this), searchTimeout)
                }
                else
                    this._searchDataSource()
            },
            _searchCanceled: function() {
                this._clearSearchTimer();
                this._refreshList()
            },
            _searchDataSource: function() {
                this._filterDataSource(this._searchValue())
            },
            _filterDataSource: function(searchValue) {
                var dataSource = this._dataSource;
                dataSource.searchExpr(this.option("searchExpr") || this.option("displayExpr"));
                dataSource.searchOperation(this.option("searchMode"));
                dataSource.searchValue(searchValue);
                dataSource.pageIndex(0);
                return dataSource.load().done($.proxy(this._dataSourceFiltered, this))
            },
            _clearFilter: function() {
                this._dataSource.searchValue("")
            },
            _dataSourceFiltered: function() {
                this._clearSearchTimer();
                this._refreshList();
                this._refreshPopupVisibility()
            },
            _refreshPopupVisibility: function() {
                this.option("opened", this._hasItemsToShow());
                if (this.option("opened"))
                    this._dimensionChanged()
            },
            _hasItemsToShow: function() {
                var resultItems = this._dataSource && this._dataSource.items() || [];
                var resultAmount = resultItems.length;
                var value = this.option("value");
                var isMinFilterLengthExceeded = this._isMinFilterLengthExceeded();
                var firstResultValue = this._displayGetter(resultItems[0]) || "";
                var foundSingleResultEqualToValue = resultItems.length === 1 && firstResultValue === value;
                return isMinFilterLengthExceeded && resultAmount && !foundSingleResultEqualToValue
            },
            _clearSearchTimer: function() {
                clearTimeout(this._searchTimer);
                delete this._searchTimer
            },
            _popupShowingHandler: function() {
                this._dimensionChanged()
            },
            _dimensionChanged: function() {
                this._popup && this._updatePopupDimensions()
            },
            _updatePopupDimensions: function() {
                this._updatePopupWidth();
                this._updatePopupHeight()
            },
            _updatePopupWidth: function() {
                var currentDevice = DX.devices.current(),
                    widthCorrection = currentDevice.android && currentDevice.version[0] >= 5 ? 16 : 0;
                this._setPopupOption("width", this.element().outerWidth() + widthCorrection)
            },
            _updatePopupHeight: function() {
                this._setPopupOption("height", "auto");
                var popupHeight = this._popup.overlayContent().outerHeight();
                var maxHeight = $(window).height() * 0.5;
                this._setPopupOption("height", Math.min(popupHeight, maxHeight));
                this._list && this._list.updateDimensions()
            },
            _changeSelectedItem: function($selectedItem, $newItem) {
                var selectedItemClass = this._selectedItemClass();
                $newItem.addClass(selectedItemClass);
                $selectedItem.removeClass(selectedItemClass)
            },
            _selectedItemValue: function() {
                var $selectedItem = this._listSelectedItemElements();
                return this._valueGetter($selectedItem.data(LIST_ITEM_DATA_KEY))
            },
            _valueChangeArgs: function() {
                return $.extend(this.callBase.apply(this, arguments), {
                        selectedItem: this.option("selectedItem"),
                        itemData: this.option("selectedItem")
                    })
            },
            _clean: function() {
                if (this._list)
                    delete this._list;
                this.callBase()
            },
            _dispose: function() {
                this._clearSearchTimer();
                this.callBase()
            },
            _setCollectionWidgetOption: function() {
                this._setListOption.apply(this, arguments)
            },
            _optionChanged: function(args) {
                this._dataExpressionOptionChanged(args);
                switch (args.name) {
                    case"items":
                        if (!this.option("dataSource"))
                            this._setListDataSource();
                        break;
                    case"dataSource":
                        this._setListDataSource();
                        break;
                    case"valueExpr":
                    case"displayExpr":
                    case"placeholder":
                        this._renderValue();
                        break;
                    case"searchMode":
                        this._validateSearchMode();
                        break;
                    case"minSearchLength":
                        this._refreshList();
                        break;
                    case"searchEnabled":
                    case"searchExpr":
                    case"pagingEnabled":
                        this._invalidate();
                        break;
                    case"onContentReady":
                        this._initContentReadyAction();
                        break;
                    case"itemTemplate":
                    case"displayValue":
                    case"selectedItem":
                    case"searchTimeout":
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }).include(ui.DataExpressionMixin))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.textArea.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var TEXTAREA_CLASS = "dx-textarea",
            TEXTEDITOR_INPUT_CLASS = "dx-texteditor-input",
            TEXTEDITOR_CONTAINER_CLASS = "dx-texteditor-container";
        DX.registerComponent("dxTextArea", ui, ui.dxTextBox.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({spellcheck: true})
            },
            _render: function() {
                this.callBase();
                this.element().addClass(TEXTAREA_CLASS)
            },
            _renderInput: function() {
                this.callBase();
                this._renderScrollHandler()
            },
            _createInput: function() {
                return $("<textarea>").addClass(TEXTEDITOR_INPUT_CLASS)
            },
            _renderScrollHandler: function() {
                var $input = this._input(),
                    eventY = 0;
                $input.on(events.addNamespace("dxpointerdown", this.NAME), function(e) {
                    eventY = events.eventData(e).y
                });
                $input.on(events.addNamespace("dxpointermove", this.NAME), function(e) {
                    var scrollTopPos = $input.scrollTop(),
                        scrollBottomPos = $input.prop("scrollHeight") - $input.prop("clientHeight") - scrollTopPos;
                    if (scrollTopPos === 0 && scrollBottomPos === 0)
                        return;
                    var currentEventY = events.eventData(e).y;
                    var isScrollFromTop = scrollTopPos === 0 && eventY >= currentEventY,
                        isScrollFromBottom = scrollBottomPos === 0 && eventY <= currentEventY,
                        isScrollFromMiddle = scrollTopPos > 0 && scrollBottomPos > 0;
                    if (isScrollFromTop || isScrollFromBottom || isScrollFromMiddle)
                        e.isScrollingEvent = true;
                    eventY = currentEventY
                })
            },
            _renderInputType: $.noop
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.numberBox.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            math = Math,
            events = ui.events,
            WIDGET_CLASS = "dx-numberbox",
            SPIN_CLASS = "dx-numberbox-spin",
            SPIN_CONTAINER_CLASS = "dx-numberbox-spin-container",
            SPIN_UP_CLASS = "dx-numberbox-spin-up",
            SPIN_DOWN_CLASS = "dx-numberbox-spin-down",
            SPIN_BUTTON_CLASS = "dx-numberbox-spin-button",
            SPIN_TOUCH_FRIENDLY_CLASS = "dx-numberbox-spin-touch-friendly",
            SPIN_UP_SELECTOR = "." + SPIN_UP_CLASS,
            SPIN_DOWN_SELECTOR = "." + SPIN_DOWN_CLASS,
            SPIN_HOLD_DELAY = 150,
            CONTROL_KEYS = ["Del", "Backspace", "Left", "Right", "Home", "End"];
        var androidNativeBrowser = DX.devices.real().android && navigator.userAgent.indexOf("Chrome") === -1;
        var dxSpinButton = ui.Widget.inherit({
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        direction: "up",
                        onChange: null
                    })
                },
                _render: function() {
                    this.callBase();
                    var that = this,
                        $element = this.element(),
                        pointerDownEvent = events.addNamespace("dxpointerdown", this.NAME),
                        direction = SPIN_CLASS + "-" + this.option("direction");
                    $element.addClass(SPIN_BUTTON_CLASS).addClass(direction).off(pointerDownEvent).on(pointerDownEvent, $.proxy(this._spinHoldHandler, this));
                    this._spinIcon = $("<div>").addClass(direction + "-icon").appendTo(this.element());
                    this._spinChangeHandler = this._createActionByOption("onChange")
                },
                _spinHoldHandler: function(e) {
                    e.preventDefault();
                    var pointerUpEvent = events.addNamespace("dxpointerup", this.NAME),
                        pointerCancelEvent = events.addNamespace("dxpointercancel", this.NAME);
                    this._clearTimer();
                    $(document).off(pointerUpEvent).off(pointerCancelEvent).on(pointerUpEvent, $.proxy(this._clearTimer, this)).on(pointerCancelEvent, $.proxy(this._clearTimer, this));
                    this._spinChangeHandler({jQueryEvent: e});
                    this._holdTimer = setInterval(this._spinChangeHandler, SPIN_HOLD_DELAY, {jQueryEvent: e})
                },
                _dispose: function() {
                    this._clearTimer();
                    this.callBase()
                },
                _clearTimer: function(e) {
                    if (this._holdTimer)
                        clearInterval(this._holdTimer)
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"onChange":
                        case"direction":
                            this._invalidate();
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        DX.registerComponent("dxNumberBox", ui, ui.dxTextEditor.inherit({
            _supportedKeys: function() {
                return $.extend(this.callBase(), {
                        upArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            this._spinUpChangeHandler()
                        },
                        downArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            this._spinDownChangeHandler()
                        },
                        enter: function(e) {
                            this._input().trigger(this.option("valueChangeEvent"))
                        }
                    })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    value: 0,
                    min: undefined,
                    max: undefined,
                    step: 1,
                    showSpinButtons: false,
                    useTouchSpinButtons: true,
                    mode: "number"
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic
                            },
                            options: {useTouchSpinButtons: false}
                        }])
            },
            _render: function() {
                this.callBase();
                this.element().addClass(WIDGET_CLASS);
                this._keyPressHandlerEvent()
            },
            _keyPressHandlerEvent: function() {
                var that = this;
                this._input().keypress(function(e) {
                    var ch = String.fromCharCode(e.which),
                        validCharRegExp = /[\d.,eE\-+]/,
                        isInputCharValid = validCharRegExp.test(ch);
                    if (!isInputCharValid)
                        if (!(e.key && $.inArray(e.key, CONTROL_KEYS) >= 0)) {
                            e.preventDefault();
                            return false
                        }
                    that._isIncompleteValue = false;
                    if (that._isValueIncomplete(that._input().val() + ch))
                        that._isIncompleteValue = true
                })
            },
            _isValueIncomplete: function(value) {
                var expRegex = /\d+e$/,
                    negRegex = /^-/;
                return expRegex.test(value) || negRegex.test(value)
            },
            _renderInputAddons: function() {
                this.callBase();
                this._renderSpinButtons()
            },
            _renderSpinButtons: function() {
                var spinButtonsVisible = this.option("showSpinButtons");
                this.element().toggleClass(SPIN_CLASS, spinButtonsVisible);
                this._toggleTouchFriendlyClass();
                if (!spinButtonsVisible) {
                    this._$spinContainer && this._$spinContainer.remove();
                    this._$spinContainer = null;
                    return
                }
                if (!this._$spinContainer)
                    this._$spinContainer = this._createSpinButtons();
                this._$spinContainer.prependTo(this._buttonsContainer())
            },
            _toggleTouchFriendlyClass: function() {
                this.element().toggleClass(SPIN_TOUCH_FRIENDLY_CLASS, this.option("showSpinButtons") && this.option("useTouchSpinButtons"))
            },
            _createSpinButtons: function() {
                var clickEventName = events.addNamespace("dxclick", this.NAME);
                var pointerDownEventName = events.addNamespace("dxpointerdown", this.NAME);
                var $spinContainer = $("<div>").addClass(SPIN_CONTAINER_CLASS).off(pointerDownEventName).off(clickEventName).on(pointerDownEventName, $.proxy(this._spinButtonsPointerDownHandler, this)).on(clickEventName, $.proxy(this._spinButtonsClickHandler, this));
                this._$spinUp = $("<div>").dxSpinButton({
                    direction: "up",
                    onChange: $.proxy(this._spinUpChangeHandler, this)
                }).appendTo($spinContainer);
                this._$spinDown = $("<div>").dxSpinButton({
                    direction: "down",
                    onChange: $.proxy(this._spinDownChangeHandler, this)
                }).appendTo($spinContainer);
                return $spinContainer
            },
            _spinButtonsClickHandler: function(e) {
                e.dxPreventBlur = true
            },
            _spinButtonsPointerDownHandler: function(e) {
                var $input = this._input();
                if (!this.option("useTouchSpinButtons") && document.activeElement !== $input[0])
                    $input.trigger("focus")
            },
            _spinValueChange: function(sign) {
                this._input().trigger(this.option("valueChangeEvent"));
                var value = parseFloat(this.option().value || 0),
                    step = parseFloat(this.option().step);
                value = this._correctRounding(value, step * sign);
                this.option("value", value)
            },
            _spinUpChangeHandler: function() {
                this._spinValueChange(1)
            },
            _spinDownChangeHandler: function() {
                this._spinValueChange(-1)
            },
            _correctRounding: function(value, step) {
                var regex = /[,|.](.*)/;
                var isFloatValue = regex.test(value),
                    isFloatStep = regex.test(step);
                if (isFloatValue || isFloatStep) {
                    var valueAccuracy = isFloatValue ? regex.exec(value)[0].length : 0,
                        stepAccuracy = isFloatStep ? regex.exec(step)[0].length : 0,
                        accuracy = math.max(valueAccuracy, stepAccuracy);
                    value = this._round(value + step, accuracy);
                    return value
                }
                return value + step
            },
            _round: function(value, precision) {
                precision = precision || 0;
                var multiplier = Math.pow(10, precision);
                value *= multiplier;
                value = Math.round(value) / multiplier;
                return value
            },
            _renderValue: function() {
                var value = this.option("value") ? this.option("value").toString() : this.option("value");
                if (this._input().val() !== value) {
                    this._forceValueRender();
                    this._toggleEmptinessEventHandler()
                }
                this._renderInputAddons()
            },
            _forceValueRender: function() {
                var $input = this._input(),
                    value = this.option("value");
                if (androidNativeBrowser) {
                    var inputType = $input.attr("type");
                    this._setInputType("text");
                    $input.val(value);
                    this._setInputType(inputType)
                }
                else
                    $input.val(value)
            },
            _renderProps: function() {
                this.callBase();
                this._input().prop({
                    min: this.option("min"),
                    max: this.option("max"),
                    step: this.option("step")
                })
            },
            _trimInputValue: function() {
                var $input = this._input(),
                    value = $.trim($input.val());
                if (value[value.length - 1] === ".")
                    value = value.slice(0, -1);
                this._forceRefreshInputValue(value)
            },
            _inputInvalidHandler: function() {
                var $input = this._input(),
                    value = $input.val();
                if (this._oldValue) {
                    this.option("value", this._oldValue);
                    $input.val(this._oldValue);
                    this._oldValue = null
                }
                else {
                    this.option("value", "");
                    $input.val("")
                }
            },
            _forceRefreshInputValue: function(value) {
                var $input = this._input();
                $input.val("").val(value);
                $input.val(this.option("value"))
            },
            _renderValueChangeEvent: function() {
                this.callBase();
                this._input().focusout($.proxy(this._trimInputValue, this))
            },
            _valueChangeEventHandler: function(e) {
                var $input = this._input(),
                    value = $.trim($input.val()),
                    input = $input.get(0);
                value = value.replace(",", ".");
                this._valueChangeEventInstance = e;
                if (!this._isIncompleteValue)
                    if (!this._validateValue(value)) {
                        this._inputInvalidHandler();
                        return
                    }
                if (value !== "") {
                    value = this._parseValue(value);
                    if (!value && value !== 0)
                        return;
                    this.callBase(e, value);
                    if ($input.val() != value)
                        $input.val(this.option("value"))
                }
                else if (!this._isIncompleteValue && this.option("value") !== "") {
                    this.option("value", this._oldValue);
                    $input.val(this._oldValue)
                }
            },
            _validateValue: function(value) {
                var isValueValid = this._isValueValid();
                if (!value && isValueValid) {
                    this.option("value", "");
                    return true
                }
                var isNumber = /^-?\d*\.?\d*$/.test(value),
                    isExponent = /^-?\d+e[-+]?\d+$/.test(value);
                this._oldValue = this.option("value");
                if (!isNumber && !isExponent && !isValueValid)
                    return false;
                return true
            },
            _parseValue: function(value) {
                var number = parseFloat(value);
                if (this.option("min") !== undefined)
                    number = math.max(number, this.option("min"));
                if (this.option("max") !== undefined)
                    number = math.min(number, this.option("max"));
                return number
            },
            _setValue: function(value, prevValue) {
                if (!value && value !== 0) {
                    this.option("value", "");
                    if (value !== "")
                        this._suppressValueChangeAction();
                    return
                }
                if ($.type(value) === "string")
                    value = value.replace(",", ".");
                var newValue = this._parseValue(value);
                if (!newValue && newValue !== 0) {
                    this.option("value", prevValue);
                    this._suppressValueChangeAction();
                    return
                }
                if (value !== newValue) {
                    this.option("value", newValue);
                    this._suppressValueChangeAction()
                }
            },
            _clean: function() {
                delete this._$spinContainer;
                delete this._$spinUp;
                delete this._$spinDown;
                this.callBase()
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"value":
                        this._setValue(args.value, args.previousValue);
                        this.callBase(args);
                        this._resumeValueChangeAction();
                        break;
                    case"step":
                    case"min":
                    case"max":
                        this._renderProps();
                        break;
                    case"showSpinButtons":
                        this._renderInputAddons();
                        break;
                    case"useTouchSpinButtons":
                        this._toggleTouchFriendlyClass();
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }));
        DX.registerComponent("dxSpinButton", ui.dxNumberBox, dxSpinButton);
        ui.dxNumberBox.__internals = {
            WIDGET_CLASS: WIDGET_CLASS,
            SPIN_CLASS: SPIN_CLASS,
            SPIN_CONTAINER_CLASS: SPIN_CONTAINER_CLASS,
            SPIN_UP_CLASS: SPIN_UP_CLASS,
            SPIN_DOWN_CLASS: SPIN_DOWN_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.radioButton.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var RADIO_BUTTON = "dxRadioButton",
            RADIO_BUTTON_CLASS = "dx-radio-button",
            RADIO_BUTTON_ICON_CLASS = "dx-radio-button-icon",
            RADIO_BUTTON_CHECKED_CLASS = "dx-radio-button-checked",
            RADIO_BUTTON_DXCLICK_EVENT_NAME = events.addNamespace("dxclick", RADIO_BUTTON);
        DX.registerComponent(RADIO_BUTTON, ui, ui.Editor.inherit({
            _supportedKeys: function() {
                var click = function(e) {
                        this._clickAction({jQueryEvent: e})
                    };
                return $.extend(this.callBase(), {
                        space: click,
                        enter: click
                    })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({value: false})
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {
                                focusStateEnabled: true,
                                hoverStateEnabled: true
                            }
                        }])
            },
            _init: function() {
                this.callBase();
                this.element().addClass(RADIO_BUTTON_CLASS)
            },
            _render: function() {
                this.callBase();
                this._renderIcon();
                this._renderCheckedState(this.option("value"));
                this._renderClick()
            },
            _renderIcon: function() {
                var $icon = $("<div>").addClass(RADIO_BUTTON_ICON_CLASS);
                this.element().append($icon)
            },
            _renderCheckedState: function(checked) {
                this.element().toggleClass(RADIO_BUTTON_CHECKED_CLASS, checked)
            },
            _renderClick: function() {
                this._clickAction = this._createAction($.proxy(function(args) {
                    this._clickHandler(args.jQueryEvent)
                }, this));
                this.element().off(RADIO_BUTTON_DXCLICK_EVENT_NAME).on(RADIO_BUTTON_DXCLICK_EVENT_NAME, $.proxy(function(e) {
                    this._clickAction({jQueryEvent: e})
                }, this))
            },
            _clickHandler: function(e) {
                this._valueChangeEventInstance = e;
                this.option("value", true)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"value":
                        this._renderCheckedState(args.value);
                        this.callBase(args);
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.radioGroup.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var RADIO_GROUP_CLASS = "dx-radio-group",
            RADIO_GROUP_VERTICAL_CLASS = "dx-radio-group-vertical",
            RADIO_GROUP_HORIZONTAL_CLASS = "dx-radio-group-horizontal",
            RADIO_BUTTON_CLASS = "dx-radio-button",
            RADIO_BUTTON_ICON_CLASS = "dx-radio-button-icon",
            RADIO_VALUE_CONTAINER_CLASS = "dx-radio-value-container",
            RADIO_BUTTON_CHECKED_CLASS = "dx-radio-button-checked",
            ITEM_DATA_KEY = "dxItemData",
            RADIO_FEEDBACK_HIDE_TIMEOUT = 100;
        DX.registerComponent("dxRadioGroup", ui, ui.Editor.inherit({
            _activeStateUnit: "." + RADIO_BUTTON_CLASS,
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, this._dataExpressionDeprecatedOptions())
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option($.extend(this._dataExpressionDefaultOptions(), {layout: "vertical"}))
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {tablet: true},
                            options: {layout: "horizontal"}
                        }, {
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {
                                focusStateEnabled: true,
                                hoverStateEnabled: true
                            }
                        }])
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {value: true})
            },
            _dataSourceOptions: function() {
                return {
                        paginate: false,
                        _preferSync: true
                    }
            },
            _init: function() {
                this.callBase();
                this._initDataExpressions();
                this._feedbackHideTimeout = RADIO_FEEDBACK_HIDE_TIMEOUT
            },
            _render: function() {
                this.element().addClass(RADIO_GROUP_CLASS);
                this._renderCollectionWidget();
                this.callBase();
                this._renderLayout();
                this._updateItemsSize()
            },
            _renderFocusTarget: $.noop,
            _renderContentImpl: $.noop,
            _renderCollectionWidget: function() {
                this._$collectionWidget = $("<div>").appendTo(this.element());
                this._collectionWidget = new ui.CollectionWidget(this._$collectionWidget, {
                    _templates: this.option("_templates"),
                    _focusEventPropagation: true,
                    dataSource: this._dataSource,
                    onItemRendered: $.proxy(this._itemRenderedHandler, this),
                    onItemClick: $.proxy(this._itemClickHandler, this),
                    itemTemplate: this._getTemplateByOption("itemTemplate"),
                    rtlEnabled: this.option("rtlEnabled"),
                    autoPagingEnabled: false,
                    scrollingEnabled: false,
                    focusStateEnabled: this.option("focusStateEnabled"),
                    noDataText: "",
                    tabIndex: this.option("tabIndex")
                });
                this._setCollectionWidgetOption("onContentReady", $.proxy(this._contentReadyHandler, this));
                this._contentReadyHandler()
            },
            _attachKeyboardEvents: function() {
                this.callBase.apply(this, arguments);
                this._collectionProcessor = this._keyboardProcessor.attachChildProcessor();
                if (this._collectionWidget)
                    this._collectionWidget.option("_keyboardProcessor", this._collectionProcessor)
            },
            _cleanFocusState: function() {
                this.callBase.apply(this, arguments);
                delete this._collectionProcessor
            },
            _focusTarget: function() {
                return this.element()
            },
            _contentReadyHandler: function() {
                this.itemElements().addClass(RADIO_BUTTON_CLASS);
                this._refreshSelected()
            },
            _itemRenderedHandler: function(e) {
                if (e.itemData.html)
                    return;
                var $radio = $("<div>").addClass(RADIO_BUTTON_ICON_CLASS);
                var $radioContainer = $("<div>").append($radio).addClass(RADIO_VALUE_CONTAINER_CLASS);
                e.itemElement.prepend($radioContainer)
            },
            _itemClickHandler: function(e) {
                this.option("value", this._getItemValue(e.itemData))
            },
            _getItemValue: function(item) {
                return !!this._valueGetter ? this._valueGetter(item) : item.text
            },
            itemElements: function() {
                return this._collectionWidget.itemElements()
            },
            _renderDimensions: function() {
                this.callBase();
                this._updateItemsSize()
            },
            _renderLayout: function() {
                var layout = this.option("layout");
                this.element().toggleClass(RADIO_GROUP_VERTICAL_CLASS, layout === "vertical");
                this.element().toggleClass(RADIO_GROUP_HORIZONTAL_CLASS, layout === "horizontal")
            },
            _refreshSelected: function() {
                var selectedValue = this.option("value");
                this.itemElements().each($.proxy(function(_, item) {
                    var $item = $(item);
                    var itemValue = this._valueGetter($item.data(ITEM_DATA_KEY));
                    $item.toggleClass(RADIO_BUTTON_CHECKED_CLASS, this._valueEquals(itemValue, selectedValue))
                }, this))
            },
            _updateItemsSize: function() {
                if (this.option("layout") === "horizontal")
                    this.itemElements().css("height", "auto");
                else {
                    var itemsCount = this.option("items").length;
                    this.itemElements().css("height", 100 / itemsCount + "%")
                }
            },
            _setCollectionWidgetOption: function() {
                this._setWidgetOption("_collectionWidget", arguments)
            },
            _optionChanged: function(args) {
                this._dataExpressionOptionChanged(args);
                switch (args.name) {
                    case"focusStateEnabled":
                        this._setCollectionWidgetOption(args.name, args.value);
                        break;
                    case"dataSource":
                        this._setCollectionWidgetOption("dataSource");
                        break;
                    case"valueExpr":
                        this._refreshSelected();
                        break;
                    case"value":
                        this._refreshSelected();
                        this.callBase(args);
                        break;
                    case"items":
                    case"itemTemplate":
                    case"displayExpr":
                        break;
                    case"layout":
                        this._renderLayout();
                        this._updateItemsSize();
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }).include(ui.DataExpressionMixin))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.tabs.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            fx = DX.fx,
            TABS_CLASS = "dx-tabs",
            TABS_WRAPPER_CLASS = "dx-indent-wrapper",
            TABS_EXPANDED_CLASS = "dx-tabs-expanded",
            TABS_SCROLLABLE_CLASS = "dx-scrollable-wrapper",
            TABS_NAV_BUTTONS_CLASS = "dx-tabs-nav-buttons",
            TABS_MARGIN = 25,
            TABS_ITEM_CLASS = "dx-tab",
            TABS_ITEM_SELECTOR = ".dx-tab",
            TABS_ITEM_SELECTED_CLASS = "dx-tab-selected",
            TABS_NAV_BUTTON_CLASS = "dx-tabs-nav-button",
            TABS_LEFT_NAV_BUTTON_CLASS = "dx-tabs-nav-button-left",
            TABS_RIGHT_NAV_BUTTON_CLASS = "dx-tabs-nav-button-right",
            TABS_ITEM_DATA_KEY = "dxTabData",
            FEEDBACK_HIDE_TIMEOUT = 100,
            ACTIVE_STATE_CLASS = "dx-state-active",
            SCROLLABLE_CONTENT_CLASS = "dx-scrollable-content",
            TAB_OFFSET = 30;
        DX.registerComponent("dxTabs", ui, ui.CollectionWidget.inherit({
            _activeStateUnit: TABS_ITEM_SELECTOR,
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    showNavButtons: false,
                    scrollByContent: true,
                    scrollingEnabled: true,
                    wordWrap: false,
                    activeStateEnabled: true,
                    selectionMode: "single",
                    selectionRequired: true,
                    selectOnFocus: true,
                    loopItemFocus: false
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "win8"},
                            options: {wordWrap: true}
                        }, {
                            device: {platform: "generic"},
                            options: {
                                showNavButtons: true,
                                scrollByContent: false
                            }
                        }, {
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {
                                hoverStateEnabled: true,
                                focusStateEnabled: true
                            }
                        }])
            },
            _init: function() {
                this.callBase();
                this.element().addClass(TABS_CLASS);
                this._feedbackHideTimeout = FEEDBACK_HIDE_TIMEOUT
            },
            _itemClass: function() {
                return TABS_ITEM_CLASS
            },
            _selectedItemClass: function() {
                return TABS_ITEM_SELECTED_CLASS
            },
            _itemDataKey: function() {
                return TABS_ITEM_DATA_KEY
            },
            _render: function() {
                this.callBase();
                this._renderWrapper();
                if (this._allowScrolling()) {
                    this._renderScrollable();
                    this._renderNavButtons();
                    this._updateNavButtons()
                }
                else
                    this.element().addClass(TABS_EXPANDED_CLASS);
                this.element().addClass(ACTIVE_STATE_CLASS).removeClass(ACTIVE_STATE_CLASS)
            },
            _renderWrapper: function() {
                this.element().wrapInner($("<div>").addClass(TABS_WRAPPER_CLASS))
            },
            _renderScrollable: function() {
                var $itemContainer = this.element().wrapInner($("<div>").addClass(TABS_SCROLLABLE_CLASS)).children();
                this._scrollable = $itemContainer.dxScrollable({
                    direction: "horizontal",
                    showScrollbar: false,
                    useKeyboard: false,
                    useNative: false,
                    scrollByContent: this.option("scrollByContent"),
                    onScroll: $.proxy(this._updateNavButtonsVisibility, this)
                }).dxScrollable("instance");
                this.element().append(this._scrollable.element())
            },
            _allowScrolling: function() {
                if (this.option("wordWrap"))
                    return;
                if (!this.option("scrollingEnabled"))
                    return false;
                var tabItemsWidth = 0;
                this.itemElements().each(function(_, tabItem) {
                    tabItemsWidth += $(tabItem).outerWidth(true)
                });
                return tabItemsWidth > this.element().width()
            },
            _renderNavButtons: function() {
                this.element().toggleClass(TABS_NAV_BUTTONS_CLASS, this.option("showNavButtons"));
                if (this.option("showNavButtons")) {
                    this._leftButton = this._createNavButton(-TAB_OFFSET);
                    var $leftButton = this._leftButton.element();
                    $leftButton.addClass(TABS_LEFT_NAV_BUTTON_CLASS);
                    this.element().prepend($leftButton);
                    this._rightButton = this._createNavButton(TAB_OFFSET);
                    var $rightButton = this._rightButton.element();
                    $rightButton.addClass(TABS_RIGHT_NAV_BUTTON_CLASS);
                    this.element().append($rightButton);
                    this._updateNavButtonsVisibility();
                    this._scrollable.update()
                }
            },
            _updateNavButtonsVisibility: function() {
                this._leftButton && this._leftButton.option("disabled", this._scrollable.scrollLeft() <= 0);
                this._rightButton && this._rightButton.option("disabled", this._scrollable.scrollLeft() >= this._scrollable.scrollWidth() - this._scrollable.clientWidth())
            },
            _createNavButton: function(offset) {
                var $navButton = $("<div>").addClass(TABS_NAV_BUTTON_CLASS).dxButton({
                        focusStateEnabled: false,
                        onClick: $.proxy(function() {
                            this._scrollable.update();
                            this._scrollable.scrollBy(offset)
                        }, this)
                    });
                return $navButton.dxButton("instance")
            },
            _updateNavButtons: function() {
                var $element = this.element(),
                    tabsHeight = $element.height();
                $element.find("." + TABS_LEFT_NAV_BUTTON_CLASS).css({height: tabsHeight});
                $element.find("." + TABS_RIGHT_NAV_BUTTON_CLASS).css({
                    height: tabsHeight,
                    "margin-top": -tabsHeight
                })
            },
            _renderSelection: function(addedSelection) {
                this._scrollable && this._scrollable.scrollToElement(this.itemElements().eq(addedSelection[0]))
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"wordWrap":
                    case"scrollingEnabled":
                    case"showNavButtons":
                        this._invalidate();
                        break;
                    case"scrollByContent":
                        this._scrollable && this._scrollable.option(args.name, args.value);
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.navBar.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            NAVBAR_CLASS = "dx-navbar",
            ITEM_CLASS = "dx-item-content",
            NAVBAR_ITEM_CLASS = "dx-nav-item",
            NAVBAR_ITEM_CONTENT_CLASS = "dx-nav-item-content",
            NAVBAR_ITEM_BADGE_CLASS = "dx-navbar-item-badge",
            BADGE_CLASS = "dx-badge";
        DX.registerComponent("dxNavBar", ui, ui.dxTabs.inherit({
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "generic"},
                            options: {
                                showNavButtons: false,
                                scrollByContent: false,
                                scrollingEnabled: false
                            }
                        }])
            },
            _render: function() {
                this.callBase();
                this.element().addClass(NAVBAR_CLASS)
            },
            _postprocessRenderItem: function(args) {
                this.callBase(args);
                var $itemElement = args.itemElement,
                    itemData = args.itemData;
                $itemElement.addClass(NAVBAR_ITEM_CLASS);
                $itemElement.find("." + ITEM_CLASS).addClass(NAVBAR_ITEM_CONTENT_CLASS);
                if (!itemData.icon && !itemData.iconSrc)
                    $itemElement.addClass("dx-navbar-text-item")
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.toolbar.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx,
            utils = DX.utils,
            translator = DX.translator;
        var TOOLBAR_CLASS = "dx-toolbar",
            TOOLBAR_BOTTOM_CLASS = "dx-toolbar-bottom",
            TOOLBAR_MINI_CLASS = "dx-toolbar-mini",
            TOOLBAR_ITEM_CLASS = "dx-toolbar-item",
            TOOLBAR_LABEL_CLASS = "dx-toolbar-label",
            TOOLBAR_BUTTON_CLASS = "dx-toolbar-button",
            TOOLBAR_MENU_CONTAINER_CLASS = "dx-toolbar-menu-container",
            TOOLBAR_MENU_BUTTON_CLASS = "dx-toolbar-menu-button",
            TOOLBAR_ITEMS_CONTAINER_CLASS = "dx-toolbar-items-container",
            TOOLBAR_LABEL_SELECTOR = "." + TOOLBAR_LABEL_CLASS,
            TOOLBAR_ITEM_DATA_KEY = "dxToolbarItemDataKey",
            SUBMENU_SWIPE_EASING = "easeOutCubic",
            SUBMENU_HIDE_DURATION = 200,
            SUBMENU_SHOW_DURATION = 400;
        var slideSubmenu = function($element, position, isShowAnimation) {
                var duration = isShowAnimation ? SUBMENU_SHOW_DURATION : SUBMENU_HIDE_DURATION;
                fx.animate($element, {
                    type: "slide",
                    to: {top: position},
                    easing: SUBMENU_SWIPE_EASING,
                    duration: duration
                })
            };
        DX.registerComponent("dxToolbar", ui, ui.CollectionWidget.inherit({
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {menuItemRender: {
                        since: "14.2",
                        alias: "menuItemTemplate"
                    }})
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    menuItemTemplate: "menuItem",
                    submenuType: "dxDropDownMenu",
                    renderAs: "topToolbar"
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "ios"},
                            options: {submenuType: "dxActionSheet"}
                        }, {
                            device: {platform: "android"},
                            options: {submenuType: "dxDropDownMenu"}
                        }, {
                            device: {platform: "win8"},
                            options: {submenuType: "dxList"}
                        }])
            },
            _itemContainer: function() {
                return this._$toolbarItemsContainer.find([".dx-toolbar-before", ".dx-toolbar-center", ".dx-toolbar-after"].join(","))
            },
            _itemClass: function() {
                return TOOLBAR_ITEM_CLASS
            },
            _itemDataKey: function() {
                return TOOLBAR_ITEM_DATA_KEY
            },
            _dimensionChanged: function() {
                if (this._menu)
                    this._toggleMenuVisibility(false, true);
                this._arrangeTitle()
            },
            _render: function() {
                this._renderToolbar();
                this._renderSections();
                this.callBase();
                this._renderMenu();
                this._arrangeTitle()
            },
            _renderToolbar: function() {
                this.element().addClass(TOOLBAR_CLASS).toggleClass(TOOLBAR_BOTTOM_CLASS, this.option("renderAs") === "bottomToolbar");
                this._$toolbarItemsContainer = $("<div>").appendTo(this.element());
                this._$toolbarItemsContainer.addClass(TOOLBAR_ITEMS_CONTAINER_CLASS)
            },
            _renderSections: function() {
                var $container = this._$toolbarItemsContainer,
                    that = this;
                $.each(["before", "center", "after"], function() {
                    var sectionClass = "dx-toolbar-" + this,
                        $section = $container.find("." + sectionClass);
                    if (!$section.length)
                        that["_$" + this + "Section"] = $section = $("<div>").addClass(sectionClass).appendTo($container)
                })
            },
            _arrangeTitle: function() {
                if (this.element().is(":hidden"))
                    return;
                var $container = this._$toolbarItemsContainer,
                    $centerSection = this._$centerSection,
                    $label = $centerSection.children(TOOLBAR_LABEL_SELECTOR).eq(0);
                if (!$label.length)
                    return;
                $centerSection.css({
                    marginLeft: "auto",
                    marginRight: "auto"
                });
                $label.css("max-width", "");
                var containerWidth = $container.width(),
                    beforeWidth = this._$beforeSection.outerWidth(),
                    afterWidth = this._$afterSection.outerWidth();
                var elemsAtCenterWidth = 10;
                $centerSection.children().not(TOOLBAR_LABEL_SELECTOR).each(function() {
                    elemsAtCenterWidth += $(this).outerWidth()
                });
                var maxLabelWidth = containerWidth - beforeWidth - afterWidth - elemsAtCenterWidth;
                var labelLongerThanMax = $label.width() > maxLabelWidth;
                $centerSection.css({
                    marginLeft: labelLongerThanMax ? beforeWidth : "",
                    marginRight: labelLongerThanMax ? afterWidth : ""
                });
                $label.css("max-width", maxLabelWidth)
            },
            _renderItem: function(index, item) {
                if (item.align)
                    DX.log("W0001", "dxToolbar.items.align", "14.1", "Use 'location' instead");
                var align = item.location || item.align || "center";
                if (align === "left") {
                    align = "before";
                    DX.log("W0001", this.NAME, "items.location = 'left'", "14.1", "Use 'before' instead")
                }
                else if (align === "right") {
                    align = "after";
                    DX.log("W0001", this.NAME, "items.location = 'right'", "14.1", "Use 'after' instead")
                }
                var container = this._$toolbarItemsContainer.find(".dx-toolbar-" + align);
                var itemElement = this.callBase(index, item, container);
                itemElement.addClass(TOOLBAR_BUTTON_CLASS);
                if (item.text)
                    itemElement.addClass(TOOLBAR_LABEL_CLASS).removeClass(TOOLBAR_BUTTON_CLASS);
                return itemElement
            },
            _hasVisibleMenuItems: function() {
                var menuItems = this._getMenuItems(),
                    result = false;
                var optionGetter = DevExpress.data.utils.compileGetter("visible");
                $.each(menuItems, function(index, item) {
                    var itemVisible = optionGetter(item, {functionsAsIs: true});
                    if (itemVisible !== false)
                        result = true
                });
                return result
            },
            _getToolbarItems: function() {
                return $.grep(this.option("items") || [], function(item) {
                        return item.location !== "menu"
                    })
            },
            _getMenuItems: function() {
                return $.grep(this.option("items") || [], function(item) {
                        return item.location === "menu"
                    })
            },
            _renderContentImpl: function() {
                var items = this._getToolbarItems();
                this.element().toggleClass(TOOLBAR_MINI_CLASS, items.length === 0);
                if (this._renderedItemsCount)
                    this._renderItems(items.slice(this._renderedItemsCount));
                else
                    this._renderItems(items)
            },
            _renderMenu: function() {
                var that = this,
                    itemClickAction = this._createActionByOption("onItemClick");
                var options = {
                        itemTemplate: function() {
                            if (that._menuType == "dxActionSheet")
                                return that._getTemplate("actionSheetItem");
                            return that._getTemplateByOption("menuItemTemplate")
                        },
                        onItemClick: function(e) {
                            that._toggleMenuVisibility(false, true);
                            itemClickAction(e)
                        },
                        rtlEnabled: this.option("rtlEnabled")
                    };
                this._menuType = this.option("submenuType");
                if (this._menuType === "dxList" && this.option("renderAs") === "topToolbar")
                    this._menuType = "dxDropDownMenu";
                switch (this._menuType) {
                    case"dxActionSheet":
                        this._renderActionSheet(options);
                        break;
                    case"dxDropDownMenu":
                        this._renderDropDown(options);
                        break;
                    case"dxList":
                        this._renderList(options);
                        break
                }
            },
            _renderMenuButton: function(options) {
                var buttonOptions = $.extend({onClick: $.proxy(this._menuButtonClickHandler, this)}, options);
                this._renderMenuButtonContainer();
                this._$button = $("<div>").appendTo(this._$menuButtonContainer).addClass(TOOLBAR_MENU_BUTTON_CLASS).dxButton(buttonOptions)
            },
            _renderMenuButtonContainer: function() {
                var $afterSection = this._$afterSection;
                this._$menuButtonContainer = $("<div>").appendTo($afterSection).addClass(TOOLBAR_BUTTON_CLASS).addClass(TOOLBAR_MENU_CONTAINER_CLASS)
            },
            _renderDropDown: function(options) {
                if (!this._hasVisibleMenuItems())
                    return;
                this._renderMenuButtonContainer();
                this._menu = $("<div>").appendTo(this._$menuButtonContainer).dxDropDownMenu(options).dxDropDownMenu("instance");
                this._renderMenuItems()
            },
            _renderActionSheet: function(options) {
                if (!this._hasVisibleMenuItems())
                    return;
                this._renderMenuButton({icon: "overflow"});
                var actionSheetOptions = $.extend({
                        target: this._$button,
                        showTitle: false
                    }, options);
                this._menu = $("<div>").appendTo(this.element()).dxActionSheet(actionSheetOptions).dxActionSheet("instance");
                this._renderMenuItems()
            },
            _renderList: function(options) {
                this._renderMenuButton({
                    activeStateEnabled: false,
                    text: "..."
                });
                var listOptions = $.extend({
                        width: "100%",
                        indicateLoading: false
                    }, options);
                this._renderListOverlay();
                this._renderContainerSwipe();
                if (this._hasVisibleMenuItems()) {
                    this._menu = $("<div>").appendTo(this._listOverlay.content()).dxList(listOptions).dxList("instance");
                    this._renderMenuItems()
                }
                this._changeListVisible(this.option("visible"))
            },
            _renderMenuItems: function() {
                this._menu.option("items", this._getMenuItems())
            },
            _getListHeight: function() {
                var listHeight = this._listOverlay.content().find(".dx-list").height(),
                    semiHiddenHeight = this._$toolbarItemsContainer.height() - this.element().height();
                return listHeight + semiHiddenHeight
            },
            _renderListOverlay: function() {
                var element = this.element();
                this._listOverlay = $("<div>").appendTo(element).dxOverlay({
                    container: false,
                    deferRendering: false,
                    shading: false,
                    height: "auto",
                    width: "100%",
                    showTitle: false,
                    closeOnOutsideClick: $.proxy(this._listOutsideClickHandler, this),
                    position: null,
                    animation: null,
                    closeOnBackButton: false
                }).dxOverlay("instance")
            },
            _hideTopOverlayHandler: function() {
                this._toggleMenuVisibility(false, true)
            },
            _toggleHideTopOverlayCallback: function() {
                if (this._closeCallback)
                    DX.hideTopOverlayCallback.remove(this._closeCallback);
                if (this._menuShown) {
                    this._closeCallback = $.proxy(this._hideTopOverlayHandler, this);
                    DX.hideTopOverlayCallback.add(this._closeCallback)
                }
            },
            _renderContainerSwipe: function() {
                this._$toolbarItemsContainer.appendTo(this._listOverlay.content()).dxSwipeable({
                    elastic: false,
                    onStart: $.proxy(this._swipeStartHandler, this),
                    onUpdated: $.proxy(this._swipeUpdateHandler, this),
                    onEnd: $.proxy(this._swipeEndHandler, this),
                    itemSizeFunc: $.proxy(this._getListHeight, this),
                    direction: "vertical"
                })
            },
            _listOutsideClickHandler: function(e) {
                if (!$(e.target).closest(this._listOverlay.content()).length)
                    this._toggleMenuVisibility(false, true)
            },
            _calculatePixelOffset: function(offset) {
                offset = (offset || 0) - 1;
                var maxOffset = this._getListHeight();
                return offset * maxOffset
            },
            _swipeStartHandler: function(e) {
                e.jQueryEvent.maxTopOffset = this._menuShown ? 0 : 1;
                e.jQueryEvent.maxBottomOffset = this._menuShown ? 1 : 0
            },
            _swipeUpdateHandler: function(e) {
                var offset = this._menuShown ? e.jQueryEvent.offset : 1 + e.jQueryEvent.offset;
                this._renderMenuPosition(offset, false)
            },
            _swipeEndHandler: function(e) {
                var targetOffset = e.jQueryEvent.targetOffset;
                targetOffset -= this._menuShown - 1;
                this._toggleMenuVisibility(targetOffset === 0, true)
            },
            _renderMenuPosition: function(offset, animate) {
                var pos = this._calculatePixelOffset(offset),
                    element = this._listOverlay.content();
                if (animate)
                    slideSubmenu(element, pos, this._menuShown);
                else
                    translator.move(element, {top: pos})
            },
            _menuButtonClickHandler: function() {
                this._toggleMenuVisibility(!this._menuShown, true)
            },
            _toggleMenuVisibility: function(visible, animate) {
                this._menuShown = visible;
                switch (this._menuType) {
                    case"dxList":
                        this._toggleHideTopOverlayCallback();
                        this._renderMenuPosition(this._menuShown ? 0 : 1, animate);
                        break;
                    case"dxActionSheet":
                        this._menu.toggle(this._menuShown);
                        this._menuShown = false;
                        break
                }
            },
            _renderEmptyMessage: $.noop,
            _clean: function() {
                this._$toolbarItemsContainer.children().empty();
                this.element().empty()
            },
            _changeMenuOption: function(name, value) {
                if (this._menu)
                    this._menu.option(name, value)
            },
            _changeListVisible: function(value) {
                if (this._listOverlay) {
                    this._listOverlay.option("visible", value);
                    this._toggleMenuVisibility(false, false)
                }
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._arrangeTitle()
            },
            _optionChanged: function(args) {
                var name = args.name;
                var value = args.value;
                switch (name) {
                    case"renderAs":
                    case"submenuType":
                        this._invalidate();
                        break;
                    case"visible":
                        this.callBase.apply(this, arguments);
                        this._changeListVisible(value);
                        break;
                    case"menuItemTemplate":
                        this._changeMenuOption("itemTemplate", this._getTemplate(value));
                        break;
                    case"onItemClick":
                        this._changeMenuOption(name, value);
                        this.callBase.apply(this, arguments);
                        break;
                    default:
                        this.callBase.apply(this, arguments)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            utils = DX.utils;
        var LIST_CLASS = "dx-list",
            LIST_ITEM_CLASS = "dx-list-item",
            LIST_ITEM_SELECTOR = "." + LIST_ITEM_CLASS,
            LIST_GROUP_CLASS = "dx-list-group",
            LIST_GROUP_HEADER_CLASS = "dx-list-group-header",
            LIST_GROUP_BODY_CLASS = "dx-list-group-body",
            LIST_COLLAPSIBLE_GROUPS_CLASS = "dx-list-collapsible-groups",
            LIST_GROUP_COLLAPSED_CLASS = "dx-list-group-collapsed",
            LIST_HAS_NEXT_CLASS = "dx-has-next",
            LIST_NEXT_BUTTON_CLASS = "dx-list-next-button",
            LIST_ITEM_BADGE_CONTAINER_CLASS = "dx-list-item-badge-container",
            LIST_ITEM_BADGE_CLASS = "dx-list-item-badge",
            BADGE_CLASS = "dx-badge",
            LIST_ITEM_CHEVRON_CONTAINER_CLASS = "dx-list-item-chevron-container",
            LIST_ITEM_CHEVRON_CLASS = "dx-list-item-chevron",
            LIST_ITEM_DATA_KEY = "dxListItemData",
            LIST_FEEDBACK_SHOW_TIMEOUT = 70;
        DX.registerComponent("dxList", ui, ui.CollectionWidget.inherit({
            _activeStateUnit: LIST_ITEM_SELECTOR,
            _supportedKeys: function() {
                return $.extend(this.callBase(), {
                        leftArrow: $.noop,
                        rightArrow: $.noop
                    })
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    itemSwipeAction: {
                        since: "14.2",
                        alias: "onItemSwipe"
                    },
                    scrollAction: {
                        since: "14.2",
                        alias: "onScroll"
                    },
                    pullRefreshAction: {
                        since: "14.2",
                        alias: "onPullRefresh"
                    },
                    pageLoadingAction: {
                        since: "14.2",
                        alias: "onPageLoading"
                    },
                    groupRender: {
                        since: "14.2",
                        alias: "groupTemplate"
                    }
                })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    pullRefreshEnabled: false,
                    autoPagingEnabled: true,
                    scrollingEnabled: true,
                    showScrollbar: true,
                    useNativeScrolling: true,
                    pullingDownText: Globalize.localize("dxList-pullingDownText"),
                    pulledDownText: Globalize.localize("dxList-pulledDownText"),
                    refreshingText: Globalize.localize("dxList-refreshingText"),
                    pageLoadingText: Globalize.localize("dxList-pageLoadingText"),
                    onScroll: null,
                    onPullRefresh: null,
                    onPageLoading: null,
                    showNextButton: false,
                    nextButtonText: Globalize.localize("dxList-nextButtonText"),
                    onItemSwipe: null,
                    grouped: false,
                    collapsibleGroups: false,
                    groupTemplate: "group",
                    indicateLoading: true,
                    activeStateEnabled: true
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return !DX.support.nativeScrolling
                            },
                            options: {useNativeScrolling: false}
                        }, {
                            device: function(device) {
                                return !DX.support.nativeScrolling && !DX.devices.isSimulator() && DX.devices.real().platform === "generic" && device.platform === "generic"
                            },
                            options: {
                                showScrollbar: "onHover",
                                showNextButton: true,
                                autoPagingEnabled: false
                            }
                        }, {
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {
                                hoverStateEnabled: true,
                                focusStateEnabled: true
                            }
                        }])
            },
            _itemClass: function() {
                return LIST_ITEM_CLASS
            },
            _itemDataKey: function() {
                return LIST_ITEM_DATA_KEY
            },
            _itemContainer: function() {
                return this._$container
            },
            _allowDinamicItemsAppend: function() {
                return true
            },
            _init: function() {
                this.callBase();
                this._$container = this.element();
                this._initScrollView();
                this._feedbackShowTimeout = LIST_FEEDBACK_SHOW_TIMEOUT
            },
            _dataSourceOptions: function() {
                return $.extend(this.callBase(), {paginate: true})
            },
            _initScrollView: function() {
                var scrollingEnabled = this.option("scrollingEnabled"),
                    pullRefreshEnabled = scrollingEnabled && this.option("pullRefreshEnabled"),
                    autoPagingEnabled = scrollingEnabled && this.option("autoPagingEnabled") && !!this._dataSource;
                var $scrollView = this.element().dxScrollView({
                        rtlEnabled: this.option("rtlEnabled"),
                        disabled: this.option("disabled") || !scrollingEnabled,
                        onScroll: $.proxy(this._scrollHandler, this),
                        onPullDown: pullRefreshEnabled ? $.proxy(this._pullDownHandler, this) : null,
                        onReachBottom: autoPagingEnabled ? $.proxy(this._scrollBottomHandler, this) : null,
                        showScrollbar: this.option("showScrollbar"),
                        useNative: this.option("useNativeScrolling"),
                        pullingDownText: this.option("pullingDownText"),
                        pulledDownText: this.option("pulledDownText"),
                        refreshingText: this.option("refreshingText"),
                        reachBottomText: this.option("pageLoadingText"),
                        useKeyboard: false
                    });
                this._scrollView = $scrollView.dxScrollView("instance");
                this._scrollView.toggleLoading(autoPagingEnabled);
                this._$container = this._scrollView.content();
                this._createScrollViewActions();
                this._afterItemsRendered()
            },
            _createScrollViewActions: function() {
                this._scrollAction = this._createActionByOption("onScroll");
                this._pullRefreshAction = this._createActionByOption("onPullRefresh");
                this._pageLoadingAction = this._createActionByOption("onPageLoading")
            },
            _scrollHandler: function(e) {
                this._scrollAction(e)
            },
            _afterItemsRendered: function(tryLoadMore) {
                var isLastPage = this._isLastPage(),
                    allDataLoaded = !tryLoadMore || isLastPage,
                    autoPagingEnabled = this.option("autoPagingEnabled"),
                    stopLoading = !autoPagingEnabled || allDataLoaded,
                    scrollViewIsFull = this._scrollViewIsFull();
                if (stopLoading || scrollViewIsFull) {
                    this._scrollView.release(stopLoading);
                    this._loadIndicationSuppressed = false;
                    if (this._shouldRenderNextButton() && this._dataSource.isLoaded())
                        this._toggleNextButton(!allDataLoaded)
                }
                else
                    this._infiniteDataLoading()
            },
            _shouldRenderNextButton: function() {
                return this.option("showNextButton") && this._dataSource
            },
            _dataSourceLoadingChangedHandler: function(isLoading) {
                if (this._loadIndicationSuppressed)
                    return;
                if (isLoading && this.option("indicateLoading"))
                    this._showLoadingIndicatorTimer = setTimeout($.proxy(function() {
                        this._scrollView && this._scrollView.startLoading()
                    }, this));
                else {
                    clearTimeout(this._showLoadingIndicatorTimer);
                    this._scrollView && this._scrollView.finishLoading()
                }
            },
            _hideLoadingIfLoadIndicationOff: function() {
                if (!this.option("indicateLoading"))
                    this._dataSourceLoadingChangedHandler(false)
            },
            _suppressLoadingIndication: function() {
                this._loadIndicationSuppressed = true
            },
            _scrollViewIsFull: function() {
                return !this._scrollView || this._scrollView.isFull()
            },
            _pullDownHandler: function(e) {
                this._pullRefreshAction(e);
                if (this._dataSource && !this._dataSource.isLoading()) {
                    this._dataSource.pageIndex(0);
                    this._dataSource.load()
                }
                else
                    this._afterItemsRendered()
            },
            _infiniteDataLoading: function() {
                var dataSource = this._dataSource;
                if (!this._scrollViewIsFull() && dataSource && !dataSource.isLoading() && !this._isLastPage()) {
                    clearTimeout(this._loadNextPageTimer);
                    this._loadNextPageTimer = setTimeout($.proxy(this._loadNextPage, this))
                }
            },
            _scrollBottomHandler: function(e) {
                this._pageLoadingAction(e);
                var dataSource = this._dataSource;
                if (dataSource && !dataSource.isLoading())
                    this._loadNextPage();
                else
                    this._afterItemsRendered()
            },
            _loadNextPage: function() {
                var dataSource = this._dataSource;
                this._expectNextPageLoading();
                dataSource.pageIndex(1 + dataSource.pageIndex());
                return dataSource.load().done($.proxy(this._forgetNextPageLoading, this))
            },
            _renderItems: function(items) {
                if (this.option("grouped")) {
                    $.each(items, $.proxy(this._renderGroup, this));
                    this._attachGroupCollapseEvent();
                    this._renderEmptyMessage()
                }
                else
                    this.callBase.apply(this, arguments);
                this._afterItemsRendered(true)
            },
            _attachGroupCollapseEvent: function() {
                var eventName = events.addNamespace("dxclick", this.NAME),
                    selector = "." + LIST_GROUP_HEADER_CLASS,
                    $element = this.element(),
                    collapsibleGroups = this.option("collapsibleGroups");
                $element.toggleClass(LIST_COLLAPSIBLE_GROUPS_CLASS, collapsibleGroups);
                $element.off(eventName, selector);
                if (collapsibleGroups)
                    $element.on(eventName, selector, $.proxy(function(e) {
                        this._createAction($.proxy(function(e) {
                            this._collapseGroupHandler($(e.jQueryEvent.currentTarget).parent())
                        }, this), {validatingTargetName: "element"})({jQueryEvent: e})
                    }, this))
            },
            _collapseGroupHandler: function($group, toggle) {
                var deferred = $.Deferred(),
                    $groupBody = $group.children("." + LIST_GROUP_BODY_CLASS);
                $group.toggleClass(LIST_GROUP_COLLAPSED_CLASS, toggle);
                var slideMethod = "slideToggle";
                if (toggle === true)
                    slideMethod = "slideUp";
                if (toggle === false)
                    slideMethod = "slideDown";
                $groupBody[slideMethod]({
                    duration: 200,
                    complete: function() {
                        deferred.resolve()
                    }
                });
                return deferred.promise()
            },
            _dataSourceLoadErrorHandler: function() {
                this.callBase.apply(this, arguments);
                if (this._initialized)
                    this._afterItemsRendered()
            },
            _render: function() {
                this.element().addClass(LIST_CLASS);
                this.callBase()
            },
            _postprocessRenderItem: function(args) {
                this.callBase.apply(this, arguments);
                if (this.option("onItemSwipe"))
                    this._attachSwipeEvent($(args.itemElement))
            },
            _attachSwipeEvent: function($itemElement) {
                var endEventName = events.addNamespace("dxswipeend", this.NAME);
                $itemElement.on(endEventName, $.proxy(this._itemSwipeEndHandler, this))
            },
            _itemSwipeEndHandler: function(e) {
                this._itemJQueryEventHandler(e, "onItemSwipe", {direction: e.offset < 0 ? "left" : "right"})
            },
            _nextButtonHandler: function() {
                var source = this._dataSource;
                if (source && !source.isLoading()) {
                    this._scrollView.toggleLoading(true);
                    this._$nextButton.detach();
                    this._suppressLoadingIndication();
                    this._loadNextPage()
                }
            },
            _renderGroup: function(index, group) {
                var $groupElement = $("<div>").addClass(LIST_GROUP_CLASS).appendTo(this._itemContainer());
                var groupTemplateName = this.option("groupTemplate"),
                    groupTemplate = this._getTemplate(group.template || groupTemplateName, group, index, $groupElement),
                    renderArgs = {
                        index: index,
                        item: group,
                        container: $groupElement
                    };
                var $groupHeaderElement = this._createItemByTemplate(groupTemplate, renderArgs);
                $groupHeaderElement.addClass(LIST_GROUP_HEADER_CLASS);
                this._renderingGroupIndex = index;
                var $groupBody = $("<div>").addClass(LIST_GROUP_BODY_CLASS).appendTo($groupElement);
                $.each(group.items || [], $.proxy(function(index, item) {
                    this._renderItem(index, item, $groupBody)
                }, this))
            },
            _clean: function() {
                if (this._$nextButton) {
                    this._$nextButton.remove();
                    this._$nextButton = null
                }
                this.callBase.apply(this, arguments)
            },
            _dispose: function() {
                clearTimeout(this._holdTimer);
                clearTimeout(this._loadNextPageTimer);
                clearTimeout(this._showLoadingIndicatorTimer);
                this.callBase()
            },
            _toggleDisabledState: function(value) {
                this.callBase(value);
                this._scrollView.option("disabled", value || !this.option("scrollingEnabled"))
            },
            _toggleNextButton: function(value) {
                var dataSource = this._dataSource,
                    $nextButton = this._getNextButton();
                this.element().toggleClass(LIST_HAS_NEXT_CLASS, value);
                if (value && dataSource && dataSource.isLoaded())
                    $nextButton.appendTo(this._itemContainer());
                if (!value)
                    $nextButton.detach()
            },
            _getNextButton: function() {
                if (!this._$nextButton)
                    this._$nextButton = this._createNextButton();
                return this._$nextButton
            },
            _createNextButton: function() {
                var $result = $("<div>").addClass(LIST_NEXT_BUTTON_CLASS);
                $result.append($("<div>").dxButton({
                    text: this.option("nextButtonText"),
                    onClick: $.proxy(this._nextButtonHandler, this)
                }));
                return $result
            },
            _resetFocusedItem: function($target) {
                this.callBase.apply(this, arguments);
                this.scrollToItem($target)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"showNextButton":
                        this._toggleNextButton(args.value);
                        break;
                    case"dataSource":
                        this.callBase(args);
                        this._initScrollView();
                        break;
                    case"pullingDownText":
                    case"pulledDownText":
                    case"refreshingText":
                    case"pageLoadingText":
                    case"useNativeScrolling":
                    case"showScrollbar":
                    case"scrollingEnabled":
                    case"pullRefreshEnabled":
                    case"autoPagingEnabled":
                        this._initScrollView();
                        break;
                    case"nextButtonText":
                    case"onItemSwipe":
                        this._invalidate();
                        break;
                    case"onScroll":
                    case"onPullRefresh":
                    case"onPageLoading":
                        this._createScrollViewActions();
                        this._invalidate();
                        break;
                    case"grouped":
                    case"collapsibleGroups":
                    case"groupTemplate":
                        this._invalidate();
                        break;
                    case"items":
                        this._invalidate();
                        break;
                    case"width":
                    case"height":
                        this.callBase(args);
                        this._scrollView.update();
                        break;
                    case"indicateLoading":
                        this._hideLoadingIfLoadIndicationOff();
                        break;
                    case"visible":
                        this.callBase(args);
                        this._scrollView.update();
                        break;
                    case"rtlEnabled":
                        this._initScrollView();
                        this.callBase(args);
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _extendActionArgs: function($itemElement) {
                if (!this.option("grouped"))
                    return this.callBase($itemElement);
                var $group = $itemElement.closest("." + LIST_GROUP_CLASS);
                var $item = $group.find("." + LIST_ITEM_CLASS);
                return $.extend(this.callBase($itemElement), {itemIndex: {
                            group: $group.index(),
                            item: $item.index($itemElement)
                        }})
            },
            expandGroup: function(groupIndex) {
                var deferred = $.Deferred(),
                    $group = this._itemContainer().find("." + LIST_GROUP_CLASS).eq(groupIndex);
                this._collapseGroupHandler($group, false).done($.proxy(function() {
                    deferred.resolveWith(this)
                }, this));
                return deferred.promise()
            },
            collapseGroup: function(groupIndex) {
                var deferred = $.Deferred(),
                    $group = this._itemContainer().find("." + LIST_GROUP_CLASS).eq(groupIndex);
                this._collapseGroupHandler($group, true).done($.proxy(function() {
                    deferred.resolveWith(this)
                }, this));
                return deferred
            },
            update: function() {
                DX.log("W0002", this.NAME, "update", "14.1", "Use the 'updateDimensions' method instead.");
                return this.updateDimensions.apply(this, arguments)
            },
            updateDimensions: function() {
                var that = this,
                    deferred = $.Deferred();
                if (that._scrollView)
                    that._scrollView.update().done(function() {
                        deferred.resolveWith(that)
                    });
                else
                    deferred.resolveWith(that);
                return deferred.promise()
            },
            refresh: function() {
                DX.log("W0002", this.NAME, "refresh", "14.1", "Use the 'reload' method instead.");
                return this.reload.apply(this, arguments)
            },
            reload: function() {
                this.scrollTo(0);
                this._pullDownHandler()
            },
            scrollTop: function() {
                return this._scrollView.scrollOffset().top
            },
            clientHeight: function() {
                return this._scrollView.clientHeight()
            },
            scrollHeight: function() {
                return this._scrollView.scrollHeight()
            },
            scrollBy: function(distance) {
                this._scrollView.scrollBy(distance)
            },
            scrollTo: function(location) {
                this._scrollView.scrollTo(location)
            },
            scrollToItem: function(itemElement) {
                var $item = this._editStrategy.getItemElement(itemElement);
                this._scrollView.scrollToElement($item)
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            removeDublicates = utils.removeDublicates;
        var LIST_EDITING_CLASS = "dx-list-editing",
            LIST_ITEM_SELECTED_CLASS = "dx-list-item-selected",
            LIST_ITEM_RESPONSE_WAIT_CLASS = "dx-list-item-response-wait";
        DX.registerComponent("dxList", ui, ui.dxList.inherit({
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    itemDeleteAction: {
                        since: "14.2",
                        alias: "onItemDeleted"
                    },
                    itemReorderAction: {
                        since: "14.2",
                        alias: "onItemReordered"
                    },
                    itemUnselectAction: {
                        since: "14.2",
                        message: "Use the 'onSelectionChanged' option instead"
                    },
                    "editConfig.itemRender": {
                        since: "14.2",
                        alias: "editConfig.itemTemplate"
                    }
                })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    editEnabled: false,
                    editConfig: {
                        itemTemplate: null,
                        menuType: "context",
                        menuItems: [],
                        deleteEnabled: false,
                        deleteMode: "toggle",
                        deleteType: "toggle",
                        selectionEnabled: false,
                        selectionMode: "item",
                        selectionType: "item",
                        reorderEnabled: false
                    },
                    selectionMode: 'multi',
                    selectAllText: Globalize.localize("dxList-selectAll"),
                    selectionByClick: false
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: [{platform: "ios"}],
                            options: {editConfig: {
                                    deleteType: "slideButton",
                                    deleteMode: "slideButton"
                                }}
                        }, {
                            device: function(device) {
                                return device.platform === "ios" && device.version[0] > 6
                            },
                            options: {editConfig: {
                                    menuType: "slide",
                                    deleteType: "slideItem",
                                    deleteMode: "slideItem"
                                }}
                        }, {
                            device: {platform: "android"},
                            options: {editConfig: {
                                    deleteType: "swipe",
                                    deleteMode: "swipe"
                                }}
                        }, {
                            device: {platform: "win8"},
                            options: {editConfig: {
                                    deleteType: "context",
                                    deleteMode: "context"
                                }}
                        }, {
                            device: {platform: "generic"},
                            options: {editConfig: {
                                    deleteType: "static",
                                    deleteMode: "static"
                                }}
                        }])
            },
            _init: function() {
                this.callBase();
                this._initEditProvider()
            },
            _initEditProvider: function() {
                var defaultConfig = this.initialOption("editConfig");
                this._editProvider = new ui.dxList.EditProvider(this, this.option("editConfig"), defaultConfig)
            },
            _disposeEditProvider: function() {
                if (this._editProvider)
                    this._editProvider.dispose()
            },
            _refreshEditProvider: function() {
                this._disposeEditProvider();
                this._initEditProvider()
            },
            _initEditStrategy: function(grouped) {
                if (this.option("grouped"))
                    this._editStrategy = new ui.dxList.GroupedEditStrategy(this);
                else
                    this.callBase()
            },
            _render: function() {
                this._renderEditing();
                this._refreshEditProvider();
                this.callBase()
            },
            _renderItems: function() {
                this.callBase.apply(this, arguments);
                if (this.option("editEnabled"))
                    this._editProvider.afterItemsRendered()
            },
            _renderEditing: function() {
                this.element().toggleClass(LIST_EDITING_CLASS, this.option("editEnabled"))
            },
            _selectedItemClass: function() {
                return LIST_ITEM_SELECTED_CLASS
            },
            _itemResponseWaitClass: function() {
                return LIST_ITEM_RESPONSE_WAIT_CLASS
            },
            _itemClickHandler: function(e) {
                var $itemElement = $(e.currentTarget);
                if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *"))
                    return;
                var handledByEditProvider = this.option("editEnabled") && this._editProvider.handleClick($itemElement, e);
                if (handledByEditProvider)
                    return;
                this.callBase.apply(this, arguments)
            },
            _shouldAttachContextMenuEvent: function() {
                return this.callBase.apply(this, arguments) || this._editProvider.contextMenuHandlerExists()
            },
            _itemHoldHandler: function(e) {
                var $itemElement = $(e.currentTarget);
                if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *"))
                    return;
                var isTouchEvent = ui.events.isTouchEvent(e),
                    handledByEditProvider = this.option("editEnabled") && isTouchEvent && this._editProvider.handleContextMenu($itemElement, e);
                if (handledByEditProvider) {
                    e.handledByEditProvider = true;
                    return
                }
                this.callBase.apply(this, arguments)
            },
            _itemContextMenuHandler: function(e) {
                var $itemElement = $(e.currentTarget);
                if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *"))
                    return;
                var handledByEditProvider = this.option("editEnabled") && !e.handledByEditProvider && this._editProvider.handleContextMenu($itemElement, e);
                if (handledByEditProvider)
                    return;
                this.callBase.apply(this, arguments)
            },
            _getItemTemplateName: function(itemData) {
                if (this.option("editEnabled") && this._editProvider.isRenderingByTemplate(itemData))
                    return this._editProvider.getItemTemplateName(itemData);
                return this.callBase.apply(this, arguments)
            },
            _postprocessRenderItem: function(args) {
                this.callBase.apply(this, arguments);
                if (this.option("editEnabled") && this._editProvider.isModifyingByDecorators(args.itemData))
                    this._editProvider.modifyItemElement(args)
            },
            _clean: function() {
                this._disposeEditProvider();
                this.callBase()
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"items":
                        this._clearSelectedItems();
                        this.callBase(args);
                        break;
                    case"grouped":
                        this._clearSelectedItems();
                        delete this._renderingGroupIndex;
                        this._initEditStrategy(args.value);
                        this.callBase(args);
                        break;
                    case"editEnabled":
                        this._clearSelectedItems();
                        this._invalidate();
                        break;
                    case"editConfig":
                    case"selectionMode":
                    case"selectAllText":
                        this._invalidate();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            getFlatIndexByItemElement: function(itemElement) {
                return this._itemElements().index(itemElement)
            },
            getItemElementByFlatIndex: function(flatIndex) {
                var $itemElements = this._itemElements();
                if (flatIndex < 0 || flatIndex >= $itemElements.length)
                    return $();
                return $itemElements.eq(flatIndex)
            },
            getItemByIndex: function(index) {
                return this._getItemData(this._itemElements().eq(index))
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.strategy.grouped.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var LIST_ITEM_CLASS = "dx-list-item",
            LIST_GROUP_CLASS = "dx-list-group";
        var SELECTION_SHIFT = 20,
            SELECTION_MASK = 0x8FF;
        var combineIndex = function(indices) {
                return (indices.group << SELECTION_SHIFT) + indices.item
            };
        var splitIndex = function(combinedIndex) {
                return {
                        group: combinedIndex >> SELECTION_SHIFT,
                        item: combinedIndex & SELECTION_MASK
                    }
            };
        var createGroupSelection = function(group, selectedItems) {
                var groupItems = group.items,
                    groupSelection = {
                        key: group.key,
                        items: []
                    };
                $.each(selectedItems, function(_, itemIndex) {
                    groupSelection.items.push(groupItems[itemIndex])
                });
                return groupSelection
            };
        var groupByKey = function(groups, key) {
                var length = groups.length;
                for (var i = 0; i < length; i++)
                    if (groups[i].key === key)
                        return groups[i]
            };
        ui.dxList.GroupedEditStrategy = ui.CollectionWidget.EditStrategy.inherit({
            _groupElements: function() {
                return this._collectionWidget._itemContainer().find("." + LIST_GROUP_CLASS)
            },
            _groupItemElements: function($group) {
                return $group.find("." + LIST_ITEM_CLASS)
            },
            deleteItemAtIndex: function(index) {
                var indices = splitIndex(index),
                    itemGroup = this._collectionWidget.option("items")[indices.group].items;
                itemGroup.splice(indices.item, 1)
            },
            updateSelectionAfterDelete: function(fromIndex) {
                var deletedIndices = splitIndex(fromIndex),
                    selectedItemIndices = this._collectionWidget._selectedItemIndices;
                $.each(selectedItemIndices, function(i, index) {
                    var indices = splitIndex(index);
                    if (indices.group === deletedIndices.group && indices.item > deletedIndices.item)
                        selectedItemIndices[i] -= 1
                })
            },
            fetchSelectedItems: function(indices) {
                indices = indices || this._collectionWidget._selectedItemIndices;
                var items = this._collectionWidget.option("items"),
                    selectedItems = [];
                indices.sort(function(a, b) {
                    return a - b
                });
                var currentGroupIndex = 0,
                    groupSelectedIndices = [];
                $.each(indices, function(_, combinedIndex) {
                    var index = splitIndex(combinedIndex);
                    if (index.group !== currentGroupIndex && groupSelectedIndices.length) {
                        selectedItems.push(createGroupSelection(items[currentGroupIndex], groupSelectedIndices));
                        groupSelectedIndices.length = 0
                    }
                    currentGroupIndex = index.group;
                    groupSelectedIndices.push(index.item)
                });
                if (groupSelectedIndices.length)
                    selectedItems.push(createGroupSelection(items[currentGroupIndex], groupSelectedIndices));
                return selectedItems
            },
            selectedItemIndices: function() {
                var selectedIndices = [],
                    items = this._collectionWidget.option("items"),
                    selected = this._collectionWidget.option("selectedItems");
                $.each(selected, function(_, selectionInGroup) {
                    var group = groupByKey(items, selectionInGroup.key),
                        groupIndex = $.inArray(group, items);
                    if (!group) {
                        DX.log("W1003", selectionInGroup.key);
                        return
                    }
                    $.each(selectionInGroup.items, function(_, selectedGroupItem) {
                        var itemIndex = $.inArray(selectedGroupItem, group.items);
                        if (itemIndex !== -1)
                            selectedIndices.push(combineIndex({
                                group: groupIndex,
                                item: itemIndex
                            }));
                        else
                            DX.log("W1004", selectedGroupItem, selectionInGroup.key)
                    })
                });
                return selectedIndices
            },
            moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
                var items = this._collectionWidget.option("items"),
                    movingIndices = splitIndex(movingIndex),
                    destinationIndices = splitIndex(destinationIndex),
                    movingItemGroup = items[movingIndices.group].items,
                    destinationItemGroup = items[destinationIndices.group].items,
                    movedItemData = movingItemGroup[movingIndices.item];
                movingItemGroup.splice(movingIndices.item, 1);
                destinationItemGroup.splice(destinationIndices.item, 0, movedItemData)
            },
            getSelectedItemsAfterReorderItem: function(movingIndex, destinationIndex) {
                if (this._itemsFromSameParent(movingIndex, destinationIndex) || $.inArray(movingIndex, this._collectionWidget._selectedItemIndices))
                    return this.callBase();
                var items = this._collectionWidget.option("items"),
                    selectedItems = this._collectionWidget.option("selectedItems"),
                    movingIndices = splitIndex(movingIndex),
                    destinationIndices = splitIndex(destinationIndex),
                    movingSelectedItemGroup = selectedItems[movingIndices.group].items,
                    destinationSelectedItemGroup = selectedItems[destinationIndices.group].items,
                    movedItemData = items[movingIndices.group].items[movingIndices.item],
                    movedItemSelectedIndex = $.inArray(movedItemData, movingSelectedItemGroup);
                movingSelectedItemGroup.splice(movedItemSelectedIndex, 1);
                destinationSelectedItemGroup.push(movedItemData);
                return selectedItems
            },
            _isItemIndex: function(index) {
                return $.isNumeric(index.group) && $.isNumeric(index.item)
            },
            _getNormalizedItemIndex: function(itemElement) {
                var $item = $(itemElement),
                    $group = $item.closest("." + LIST_GROUP_CLASS);
                return combineIndex({
                        group: this._groupElements().index($group),
                        item: this._groupItemElements($group).index($item)
                    })
            },
            _normalizeItemIndex: function(index) {
                return combineIndex(index)
            },
            _denormalizeItemIndex: function(index) {
                return splitIndex(index)
            },
            _getItemByNormalizedIndex: function(index) {
                var indices = splitIndex(index),
                    $group = this._groupElements().eq(indices.group);
                return this._groupItemElements($group).eq(indices.item)
            },
            _itemsFromSameParent: function(firstIndex, secondIndex) {
                return splitIndex(firstIndex).group === splitIndex(secondIndex).group
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        ui.dxList.EditDecoratorsRegistry = {};
        ui.dxList.registerEditDecorator = function(option, type, decoratorClass) {
            var decoratorsRegistry = ui.dxList.EditDecoratorsRegistry;
            var decoratorConfig = {};
            decoratorConfig[option] = decoratorsRegistry[option] ? decoratorsRegistry[option] : {};
            decoratorConfig[option][type] = decoratorClass;
            decoratorsRegistry = $.extend(decoratorsRegistry, decoratorConfig)
        };
        var LIST_EDIT_DECORATOR = "dxListEditDecorator",
            SWIPE_START_EVENT_NAME = events.addNamespace("dxswipestart", LIST_EDIT_DECORATOR),
            SWIPE_UPDATE_EVENT_NAME = events.addNamespace("dxswipe", LIST_EDIT_DECORATOR),
            SWIPE_END_EVENT_NAME = events.addNamespace("dxswipeend", LIST_EDIT_DECORATOR);
        ui.dxList.EditDecorator = DX.Class.inherit({
            ctor: function(list) {
                this._list = list;
                this._init()
            },
            _init: $.noop,
            _shouldHandleSwipe: false,
            _attachSwipeEvent: function(config) {
                var swipeConfig = {itemSizeFunc: $.proxy(function() {
                            if (this._clearSwipeCache) {
                                this._itemWidthCache = this._list.element().width();
                                this._clearSwipeCache = false
                            }
                            return this._itemWidthCache
                        }, this)};
                config.$itemElement.on(SWIPE_START_EVENT_NAME, swipeConfig, $.proxy(this._itemSwipeStartHandler, this)).on(SWIPE_UPDATE_EVENT_NAME, $.proxy(this._itemSwipeUpdateHandler, this)).on(SWIPE_END_EVENT_NAME, $.proxy(this._itemSwipeEndHandler, this))
            },
            _itemSwipeStartHandler: function(e) {
                var $itemElement = $(e.currentTarget);
                if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
                    e.cancel = true;
                    return
                }
                this._swipeStartHandler($itemElement, e)
            },
            _itemSwipeUpdateHandler: function(e) {
                var $itemElement = $(e.currentTarget);
                this._swipeUpdateHandler($itemElement, e)
            },
            _itemSwipeEndHandler: function(e) {
                var $itemElement = $(e.currentTarget);
                this._swipeEndHandler($itemElement, e);
                this._clearSwipeCache = true
            },
            beforeBag: $.noop,
            afterBag: $.noop,
            _commonOptions: function() {
                return {
                        activeStateEnabled: this._list.option("activeStateEnabled"),
                        hoverStateEnabled: this._list.option("hoverStateEnabled"),
                        focusStateEnabled: this._list.option("focusStateEnabled")
                    }
            },
            modifyElement: function(config) {
                if (this._shouldHandleSwipe) {
                    this._attachSwipeEvent(config);
                    this._clearSwipeCache = true
                }
            },
            afterRender: $.noop,
            handleClick: $.noop,
            handleContextMenu: $.noop,
            _swipeStartHandler: $.noop,
            _swipeUpdateHandler: $.noop,
            _swipeEndHandler: $.noop,
            dispose: $.noop
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decoratorMenuHelper.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        ui.dxList.EditDecoratorMenuHelperMixin = {
            _menuEnabled: function() {
                return !!this._menuItems().length
            },
            _menuItems: function() {
                return this._list.option("editConfig.menuItems")
            },
            _deleteEnabled: function() {
                return this._list.option("editConfig.deleteEnabled")
            },
            _fireMenuAction: function($itemElement, action) {
                this._list._itemEventHandlerByHandler($itemElement, action, {}, {excludeValidators: ["disabled"]})
            }
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.static.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var STATIC_DELETE_BUTTON_CONTAINER_CLASS = "dx-list-static-delete-button-container",
            STATIC_DELETE_BUTTON_CLASS = "dx-list-static-delete-button";
        ui.dxList.registerEditDecorator("delete", "static", ui.dxList.EditDecorator.inherit({
            afterBag: function(config) {
                var $itemElement = config.$itemElement,
                    $container = config.$container;
                var $button = $("<div>").addClass(STATIC_DELETE_BUTTON_CLASS);
                $button.dxButton({
                    text: Globalize.localize("dxListEditDecorator-delete"),
                    type: "danger",
                    onClick: $.proxy(function(e) {
                        this._deleteItem($itemElement)
                    }, this)
                });
                $container.addClass(STATIC_DELETE_BUTTON_CONTAINER_CLASS).append($button)
            },
            modifyElement: function(config) {
                var $itemElement = config.$itemElement,
                    $button = $itemElement.find("." + STATIC_DELETE_BUTTON_CLASS);
                if (!this._buttonWidth) {
                    $button.css("position", "absolute");
                    this._buttonWidth = $button.outerWidth();
                    $button.css("position", "static")
                }
                $button.parent().outerWidth(this._buttonWidth)
            },
            _deleteItem: function($itemElement) {
                if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *"))
                    return;
                this._list.deleteItem($itemElement)
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.switchable.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var LIST_EDIT_DECORATOR = "dxListEditDecorator",
            POINTER_DOWN_EVENT_NAME = events.addNamespace("dxpointerdown", LIST_EDIT_DECORATOR),
            LIST_ITEM_CONTENT_CLASS = "dx-list-item-content",
            MENU_POSITIONING_CLASS = "dx-list-menu-positioning",
            SWITCHABLE_DELETE_READY_CLASS = "dx-list-switchable-delete-ready",
            SWITCHABLE_DELETE_TOP_SHIELD_CLASS = "dx-list-switchable-delete-top-shield",
            SWITCHABLE_DELETE_BOTTOM_SHIELD_CLASS = "dx-list-switchable-delete-bottom-shield",
            SWITCHABLE_DELETE_ITEM_CONTENT_SHIELD_CLASS = "dx-list-switchable-delete-item-content-shield";
        ui.dxList.SwitchableEditDecorator = ui.dxList.EditDecorator.inherit({
            _init: function() {
                this._$topShield = $("<div />").addClass(SWITCHABLE_DELETE_TOP_SHIELD_CLASS);
                this._$bottomShield = $("<div />").addClass(SWITCHABLE_DELETE_BOTTOM_SHIELD_CLASS);
                this._$itemContentShield = $("<div />").addClass(SWITCHABLE_DELETE_ITEM_CONTENT_SHIELD_CLASS);
                this._$topShield.on(POINTER_DOWN_EVENT_NAME, $.proxy(this._cancelDeleteReadyItem, this));
                this._$bottomShield.on(POINTER_DOWN_EVENT_NAME, $.proxy(this._cancelDeleteReadyItem, this));
                this._list.element().append(this._$topShield.toggle(false)).append(this._$bottomShield.toggle(false))
            },
            handleClick: function($itemElement) {
                return this._cancelDeleteReadyItem()
            },
            _cancelDeleteReadyItem: function() {
                if (!this._$readyToDeleteItem)
                    return false;
                this._cancelDelete(this._$readyToDeleteItem);
                return true
            },
            _cancelDelete: function($itemElement) {
                this._toggleDeleteReady($itemElement, false)
            },
            _toggleDeleteReady: function($itemElement, readyToDelete) {
                if (readyToDelete === undefined)
                    readyToDelete = !this._isReadyToDelete($itemElement);
                this._toggleShields($itemElement, readyToDelete);
                this._toggleScrolling(readyToDelete);
                this._cacheReadyToDeleteItem($itemElement, readyToDelete);
                this._animateToggleDelete($itemElement, readyToDelete)
            },
            _isReadyToDelete: function($itemElement) {
                return $itemElement.hasClass(SWITCHABLE_DELETE_READY_CLASS)
            },
            _toggleShields: function($itemElement, enabled) {
                this._$topShield.toggle(enabled);
                this._$bottomShield.toggle(enabled);
                if (enabled)
                    this._updateShieldsHeight($itemElement);
                this._toggleContentShield($itemElement, enabled)
            },
            _updateShieldsHeight: function($itemElement) {
                var $list = this._list.element(),
                    listTopOffset = $list.offset().top,
                    listHeight = $list.outerHeight(),
                    itemTopOffset = $itemElement.offset().top,
                    itemHeight = $itemElement.outerHeight(),
                    dirtyTopShieldHeight = itemTopOffset - listTopOffset,
                    dirtyBottomShieldHeight = listHeight - itemHeight - dirtyTopShieldHeight;
                this._$topShield.height(Math.max(dirtyTopShieldHeight, 0));
                this._$bottomShield.height(Math.max(dirtyBottomShieldHeight, 0))
            },
            _toggleContentShield: function($itemElement, enabled) {
                if (enabled)
                    $itemElement.find("." + LIST_ITEM_CONTENT_CLASS).append(this._$itemContentShield);
                else
                    this._$itemContentShield.detach()
            },
            _toggleScrolling: function(readyToDelete) {
                var scrollView = this._list.element().dxScrollView("instance");
                if (readyToDelete) {
                    this._scrollViewDisabled = scrollView.option("disabled");
                    scrollView.option("disabled", true)
                }
                else
                    scrollView.option("disabled", this._scrollViewDisabled)
            },
            _cacheReadyToDeleteItem: function($itemElement, cache) {
                if (cache)
                    this._$readyToDeleteItem = $itemElement;
                else
                    delete this._$readyToDeleteItem
            },
            _animateToggleDelete: function($itemElement, readyToDelete) {
                if (readyToDelete) {
                    this._enablePositioning($itemElement);
                    this._prepareDeleteReady($itemElement);
                    this._animatePrepareDeleteReady($itemElement)
                }
                else {
                    this._forgetDeleteReady($itemElement);
                    this._animateForgetDeleteReady($itemElement).done($.proxy(this._disablePositioning, this, $itemElement))
                }
            },
            _enablePositioning: function($itemElement) {
                $itemElement.addClass(MENU_POSITIONING_CLASS)
            },
            _disablePositioning: function($itemElement) {
                $itemElement.removeClass(MENU_POSITIONING_CLASS)
            },
            _prepareDeleteReady: function($itemElement) {
                $itemElement.addClass(SWITCHABLE_DELETE_READY_CLASS)
            },
            _forgetDeleteReady: function($itemElement) {
                $itemElement.removeClass(SWITCHABLE_DELETE_READY_CLASS)
            },
            _animatePrepareDeleteReady: DX.abstract,
            _animateForgetDeleteReady: DX.abstract,
            _deleteItem: function($itemElement) {
                $itemElement = $itemElement || this._$readyToDeleteItem;
                if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *"))
                    return;
                this._list.deleteItem($itemElement).always($.proxy(this._cancelDelete, this, $itemElement))
            },
            _isRtlEnabled: function() {
                return this._list.option("rtlEnabled")
            },
            dispose: function() {
                if (this._$topShield)
                    this._$topShield.remove();
                if (this._$bottomShield)
                    this._$bottomShield.remove();
                this.callBase.apply(this, arguments)
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.switchable.button.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx;
        var SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS = "dx-list-switchable-delete-button-container",
            SWITCHABLE_DELETE_BUTTON_WRAPPER_CLASS = "dx-list-switchable-delete-button-wrapper",
            SWITCHABLE_DELETE_BUTTON_INNER_WRAPPER_CLASS = "dx-list-switchable-delete-button-inner-wrapper",
            SWITCHABLE_DELETE_BUTTON_CLASS = "dx-list-switchable-delete-button",
            SWITCHABLE_DELETE_MENU_CLASS = "dx-list-switchable-delete-menu",
            SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION = 200;
        ui.dxList.SwitchableButtonEditDecorator = ui.dxList.SwitchableEditDecorator.inherit({
            _init: function() {
                this.callBase.apply(this, arguments);
                var $buttonContainer = $("<div >").addClass(SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS),
                    $buttonWrapper = $("<div />").addClass(SWITCHABLE_DELETE_BUTTON_WRAPPER_CLASS),
                    $buttonInnerWrapper = $("<div />").addClass(SWITCHABLE_DELETE_BUTTON_INNER_WRAPPER_CLASS),
                    $button = $("<div />").addClass(SWITCHABLE_DELETE_BUTTON_CLASS);
                $button.dxButton({
                    text: Globalize.localize("dxListEditDecorator-delete"),
                    type: "danger",
                    onClick: $.proxy(function(e) {
                        this._deleteItem();
                        e.jQueryEvent.stopPropagation()
                    }, this)
                });
                $buttonContainer.append($buttonWrapper);
                $buttonWrapper.append($buttonInnerWrapper);
                $buttonInnerWrapper.append($button);
                this._$buttonContainer = $buttonContainer
            },
            _enablePositioning: function($itemElement) {
                this.callBase.apply(this, arguments);
                fx.stop(this._$buttonContainer, true);
                this._$buttonContainer.appendTo($itemElement)
            },
            _disablePositioning: function() {
                this.callBase.apply(this, arguments);
                this._$buttonContainer.detach()
            },
            _animatePrepareDeleteReady: function() {
                var rtl = this._isRtlEnabled(),
                    listWidth = this._list.element().width(),
                    buttonWidth = this._buttonWidth(),
                    fromValue = rtl ? listWidth : -buttonWidth,
                    toValue = rtl ? listWidth - buttonWidth : 0;
                return fx.animate(this._$buttonContainer, {
                        type: "custom",
                        duration: SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION,
                        from: {right: fromValue},
                        to: {right: toValue}
                    })
            },
            _animateForgetDeleteReady: function() {
                var rtl = this._isRtlEnabled(),
                    listWidth = this._list.element().width(),
                    buttonWidth = this._buttonWidth(),
                    fromValue = rtl ? listWidth - buttonWidth : 0,
                    toValue = rtl ? listWidth : -buttonWidth;
                return fx.animate(this._$buttonContainer, {
                        type: "custom",
                        duration: SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION,
                        from: {right: fromValue},
                        to: {right: toValue}
                    })
            },
            _buttonWidth: function() {
                if (!this._buttonContainerWidth)
                    this._buttonContainerWidth = this._$buttonContainer.outerWidth();
                return this._buttonContainerWidth
            },
            dispose: function() {
                if (this._$buttonContainer)
                    this._$buttonContainer.remove();
                this.callBase.apply(this, arguments)
            }
        });
        var TOGGLE_DELETE_SWITCH_CONTAINER_CLASS = "dx-list-toggle-delete-switch-container",
            TOGGLE_DELETE_SWITCH_CLASS = "dx-list-toggle-delete-switch";
        ui.dxList.registerEditDecorator("delete", "toggle", ui.dxList.SwitchableButtonEditDecorator.inherit({beforeBag: function(config) {
                var $itemElement = config.$itemElement,
                    $container = config.$container;
                var $toggle = $("<div />").dxButton({
                        icon: "toggle-delete",
                        onClick: $.proxy(function(e) {
                            this._toggleDeleteReady($itemElement);
                            e.jQueryEvent.stopPropagation()
                        }, this)
                    }).addClass(TOGGLE_DELETE_SWITCH_CLASS);
                $container.addClass(TOGGLE_DELETE_SWITCH_CONTAINER_CLASS);
                $container.append($toggle)
            }}));
        ui.dxList.registerEditDecorator("delete", "slideButton", ui.dxList.SwitchableButtonEditDecorator.inherit({
            _shouldHandleSwipe: true,
            _swipeEndHandler: function($itemElement, args) {
                if (args.targetOffset !== 0)
                    this._toggleDeleteReady($itemElement);
                return true
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.switchable.slide.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            translator = DX.translator,
            fx = DX.fx;
        var LIST_EDIT_DECORATOR = "dxListEditDecorator",
            CLICK_EVENT_NAME = events.addNamespace("dxclick", LIST_EDIT_DECORATOR),
            SLIDE_MENU_CLASS = "dx-list-slide-menu",
            SLIDE_MENU_WRAPPER_CLASS = "dx-list-slide-menu-wrapper",
            SLIDE_MENU_CONTENT_CLASS = "dx-list-slide-menu-content",
            SLIDE_MENU_BUTTONS_CONTAINER_CLASS = "dx-list-slide-menu-buttons-container",
            SLIDE_MENU_BUTTONS_CLASS = "dx-list-slide-menu-buttons",
            SLIDE_MENU_BUTTON_CLASS = "dx-list-slide-menu-button",
            SLIDE_MENU_BUTTON_MENU_CLASS = "dx-list-slide-menu-button-menu",
            SLIDE_MENU_BUTTON_DELETE_CLASS = "dx-list-slide-menu-button-delete";
        ui.dxList.registerEditDecorator("menu", "slide", ui.dxList.SwitchableEditDecorator.inherit({
            _shouldHandleSwipe: true,
            _init: function() {
                this.callBase.apply(this, arguments);
                this._$buttonsContainer = $("<div/>").addClass(SLIDE_MENU_BUTTONS_CONTAINER_CLASS);
                this._$buttons = $("<div/>").addClass(SLIDE_MENU_BUTTONS_CLASS).appendTo(this._$buttonsContainer);
                this._renderMenu();
                this._renderDeleteButton()
            },
            _renderMenu: function() {
                if (!this._menuEnabled())
                    return;
                var menuItems = this._menuItems();
                if (menuItems.length === 1) {
                    var menuItem = menuItems[0];
                    this._renderMenuButton(menuItem.text, $.proxy(function() {
                        this._fireAction(menuItem)
                    }, this))
                }
                else {
                    var $menu = $("<div />").addClass(SLIDE_MENU_CLASS);
                    $menu.dxActionSheet({
                        showTitle: false,
                        items: menuItems,
                        onItemClick: $.proxy(function(args) {
                            this._fireAction(args.itemData)
                        }, this)
                    });
                    $menu.appendTo(this._list.element());
                    this._menu = $menu.dxActionSheet("instance");
                    var $menuButton = this._renderMenuButton(Globalize.localize("dxListEditDecorator-more"), $.proxy(this._menu.show, this._menu));
                    this._menu.option("target", $menuButton)
                }
            },
            _renderMenuButton: function(text, action) {
                var $menuButton = $("<div/>").addClass(SLIDE_MENU_BUTTON_CLASS).addClass(SLIDE_MENU_BUTTON_MENU_CLASS).text(text);
                this._$buttons.append($menuButton);
                $menuButton.on(CLICK_EVENT_NAME, action);
                return $menuButton
            },
            _renderDeleteButton: function() {
                if (!this._deleteEnabled())
                    return;
                var $deleteButton = $("<div/>").addClass(SLIDE_MENU_BUTTON_CLASS).addClass(SLIDE_MENU_BUTTON_DELETE_CLASS).text(Globalize.localize("dxListEditDecorator-delete"));
                $deleteButton.on(CLICK_EVENT_NAME, $.proxy(function() {
                    this._deleteItem()
                }, this));
                this._$buttons.append($deleteButton)
            },
            _fireAction: function(menuItem) {
                this._fireMenuAction($(this._cachedNode), menuItem.action);
                this._cancelDeleteReadyItem()
            },
            modifyElement: function(config) {
                this.callBase.apply(this, arguments);
                var $itemElement = config.$itemElement;
                $itemElement.addClass(SLIDE_MENU_WRAPPER_CLASS);
                var $slideMenuContent = $("<div/>").addClass(SLIDE_MENU_CONTENT_CLASS);
                $itemElement.wrapInner($slideMenuContent)
            },
            handleClick: function(_, e) {
                if ($(e.target).closest("." + SLIDE_MENU_CONTENT_CLASS).length)
                    return this.callBase.apply(this, arguments);
                return true
            },
            _swipeStartHandler: function($itemElement) {
                this._enablePositioning($itemElement);
                this._cacheItemData($itemElement)
            },
            _swipeUpdateHandler: function($itemElement, args) {
                var rtl = this._isRtlEnabled(),
                    signCorrection = rtl ? -1 : 1,
                    offset = this._cachedItemWidth * args.offset,
                    startOffset = this._isReadyToDelete($itemElement) ? -this._cachedButtonWidth * signCorrection : 0,
                    correctedOffset = (offset + startOffset) * signCorrection,
                    contentPosition = correctedOffset < 0 ? offset + startOffset : 0,
                    buttonPosition = correctedOffset < 0 ? correctedOffset : 0;
                translator.move(this._$cachedContent, {left: contentPosition});
                this._$buttonsContainer.css(rtl ? "right" : "left", Math.max(this._cachedItemWidth + buttonPosition, this._minButtonContainerLeftOffset()));
                return true
            },
            _cacheItemData: function($itemElement) {
                if ($itemElement[0] === this._cachedNode)
                    return;
                this._$cachedContent = $itemElement.find("." + SLIDE_MENU_CONTENT_CLASS);
                this._cachedItemWidth = $itemElement.outerWidth();
                this._cachedButtonWidth = this._cachedButtonWidth || $itemElement.find("." + SLIDE_MENU_BUTTONS_CLASS).outerWidth();
                if (this._$cachedContent.length)
                    this._cachedNode = $itemElement[0]
            },
            _minButtonContainerLeftOffset: function() {
                return this._cachedItemWidth - this._cachedButtonWidth
            },
            _swipeEndHandler: function($itemElement, args) {
                this._cacheItemData($itemElement);
                var signCorrection = this._isRtlEnabled() ? 1 : -1,
                    offset = this._cachedItemWidth * args.offset,
                    endedAtReadyToDelete = !this._isReadyToDelete($itemElement) && offset * signCorrection > this._cachedButtonWidth * .2,
                    readyToDelete = args.targetOffset === signCorrection || endedAtReadyToDelete;
                this._toggleDeleteReady($itemElement, readyToDelete);
                return true
            },
            _enablePositioning: function($itemElement) {
                this.callBase.apply(this, arguments);
                this._$buttonsContainer.appendTo($itemElement)
            },
            _disablePositioning: function($itemElement) {
                this.callBase.apply(this, arguments);
                this._$buttonsContainer.detach()
            },
            _animatePrepareDeleteReady: function() {
                var rtl = this._isRtlEnabled(),
                    directionCorrection = rtl ? 1 : -1;
                this._$buttonsContainer.css(rtl ? "left" : "right", "0");
                var contentAnimation = fx.animate(this._$cachedContent, {
                        to: {left: this._cachedButtonWidth * directionCorrection},
                        type: "slide",
                        duration: 200
                    });
                var direction = rtl ? "right" : "left",
                    buttonToAnimation = {};
                buttonToAnimation[direction] = this._minButtonContainerLeftOffset();
                var buttonAnimation = fx.animate(this._$buttonsContainer, {
                        to: buttonToAnimation,
                        duration: 200
                    });
                return $.when(contentAnimation, buttonAnimation).promise()
            },
            _animateForgetDeleteReady: function($itemElement) {
                this._cacheItemData($itemElement);
                var rtl = this._isRtlEnabled();
                this._$buttonsContainer.css(rtl ? "left" : "right", "0");
                var contentAnimation = fx.animate(this._$cachedContent, {
                        to: {left: 0},
                        type: "slide",
                        duration: 200
                    });
                var direction = rtl ? "right" : "left",
                    buttonToAnimation = {};
                buttonToAnimation[direction] = this._cachedItemWidth;
                var buttonAnimation = fx.animate(this._$buttonsContainer, {
                        to: buttonToAnimation,
                        duration: 200,
                        complete: $.proxy(function() {
                            this._$buttonsContainer.css(direction, "100%")
                        }, this)
                    });
                return $.when(contentAnimation, buttonAnimation).promise()
            },
            dispose: function() {
                if (this._menu)
                    this._menu.element().remove();
                if (this._$buttonsContainer)
                    this._$buttonsContainer.remove();
                this.callBase.apply(this, arguments)
            }
        }).include(ui.dxList.EditDecoratorMenuHelperMixin))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.swipe.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            translator = DX.translator,
            fx = DX.fx;
        ui.dxList.registerEditDecorator("delete", "swipe", ui.dxList.EditDecorator.inherit({
            _shouldHandleSwipe: true,
            _renderItemPosition: function($itemElement, offset, animate) {
                var deferred = $.Deferred(),
                    itemOffset = offset * this._itemElementWidth;
                if (animate)
                    fx.animate($itemElement, {
                        to: {left: itemOffset},
                        type: "slide",
                        complete: function() {
                            deferred.resolve($itemElement, offset)
                        }
                    });
                else {
                    translator.move($itemElement, {left: itemOffset});
                    deferred.resolve()
                }
                return deferred.promise()
            },
            _swipeStartHandler: function($itemElement) {
                this._itemElementWidth = $itemElement.width();
                return true
            },
            _swipeUpdateHandler: function($itemElement, args) {
                this._renderItemPosition($itemElement, args.offset);
                return true
            },
            _swipeEndHandler: function($itemElement, args) {
                var offset = args.targetOffset;
                this._renderItemPosition($itemElement, offset, true).done($.proxy(function($itemElement, offset) {
                    if (Math.abs(offset))
                        this._list.deleteItem($itemElement).fail($.proxy(function() {
                            this._renderItemPosition($itemElement, 0, true)
                        }, this))
                }, this));
                return true
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.context.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var CONTEXTMENU_CLASS = "dx-list-context-menu",
            CONTEXTMENU_MENUCONTENT_CLASS = "dx-list-context-menucontent";
        ui.dxList.registerEditDecorator("menu", "context", ui.dxList.EditDecorator.inherit({
            _init: function() {
                var $menu = $("<div/>").addClass(CONTEXTMENU_CLASS);
                this._list.element().append($menu);
                this._menu = this._renderOverlay($menu)
            },
            _renderOverlay: function($element) {
                return $element.dxOverlay({
                        shading: false,
                        deferRendering: true,
                        closeOnTargetScroll: true,
                        closeOnOutsideClick: function(e) {
                            return !$(e.target).closest("." + CONTEXTMENU_CLASS).length
                        },
                        animation: {
                            show: {
                                type: "slide",
                                duration: 300,
                                from: {
                                    height: 0,
                                    opacity: 1
                                },
                                to: {
                                    height: $.proxy(function() {
                                        return this._$menuList.outerHeight()
                                    }, this),
                                    opacity: 1
                                }
                            },
                            hide: {
                                type: "slide",
                                duration: 0,
                                from: {opacity: 1},
                                to: {opacity: 0}
                            }
                        },
                        height: $.proxy(function() {
                            return this._$menuList ? this._$menuList.outerHeight() : 0
                        }, this),
                        width: $.proxy(function() {
                            return this._list.element().outerWidth()
                        }, this),
                        onContentReady: $.proxy(this._renderMenuContent, this)
                    }).dxOverlay("instance")
            },
            _renderMenuContent: function(e) {
                var $overlayContent = e.component.content();
                var items = this._menuItems().slice();
                if (this._deleteEnabled())
                    items.push({
                        text: Globalize.localize("dxListEditDecorator-delete"),
                        action: $.proxy(this._deleteItem, this)
                    });
                this._$menuList = $("<div>").dxList({
                    items: items,
                    onItemClick: $.proxy(this._menuItemClickHandler, this),
                    height: "auto"
                });
                $overlayContent.addClass(CONTEXTMENU_MENUCONTENT_CLASS);
                $overlayContent.append(this._$menuList)
            },
            _menuItemClickHandler: function(args) {
                this._menu.hide();
                this._fireMenuAction(this._$itemWithMenu, args.itemData.action)
            },
            _deleteItem: function() {
                this._list.deleteItem(this._$itemWithMenu)
            },
            handleContextMenu: function($itemElement) {
                this._$itemWithMenu = $itemElement;
                this._menu.option({position: {
                        my: "top",
                        at: "bottom",
                        of: $itemElement,
                        collision: "flip"
                    }});
                this._menu.show();
                return true
            },
            dispose: function() {
                if (this._menu)
                    this._menu.element().remove();
                this.callBase.apply(this, arguments)
            }
        }).include(ui.dxList.EditDecoratorMenuHelperMixin))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.selection.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var SELECT_DECORATOR_ENABLED_CLASS = "dx-list-select-decorator-enabled",
            SELECT_DECORATOR_SELECT_ALL_CLASS = "dx-list-select-all",
            SELECT_DECORATOR_SELECT_ALL_CHECKBOX_CLASS = "dx-list-select-all-checkbox",
            SELECT_DECORATOR_SELECT_ALL_LABEL_CLASS = "dx-list-select-all-label",
            SELECT_CHECKBOX_CONTAINER_CLASS = "dx-list-select-checkbox-container",
            SELECT_CHECKBOX_CLASS = "dx-list-select-checkbox",
            SELECT_RADIO_BUTTON_CONTAINER_CLASS = "dx-list-select-radio-button-container",
            SELECT_RADIO_BUTTON_CLASS = "dx-list-select-radio-button";
        var CLICK_EVENT_NAME = events.addNamespace("dxclick", "dxListEditDecorator");
        ui.dxList.registerEditDecorator("selection", "control", ui.dxList.EditDecorator.inherit({
            _init: function() {
                this.callBase.apply(this, arguments);
                var selectionMode = this._list.option("selectionMode");
                this._singleStrategy = selectionMode === "single";
                this._containerClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CONTAINER_CLASS : SELECT_CHECKBOX_CONTAINER_CLASS;
                this._controlClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CLASS : SELECT_CHECKBOX_CLASS;
                this._controlWidget = this._singleStrategy ? "dxRadioButton" : "dxCheckBox";
                this._list.element().addClass(SELECT_DECORATOR_ENABLED_CLASS)
            },
            beforeBag: function(config) {
                var $itemElement = config.$itemElement,
                    $container = config.$container;
                var $control = $("<div />").addClass(this._controlClass);
                $control[this._controlWidget]($.extend({
                    value: this._isSelected($itemElement),
                    onValueChanged: $.proxy(function(e) {
                        this._processCheckedState($itemElement, e.value);
                        e.jQueryEvent && e.jQueryEvent.stopPropagation()
                    }, this)
                }, this._commonOptions()));
                $container.addClass(this._containerClass);
                $container.append($control)
            },
            modifyElement: function(config) {
                this.callBase.apply(this, arguments);
                var $itemElement = config.$itemElement,
                    control = $itemElement.find("." + this._controlClass)[this._controlWidget]("instance");
                $itemElement.on("stateChanged", $.proxy(function() {
                    control.option("value", this._isSelected($itemElement));
                    this._updateSelectAllState()
                }, this))
            },
            _updateSelectAllState: function() {
                if (!this._$selectAll)
                    return;
                var items = this._list.option("items");
                var selectedItems = this._list.option("selectedItems");
                var isSelectedAll = items.length === selectedItems.length ? true : selectedItems.length === 0 ? false : undefined;
                this._selectAllCheckBox.option("value", isSelectedAll)
            },
            afterRender: function() {
                if (this._list.option("selectionMode") !== "all" || this._$selectAll)
                    return;
                var $selectAll = this._$selectAll = $("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_CLASS);
                this._selectAllCheckBox = $("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_CHECKBOX_CLASS).appendTo($selectAll).dxCheckBox().dxCheckBox("instance");
                var $label = $("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_LABEL_CLASS).text(this._list.option("selectAllText")).appendTo($selectAll);
                this._list.itemsContainer().prepend($selectAll);
                this._updateSelectAllState();
                this._attachSelectAllHandler()
            },
            _attachSelectAllHandler: function() {
                this._selectAllCheckBox.option("onValueChanged", $.proxy(this._selectAllHandler, this))
            },
            _selectAllHandler: function(e) {
                var isSelectedAll = this._selectAllCheckBox.option("value");
                if (isSelectedAll === true)
                    this._list._selectAllItems();
                else if (isSelectedAll === false)
                    this._list._unselectAllItems();
                e.jQueryEvent && e.jQueryEvent.stopPropagation()
            },
            _isSelected: function($itemElement) {
                return this._list.isItemSelected($itemElement)
            },
            _processCheckedState: function($itemElement, checked) {
                if (checked)
                    this._list.selectItem($itemElement);
                else
                    this._list.unselectItem($itemElement)
            },
            dispose: function() {
                this._disposeSelectAll();
                this._list.element().removeClass(SELECT_DECORATOR_ENABLED_CLASS);
                this.callBase.apply(this, arguments)
            },
            _disposeSelectAll: function() {
                if (this._$selectAll) {
                    this._$selectAll.remove();
                    this._$selectAll = null
                }
            }
        }));
        ui.dxList.registerEditDecorator("selection", "item", ui.dxList.EditDecoratorsRegistry.selection.control.inherit({
            handleClick: function($itemElement) {
                var newState = !this._isSelected($itemElement) || this._singleStrategy;
                this._processCheckedState($itemElement, newState);
                return true
            },
            _attachSelectAllHandler: function() {
                this.callBase();
                this._$selectAll.off(CLICK_EVENT_NAME).on(CLICK_EVENT_NAME, $.proxy(this._selectAllClickHandler, this))
            },
            _selectAllClickHandler: function() {
                this._selectAllCheckBox.option("value", !this._selectAllCheckBox.option("value"))
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.reorder.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            translator = DX.translator,
            fx = DX.fx,
            support = DX.support,
            utils = DX.utils,
            fitIntoRange = utils.fitIntoRange;
        var ReorderScrollAnimator = DX.Animator.inherit({
                ctor: function(strategy) {
                    this.callBase();
                    this._strategy = strategy
                },
                _isFinished: function() {
                    return this._strategy.scrollFinished()
                },
                _step: function() {
                    this._strategy.scrollByStep()
                }
            });
        var LIST_EDIT_DECORATOR = "dxListEditDecorator",
            DRAG_START_EVENT_NAME = events.addNamespace("dxdragstart", LIST_EDIT_DECORATOR),
            DRAG_UPDATE_EVENT_NAME = events.addNamespace("dxdrag", LIST_EDIT_DECORATOR),
            DRAG_END_EVENT_NAME = events.addNamespace("dxdragend", LIST_EDIT_DECORATOR),
            REORDER_HANDLE_CONTAINER_CLASS = "dx-list-reorder-handle-container",
            REORDER_HANDLE_CLASS = "dx-list-reorder-handle",
            REOREDERING_ITEM_CLASS = "dx-list-item-reordering",
            REOREDERING_ITEM_GHOST_CLASS = "dx-list-item-ghost-reordering",
            LIST_REORDER_COMPATIBILITY_MODE_CLASS = "dx-list-reorder-compatibility-mode";
        ui.dxList.registerEditDecorator("reorder", "default", ui.dxList.EditDecorator.inherit({
            _init: function() {
                this._groupedEnabled = this._list.option("grouped");
                this._initAnimator()
            },
            _initAnimator: function() {
                this._scrollAnimator = new ReorderScrollAnimator(this)
            },
            _startAnimator: function() {
                if (!this._scrollAnimator.inProgress())
                    this._scrollAnimator.start()
            },
            _stopAnimator: function() {
                this._scrollAnimator.stop()
            },
            afterBag: function(config) {
                var $itemElement = config.$itemElement,
                    $container = config.$container;
                var $handle = $("<div>").addClass(REORDER_HANDLE_CLASS);
                $handle.on(DRAG_START_EVENT_NAME, {
                    direction: "vertical",
                    immediate: true
                }, $.proxy(this._dragStartHandler, this, $itemElement));
                $handle.on(DRAG_UPDATE_EVENT_NAME, $.proxy(this._dragHandler, this, $itemElement));
                $handle.on(DRAG_END_EVENT_NAME, $.proxy(this._dragEndHandler, this, $itemElement));
                $container.addClass(REORDER_HANDLE_CONTAINER_CLASS);
                $container.append($handle)
            },
            _dragStartHandler: function($itemElement, e) {
                if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
                    e.cancel = true;
                    return
                }
                this._stopPreviousAnimation();
                e.targetElements = [];
                this._cacheItemsPositions();
                this._startPointerOffset = e.pageY - $itemElement.offset().top;
                this._elementHeight = $itemElement.outerHeight();
                var itemIndex = this._list.getFlatIndexByItemElement($itemElement);
                this._startIndex = itemIndex;
                this._lastIndex = itemIndex;
                this._cacheScrollData();
                this._createGhost($itemElement);
                $itemElement.addClass(REOREDERING_ITEM_CLASS);
                this._toggleCompatibilityMode(true)
            },
            _stopPreviousAnimation: function() {
                fx.stop(this._$ghostItem, true)
            },
            _toggleCompatibilityMode: function(enabled) {
                this._list.element().toggleClass(LIST_REORDER_COMPATIBILITY_MODE_CLASS, !support.transform && enabled)
            },
            _cacheItemsPositions: function() {
                this._itemPositions = [];
                $.each(this._list.itemElements(), $.proxy(function(index, item) {
                    this._itemPositions.push($(item).position().top)
                }, this))
            },
            _getDraggingElementPosition: function() {
                return this._itemPositions[this._startIndex]
            },
            _getLastElementPosition: function() {
                return this._itemPositions[this._lastIndex]
            },
            _cacheScrollData: function() {
                this._list.updateDimensions();
                this._startScrollTop = this._list.scrollTop();
                this._scrollOffset = 0;
                this._scrollHeight = this._list.scrollHeight();
                this._clientHeight = this._list.clientHeight()
            },
            _scrollTop: function() {
                return this._startScrollTop + this._scrollOffset
            },
            _createGhost: function($itemElement) {
                this._$ghostItem = $itemElement.clone();
                this._$ghostItem.addClass(REOREDERING_ITEM_GHOST_CLASS).appendTo(this._list.itemsContainer());
                this._startGhostPosition = this._getDraggingElementPosition() - this._$ghostItem.position().top;
                translator.move(this._$ghostItem, {top: this._startGhostPosition})
            },
            _dragHandler: function($itemElement, e) {
                this._topOffset = e.offset.y;
                this._updateItemPositions();
                var pointerPosition = this._getPonterPosition();
                this._toggleScroll(pointerPosition)
            },
            _getPonterPosition: function() {
                return this._getDraggingElementPosition() + this._startPointerOffset + this._scrollOffset + this._topOffset
            },
            _toggleScroll: function(pointerPosition) {
                if (this._scrollHeight <= this._clientHeight)
                    return;
                var minOffset = this._elementHeight * .7,
                    topOffset = this._clientHeight - (pointerPosition - this._scrollTop()),
                    topOffsetRatio = topOffset / minOffset,
                    bottomOffset = pointerPosition - this._scrollTop(),
                    bottomOffsetRatio = bottomOffset / minOffset;
                if (topOffsetRatio < 1) {
                    this._stepSize = this._adjustRationIntoRange(topOffsetRatio);
                    this._startAnimator()
                }
                else if (bottomOffsetRatio < 1) {
                    this._stepSize = -this._adjustRationIntoRange(bottomOffsetRatio);
                    this._startAnimator()
                }
                else
                    this._stopAnimator()
            },
            _adjustRationIntoRange: function(ratio) {
                return fitIntoRange(Math.round(Math.abs(ratio - 1) * 7), 1, 7)
            },
            _updateItemPositions: function() {
                this._updateGhostPosition();
                this._updateOthersPositions()
            },
            _updateGhostPosition: function() {
                translator.move(this._$ghostItem, {top: this._startGhostPosition + this._scrollOffset + this._topOffset})
            },
            _updateOthersPositions: function() {
                var currentIndex = this._findItemIndexByPosition(this._getPonterPosition());
                if (this._lastIndex === currentIndex || this._groupedEnabled && !this._sameParent(currentIndex))
                    return;
                var currentIndexOffset = currentIndex - this._startIndex,
                    currentDirection = utils.sign(currentIndexOffset),
                    minIndex = Math.min(currentIndex, this._lastIndex),
                    maxIndex = Math.max(currentIndex, this._lastIndex);
                for (var itemIndex = minIndex; itemIndex <= maxIndex; itemIndex++) {
                    if (itemIndex === this._startIndex)
                        continue;
                    var $item = this._list.getItemElementByFlatIndex(itemIndex),
                        itemIndexOffset = itemIndex - this._startIndex,
                        itemDirection = utils.sign(itemIndexOffset),
                        offsetsDifference = Math.abs(itemIndexOffset) <= Math.abs(currentIndexOffset),
                        sameDirections = currentDirection === itemDirection,
                        setupPosition = offsetsDifference && sameDirections,
                        resetPosition = !offsetsDifference || !sameDirections;
                    fx.stop($item);
                    if (setupPosition)
                        fx.animate($item, {
                            type: "slide",
                            to: {top: this._elementHeight * -currentDirection},
                            duration: 300
                        });
                    if (resetPosition)
                        fx.animate($item, {
                            type: "slide",
                            to: {top: 0},
                            duration: 300
                        })
                }
                this._lastIndex = currentIndex
            },
            _sameParent: function(index) {
                var $dragging = this._list.getItemElementByFlatIndex(this._startIndex),
                    $over = this._list.getItemElementByFlatIndex(index);
                return $over.parent().get(0) === $dragging.parent().get(0)
            },
            scrollByStep: function() {
                this._scrollOffset += this._stepSize;
                this._list.scrollBy(this._stepSize);
                this._updateItemPositions()
            },
            scrollFinished: function() {
                var scrollTop = this._scrollTop(),
                    rejectScrollTop = scrollTop <= 0 && this._stepSize < 0,
                    rejectScrollBottom = scrollTop >= this._scrollHeight - this._clientHeight && this._stepSize > 0;
                return rejectScrollTop || rejectScrollBottom
            },
            _dragEndHandler: function($itemElement) {
                this._scrollAnimator.stop();
                fx.animate(this._$ghostItem, {
                    type: "slide",
                    to: {top: this._startGhostPosition + this._getLastElementPosition() - this._getDraggingElementPosition()},
                    duration: 300
                }).done($.proxy(function() {
                    $itemElement.removeClass(REOREDERING_ITEM_CLASS);
                    this._resetPositions();
                    this._list.reorderItem($itemElement, this._list.getItemElementByFlatIndex(this._lastIndex));
                    this._deleteGhost();
                    this._toggleCompatibilityMode(false)
                }, this))
            },
            _deleteGhost: function() {
                this._$ghostItem.remove()
            },
            _resetPositions: function() {
                var minIndex = Math.min(this._startIndex, this._lastIndex),
                    maxIndex = Math.max(this._startIndex, this._lastIndex);
                for (var itemIndex = minIndex; itemIndex <= maxIndex; itemIndex++) {
                    var $item = this._list.getItemElementByFlatIndex(itemIndex);
                    translator.resetPosition($item)
                }
            },
            _findItemIndexByPosition: function(position) {
                var minIndex = 0;
                var maxIndex = this._itemPositions.length - 1;
                var currentIndex;
                var currentPosition;
                while (minIndex <= maxIndex) {
                    currentIndex = (minIndex + maxIndex) / 2 | 0;
                    currentPosition = this._itemPositions[currentIndex];
                    if (currentPosition < position)
                        minIndex = currentIndex + 1;
                    else if (currentPosition > position)
                        maxIndex = currentIndex - 1;
                    else
                        return currentIndex
                }
                return fitIntoRange(minIndex, 0, Math.max(maxIndex, 0))
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.provider.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            utils = DX.utils;
        var editOptionsRegistry = [];
        var registerOption = function(enabledFunc, decoratorTypeFunc, decoratorSubTypeFunc) {
                editOptionsRegistry.push({
                    enabled: enabledFunc,
                    decoratorType: decoratorTypeFunc,
                    decoratorSubType: decoratorSubTypeFunc
                })
            };
        registerOption(function(config) {
            return config.menuItems.length
        }, function() {
            return "menu"
        }, function(config) {
            if (config.menuType === "hold") {
                DX.log("W0001", "dxList", "'hold' menu type", "14.1", "Use the 'context' menuType option instead");
                config.menuType = "context"
            }
            return config.menuType
        });
        registerOption(function(config) {
            return !config.menuItems.length && config.deleteEnabled
        }, function(config, defaultConfig) {
            var deleteType = config.deleteMode !== defaultConfig.deleteMode ? config.deleteMode : config.deleteType;
            return deleteType === "toggle" || deleteType === "slideButton" || deleteType === "swipe" || deleteType === "static" ? "delete" : "menu"
        }, function(config, defaultConfig) {
            var deleteType;
            if (config.deleteMode !== defaultConfig.deleteMode) {
                DX.log("W0001", "dxList", "deleteMode", "14.1", "Use the 'deleteType' option instead");
                deleteType = config.deleteMode
            }
            else
                deleteType = config.deleteType;
            if (deleteType === "slideItem")
                deleteType = "slide";
            if (deleteType === "hold")
                deleteType = "context";
            return deleteType
        });
        registerOption(function(config) {
            return config.selectionEnabled
        }, function() {
            return "selection"
        }, function(config, defaultConfig) {
            var selectionType;
            if (config.selectionMode !== defaultConfig.selectionMode) {
                DX.log("W0001", "dxList", "selectionMode", "14.1", "Use the 'selectionType' option instead");
                selectionType = config.selectionMode
            }
            else
                selectionType = config.selectionType;
            return selectionType
        });
        registerOption(function(config) {
            return config.reorderEnabled
        }, function() {
            return "reorder"
        }, function() {
            return "default"
        });
        var LIST_ITEM_BEFORE_BAG_CLASS = "dx-list-item-before-bag",
            LIST_ITEM_AFTER_BAG_CLASS = "dx-list-item-after-bag",
            DECORATOR_BEFORE_BAG_CREATE_METHOD = "beforeBag",
            DECORATOR_AFTER_BAG_CREATE_METHOD = "afterBag",
            DECORATOR_MODIFY_ELEMENT_METHOD = "modifyElement",
            DECORATOR_AFTER_RENDER_METHOD = "afterRender";
        ui.dxList.EditProvider = DX.Class.inherit({
            ctor: function(list, config, defaultConfig) {
                this._list = list;
                this._config = config;
                this._defaultConfig = defaultConfig;
                this._fetchRequiredDecorators()
            },
            dispose: function() {
                if (this._decorators && this._decorators.length)
                    $.each(this._decorators, function(_, decorator) {
                        decorator.dispose()
                    })
            },
            isModifyingByDecorators: function(itemData) {
                return !this.isRenderingByTemplate(itemData)
            },
            isRenderingByTemplate: function(itemData) {
                return !!this.getItemTemplateName(itemData)
            },
            getItemTemplateName: function(itemData) {
                return itemData && itemData.editTemplate || this._config.itemTemplate || this._config.itemRender
            },
            _fetchRequiredDecorators: function() {
                this._decorators = [];
                if (!this.isModifyingByDecorators())
                    return;
                var config = this._config,
                    defaultConfig = this._defaultConfig;
                $.each(editOptionsRegistry, $.proxy(function(_, option) {
                    var optionEnabled = option.enabled(config, defaultConfig);
                    if (optionEnabled) {
                        var decoratorType = option.decoratorType(config, defaultConfig),
                            decoratorSubType = option.decoratorSubType(config, defaultConfig),
                            decorator = this._createDecorator(decoratorType, decoratorSubType);
                        this._decorators.push(decorator)
                    }
                }, this))
            },
            _createDecorator: function(type, subType) {
                var decoratorClass = this._findDecorator(type, subType);
                return new decoratorClass(this._list)
            },
            _findDecorator: function(type, subType) {
                var foundDecorator = ui.dxList.EditDecoratorsRegistry[type][subType];
                if (!foundDecorator)
                    throw DX.Error("E1012", type, subType);
                return foundDecorator
            },
            modifyItemElement: function(args) {
                var $itemElement = $(args.itemElement);
                var config = {$itemElement: $itemElement};
                this._prependBeforeBags($itemElement, config);
                this._appendAfterBags($itemElement, config);
                this._applyDecorators(DECORATOR_MODIFY_ELEMENT_METHOD, config)
            },
            afterItemsRendered: function() {
                this._applyDecorators(DECORATOR_AFTER_RENDER_METHOD)
            },
            _prependBeforeBags: function($itemElement, config) {
                var $beforeBags = this._collectDecoratorsMarkup(DECORATOR_BEFORE_BAG_CREATE_METHOD, config, LIST_ITEM_BEFORE_BAG_CLASS);
                $itemElement.prepend($beforeBags)
            },
            _appendAfterBags: function($itemElement, config) {
                var $afterBags = this._collectDecoratorsMarkup(DECORATOR_AFTER_BAG_CREATE_METHOD, config, LIST_ITEM_AFTER_BAG_CLASS);
                $itemElement.append($afterBags)
            },
            _collectDecoratorsMarkup: function(method, config, containerClass) {
                var $collector = $("<div />");
                $.each(this._decorators, function() {
                    var $container = $("<div />").addClass(containerClass);
                    this[method]($.extend({$container: $container}, config));
                    if ($container.children().length)
                        $collector.append($container)
                });
                return $collector.children()
            },
            _applyDecorators: function(method, config) {
                $.each(this._decorators, function() {
                    this[method](config)
                })
            },
            _handlerExists: function(name) {
                if (!this._decorators)
                    return false;
                var decorators = this._decorators,
                    length = decorators.length;
                for (var i = 0; i < length; i++)
                    if (decorators[i][name] !== $.noop)
                        return true;
                return false
            },
            _eventHandler: function(name, $itemElement, e) {
                if (!this._decorators)
                    return false;
                var response = false,
                    decorators = this._decorators,
                    length = decorators.length;
                for (var i = 0; i < length; i++) {
                    response = decorators[i][name]($itemElement, e);
                    if (response)
                        break
                }
                return response
            },
            handleClick: function($itemElement, e) {
                return this._eventHandler("handleClick", $itemElement, e)
            },
            contextMenuHandlerExists: function() {
                return this._handlerExists("handleContextMenu")
            },
            handleContextMenu: function($itemElement, e) {
                return this._eventHandler("handleContextMenu", $itemElement, e)
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.tileView.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils;
        var TILEVIEW_CLASS = "dx-tileview",
            TILEVIEW_CONTAINER_CLASS = "dx-tileview-wrapper",
            TILEVIEW_ITEM_CLASS = "dx-tile",
            TILEVIEW_ITEM_SELECTOR = "." + TILEVIEW_ITEM_CLASS,
            TILEVIEW_ITEM_DATA_KEY = "dxTileData";
        DX.registerComponent("dxTileView", ui, ui.CollectionWidget.inherit({
            _activeStateUnit: TILEVIEW_ITEM_SELECTOR,
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {listHeight: {
                        since: "14.1",
                        alias: "height"
                    }})
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    items: null,
                    showScrollbar: false,
                    height: 500,
                    baseItemWidth: 100,
                    baseItemHeight: 100,
                    itemMargin: 20,
                    indicateLoading: true
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {
                                hoverStateEnabled: true,
                                focusStateEnabled: true
                            }
                        }])
            },
            _itemClass: function() {
                return TILEVIEW_ITEM_CLASS
            },
            _itemDataKey: function() {
                return TILEVIEW_ITEM_DATA_KEY
            },
            _itemContainer: function() {
                return this._$container
            },
            _init: function() {
                this.callBase();
                this._initScrollView()
            },
            _dataSourceLoadingChangedHandler: function(isLoading) {
                var scrollView = this._scrollView;
                if (!scrollView)
                    return;
                if (isLoading && this.option("indicateLoading"))
                    scrollView.startLoading();
                else
                    scrollView.finishLoading()
            },
            _hideLoadingIfLoadIndicationOff: function() {
                if (!this.option("indicateLoading"))
                    this._dataSourceLoadingChangedHandler(false)
            },
            _initScrollView: function() {
                this._scrollView = this.element().dxScrollView({
                    direction: "horizontal",
                    scrollByContent: true
                }).dxScrollView("instance");
                this._$container = this._scrollView.content();
                this._$container.addClass(TILEVIEW_CONTAINER_CLASS);
                this._scrollView.option("onUpdated", $.proxy(this._renderGeometry, this))
            },
            _render: function() {
                this.callBase();
                this.element().addClass(TILEVIEW_CLASS);
                this.cellsPerColumn = 1;
                this._updateScrollView();
                this._fireContentReadyAction()
            },
            _renderContent: function() {
                this._renderContentImpl()
            },
            _updateScrollView: function() {
                this._scrollView.option({
                    rtlEnabled: this.option("rtlEnabled"),
                    showScrollbar: this.option("showScrollbar"),
                    disabled: this.option("disabled")
                });
                this._scrollView.update();
                this._indicateLoadingIfAlreadyStarted()
            },
            _indicateLoadingIfAlreadyStarted: function() {
                if (this._dataSource && this._dataSource.isLoading())
                    this._dataSourceLoadingChangedHandler(true)
            },
            _renderGeometry: function() {
                var items = this.option("items") || [],
                    maxItemHeight = Math.max.apply(Math, $.map(items || [], function(item) {
                        return Math.round(item.heightRatio || 1)
                    }));
                this.cellsPerColumn = Math.floor(this.element().height() / (this.option("baseItemHeight") + this.option("itemMargin")));
                this.cellsPerColumn = Math.max(this.cellsPerColumn, maxItemHeight);
                this.cells = [];
                this.cells.push(new Array(this.cellsPerColumn));
                this._arrangeItems(items);
                this._$container.width(this.cells.length * this.option("baseItemWidth") + (this.cells.length + 1) * this.option("itemMargin"))
            },
            _arrangeItems: function(items) {
                var that = this;
                this._itemsPositions = [];
                $.each(items, function(index, item) {
                    var currentItem = {};
                    currentItem.widthRatio = item.widthRatio || 1;
                    currentItem.heightRatio = item.heightRatio || 1;
                    currentItem.index = index;
                    currentItem.widthRatio = currentItem.widthRatio <= 0 ? 0 : Math.round(currentItem.widthRatio);
                    currentItem.heightRatio = currentItem.heightRatio <= 0 ? 0 : Math.round(currentItem.heightRatio);
                    var itemPosition = that._getItemPosition(currentItem);
                    if (itemPosition.x === -1)
                        itemPosition.x = that.cells.push(new Array(that.cellsPerColumn)) - 1;
                    that._occupyCells(currentItem, itemPosition);
                    that._arrangeItem(currentItem, itemPosition);
                    that._itemsPositions.push(itemPosition)
                })
            },
            _getItemPosition: function(item) {
                var position = {
                        x: -1,
                        y: 0
                    };
                for (var col = 0; col < this.cells.length; col++) {
                    for (var row = 0; row < this.cellsPerColumn; row++)
                        if (this._itemFit(col, row, item)) {
                            position.x = col;
                            position.y = row;
                            break
                        }
                    if (position.x > -1)
                        break
                }
                return position
            },
            _itemFit: function(column, row, item) {
                var result = true;
                if (row + item.heightRatio > this.cellsPerColumn)
                    return false;
                for (var columnIndex = column; columnIndex < column + item.widthRatio; columnIndex++)
                    for (var rowIndex = row; rowIndex < row + item.heightRatio; rowIndex++)
                        if (this.cells.length - 1 < columnIndex)
                            this.cells.push(new Array(this.cellsPerColumn));
                        else if (this.cells[columnIndex][rowIndex] !== undefined) {
                            result = false;
                            break
                        }
                return result
            },
            _occupyCells: function(item, itemPosition) {
                for (var i = itemPosition.x; i < itemPosition.x + item.widthRatio; i++)
                    for (var j = itemPosition.y; j < itemPosition.y + item.heightRatio; j++)
                        this.cells[i][j] = item.index
            },
            _arrangeItem: function(item, itemPosition) {
                var baseItemHeight = this.option("baseItemHeight"),
                    baseItemWidth = this.option("baseItemWidth"),
                    itemMargin = this.option("itemMargin"),
                    leftOffset,
                    offsetCorrection = this.option("rtlEnabled") ? this._$container.width() : 0,
                    $item = this._itemElements().eq(item.index);
                if (!offsetCorrection)
                    leftOffset = itemPosition.x * baseItemWidth + (itemPosition.x + 1) * itemMargin;
                else {
                    var startOffsetPosition = itemPosition.x * baseItemWidth,
                        itemBasePartWidth = baseItemWidth + itemMargin,
                        itemWidth = itemBasePartWidth * item.widthRatio,
                        subitemMarginsWidth = itemPosition.x * itemMargin;
                    leftOffset = offsetCorrection - (startOffsetPosition + itemWidth + subitemMarginsWidth)
                }
                $item.css({
                    height: item.heightRatio * baseItemHeight + (item.heightRatio - 1) * itemMargin,
                    width: item.widthRatio * baseItemWidth + (item.widthRatio - 1) * itemMargin,
                    top: itemPosition.y * baseItemHeight + (itemPosition.y + 1) * itemMargin,
                    left: leftOffset,
                    display: item.widthRatio <= 0 || item.heightRatio <= 0 ? "none" : ""
                })
            },
            _moveFocus: function(location) {
                var FOCUS_UP = "up",
                    FOCUS_DOWN = "down",
                    FOCUS_LEFT = this.option("rtlEnabled") ? "right" : "left",
                    FOCUS_RIGHT = this.option("rtlEnabled") ? "left" : "right",
                    FOCUS_PAGE_UP = "pageup",
                    FOCUS_PAGE_DOWN = "pagedown";
                var cells = this.cells,
                    index = this._$focusedItem.index(),
                    newTargetCol = this._itemsPositions[index].x,
                    targetRow = this._itemsPositions[index].y,
                    newTargetIndex;
                switch (location) {
                    case FOCUS_PAGE_UP:
                    case FOCUS_UP:
                        while (targetRow > 0 && index === cells[newTargetCol][targetRow])
                            targetRow--;
                        if (targetRow < 0)
                            targetRow = 0;
                        break;
                    case FOCUS_PAGE_DOWN:
                    case FOCUS_DOWN:
                        while (targetRow < cells[0].length && index === cells[newTargetCol][targetRow])
                            targetRow++;
                        if (targetRow === cells[0].length)
                            targetRow = cells[0].length - 1;
                        break;
                    case FOCUS_RIGHT:
                        while (newTargetCol < cells.length && index === cells[newTargetCol][targetRow])
                            newTargetCol++;
                        if (newTargetCol === cells.length)
                            newTargetCol = cells.length - 1;
                        break;
                    case FOCUS_LEFT:
                        while (newTargetCol >= 0 && index === cells[newTargetCol][targetRow])
                            newTargetCol--;
                        if (newTargetCol < 0)
                            newTargetCol = 0;
                        break;
                    default:
                        this.callBase.apply(this, arguments);
                        return
                }
                newTargetIndex = cells[newTargetCol][targetRow];
                var $newTarget = this._itemElements().eq(newTargetIndex);
                this._resetFocusedItem($newTarget);
                this._scrollToItem($newTarget)
            },
            _scrollToItem: function($itemElement) {
                if (!$itemElement.length)
                    return;
                var itemPosition = $itemElement.position().left,
                    itemWidth = $itemElement.outerWidth(),
                    itemRight = itemPosition + itemWidth,
                    scrollLeft = this._scrollView.scrollLeft(),
                    clientWidht = this._scrollView.element().outerWidth();
                if (scrollLeft <= itemPosition && itemRight <= scrollLeft + clientWidht)
                    return;
                if (scrollLeft > itemPosition)
                    this._scrollView.scrollTo(itemPosition - this.option("itemMargin"));
                else
                    this._scrollView.scrollTo(itemPosition + itemWidth - clientWidht + this.option("itemMargin"))
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"showScrollbar":
                        this._initScrollView();
                        break;
                    case"disabled":
                        this._scrollView.option("disabled", args.value);
                        break;
                    case"baseItemWidth":
                    case"baseItemHeight":
                    case"itemMargin":
                        this._renderGeometry();
                        break;
                    case"height":
                        this.callBase(args);
                        this._renderGeometry();
                        this._scrollView.update();
                        break;
                    case"indicateLoading":
                        this._hideLoadingIfLoadIndicationOff();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            scrollPosition: function() {
                return this._scrollView.scrollOffset().left
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.trackBar.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx;
        var TRACKBAR_CLASS = "dx-trackbar",
            TRACKBAR_CONTAINER_CLASS = "dx-trackbar-container",
            TRACKBAR_RANGE_CLASS = "dx-trackbar-range",
            TRACKBAR_WRAPPER_CLASS = "dx-trackbar-wrapper";
        DX.registerComponent("dxTrackBar", ui, ui.Editor.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    min: 0,
                    max: 100,
                    value: 0
                })
            },
            _render: function() {
                this.element().addClass(TRACKBAR_CLASS);
                this._renderWrapper();
                this._renderContainer();
                this._renderRange();
                this.callBase();
                this._renderValue()
            },
            _renderWrapper: function() {
                this._$wrapper = $("<div>").addClass(TRACKBAR_WRAPPER_CLASS).appendTo(this.element())
            },
            _renderContainer: function() {
                this._$bar = $("<div>").addClass(TRACKBAR_CONTAINER_CLASS).appendTo(this._$wrapper)
            },
            _renderRange: function() {
                this._$range = $("<div>").addClass(TRACKBAR_RANGE_CLASS).appendTo(this._$bar)
            },
            _renderValue: function() {
                var val = this.option("value"),
                    min = this.option("min"),
                    max = this.option("max");
                if (min > max)
                    return;
                if (val < min) {
                    this.option("value", min);
                    this._currentRatio = 0;
                    return
                }
                if (val > max) {
                    this.option("value", max);
                    this._currentRatio = 1;
                    return
                }
                var ratio = min === max ? 0 : (val - min) / (max - min);
                this._animateRange({width: ratio * 100 + "%"});
                this._currentRatio = ratio
            },
            _animateRange: function(configTo) {
                fx.stop(this._$range);
                if (!this._needPreventAnimation)
                    fx.animate(this._$range, {
                        type: "custom",
                        duration: 100,
                        to: configTo,
                        complete: $.proxy(this._rangeAnimationCompleteHandler, this)
                    })
            },
            _rangeAnimationCompleteHandler: $.noop,
            _optionChanged: function(args) {
                switch (args.name) {
                    case"value":
                        this._renderValue();
                        this.callBase(args);
                        break;
                    case"max":
                    case"min":
                        this._renderValue();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _dispose: function() {
                fx.stop(this._$range);
                this.callBase()
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.progressBar.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx;
        var PROGRESSBAR_CLASS = "dx-progressbar",
            PROGRESSBAR_CONTAINER_CLASS = "dx-progressbar-container",
            PROGRESSBAR_RANGE_CLASS = "dx-progressbar-range",
            PROGRESSBAR_WRAPPER_CLASS = "dx-progressbar-wrapper",
            PROGRESSBAR_STATUS_CLASS = "dx-progressbar-status",
            PROGRESSBAR_INDETERMINATE_SEGMENT_CONTAINER = "dx-progressbar-animating-container",
            PROGRESSBAR_INDETERMINATE_SEGMENT = "dx-progressbar-animating-segment";
        DX.registerComponent("dxProgressBar", ui, ui.dxTrackBar.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    statusFormat: function(ratio, value) {
                        return "Progress: " + Math.round(ratio * 100) + "%"
                    },
                    showStatus: true,
                    onComplete: null,
                    activeStateEnabled: false,
                    _animatingSegmentCount: 0
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: [{platform: "win8"}],
                            options: {_animatingSegmentCount: 5}
                        }, {
                            device: [{platform: "android"}],
                            options: {_animatingSegmentCount: 3}
                        }, {
                            device: function(device) {
                                return device.platform === "android" && device.version[0] > 4
                            },
                            options: {_animatingSegmentCount: 2}
                        }])
            },
            _init: function() {
                this.callBase()
            },
            _render: function() {
                this._createCompleteAction();
                this._renderStatus();
                this.callBase();
                this.element().addClass(PROGRESSBAR_CLASS);
                this._$wrapper.addClass(PROGRESSBAR_WRAPPER_CLASS);
                this._$bar.addClass(PROGRESSBAR_CONTAINER_CLASS);
                this._$range.addClass(PROGRESSBAR_RANGE_CLASS);
                this._toggleStatus(this.option("showStatus"))
            },
            _createCompleteAction: function() {
                this._completeAction = this._createActionByOption("onComplete")
            },
            _renderStatus: function() {
                this._$status = $("<div>").addClass(PROGRESSBAR_STATUS_CLASS)
            },
            _renderIndeterminateState: function() {
                this._$segmentContainer = $("<div>").addClass(PROGRESSBAR_INDETERMINATE_SEGMENT_CONTAINER);
                var segments = this.option("_animatingSegmentCount");
                for (var i = 0; i < segments; i++)
                    $("<div>").addClass(PROGRESSBAR_INDETERMINATE_SEGMENT).addClass(PROGRESSBAR_INDETERMINATE_SEGMENT + "-" + (i + 1)).appendTo(this._$segmentContainer);
                this._$segmentContainer.appendTo(this._$wrapper)
            },
            _toggleStatus: function(value) {
                value ? this._$status.appendTo(this._$bar) : this._$status.detach()
            },
            _toggleIndeterminateState: function(value) {
                if (value) {
                    this._renderIndeterminateState();
                    this._$bar.toggle(false)
                }
                else {
                    this._$bar.toggle(true);
                    this._$segmentContainer.remove();
                    delete this._$segmentContainer
                }
            },
            _renderValue: function() {
                var val = this.option("value"),
                    max = this.option("max");
                if (!val && val !== 0) {
                    this._toggleIndeterminateState(true);
                    return
                }
                if (this._$segmentContainer)
                    this._toggleIndeterminateState(false);
                if (val == max)
                    this._completeAction();
                this.callBase();
                this._setStatus()
            },
            _setStatus: function() {
                var format = this.option("statusFormat");
                if ($.isFunction(format))
                    format = $.proxy(format, this);
                else
                    format = function(value) {
                        return value
                    };
                var statusText = format(this._currentRatio, this.option("value"));
                this._$status.text(statusText)
            },
            _dispose: function() {
                this._$status.remove();
                this.callBase()
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"statusFormat":
                        this._setStatus();
                        break;
                    case"showStatus":
                        this._toggleStatus(args.value);
                        break;
                    case"onComplete":
                        this._createCompleteAction();
                        break;
                    case"_animatingSegmentCount":
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.slider.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            fx = DX.fx,
            utils = DX.utils,
            translator = DX.translator,
            transionEndEventName = DX.support.transitionEndEventName;
        var SLIDER_CLASS = "dx-slider",
            SLIDER_WRAPPER_CLASS = SLIDER_CLASS + "-wrapper",
            SLIDER_HANDLE_CLASS = SLIDER_CLASS + "-handle",
            SLIDER_HANDLE_SELECTOR = "." + SLIDER_HANDLE_CLASS,
            SLIDER_BAR_CLASS = SLIDER_CLASS + "-bar",
            SLIDER_RANGE_CLASS = SLIDER_CLASS + "-range",
            SLIDER_RANGE_VISIBLE_CLASS = SLIDER_RANGE_CLASS + "-visible",
            SLIDER_LABEL_CLASS = SLIDER_CLASS + "-label",
            SLIDER_LABEL_POSITION_CLASS_PREFIX = SLIDER_LABEL_CLASS + "-position-",
            SLIDER_TOOLTIP_CLASS = SLIDER_CLASS + "-tooltip",
            SLIDER_TOOLTIP_POSITION_CLASS_PREFIX = SLIDER_TOOLTIP_CLASS + "-position-";
        var dxSliderHandle = ui.Widget.inherit({
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        hoverStateEnabled: false,
                        value: 50,
                        tooltipEnabled: false,
                        tooltipFormat: function(v) {
                            return v
                        },
                        tooltipPosition: "top",
                        tooltipShowMode: "onHover",
                        tooltipFitIn: null
                    })
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(SLIDER_HANDLE_CLASS);
                    this._renderTooltip()
                },
                _renderTooltip: function() {
                    if (this.option("tooltipEnabled")) {
                        if (!this._$tooltip) {
                            this._$tooltip = $("<div>").appendTo(this.element()).dxTooltip({
                                visible: true,
                                height: undefined,
                                target: this.element(),
                                closeOnOutsideClick: false,
                                container: this.element(),
                                closeOnBackButton: false,
                                closeOnTargetScroll: false,
                                animation: null
                            });
                            this._tooltip = this._$tooltip.dxTooltip("instance")
                        }
                        this._renderTooltipPosition();
                        this._renderTooltipShowMode();
                        this._renderValue()
                    }
                    else
                        this._removeTooltip()
                },
                _visibilityChanged: function() {
                    this._dimensionChanged()
                },
                _dimensionChanged: function() {
                    this._repaintTooltip()
                },
                _removeTooltip: function() {
                    if (!this._$tooltip)
                        return;
                    this._$tooltip.remove();
                    delete this._$tooltip;
                    delete this._tooltip
                },
                _renderTooltipPosition: function() {
                    if (!this._tooltip)
                        return;
                    var position = this.option("tooltipPosition");
                    if ($.type(position) === "string")
                        position = position + "None";
                    this._tooltip.option("position", position)
                },
                _repaintTooltip: function() {
                    if (this._tooltip)
                        this._tooltip.repaint()
                },
                _renderValue: function() {
                    if (!this._tooltip)
                        return;
                    var format = this.option("tooltipFormat"),
                        value = format(this.option("value"));
                    this._tooltip.content().html(value);
                    this._fitTooltipPosition()
                },
                _renderTooltipShowMode: function() {
                    this.element().toggleClass("dx-slider-tooltip-on-hover", /^onhover$/i.test(this.option("tooltipShowMode")))
                },
                _fitTooltipPosition: function() {
                    if (!this._$tooltip)
                        return;
                    var $tooltipContent = this._tooltip.content().parent(),
                        tooltipWidth = $tooltipContent.outerWidth(),
                        $boundElement = this.option("tooltipFitIn"),
                        boundElementWidth = $boundElement.outerWidth(),
                        boundElementLeft = $boundElement.offset().left,
                        boundElementRight = boundElementLeft + boundElementWidth,
                        $element = this.element(),
                        elementWidth = $element.outerWidth(),
                        elementLeft = $element.offset().left,
                        elementRight = elementLeft + elementWidth,
                        idealOffset = Math.round(elementWidth / 2 - tooltipWidth / 2),
                        minOffset = Math.ceil(boundElementLeft - elementLeft),
                        maxOffset = Math.floor(boundElementRight - elementRight) + idealOffset * 2,
                        newOffset = Math.min(Math.max(minOffset, idealOffset), maxOffset);
                    translator.move($tooltipContent, {left: newOffset})
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"tooltipFormat":
                            this._renderValue();
                            break;
                        case"value":
                            this._renderValue();
                            break;
                        case"tooltipEnabled":
                            this._renderTooltip();
                            break;
                        case"tooltipPosition":
                            this._renderTooltipPosition();
                            break;
                        case"tooltipShowMode":
                            this._renderTooltipShowMode();
                            break;
                        case"tooltipFitIn":
                            this._fitTooltipPosition();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                fitTooltipPosition: function() {
                    this._fitTooltipPosition()
                },
                repaint: function() {
                    this._repaintTooltip();
                    this._renderTooltipPosition();
                    this._fitTooltipPosition()
                }
            });
        DX.registerComponent("dxSlider", ui, ui.dxTrackBar.inherit({
            _activeStateUnit: SLIDER_HANDLE_SELECTOR,
            _supportedKeys: function() {
                var isRTL = this.option("rtlEnabled");
                return $.extend(this.callBase(), {
                        leftArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            var val = this.option("value"),
                                step = this._valueStep();
                            val = isRTL ? val + step : val - step;
                            this.option("value", val)
                        },
                        rightArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            var val = this.option("value"),
                                step = this._valueStep();
                            val = isRTL ? val - step : val + step;
                            this.option("value", val)
                        },
                        home: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            var min = this.option("min");
                            this.option("value", min)
                        },
                        end: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            var max = this.option("max");
                            this.option("value", max)
                        }
                    })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    step: 1,
                    value: 50,
                    showRange: true,
                    tooltip: {
                        enabled: false,
                        format: function(value) {
                            return value
                        },
                        position: "top",
                        showMode: "onHover"
                    },
                    label: {
                        visible: false,
                        position: "bottom",
                        format: function(value) {
                            return value
                        }
                    }
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {
                                focusStateEnabled: true,
                                hoverStateEnabled: true
                            }
                        }])
            },
            _render: function() {
                this.element().addClass(SLIDER_CLASS);
                this.callBase();
                this._renderLabels();
                this._renderStartHandler()
            },
            _visibilityChanged: function() {
                this.repaint()
            },
            _renderWrapper: function() {
                this.callBase();
                this._$wrapper.addClass(SLIDER_WRAPPER_CLASS);
                this._$wrapper.dxSwipeable({
                    elastic: false,
                    immediate: true,
                    onStart: $.proxy(this._swipeStartHandler, this),
                    onUpdated: $.proxy(this._swipeUpdateHandler, this),
                    onEnd: $.proxy(this._swipeEndHandler, this),
                    itemSizeFunc: $.proxy(this._itemWidthFunc, this)
                })
            },
            _renderContainer: function() {
                this.callBase();
                this._$bar.addClass(SLIDER_BAR_CLASS);
                this._$bar.off(transionEndEventName + "." + this.NAME).on(transionEndEventName, $.proxy(this._fitHandleTooltipPosition, this))
            },
            _renderRange: function() {
                this.callBase();
                this._$range.addClass(SLIDER_RANGE_CLASS);
                this._renderHandle();
                this._renderRangeVisibility()
            },
            _renderRangeVisibility: function() {
                this._$range.toggleClass(SLIDER_RANGE_VISIBLE_CLASS, Boolean(this.option("showRange")))
            },
            _renderHandle: function() {
                this._$handle = this._renderHandleImpl(this.option("value"), this._$handle)
            },
            _renderHandleImpl: function(value, $element) {
                var $handle = $element || $("<div>").appendTo(this._$range),
                    format = this._normalizeFormat(this.option("tooltip.format")),
                    tooltipEnabled = this.option("tooltip.enabled"),
                    tooltipPosition = this.option("tooltip.position");
                this.element().toggleClass(SLIDER_TOOLTIP_POSITION_CLASS_PREFIX + "bottom", tooltipEnabled && tooltipPosition === "bottom").toggleClass(SLIDER_TOOLTIP_POSITION_CLASS_PREFIX + "top", tooltipEnabled && tooltipPosition === "top");
                return $handle.dxSliderHandle({
                        value: value,
                        tooltipEnabled: tooltipEnabled,
                        tooltipPosition: tooltipPosition,
                        tooltipFormat: format,
                        tooltipShowMode: this.option("tooltip.showMode"),
                        tooltipFitIn: this.element()
                    })
            },
            _renderLabels: function() {
                this.element().removeClass(SLIDER_LABEL_POSITION_CLASS_PREFIX + "bottom").removeClass(SLIDER_LABEL_POSITION_CLASS_PREFIX + "top");
                if (this.option("label.visible")) {
                    var min = this.option("min"),
                        max = this.option("max"),
                        position = this.option("label.position"),
                        format = this._normalizeFormat(this.option("label.format"));
                    if (!this._$minLabel)
                        this._$minLabel = $("<div>").addClass(SLIDER_LABEL_CLASS).appendTo(this._$wrapper);
                    this._$minLabel.html(format(min));
                    if (!this._$maxLabel)
                        this._$maxLabel = $("<div>").addClass(SLIDER_LABEL_CLASS).appendTo(this._$wrapper);
                    this._$maxLabel.html(format(max));
                    this.element().addClass(SLIDER_LABEL_POSITION_CLASS_PREFIX + position)
                }
                else {
                    if (this._$minLabel) {
                        this._$minLabel.remove();
                        delete this._$minLabel
                    }
                    if (this._$maxLabel) {
                        this._$maxLabel.remove();
                        delete this._$maxLabel
                    }
                }
            },
            _normalizeFormat: function(formatSource) {
                var format = formatSource;
                if (typeof formatSource === "string")
                    format = function(value) {
                        return Globalize.format(value, formatSource)
                    };
                else if ($.isFunction(formatSource))
                    format = $.proxy(format, this);
                else
                    format = function(value) {
                        return value
                    };
                return format
            },
            _renderDimensions: function() {
                this.callBase();
                if (this._$bar) {
                    var barMarginWidth = this._$bar.outerWidth(true) - this._$bar.outerWidth();
                    this._$bar.width(this.option("width") - barMarginWidth)
                }
            },
            _renderStartHandler: function() {
                var pointerDownEventName = events.addNamespace("dxpointerdown", this.NAME),
                    clickEventName = events.addNamespace("dxclick", this.NAME),
                    startAction = this._createAction($.proxy(this._startHandler, this));
                this.element().off(pointerDownEventName).on(pointerDownEventName, function(e) {
                    if (events.isMouseEvent(e))
                        startAction({jQueryEvent: e})
                }).off(clickEventName).on(clickEventName, function(e) {
                    startAction({jQueryEvent: e})
                })
            },
            _itemWidthFunc: function() {
                return this.element().width() / this._swipePixelRatio()
            },
            _swipeStartHandler: function(e) {
                var rtlEnabled = this.option("rtlEnabled"),
                    startOffset,
                    endOffset;
                if (events.isTouchEvent(e.jQueryEvent))
                    this._createAction($.proxy(this._startHandler, this))({jQueryEvent: e.jQueryEvent});
                this._toggleActiveState(this._activeHandle(), true);
                this._startOffset = this._currentRatio;
                startOffset = this._startOffset * this._swipePixelRatio();
                endOffset = (1 - this._startOffset) * this._swipePixelRatio();
                e.jQueryEvent.maxLeftOffset = rtlEnabled ? endOffset : startOffset;
                e.jQueryEvent.maxRightOffset = rtlEnabled ? startOffset : endOffset;
                this._needPreventAnimation = true
            },
            _swipeEndHandler: function(e) {
                var offsetDirection = this.option("rtlEnabled") ? -1 : 1;
                delete this._needPreventAnimation;
                this._changeValueOnSwipe(this._startOffset + offsetDirection * e.jQueryEvent.targetOffset / this._swipePixelRatio());
                delete this._startOffset;
                this._renderValue();
                this._toggleActiveState(this._activeHandle(), false)
            },
            _activeHandle: function() {
                return this._$handle
            },
            _swipeUpdateHandler: function(e) {
                this._valueChangeEventInstance = e;
                this._updateHandlePosition(e)
            },
            _updateHandlePosition: function(e) {
                var offsetDirection = this.option("rtlEnabled") ? -1 : 1;
                var newRatio = this._startOffset + offsetDirection * e.jQueryEvent.offset / this._swipePixelRatio();
                this._$range.width(newRatio * 100 + "%");
                this._changeValueOnSwipe(newRatio)
            },
            _swipePixelRatio: function() {
                var min = this.option("min"),
                    max = this.option("max"),
                    step = this._valueStep();
                return (max - min) / step
            },
            _valueStep: function() {
                var step = this.option("step");
                if (!step || isNaN(step))
                    step = 1;
                step = parseFloat(step.toFixed(5));
                if (step === 0)
                    step = 0.00001;
                return step
            },
            _changeValueOnSwipe: function(ratio) {
                var min = this.option("min"),
                    max = this.option("max"),
                    step = this._valueStep(),
                    newChange = ratio * (max - min),
                    newValue = min + newChange;
                if (step < 0)
                    return;
                if (newValue === max || newValue === min)
                    this.option("value", newValue);
                else {
                    var stepChunks = (step + "").split('.'),
                        exponent = stepChunks.length > 1 ? stepChunks[1].length : exponent;
                    newValue = Number((Math.round(newChange / step) * step + min).toFixed(exponent));
                    this.option("value", Math.max(Math.min(newValue, max), min))
                }
            },
            _startHandler: function(args) {
                var e = args.jQueryEvent;
                this._currentRatio = (ui.events.eventData(e).x - this._$bar.offset().left) / this._$bar.width();
                if (this.option("rtlEnabled"))
                    this._currentRatio = 1 - this._currentRatio;
                this._valueChangeEventInstance = e;
                this._changeValueOnSwipe(this._currentRatio)
            },
            _renderValue: function() {
                this.callBase();
                this._activeHandle().dxSliderHandle("option", "value", this.option("value"))
            },
            _rangeAnimationCompleteHandler: function() {
                this._fitHandleTooltipPosition()
            },
            _fitHandleTooltipPosition: function() {
                if (this._activeHandle())
                    this._activeHandle().dxSliderHandle("fitTooltipPosition")
            },
            _repaintHandle: function() {
                this._$handle.dxSliderHandle("repaint")
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"visible":
                        this.callBase(args);
                        this._renderHandle();
                        this._repaintHandle();
                        break;
                    case"min":
                    case"max":
                        this._renderLabels();
                        this.callBase(args);
                        break;
                    case"step":
                        this._renderValue();
                        break;
                    case"value":
                        this.callBase(args);
                        break;
                    case"showRange":
                        this._renderRangeVisibility();
                        break;
                    case"tooltip":
                        this._renderHandle();
                        break;
                    case"label":
                        this._renderLabels();
                        break;
                    case"rtlEnabled":
                        this._toggleRTLDirection();
                        this._renderValue();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _refresh: function() {
                this._renderDimensions();
                this._renderValue();
                this._renderHandle()
            }
        }));
        DX.registerComponent("dxSliderHandle", ui.dxSlider, dxSliderHandle)
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.rangeSlider.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var SLIDER_HANDLE_CLASS = "dx-slider-handle",
            RANGE_SLIDER_CLASS = "dx-range-slider",
            RANGE_SLIDER_START_HANDLE_CLASS = RANGE_SLIDER_CLASS + "-start-handle",
            RANGE_SLIDER_END_HANDLE_CLASS = RANGE_SLIDER_CLASS + "-end-handle";
        DX.registerComponent("dxRangeSlider", ui, ui.dxSlider.inherit({
            _supportedKeys: function() {
                var isRTL = this.option("rtlEnabled");
                return $.extend(this.callBase(), {
                        leftArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            var valueOption = $(e.target).hasClass(RANGE_SLIDER_START_HANDLE_CLASS) ? "start" : "end",
                                val = this.option(valueOption),
                                step = this._valueStep();
                            val = isRTL ? val + step : val - step;
                            this.option(valueOption, val)
                        },
                        rightArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            var valueOption = $(e.target).hasClass(RANGE_SLIDER_START_HANDLE_CLASS) ? "start" : "end",
                                val = this.option(valueOption),
                                step = this._valueStep();
                            val = isRTL ? val - step : val + step;
                            this.option(valueOption, val)
                        },
                        home: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            var isStart = $(e.target).hasClass(RANGE_SLIDER_START_HANDLE_CLASS),
                                valueOption = isStart ? "start" : "end",
                                startOption = isStart ? "min" : "start",
                                val = this.option(startOption);
                            this.option(valueOption, val)
                        },
                        end: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            var isStart = $(e.target).hasClass(RANGE_SLIDER_START_HANDLE_CLASS),
                                valueOption = isStart ? "start" : "end",
                                endOption = isStart ? "end" : "max",
                                val = this.option(endOption);
                            this.option(valueOption, val)
                        }
                    })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    start: 40,
                    end: 60
                })
            },
            _render: function() {
                this.callBase();
                this.element().addClass(RANGE_SLIDER_CLASS)
            },
            _renderHandle: function() {
                this._$handleStart = this._renderHandleImpl(this.option("start"), this._$handleStart).addClass(RANGE_SLIDER_START_HANDLE_CLASS);
                this._$handleEnd = this._renderHandleImpl(this.option("end"), this._$handleEnd).addClass(RANGE_SLIDER_END_HANDLE_CLASS)
            },
            _startHandler: function(args) {
                var e = args.jQueryEvent,
                    $range = this._$range,
                    rangeWidth = $range.width(),
                    eventOffsetX = events.eventData(e).x - this._$bar.offset().left,
                    startHandleX = $range.position().left,
                    endHandleX = $range.position().left + rangeWidth,
                    rtlEnabled = this.option("rtlEnabled"),
                    startHandleIsClosest = (rtlEnabled ? -1 : 1) * ((startHandleX + endHandleX) / 2 - eventOffsetX) > 0;
                this._capturedHandle = startHandleIsClosest ? this._$handleStart : this._$handleEnd;
                this.callBase(args)
            },
            _activeHandle: function() {
                return this._capturedHandle
            },
            _updateHandlePosition: function(e) {
                var rtlEnabled = this.option("rtlEnabled"),
                    offsetDirection = rtlEnabled ? -1 : 1,
                    max = this.option("max"),
                    min = this.option("min");
                var newRatio = this._startOffset + offsetDirection * e.jQueryEvent.offset / this._swipePixelRatio(),
                    newRatio = newRatio.toPrecision(12),
                    newValue = newRatio * (max - min) + min;
                this._updateSelectedRangePosition(newRatio, newRatio);
                this._changeValueOnSwipe(newRatio);
                var startValue = this.option("start"),
                    endValue = this.option("end"),
                    $nextHandle;
                if (startValue === endValue) {
                    if (newValue < startValue)
                        $nextHandle = this._$handleStart;
                    else
                        $nextHandle = this._$handleEnd;
                    $nextHandle.focus();
                    if ($nextHandle && $nextHandle !== this._capturedHandle) {
                        this._updateSelectedRangePosition((startValue - min) / (max - min), (endValue - min) / (max - min));
                        this._toggleActiveState(this._activeHandle(), false);
                        this._toggleActiveState($nextHandle, true);
                        this._capturedHandle = $nextHandle
                    }
                    this._updateSelectedRangePosition(newRatio, newRatio);
                    this._changeValueOnSwipe(newRatio)
                }
            },
            _updateSelectedRangePosition: function(leftRatio, rightRatio) {
                var rtlEnabled = this.option("rtlEnabled"),
                    moveRight = this._capturedHandle === this._$handleStart && rtlEnabled || this._capturedHandle === this._$handleEnd && !rtlEnabled;
                var prop = moveRight ? "right" : "left";
                if (rtlEnabled ^ moveRight)
                    this._$range.css(prop, 100 - rightRatio * 100 + "%");
                else
                    this._$range.css(prop, leftRatio * 100 + "%")
            },
            _changeValueOnSwipe: function(ratio) {
                this._suppressValueChangeAction();
                this.callBase(ratio);
                this._resumeValueChangeAction();
                var option = this._capturedHandle === this._$handleStart ? "start" : "end",
                    start = this.option("start"),
                    end = this.option("end"),
                    newValue = this.option("value"),
                    max = this.option("max"),
                    min = this.option("min");
                if (start > max) {
                    start = max;
                    this.option("start", max)
                }
                if (start < min) {
                    start = min;
                    this.option("start", min)
                }
                if (end > max) {
                    end = max;
                    this.option("end", max)
                }
                if (newValue > end && option === "start")
                    newValue = end;
                if (newValue < start && option === "end")
                    newValue = start;
                this.option(option, newValue)
            },
            _renderValue: function() {
                var valStart = this.option("start"),
                    valEnd = this.option("end"),
                    min = this.option("min"),
                    max = this.option("max"),
                    rtlEnabled = this.option("rtlEnabled");
                valStart = Math.max(min, Math.min(valStart, max));
                valEnd = Math.max(valStart, Math.min(valEnd, max));
                this.option("start", valStart);
                this.option("end", valEnd);
                var ratio1 = max === min ? 0 : (valStart - min) / (max - min),
                    ratio2 = max === min ? 0 : (valEnd - min) / (max - min);
                var startOffset = parseFloat((ratio1 * 100).toPrecision(12)) + "%",
                    endOffset = parseFloat(((1 - ratio2) * 100).toPrecision(12)) + "%";
                this._animateRange({
                    right: rtlEnabled ? startOffset : endOffset,
                    left: rtlEnabled ? endOffset : startOffset
                });
                this._renderHandle()
            },
            _repaintHandle: function() {
                this._$handleStart.dxSliderHandle("repaint");
                this._$handleEnd.dxSliderHandle("repaint")
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"start":
                    case"end":
                        this._renderValue();
                        this._createActionByOption("onValueChanged")({
                            start: this.option("start"),
                            end: this.option("end")
                        });
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.gallery.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            fx = DX.fx,
            translator = DX.translator,
            GALLERY_CLASS = "dx-gallery",
            GALLERY_WRAPPER_CLASS = GALLERY_CLASS + "-wrapper",
            GALLERY_LOOP_CLASS = "dx-gallery-loop",
            GALLERY_ITEM_CONTAINER_CLASS = GALLERY_CLASS + "-container",
            GALLERY_ACTIVE_CLASS = GALLERY_CLASS + "-active",
            GALLERY_ITEM_CLASS = GALLERY_CLASS + "-item",
            GALLERY_LOOP_ITEM_CLASS = GALLERY_ITEM_CLASS + "-loop",
            GALLERY_ITEM_SELECTOR = "." + GALLERY_ITEM_CLASS,
            GALLERY_ITEM_SELECTED_CLASS = GALLERY_ITEM_CLASS + "-selected",
            GALLERY_INDICATOR_CLASS = GALLERY_CLASS + "-indicator",
            GALLERY_INDICATOR_ITEM_CLASS = GALLERY_INDICATOR_CLASS + "-item",
            GALLERY_INDICATOR_ITEM_SELECTOR = "." + GALLERY_INDICATOR_ITEM_CLASS,
            GALLERY_INDICATOR_ITEM_SELECTED_CLASS = GALLERY_INDICATOR_ITEM_CLASS + "-selected",
            GALLERY_ITEM_DATA_KEY = "dxGalleryItemData";
        var dxGalleryNavButton = ui.Widget.inherit({
                _supportedKeys: function() {
                    return $.extend(this.callBase(), {
                            pageUp: $.noop,
                            pageDown: $.noop
                        })
                },
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        direction: "next",
                        onClick: null,
                        hoverStateEnabled: true,
                        activeStateEnabled: true
                    })
                },
                _render: function() {
                    this.callBase();
                    var that = this,
                        $element = this.element(),
                        eventName = events.addNamespace("dxclick", this.NAME);
                    $element.addClass(GALLERY_CLASS + "-nav-button-" + this.option("direction")).off(eventName).on(eventName, function(e) {
                        that._createActionByOption("onClick")({jQueryEvent: e})
                    })
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"onClick":
                        case"direction":
                            this._invalidate();
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        DX.registerComponent("dxGallery", ui, ui.CollectionWidget.inherit({
            _activeStateUnit: GALLERY_ITEM_SELECTOR,
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    activeStateEnabled: false,
                    animationDuration: 400,
                    loop: false,
                    swipeEnabled: true,
                    indicatorEnabled: true,
                    showIndicator: true,
                    selectedIndex: 0,
                    slideshowDelay: 0,
                    showNavButtons: false,
                    loopItemFocus: false,
                    selectOnFocus: true,
                    selectionMode: "single",
                    selectionRequired: true
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }])
            },
            _dataSourceOptions: function() {
                return {paginate: false}
            },
            _itemContainer: function() {
                return this._$container
            },
            _itemClass: function() {
                return GALLERY_ITEM_CLASS
            },
            _itemDataKey: function() {
                return GALLERY_ITEM_DATA_KEY
            },
            _itemWidth: function() {
                if (!this._itemWidthCache)
                    this._itemWidthCache = this._itemElements().first().outerWidth();
                return this._itemWidthCache
            },
            _clearItemWidthCache: function() {
                delete this._itemWidthCache
            },
            _itemsCount: function() {
                return (this.option("items") || []).length
            },
            _offsetDirection: function() {
                return this.option("rtlEnabled") ? -1 : 1
            },
            _render: function() {
                this.element().addClass(GALLERY_CLASS);
                this.element().toggleClass(GALLERY_LOOP_CLASS, this.option("loop"));
                this._renderDragHandler();
                this._renderWrapper();
                this._renderItemsContainer();
                this.callBase();
                this._renderContainerPosition();
                this._renderItemPositions();
                this._renderNavButtons();
                this._renderIndicator();
                this._renderSelectedItem();
                this._renderSelectedIndicatorItem();
                this._renderUserInteraction();
                this._setupSlideShow();
                this._reviseDimensions()
            },
            _dimensionChanged: function() {
                this._clearItemWidthCache();
                this._renderDuplicateItems();
                this._renderItemPositions();
                this._renderContainerPosition()
            },
            _renderDragHandler: function() {
                var eventName = events.addNamespace("dragstart", this.NAME);
                this.element().off(eventName).on(eventName, "img", function() {
                    return false
                })
            },
            _renderWrapper: function() {
                if (this._$wrapper)
                    return;
                this._$wrapper = $("<div />").addClass(GALLERY_WRAPPER_CLASS).appendTo(this.element())
            },
            _renderItems: function(items) {
                this.callBase(items);
                this._renderDuplicateItems()
            },
            _renderItemsContainer: function() {
                if (this._$container)
                    return;
                this._$container = $("<div>").addClass(GALLERY_ITEM_CONTAINER_CLASS).appendTo(this._$wrapper)
            },
            _renderDuplicateItems: function() {
                var items = this.option("items") || [],
                    itemsCount = items.length;
                if (!itemsCount)
                    return;
                this.element().find("." + GALLERY_LOOP_ITEM_CLASS).remove();
                var itemsPerPage = this.element().width() / this._itemWidth(),
                    duplicateCount = Math.min(itemsPerPage, itemsCount);
                for (var i = 0; i < duplicateCount; i++)
                    this._renderItem(0, items[i]).addClass(GALLERY_LOOP_ITEM_CLASS);
                this._renderItem(0, items[this._itemsCount() - 1]).addClass(GALLERY_LOOP_ITEM_CLASS)
            },
            _renderItemPositions: function() {
                var itemWidth = this._itemWidth(),
                    loopItemsCount = this.element().find("." + GALLERY_LOOP_ITEM_CLASS).length,
                    lastItemDuplicateIndex = this._itemsCount() + loopItemsCount - 1,
                    offsetDirection = this._offsetDirection();
                this._itemElements().each(function(index) {
                    var realIndex = index;
                    if (index === lastItemDuplicateIndex)
                        realIndex = -1;
                    translator.move($(this), {left: offsetDirection * realIndex * itemWidth})
                })
            },
            _renderContainerPosition: function(offset, animate) {
                offset = offset || 0;
                var that = this,
                    itemWidth = this._itemWidth(),
                    selectedIndex = this.option("selectedIndex"),
                    targetIndex = offset - selectedIndex,
                    targetPosition = this._offsetDirection() * targetIndex * itemWidth,
                    positionReady;
                if (animate) {
                    that._startSwipe();
                    positionReady = that._animate(targetPosition).done($.proxy(that._endSwipe, that))
                }
                else {
                    translator.move(this._$container, {left: targetPosition});
                    positionReady = $.Deferred().resolveWith(that)
                }
                return positionReady.promise()
            },
            _startSwipe: function() {
                this.element().addClass(GALLERY_ACTIVE_CLASS)
            },
            _endSwipe: function() {
                this.element().removeClass(GALLERY_ACTIVE_CLASS)
            },
            _animate: function(targetPosition, extraConfig) {
                var that = this,
                    animationComplete = $.Deferred();
                fx.animate(this._$container, $.extend({
                    type: "slide",
                    to: {left: targetPosition},
                    duration: that.option("animationDuration"),
                    complete: function() {
                        animationComplete.resolveWith(that);
                        that._updateNavButtons()
                    }
                }, extraConfig || {}));
                this._updateNavButtons();
                return animationComplete
            },
            _reviseDimensions: function() {
                var that = this,
                    $firstItem = that._itemElements().first().find(".dx-item-content");
                if (!$firstItem || $firstItem.is(":hidden"))
                    return;
                if (!that.option("height"))
                    that.option("height", $firstItem.outerHeight());
                if (!that.option("width"))
                    that.option("width", $firstItem.outerWidth());
                this._dimensionChanged()
            },
            _renderIndicator: function() {
                if (!this.option("showIndicator")) {
                    this._cleanIndicators();
                    return
                }
                var indicator = this._$indicator = $("<div>").addClass(GALLERY_INDICATOR_CLASS).appendTo(this._$wrapper);
                $.each(this.option("items") || [], function() {
                    $("<div>").addClass(GALLERY_INDICATOR_ITEM_CLASS).appendTo(indicator)
                });
                this._renderSelectedIndicatorItem()
            },
            _cleanIndicators: function() {
                if (this._$indicator)
                    this._$indicator.remove()
            },
            _renderSelectedItem: function() {
                var selectedIndex = this.option("selectedIndex");
                this._itemElements().removeClass(GALLERY_ITEM_SELECTED_CLASS).eq(selectedIndex).addClass(GALLERY_ITEM_SELECTED_CLASS)
            },
            _renderSelectedIndicatorItem: function() {
                if (!this._$indicator)
                    return;
                this._$indicator.find(GALLERY_INDICATOR_ITEM_SELECTOR).removeClass(GALLERY_INDICATOR_ITEM_SELECTED_CLASS).eq(this.option("selectedIndex")).addClass(GALLERY_INDICATOR_ITEM_SELECTED_CLASS)
            },
            _renderUserInteraction: function() {
                var that = this,
                    rootElement = that.element(),
                    swipeEnabled = that.option("swipeEnabled") && this._itemsCount() > 1,
                    cursor = swipeEnabled ? "pointer" : "default";
                rootElement.dxSwipeable({
                    disabled: this.option("disabled") || !swipeEnabled,
                    onStart: $.proxy(that._swipeStartHandler, that),
                    onUpdated: $.proxy(that._swipeUpdateHandler, that),
                    onEnd: $.proxy(that._swipeEndHandler, that),
                    itemSizeFunc: $.proxy(that._itemWidth, that)
                });
                var indicatorSelectAction = this._createAction(this._indicatorSelectHandler);
                rootElement.off(events.addNamespace("dxclick", this.NAME), GALLERY_INDICATOR_ITEM_SELECTOR).on(events.addNamespace("dxclick", this.NAME), GALLERY_INDICATOR_ITEM_SELECTOR, function(e) {
                    indicatorSelectAction({jQueryEvent: e})
                })
            },
            _indicatorSelectHandler: function(args) {
                var e = args.jQueryEvent,
                    instance = args.component;
                if (!instance.option("indicatorEnabled"))
                    return;
                var index = $(e.target).index();
                instance._renderContainerPosition(instance.option("selectedIndex") - index, true).done(function() {
                    this._suppressRenderItemPositions = true;
                    this._setFocusOnSelect();
                    instance.option("selectedIndex", index)
                })
            },
            _renderNavButtons: function() {
                var that = this;
                if (!that.option("showNavButtons")) {
                    that._cleanNavButtons();
                    return
                }
                that._prevNavButton = $("<div />").dxGalleryNavButton({
                    direction: "prev",
                    onClick: function() {
                        that.prevItem(true).done(that._setFocusOnSelect)
                    }
                }).appendTo(this._$wrapper);
                that._nextNavButton = $("<div />").dxGalleryNavButton({
                    direction: "next",
                    onClick: function() {
                        that.nextItem(true).done(that._setFocusOnSelect)
                    }
                }).appendTo(this._$wrapper);
                this._renderNavButtonsVisibility()
            },
            _updateNavButtons: function() {
                if (this._prevNavButton)
                    this._prevNavButton.dxGalleryNavButton("instance").option("disabled", fx.isAnimating(this._$container));
                if (this._nextNavButton)
                    this._nextNavButton.dxGalleryNavButton("instance").option("disabled", fx.isAnimating(this._$container))
            },
            _cleanNavButtons: function() {
                if (this._prevNavButton) {
                    this._prevNavButton.remove();
                    delete this._prevNavButton
                }
                if (this._nextNavButton) {
                    this._nextNavButton.remove();
                    delete this._nextNavButton
                }
            },
            _renderNavButtonsVisibility: function() {
                if (!this.option("showNavButtons"))
                    return;
                var selectedIndex = this.option("selectedIndex"),
                    loop = this.option("loop"),
                    itemsCount = this._itemsCount();
                this._prevNavButton.show();
                this._nextNavButton.show();
                if (loop)
                    return;
                var nextHidden = itemsCount < 2 || selectedIndex === itemsCount - 1,
                    prevHidden = itemsCount < 2 || selectedIndex === 0;
                if (prevHidden)
                    this._prevNavButton.hide();
                if (nextHidden)
                    this._nextNavButton.hide()
            },
            _setupSlideShow: function() {
                var that = this,
                    slideshowDelay = that.option("slideshowDelay");
                if (!slideshowDelay)
                    return;
                clearTimeout(that._slideshowTimer);
                that._slideshowTimer = setTimeout(function() {
                    if (that._userInteraction) {
                        that._setupSlideShow();
                        return
                    }
                    that.nextItem(true).done(that._setupSlideShow)
                }, slideshowDelay)
            },
            _swipeStartHandler: function(e) {
                var itemsCount = this._itemsCount();
                if (!itemsCount) {
                    e.jQueryEvent.cancel = true;
                    return
                }
                this._stopItemAnimations();
                this._startSwipe();
                this._userInteraction = true;
                if (!this.option("loop")) {
                    var selectedIndex = this.option("selectedIndex"),
                        startOffset = itemsCount - selectedIndex - 1,
                        endOffset = selectedIndex,
                        rtlEnabled = this.option("rtlEnabled");
                    e.jQueryEvent.maxLeftOffset = rtlEnabled ? endOffset : startOffset;
                    e.jQueryEvent.maxRightOffset = rtlEnabled ? startOffset : endOffset
                }
            },
            _stopItemAnimations: function() {
                if (fx.isAnimating(this._$container))
                    fx.stop(this._$container, true)
            },
            _swipeUpdateHandler: function(e) {
                this._renderContainerPosition(this._offsetDirection() * e.jQueryEvent.offset)
            },
            _swipeEndHandler: function(e) {
                var targetOffset = e.jQueryEvent.targetOffset * this._offsetDirection();
                this._renderContainerPosition(targetOffset, true).done(function() {
                    var selectedIndex = this.option("selectedIndex"),
                        newIndex = this._fitIndex(selectedIndex - targetOffset);
                    this._suppressRenderItemPositions = true;
                    this.option("selectedIndex", newIndex);
                    this._renderContainerPosition();
                    this._setFocusOnSelect();
                    this._userInteraction = false;
                    this._setupSlideShow()
                })
            },
            _setFocusOnSelect: function() {
                this._userInteraction = true;
                var selectedItem = this.itemElements().filter("." + GALLERY_ITEM_SELECTED_CLASS);
                this._resetFocusedItem(selectedItem);
                this._userInteraction = false
            },
            _flipIndex: function(index) {
                var itemsCount = this._itemsCount();
                index = index % itemsCount;
                if (index > (itemsCount + 1) / 2)
                    index -= itemsCount;
                if (index < -(itemsCount - 1) / 2)
                    index += itemsCount;
                return index
            },
            _fitIndex: function(index) {
                if (!this.option("loop"))
                    return index;
                var itemsCount = this._itemsCount();
                index = index % itemsCount;
                if (index < 0)
                    index += itemsCount;
                return index
            },
            _clean: function() {
                this.callBase();
                this._cleanIndicators();
                this._cleanNavButtons()
            },
            _dispose: function() {
                clearTimeout(this._slideshowTimer);
                this.callBase()
            },
            _updateSelection: function() {
                if (!this._suppressRenderItemPositions)
                    this._renderContainerPosition();
                this._suppressRenderItemPositions = false;
                this._renderSelectedItem();
                this._renderSelectedIndicatorItem();
                this._renderNavButtonsVisibility()
            },
            _focusInHandler: function(e) {
                if (fx.isAnimating(this._$container) || this._userInteraction)
                    return;
                this.callBase.apply(this, arguments)
            },
            _focusOutHandler: function(e) {
                if (fx.isAnimating(this._$container) || this._userInteraction)
                    return;
                this.callBase.apply(this, arguments)
            },
            _selectFocusedItem: function($target) {
                var index = this.itemElements().index($target);
                this.goToItem(index, true)
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._reviseDimensions()
            },
            _optionChanged: function(args) {
                var value = args.value;
                switch (args.name) {
                    case"width":
                        this.callBase.apply(this, arguments);
                        this._dimensionChanged();
                        break;
                    case"animationDuration":
                        this._renderNavButtonsVisibility();
                        break;
                    case"loop":
                        this.option("loopItemFocus", value);
                        this.element().toggleClass(GALLERY_LOOP_CLASS, value);
                        this._renderNavButtonsVisibility();
                        return;
                    case"showIndicator":
                        this._renderIndicator();
                        return;
                    case"showNavButtons":
                        this._renderNavButtons();
                        return;
                    case"slideshowDelay":
                        this._setupSlideShow();
                        return;
                    case"swipeEnabled":
                    case"indicatorEnabled":
                        this._renderUserInteraction();
                        return;
                    default:
                        this.callBase(args)
                }
            },
            goToItem: function(itemIndex, animation) {
                var d = new $.Deferred,
                    selectedIndex = this.option("selectedIndex"),
                    itemsCount = this._itemsCount();
                itemIndex = this._fitIndex(itemIndex);
                if (itemIndex > itemsCount - 1 || itemIndex < 0)
                    return d.resolveWith(this).promise();
                this._renderContainerPosition(selectedIndex - itemIndex, animation).done(function() {
                    this._suppressRenderItemPositions = true;
                    this.option("selectedIndex", itemIndex);
                    d.resolveWith(this)
                });
                return d.promise()
            },
            prevItem: function(animation) {
                return this.goToItem(this.option("selectedIndex") - 1, animation)
            },
            nextItem: function(animation) {
                return this.goToItem(this.option("selectedIndex") + 1, animation)
            }
        }));
        DX.registerComponent("dxGalleryNavButton", ui.dxGallery, dxGalleryNavButton)
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.overlay.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            fx = DX.fx,
            translator = DX.translator;
        var OVERLAY_CLASS = "dx-overlay",
            OVERLAY_WRAPPER_CLASS = "dx-overlay-wrapper",
            OVERLAY_CONTENT_CLASS = "dx-overlay-content",
            OVERLAY_SHADER_CLASS = "dx-overlay-shader",
            OVERLAY_MODAL_CLASS = "dx-overlay-modal",
            ANONYMOUS_TEMPLATE_NAME = "content",
            RTL_DIRECTION_CLASS = "dx-rtl",
            ACTIONS = ["onShowing", "onShown", "onHiding", "onHidden", "onPositioning", "onPositioned"],
            FIRST_Z_INDEX = 1000,
            Z_INDEX_STACK = [],
            DISABLED_STATE_CLASS = "dx-state-disabled",
            MIN_OVERLAY_STICK_SIZE = 40;
        var realDevice = DX.devices.real(),
            android4_0nativeBrowser = realDevice.platform === "android" && /^4\.0(\.\d)?/.test(realDevice.version.join(".")) && navigator.userAgent.indexOf("Chrome") === -1;
        var forceRepaint = function($element) {
                $element.width();
                if (android4_0nativeBrowser) {
                    var $parents = $element.parents(),
                        inScrollView = $parents.is(".dx-scrollable-native");
                    if (!inScrollView) {
                        $parents.css("backface-visibility", "hidden");
                        $parents.css("backface-visibility");
                        $parents.css("backface-visibility", "visible")
                    }
                }
            };
        var getElement = function(value) {
                return $(value instanceof $.Event ? value.target : value)
            };
        DX.registerComponent("dxOverlay", ui, ui.Widget.inherit({
            _supportedKeys: function() {
                var offsetSize = 5,
                    parent = this.callBase(),
                    move = function(top, left, e) {
                        if (!this.option("dragEnabled"))
                            return;
                        e.preventDefault();
                        e.stopPropagation();
                        var offset = {
                                top: top,
                                left: left
                            };
                        this._changePosition(offset)
                    };
                return $.extend(this.callBase(), {
                        escape: function(e) {
                            this.hide()
                        },
                        downArrow: $.proxy(move, this, offsetSize, 0),
                        upArrow: $.proxy(move, this, -offsetSize, 0),
                        leftArrow: $.proxy(move, this, 0, -offsetSize),
                        rightArrow: $.proxy(move, this, 0, offsetSize)
                    })
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    shownAction: {
                        since: "14.2",
                        alias: "onShown"
                    },
                    showingAction: {
                        since: "14.2",
                        alias: "onShowing"
                    },
                    hidingAction: {
                        since: "14.2",
                        alias: "onHiding"
                    },
                    hiddenAction: {
                        since: "14.2",
                        alias: "onHidden"
                    }
                })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    activeStateEnabled: false,
                    visible: false,
                    deferRendering: true,
                    shading: true,
                    shadingColor: "",
                    position: {
                        my: "center",
                        at: "center",
                        of: window
                    },
                    width: function() {
                        return $(window).width() * 0.8
                    },
                    height: function() {
                        return $(window).height() * 0.8
                    },
                    animation: {
                        show: {
                            type: "pop",
                            duration: 400
                        },
                        hide: {
                            type: "pop",
                            duration: 400,
                            to: {
                                opacity: 0,
                                scale: 0
                            },
                            from: {
                                opacity: 1,
                                scale: 1
                            }
                        }
                    },
                    closeOnOutsideClick: false,
                    closeOnBackButton: true,
                    onShowing: null,
                    onShown: null,
                    onHiding: null,
                    onHidden: null,
                    contentTemplate: "content",
                    dragEnabled: false,
                    target: undefined,
                    container: undefined,
                    hideTopOverlayHandler: undefined,
                    closeOnTargetScroll: false,
                    onPositioning: null,
                    onPositioned: null
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                var realDevice = DX.devices.real(),
                                    realPlatform = realDevice.platform,
                                    realVersion = realDevice.version;
                                return realPlatform === "android" && (realVersion[0] < 4 || realVersion[0] == 4 && realVersion[1] <= 1)
                            },
                            options: {animation: {
                                    show: {
                                        type: "fade",
                                        duration: 400
                                    },
                                    hide: {
                                        type: "fade",
                                        duration: 400,
                                        to: {opacity: 0},
                                        from: {opacity: 1}
                                    }
                                }}
                        }])
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {animation: true})
            },
            _wrapper: function() {
                return this._$wrapper
            },
            _container: function() {
                return this._$content
            },
            _init: function() {
                this.callBase();
                this._initActions();
                this._initCloseOnOutsideClickHandler();
                this._$wrapper = $("<div>").addClass(OVERLAY_WRAPPER_CLASS);
                this._$content = $("<div>").addClass(OVERLAY_CONTENT_CLASS);
                var $element = this.element();
                this._$wrapper.addClass($element.attr("class"));
                $element.addClass(OVERLAY_CLASS);
                this._$wrapper.on("MSPointerDown", $.noop)
            },
            _clean: function() {
                this._cleanFocusState()
            },
            _initOptions: function(options) {
                this._initTarget(options.target);
                this._initContainer(options.container);
                this._initHideTopOverlayHandler(options.hideTopOverlayHandler);
                this.callBase(options)
            },
            _initTarget: function(target) {
                if (!utils.isDefined(target))
                    return;
                var options = this.option();
                $.each(["position.of", "animation.show.from.position.of", "animation.show.to.position.of", "animation.hide.from.position.of", "animation.hide.to.position.of"], function(_, path) {
                    var pathParts = path.split(".");
                    var option = options;
                    while (option)
                        if (pathParts.length == 1) {
                            if ($.isPlainObject(option))
                                option[pathParts.shift()] = target;
                            break
                        }
                        else
                            option = option[pathParts.shift()]
                })
            },
            _initContainer: function(container) {
                container = container === undefined ? DX.viewPort() : container;
                var $element = this.element(),
                    $container = $element.closest(container);
                if (!$container.length)
                    $container = $(container).first();
                this._$container = $container.length ? $container : $element.parent()
            },
            _initHideTopOverlayHandler: function(handler) {
                this._hideTopOverlayHandler = handler !== undefined ? handler : $.proxy(this._defaultHideTopOverlayHandler, this)
            },
            _defaultHideTopOverlayHandler: function() {
                this.hide()
            },
            _initActions: function() {
                this._actions = {};
                $.each(ACTIONS, $.proxy(function(_, action) {
                    this._actions[action] = this._createActionByOption(action) || $.noop
                }, this))
            },
            _getAnonimousTemplateName: function() {
                return ANONYMOUS_TEMPLATE_NAME
            },
            _visibilityChanged: function(visible) {
                if (visible) {
                    if (this.option("visible"))
                        this._show();
                    this._dimensionChanged()
                }
                else
                    this._hide()
            },
            _dimensionChanged: function() {
                this._renderGeometry()
            },
            _initCloseOnOutsideClickHandler: function() {
                this._proxiedDocumentDownHandler = $.proxy(function() {
                    this._documentDownHandler.apply(this, arguments)
                }, this)
            },
            _documentDownHandler: function(e) {
                if (!this._isTopOverlay())
                    return;
                var closeOnOutsideClick = this.option("closeOnOutsideClick");
                if ($.isFunction(closeOnOutsideClick))
                    closeOnOutsideClick = closeOnOutsideClick(e);
                if (closeOnOutsideClick) {
                    var $container = this._$content,
                        outsideClick = !$container.is(e.target) && !$.contains($container.get(0), e.target);
                    if (outsideClick) {
                        e.preventDefault();
                        this.hide()
                    }
                }
            },
            _isTopOverlay: function() {
                var zIndexStack = this._zIndexStack();
                return zIndexStack[zIndexStack.length - 1] === this._zIndex
            },
            _zIndexStack: function() {
                return Z_INDEX_STACK
            },
            _zIndexInitValue: function() {
                return FIRST_Z_INDEX
            },
            _renderVisibilityAnimate: function() {
                var visible = this.option("visible");
                this._stopAnimation();
                if (visible)
                    return this._show();
                else
                    return this._hide()
            },
            _updateRegistration: function(enabled) {
                var zIndexStack = this._zIndexStack();
                if (enabled) {
                    if (!this._zIndex) {
                        var length = zIndexStack.length;
                        this._zIndex = (length ? zIndexStack[length - 1] : this._zIndexInitValue()) + 1;
                        zIndexStack.push(this._zIndex)
                    }
                }
                else if (this._zIndex) {
                    var index = $.inArray(this._zIndex, zIndexStack);
                    zIndexStack.splice(index, 1);
                    delete this._zIndex
                }
            },
            _normalizePosition: function() {
                this._position = this.option("position")
            },
            _show: function() {
                if (this.element().parent().is(":hidden"))
                    return $.Deferred().resolve();
                this._normalizePosition();
                var that = this,
                    deferred = $.Deferred(),
                    animation = that.option("animation") || {},
                    showAnimation = animation.show,
                    completeShowAnimation = showAnimation && showAnimation.complete || $.noop;
                this._updateRegistration(true);
                if (showAnimation && showAnimation.to) {
                    showAnimation = $.extend({type: "slide"}, showAnimation);
                    $.extend(showAnimation.to, {position: this._position})
                }
                if (this._isHidingActionCancelled) {
                    delete this._isHidingActionCancelled;
                    deferred.resolve()
                }
                else {
                    this._$wrapper.css("z-index", this._zIndex);
                    this._$content.css("z-index", this._zIndex);
                    this._toggleVisibility(true);
                    this._animate(showAnimation, function() {
                        if (that.option("focusStateEnabled"))
                            that._focusTarget().focus();
                        completeShowAnimation.apply(this, arguments);
                        that._actions.onShown();
                        deferred.resolve()
                    })
                }
                return deferred.promise()
            },
            _hide: function() {
                var that = this,
                    deferred = $.Deferred(),
                    animation = this.option("animation") || {},
                    hideAnimation = animation.hide,
                    completeHideAnimation = hideAnimation && hideAnimation.complete || $.noop,
                    hidingArgs = {cancel: false};
                this._actions.onHiding(hidingArgs);
                if (hidingArgs.cancel) {
                    this._isHidingActionCancelled = true;
                    this.option("visible", true);
                    deferred.resolve()
                }
                else {
                    this._toggleShading(false);
                    this._animate(hideAnimation, function() {
                        that._toggleVisibility(false);
                        completeHideAnimation.apply(this, arguments);
                        that._updateRegistration(false);
                        that._actions.onHidden();
                        deferred.resolve()
                    })
                }
                return deferred.promise()
            },
            _animate: function(animation, completeCallback) {
                if (animation)
                    fx.animate(this._$content, $.extend({}, animation, {complete: completeCallback}));
                else
                    completeCallback()
            },
            _stopAnimation: function() {
                fx.stop(this._$content, true)
            },
            _toggleVisibility: function(visible) {
                this._stopAnimation();
                if (!visible)
                    utils.triggerHidingEvent(this._$content);
                this.callBase.apply(this, arguments);
                this._$content.toggle(visible);
                if (visible) {
                    this._actions.onShowing();
                    this._renderContent();
                    this._moveToContainer();
                    this._renderGeometry();
                    utils.triggerShownEvent(this._$content)
                }
                else
                    this._moveFromContainer();
                this._toggleShading(visible);
                this._toggleSubscriptions(visible);
                this._updateRegistration(visible)
            },
            _toggleShading: function(visible) {
                this._$wrapper.toggleClass(OVERLAY_MODAL_CLASS, this.option("shading") && !this.option("container"));
                this._$wrapper.toggleClass(OVERLAY_SHADER_CLASS, visible && this.option("shading"));
                this._$wrapper.css("background-color", this.option("shading") ? this.option("shadingColor") : "")
            },
            _toggleSubscriptions: function(enabled) {
                this._toggleHideTopOverlayCallback(enabled);
                this._toggleDocumentDownHandler(enabled);
                this._toggleParentsScrollSubscription(enabled)
            },
            _toggleHideTopOverlayCallback: function(subscribe) {
                if (!this._hideTopOverlayHandler)
                    return;
                if (subscribe && this.option("closeOnBackButton"))
                    DX.hideTopOverlayCallback.add(this._hideTopOverlayHandler);
                else
                    DX.hideTopOverlayCallback.remove(this._hideTopOverlayHandler)
            },
            _toggleDocumentDownHandler: function(enabled) {
                var that = this,
                    eventName = events.addNamespace("dxpointerdown", that.NAME);
                if (enabled)
                    $(document).on(eventName, this._proxiedDocumentDownHandler);
                else
                    $(document).off(eventName, this._proxiedDocumentDownHandler)
            },
            _toggleParentsScrollSubscription: function(subscribe) {
                var position = this._position;
                if (!position || !position.of)
                    return;
                var that = this,
                    closeOnScroll = this.option("closeOnTargetScroll"),
                    $parents = getElement(position.of).parents();
                if (DX.devices.real().platform == "generic")
                    $parents = $parents.add(window);
                $parents.off(events.addNamespace("scroll", that.NAME));
                if (subscribe && closeOnScroll)
                    $parents.on(events.addNamespace("scroll", that.NAME), function(e) {
                        if (e.overlayProcessed)
                            return;
                        e.overlayProcessed = true;
                        var closeHandled = false;
                        if ($.isFunction(closeOnScroll))
                            closeHandled = closeOnScroll(e);
                        if (!closeHandled)
                            that.hide()
                    })
            },
            _renderContent: function() {
                if (this._contentAlreadyRendered || !this.option("visible") && this.option("deferRendering"))
                    return;
                this._contentAlreadyRendered = true;
                this.callBase()
            },
            _renderContentImpl: function() {
                var $element = this.element();
                this._$content.append($element.contents()).appendTo($element);
                var contentTemplate = this._getTemplate(this.option("contentTemplate"));
                contentTemplate && contentTemplate.render(this.content());
                this._renderDrag();
                this._renderScrollTerminator()
            },
            _renderDrag: function() {
                var $dragTarget = this._getDragTarget();
                if (!$dragTarget)
                    return;
                var startEventName = events.addNamespace("dxdragstart", this.NAME),
                    updateEventName = events.addNamespace("dxdrag", this.NAME);
                $dragTarget.off(startEventName).off(updateEventName);
                if (!this.option("dragEnabled"))
                    return;
                $dragTarget.on(startEventName, $.proxy(this._dragStartHandler, this)).on(updateEventName, $.proxy(this._dragUpdateHandler, this))
            },
            _renderScrollTerminator: function() {
                var $scrollTerminator = this._wrapper();
                var scrollEventName = events.addNamespace("dxscroll", this.NAME);
                $scrollTerminator.off(scrollEventName).on("dxscroll", {
                    validate: function() {
                        return true
                    },
                    getDirection: function() {
                        return "both"
                    }
                }, function(e) {
                    e.preventDefault()
                })
            },
            _getDragTarget: function() {
                return this.content()
            },
            _dragStartHandler: function(e) {
                e.targetElements = [];
                this._prevOffset = {
                    x: 0,
                    y: 0
                };
                this._dragHandled = true;
                var position = translator.locate(this._$content),
                    allowedOffsets = this._allowedOffsets();
                e.maxLeftOffset = position.left + allowedOffsets.left;
                e.maxRightOffset = -position.left + allowedOffsets.right;
                e.maxTopOffset = position.top + allowedOffsets.top;
                e.maxBottomOffset = -position.top + allowedOffsets.bottom
            },
            _dragUpdateHandler: function(e) {
                var offset = e.offset,
                    prevOffset = this._prevOffset,
                    targetOffset = {
                        top: offset.y - prevOffset.y,
                        left: offset.x - prevOffset.x
                    };
                this._changePosition(targetOffset);
                this._prevOffset = offset
            },
            _changePosition: function(offset) {
                var position = translator.locate(this._$content);
                translator.move(this._$content, {
                    left: position.left + offset.left,
                    top: position.top + offset.top
                })
            },
            _allowedOffsets: function() {
                var $content = this._$content,
                    $container = this._$container,
                    contentWidth = $content.outerWidth(),
                    containerWidth = $container.width(),
                    containerHeight = $container.height();
                return {
                        top: 0,
                        bottom: containerHeight - MIN_OVERLAY_STICK_SIZE,
                        left: contentWidth - MIN_OVERLAY_STICK_SIZE,
                        right: containerWidth - MIN_OVERLAY_STICK_SIZE
                    }
            },
            _fireContentReadyAction: function() {
                if (this.option("visible"))
                    this._moveToContainer();
                this.callBase.apply(this, arguments)
            },
            _moveFromContainer: function() {
                this._$content.appendTo(this.element());
                this._detachWrapperToContainer()
            },
            _detachWrapperToContainer: function() {
                this._$wrapper.detach()
            },
            _moveToContainer: function() {
                this._attachWrapperToContainer();
                this._$content.appendTo(this._$wrapper)
            },
            _attachWrapperToContainer: function() {
                var $element = this.element();
                if (this._$container && !(this._$container[0] === $element.parent()[0]))
                    this._$wrapper.appendTo(this._$container);
                else
                    this._$wrapper.appendTo($element)
            },
            _renderGeometry: function() {
                if (this.option("visible"))
                    this._renderGeometryImpl()
            },
            _renderGeometryImpl: function() {
                this._stopAnimation();
                this._normalizePosition();
                this._renderShading();
                this._renderDimensions();
                this._renderPosition()
            },
            _renderShading: function() {
                var $wrapper = this._$wrapper,
                    $container = this._getContainer();
                $wrapper.css("position", $container.get(0) === window ? "fixed" : "absolute");
                if (this.option("shading"))
                    $wrapper.show();
                this._renderShadingDimensions();
                this._renderShadingPosition()
            },
            _renderShadingPosition: function() {
                if (this.option("shading")) {
                    var $container = this._getContainer();
                    DX.position(this._$wrapper, {
                        my: "top left",
                        at: "top left",
                        of: $container
                    })
                }
            },
            _renderShadingDimensions: function() {
                if (this.option("shading")) {
                    var $container = this._getContainer();
                    this._$wrapper.css({
                        width: $container.outerWidth(),
                        height: $container.outerHeight()
                    })
                }
            },
            _getContainer: function() {
                var position = this._position,
                    container = this.option("container"),
                    positionOf = position ? position.of : null;
                return getElement(container || positionOf)
            },
            _renderDimensions: function() {
                this._$content.outerWidth(this.option("width")).outerHeight(this.option("height"))
            },
            _renderPosition: function() {
                if (this._dragHandled) {
                    var $container = this._$content,
                        position = translator.locate($container),
                        allowedOffsets = this._allowedOffsets();
                    translator.move($container, {
                        top: Math.min(Math.max(-allowedOffsets.top, position.top), allowedOffsets.bottom),
                        left: Math.min(Math.max(-allowedOffsets.left, position.left), allowedOffsets.right)
                    })
                }
                else {
                    translator.resetPosition(this._$content);
                    var position = this._position,
                        containerPosition = DX.calculatePosition(this._$content, position);
                    this._actions.onPositioning({position: containerPosition});
                    var resultPosition = DX.position(this._$content, containerPosition);
                    this._actions.onPositioned({position: resultPosition});
                    forceRepaint(this._$content)
                }
            },
            _focusTarget: function() {
                return this._$content
            },
            _attachKeyboardEvents: function() {
                this._keyboardProcessor = new ui.KeyboardProcessor({
                    element: this._$content,
                    handler: this._keyboardHandler,
                    context: this
                })
            },
            _keyboardHandler: function(options) {
                var e = options.originalEvent,
                    $target = $(e.target);
                if ($target.is(this._$content))
                    this.callBase.apply(this, arguments)
            },
            _dispose: function() {
                this._stopAnimation();
                this._toggleSubscriptions(false);
                this._updateRegistration(false);
                this._actions = null;
                this.callBase();
                this._$wrapper.remove();
                this._$content.remove()
            },
            _toggleDisabledState: function(value) {
                this.callBase.apply(this, arguments);
                this._$content.toggleClass(DISABLED_STATE_CLASS, value)
            },
            _toggleRTLDirection: function(rtl) {
                this._$content.toggleClass(RTL_DIRECTION_CLASS, rtl)
            },
            _optionChanged: function(args) {
                var value = args.value;
                if ($.inArray(args.name, ACTIONS) > -1) {
                    this._initActions();
                    return
                }
                switch (args.name) {
                    case"dragEnabled":
                        this._renderDrag();
                        break;
                    case"shading":
                    case"shadingColor":
                        this._toggleShading(this.option("visible"));
                        break;
                    case"width":
                    case"height":
                    case"position":
                        this._renderGeometry();
                        break;
                    case"visible":
                        delete this._dragHandled;
                        this._renderVisibilityAnimate().done($.proxy(function() {
                            if (!this._animateDeferred)
                                return;
                            this._animateDeferred.resolveWith(this)
                        }, this));
                        break;
                    case"target":
                        this._initTarget(value);
                        this._invalidate();
                        break;
                    case"container":
                        this._initContainer(value);
                        this._invalidate();
                        break;
                    case"deferRendering":
                    case"contentTemplate":
                        this._invalidate();
                        break;
                    case"closeOnBackButton":
                        this._toggleHideTopOverlayCallback(this.option("visible"));
                        break;
                    case"closeOnOutsideClick":
                        this._toggleDocumentDownHandler(this.option("visible"));
                        break;
                    case"closeOnTargetScroll":
                        this._toggleParentsScrollSubscription(this.option("visible"));
                        break;
                    case"animation":
                        break;
                    case"rtlEnabled":
                        this._toggleRTLDirection(value);
                        break;
                    default:
                        this.callBase(args)
                }
            },
            toggle: function(showing) {
                showing = showing === undefined ? !this.option("visible") : showing;
                if (showing === this.option("visible"))
                    return $.Deferred().resolve().promise();
                var animateDeferred = $.Deferred();
                this._animateDeferred = animateDeferred;
                this.option("visible", showing);
                return animateDeferred.promise().done($.proxy(function() {
                        delete this._animateDeferred
                    }, this))
            },
            show: function() {
                return this.toggle(true)
            },
            hide: function() {
                return this.toggle(false)
            },
            content: function() {
                return this._$content
            },
            repaint: function() {
                this._renderGeometry()
            }
        }));
        ui.dxOverlay.__internals = {
            OVERLAY_CLASS: OVERLAY_CLASS,
            OVERLAY_WRAPPER_CLASS: OVERLAY_WRAPPER_CLASS,
            OVERLAY_CONTENT_CLASS: OVERLAY_CONTENT_CLASS,
            OVERLAY_SHADER_CLASS: OVERLAY_SHADER_CLASS,
            OVERLAY_MODAL_CLASS: OVERLAY_MODAL_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.toast.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var TOAST_CLASS = "dx-toast",
            TOAST_CLASS_PREFIX = TOAST_CLASS + "-",
            TOAST_WRAPPER_CLASS = TOAST_CLASS_PREFIX + "wrapper",
            TOAST_CONTENT_CLASS = TOAST_CLASS_PREFIX + "content",
            TOAST_MESSAGE_CLASS = TOAST_CLASS_PREFIX + "message",
            TOAST_ICON_CLASS = TOAST_CLASS_PREFIX + "icon",
            WIDGET_NAME = "dxToast",
            toastTypes = ["info", "warning", "error", "success"],
            Z_INDEX_STACK = [],
            FIRST_Z_INDEX = 9000,
            POSITION_ALIASES = {
                top: {
                    my: "top",
                    at: "top",
                    of: window,
                    offset: "0 0"
                },
                bottom: {
                    my: "bottom",
                    at: "bottom",
                    of: window,
                    offset: "0 -20"
                },
                center: {
                    my: "center",
                    at: "center",
                    of: window,
                    offset: "0 0"
                },
                right: {
                    my: "center right",
                    at: "center right",
                    of: window,
                    offset: "0 0"
                },
                left: {
                    my: "center left",
                    at: "center left",
                    of: window,
                    offset: "0 0"
                }
            };
        DX.registerComponent(WIDGET_NAME, ui, ui.dxOverlay.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    message: "",
                    type: "info",
                    displayTime: 2000,
                    position: "bottom center",
                    animation: {
                        show: {
                            type: "fade",
                            duration: 400,
                            from: 0,
                            to: 1
                        },
                        hide: {
                            type: "fade",
                            duration: 400,
                            to: 0
                        }
                    },
                    shading: false,
                    height: "auto"
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "win8"},
                            options: {
                                position: "top center",
                                width: function() {
                                    return $(window).width()
                                }
                            }
                        }])
            },
            _init: function() {
                this.callBase();
                this._posStringToObject()
            },
            _renderContentImpl: function() {
                if (this.option("message"))
                    this._message = $("<div>").addClass(TOAST_MESSAGE_CLASS).text(this.option("message")).appendTo(this.content());
                if ($.inArray(this.option("type").toLowerCase(), toastTypes) > -1)
                    this.content().prepend($("<div>").addClass(TOAST_ICON_CLASS));
                this.callBase()
            },
            _render: function() {
                this.callBase();
                this.element().addClass(TOAST_CLASS);
                this._wrapper().addClass(TOAST_WRAPPER_CLASS);
                this._$content.addClass(TOAST_CLASS_PREFIX + String(this.option("type")).toLowerCase());
                this.content().addClass(TOAST_CONTENT_CLASS)
            },
            _posStringToObject: function() {
                if (!DX.utils.isString(this.option("position")))
                    return;
                var verticalPosition = this.option("position").split(" ")[0],
                    horizontalPosition = this.option("position").split(" ")[1];
                this.option("position", $.extend({}, POSITION_ALIASES[verticalPosition]));
                switch (horizontalPosition) {
                    case"center":
                    case"left":
                    case"right":
                        this.option("position").at += " " + horizontalPosition;
                        this.option("position").my += " " + horizontalPosition;
                        break
                }
            },
            _show: function() {
                return this.callBase.apply(this, arguments).done($.proxy(function() {
                        clearTimeout(this._hideTimeout);
                        this._hideTimeout = setTimeout($.proxy(function() {
                            this.hide()
                        }, this), this.option("displayTime"))
                    }, this))
            },
            _zIndexStack: function() {
                return Z_INDEX_STACK
            },
            _zIndexInitValue: function() {
                return FIRST_Z_INDEX
            },
            _dispose: function() {
                clearTimeout(this._hideTimeout);
                this.callBase()
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"type":
                        this._$content.removeClass(TOAST_CLASS_PREFIX + args.previousValue);
                        this._$content.addClass(TOAST_CLASS_PREFIX + String(args.value).toLowerCase());
                        break;
                    case"message":
                        if (this._message)
                            this._message.text(args.value);
                        break;
                    case"displayTime":
                    case"position":
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }));
        ui.dxToast.__internals = {
            TOAST_CLASS: TOAST_CLASS,
            TOAST_WRAPPER_CLASS: TOAST_WRAPPER_CLASS,
            TOAST_CONTENT_CLASS: TOAST_CONTENT_CLASS,
            TOAST_MESSAGE_CLASS: TOAST_MESSAGE_CLASS,
            TOAST_ICON_CLASS: TOAST_ICON_CLASS,
            TOAST_CLASS_PREFIX: TOAST_CLASS_PREFIX,
            WIDGET_NAME: WIDGET_NAME
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.popup.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            translator = DX.translator;
        var POPUP_CLASS = "dx-popup",
            POPUP_WRAPPER_CLASS = "dx-popup-wrapper",
            POPUP_FULL_SCREEN_CLASS = "dx-popup-fullscreen",
            POPUP_CONTENT_CLASS = "dx-popup-content",
            POPUP_DRAGGABLE_CLASS = "dx-popup-draggable",
            POPUP_TITLE_CLASS = "dx-popup-title",
            POPUP_TITLE_CLOSEBUTTON_CLASS = "dx-closebutton",
            POPUP_TITLE_HAS_BUTTON_CLASS = "dx-popup-title-has-button",
            POPUP_BOTTOM_CLASS = "dx-popup-bottom";
        var ALLOWED_BUTTON_ALIASES = ["close", "cancel", "clear", "done"];
        var getButtonPlace = function(name) {
                if (name === "close")
                    return {
                            toolbar: "top",
                            location: "after"
                        };
                var device = DX.devices.current(),
                    toolbar = "bottom",
                    location = "before";
                if (device.ios)
                    switch (name) {
                        case"cancel":
                            toolbar = "top";
                            break;
                        case"clear":
                            toolbar = "top";
                            location = "after";
                            break;
                        case"done":
                            location = "after";
                            break
                    }
                else if (device.android && device.version && parseInt(device.version[0]) > 4)
                    switch (name) {
                        case"cancel":
                            location = "after";
                            break;
                        case"done":
                            location = "after";
                            break
                    }
                else if (device.android || device.tizen)
                    location = "center";
                return {
                        toolbar: toolbar,
                        location: location
                    }
            };
        DX.registerComponent("dxPopup", ui, ui.dxOverlay.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    fullScreen: false,
                    title: "",
                    showTitle: true,
                    titleTemplate: "title",
                    onTitleRendered: null,
                    dragEnabled: false,
                    buttons: [],
                    bottomTemplate: "bottom"
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "win8"},
                            options: {width: function() {
                                    return $(window).width()
                                }}
                        }, {
                            device: {
                                platform: "win8",
                                phone: true
                            },
                            options: {position: {
                                    my: "top center",
                                    at: "top center",
                                    of: window,
                                    offset: "0 0"
                                }}
                        }, {
                            device: {platform: "ios"},
                            options: {animation: this._iosAnimation}
                        }, {
                            device: function(device) {
                                return DX.devices.real().platform === "generic" && device.platform === "generic"
                            },
                            options: {dragEnabled: true}
                        }, {
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }])
            },
            _iosAnimation: {
                show: {
                    type: "slide",
                    duration: 400,
                    from: {position: {
                            my: "top",
                            at: "bottom",
                            of: window
                        }},
                    to: {position: {
                            my: "center",
                            at: "center",
                            of: window
                        }}
                },
                hide: {
                    type: "slide",
                    duration: 400,
                    from: {
                        opacity: 1,
                        position: {
                            my: "center",
                            at: "center",
                            of: window
                        }
                    },
                    to: {
                        opacity: 1,
                        position: {
                            my: "top",
                            at: "bottom",
                            of: window
                        }
                    }
                }
            },
            _init: function() {
                this.callBase();
                this._$popupContent = this._$content.wrapInner($("<div>").addClass(POPUP_CONTENT_CLASS)).children().eq(0)
            },
            _render: function() {
                this.element().addClass(POPUP_CLASS);
                this._wrapper().addClass(POPUP_WRAPPER_CLASS);
                this._$content.toggleClass(POPUP_DRAGGABLE_CLASS, this.option("dragEnabled")).toggleClass(POPUP_FULL_SCREEN_CLASS, this.option("fullScreen"));
                this.callBase()
            },
            _renderContentImpl: function() {
                this._renderTitle();
                this._renderBottom();
                this.callBase()
            },
            _renderTitle: function() {
                if (this.option("showTitle")) {
                    var items = this._getToolbarItems("top");
                    items.unshift({
                        location: DX.devices.current().ios ? "center" : "before",
                        text: this.option("title")
                    });
                    this._$title && this._$title.remove();
                    this._$title = $("<div>").addClass(POPUP_TITLE_CLASS).prependTo(this._$content);
                    var $result = this._getTemplateByOption("titleTemplate").render(items, this._$title);
                    if ($result.length) {
                        this._$title.replaceWith($result.addClass(POPUP_TITLE_CLASS));
                        this._$title = $result
                    }
                    this._executeTitleRenderAction(this._$title)
                }
                else if (this._$title)
                    this._$title.detach()
            },
            _executeTitleRenderAction: function(titleElement) {
                this._getTitleRenderAction()({titleElement: titleElement})
            },
            _getTitleRenderAction: function() {
                return this._titleRenderAction || this._createTitleRenderAction()
            },
            _createTitleRenderAction: function() {
                return this._titleRenderAction = this._createActionByOption("onTitleRendered", {
                        element: this.element(),
                        excludeValidators: ["designMode", "disabled"]
                    })
            },
            _getToolbarItems: function(toolbar) {
                var buttons = this.option("buttons");
                var toolbarsItems = [];
                this._buttonsClasses = [];
                var currentDevice = DX.devices.current(),
                    index = 0;
                $.each(buttons, $.proxy(function(_, data) {
                    var isShortcut = DX.utils.isDefined(data.shortcut),
                        item = isShortcut ? getButtonPlace(data.shortcut) : data;
                    if (isShortcut && currentDevice.ios && index < 2) {
                        item.toolbar = "top";
                        index++
                    }
                    if (item && item.toolbar === toolbar) {
                        if (isShortcut)
                            $.extend(item, {location: data.location}, this._getButtonByAlias(data));
                        var isWin8 = currentDevice.win8;
                        if (data.shortcut === "done" && isWin8 || data.shortcut === "cancel" && !isWin8)
                            toolbarsItems.unshift(item);
                        else
                            toolbarsItems.push(item)
                    }
                }, this));
                return toolbarsItems
            },
            _getButtonByAlias: function(data) {
                var buttonType = data.shortcut;
                if ($.inArray(buttonType, ALLOWED_BUTTON_ALIASES) < 0)
                    return false;
                var buttonOptions = {},
                    buttonClass;
                if (buttonType !== "close") {
                    buttonClass = POPUP_CLASS + "-" + buttonType;
                    $.extend(buttonOptions, {text: Globalize.localize(DX.inflector.camelize(buttonType, true))}, DX.utils.isDefined(data.options) ? data.options : {});
                    this._buttonsClasses.push(buttonClass)
                }
                else
                    buttonClass = POPUP_TITLE_CLOSEBUTTON_CLASS;
                $.extend(buttonOptions, {onClick: this._createButtonAction(data.onClick)});
                var $button = $("<div>").addClass(buttonClass).dxButton(buttonOptions);
                return {template: function(_, __, $container) {
                            $container.append($button)
                        }}
            },
            _createButtonAction: function(clickAction) {
                return this._createAction(clickAction, {afterExecute: function(e) {
                            e.component.hide()
                        }})
            },
            _renderBottom: function() {
                var items = this._getToolbarItems("bottom");
                if (items.length) {
                    this._$bottom && this._$bottom.remove();
                    this._$bottom = $("<div>").addClass(POPUP_BOTTOM_CLASS).appendTo(this._$content);
                    var $result = this._getTemplateByOption("bottomTemplate").render(items, this._$bottom);
                    if ($result.length) {
                        this._$bottom.replaceWith($result.addClass(POPUP_BOTTOM_CLASS));
                        this._$bottom = $result
                    }
                    this._toggleClasses()
                }
                else
                    this._$bottom && this._$bottom.detach()
            },
            _toggleClasses: function() {
                var aliases = ALLOWED_BUTTON_ALIASES.slice(1);
                $.each(aliases, $.proxy(function(_, alias) {
                    var className = POPUP_CLASS + "-" + alias;
                    if ($.inArray(className, this._buttonsClasses) >= 0) {
                        this._wrapper().addClass(className + "-visible");
                        this._$bottom.addClass(className)
                    }
                    else {
                        this._wrapper().removeClass(className + "-visible");
                        this._$bottom.removeClass(className)
                    }
                }, this))
            },
            _getDragTarget: function() {
                return this._$title
            },
            _renderGeometryImpl: function() {
                this.callBase.apply(this, arguments);
                this._setContentHeight()
            },
            _renderDimensions: function() {
                if (this.option("fullScreen"))
                    this._$content.css({
                        width: "100%",
                        height: "100%"
                    });
                else
                    this.callBase.apply(this, arguments)
            },
            _renderShadingDimensions: function() {
                if (this.option("fullScreen"))
                    this._wrapper().css({
                        width: "100%",
                        height: "100%"
                    });
                else
                    this.callBase.apply(this, arguments)
            },
            _renderPosition: function() {
                if (this.option("fullScreen"))
                    translator.move(this._$content, {
                        top: 0,
                        left: 0
                    });
                else
                    this.callBase.apply(this, arguments)
            },
            _setContentHeight: function() {
                if (!this._$popupContent)
                    return;
                var contentHeight = this._$content.height();
                if (this._$title)
                    contentHeight -= this._$title.outerHeight(true) || 0;
                if (this._$bottom) {
                    var bottomButtonsMargin = this._$bottom.outerHeight(true) || 0;
                    contentHeight -= bottomButtonsMargin;
                    this._$popupContent.css("margin-bottom", bottomButtonsMargin)
                }
                if (this.option("height") === "auto")
                    this._$popupContent.css("height", "auto");
                else if (contentHeight > 0)
                    this._$popupContent.css("height", contentHeight)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"showTitle":
                    case"title":
                    case"titleTemplate":
                        this._renderTitle();
                        this._setContentHeight();
                        break;
                    case"bottomTemplate":
                        this._renderBottom();
                        this._setContentHeight();
                        break;
                    case"onTitleRendered":
                        this._createTitleRenderAction(args.value);
                        break;
                    case"buttons":
                        this._renderTitle();
                        this._renderBottom();
                        this._setContentHeight();
                        break;
                    case"dragEnabled":
                        this._renderDrag();
                        break;
                    case"height":
                        this.callBase(args);
                        this._setContentHeight();
                        break;
                    case"fullScreen":
                        this._$content.toggleClass(POPUP_FULL_SCREEN_CLASS, args.value);
                        this._refresh();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            content: function() {
                return this._$popupContent
            },
            overlayContent: function() {
                return this._$content
            }
        }));
        ui.dxPopup.__internals = {
            POPUP_CLASS: POPUP_CLASS,
            POPUP_WRAPPER_CLASS: POPUP_WRAPPER_CLASS,
            POPUP_CONTENT_CLASS: POPUP_CONTENT_CLASS,
            POPUP_FULL_SCREEN_CLASS: POPUP_FULL_SCREEN_CLASS,
            POPUP_TITLE_CLASS: POPUP_TITLE_CLASS,
            POPUP_BOTTOM_CLASS: POPUP_BOTTOM_CLASS,
            POPUP_TITLE_CLOSEBUTTON_CLASS: POPUP_TITLE_CLOSEBUTTON_CLASS,
            POPUP_TITLE_HAS_BUTTON_CLASS: POPUP_TITLE_HAS_BUTTON_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.popover.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx;
        var POPOVER_CLASS = "dx-popover",
            POPOVER_WRAPPER_CLASS = "dx-popover-wrapper",
            POPOVER_ARROW_CLASS = "dx-popover-arrow",
            POPOVER_WITHOUT_TITLE_CLASS = "dx-popover-without-title",
            POSITION_FLIP_MAP = {
                left: "right",
                top: "bottom",
                right: "left",
                bottom: "top"
            },
            POSITION_ALIASES = {
                top: {
                    my: "bottom center",
                    at: "top center"
                },
                bottom: {
                    my: "top center",
                    at: "bottom center"
                },
                right: {
                    my: "left center",
                    at: "right center"
                },
                left: {
                    my: "right center",
                    at: "left center"
                },
                topNone: {
                    my: "bottom center",
                    at: "top center",
                    collision: "none"
                },
                bottomNone: {
                    my: "top center",
                    at: "bottom center",
                    collision: "none"
                },
                rightNone: {
                    my: "left center",
                    at: "right center",
                    collision: "none"
                },
                leftNone: {
                    my: "right center",
                    at: "left center",
                    collision: "none"
                }
            },
            DEFAULT_VIEWPORT_OFFSET = "10 10",
            ARROW_OFFSET_CORRECTION = {
                top: "0 -1",
                bottom: "0 1",
                left: "-1 0",
                right: "1 0"
            };
        DX.registerComponent("dxPopover", ui, ui.dxPopup.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    target: window,
                    shading: false,
                    position: 'bottom',
                    closeOnOutsideClick: true,
                    animation: {
                        show: {
                            type: "fade",
                            from: 0,
                            to: 1
                        },
                        hide: {
                            type: "fade",
                            to: 0
                        }
                    },
                    showTitle: false,
                    width: "auto",
                    height: "auto",
                    dragEnabled: false,
                    fullScreen: false,
                    closeOnTargetScroll: true,
                    arrowPosition: null
                })
            },
            _defaultOptionsRules: function() {
                return []
            },
            _render: function() {
                this.element().addClass(POPOVER_CLASS);
                this._wrapper().addClass(POPOVER_WRAPPER_CLASS);
                this._renderArrow();
                this.callBase()
            },
            _renderArrow: function() {
                this._$arrow = $("<div>").addClass(POPOVER_ARROW_CLASS).appendTo(this._wrapper())
            },
            _setContentHeight: function(fullUpdate) {
                if (fullUpdate)
                    this.callBase()
            },
            _updateContentSize: function(containerLocation) {
                if (!this._$popupContent)
                    return;
                var positionAt = this._position.at.split(" ")[0];
                if (containerLocation.h.oversize > 0 && (positionAt === "left" || positionAt === "right")) {
                    var newContainerWidth = this._$content.width() - containerLocation.h.oversize;
                    this._$content.width(newContainerWidth)
                }
                if (containerLocation.v.oversize > 0 && (positionAt === "top" || positionAt === "bottom")) {
                    var titleSize = this._$title ? this._$title.outerHeight() : 0,
                        newContainerHeight = this._$content.height() - containerLocation.v.oversize;
                    this._$content.height(newContainerHeight);
                    this._$popupContent.outerHeight(newContainerHeight - titleSize)
                }
            },
            _documentDownHandler: function(e) {
                if (this._isOutsideClick(e))
                    this.callBase(e)
            },
            _isOutsideClick: function(e) {
                return !$(e.target).closest(this.option("target")).length
            },
            _animate: function(animation) {
                if (animation)
                    DX.fx.animate(this._$arrow, $.extend({}, animation, {complete: $.noop}));
                if (animation && animation.to)
                    $.extend(animation.to, {position: this._contentPosition});
                this.callBase.apply(this, arguments)
            },
            _stopAnimation: function() {
                this.callBase.apply(this, arguments);
                fx.stop(this._$arrow)
            },
            _renderTitle: function() {
                this._wrapper().toggleClass(POPOVER_WITHOUT_TITLE_CLASS, !this.option("showTitle"));
                this.callBase()
            },
            _isPopoverLargerThanTarget: function() {
                var position = this._position.at.split(" ")[0],
                    $target = $(this._position.of),
                    popoverSize,
                    targetSize;
                switch (position) {
                    case"top":
                    case"bottom":
                        popoverSize = this._$content.width();
                        targetSize = $target.outerWidth() + this._$arrow.width();
                        break;
                    case"left":
                    case"right":
                        popoverSize = this._$content.height();
                        targetSize = $target.outerHeight() + this._$arrow.height();
                        break
                }
                return popoverSize > targetSize / 2
            },
            _renderPosition: function() {
                this.callBase();
                this._renderOverlayPosition();
                this._renderArrowPosition()
            },
            _renderOverlayPosition: function() {
                this._setContentHeight(true);
                this._togglePositionClass("dx-position-" + this._positionAlias);
                DX.translator.move(this._$arrow, {
                    left: 0,
                    top: 0
                });
                DX.translator.move(this._$content, {
                    left: 0,
                    top: 0
                });
                var contentPosition = $.extend({}, this._position);
                var containerPosition = $.extend({}, contentPosition, {offset: this._$arrow.width() + " " + this._$arrow.height()}),
                    containerLocation = DX.calculatePosition(this._$content, containerPosition),
                    isFlippedByVertical = containerLocation.v.flip,
                    isFlippedByHorizontal = containerLocation.h.flip;
                this._updateContentSize(containerLocation);
                if (this._position.collision === "flip")
                    contentPosition.collision = "fit";
                var positionClass = "dx-position-" + (isFlippedByVertical || isFlippedByHorizontal ? POSITION_FLIP_MAP[this._positionAlias] : this._positionAlias);
                this._togglePositionClass(positionClass);
                if (isFlippedByVertical || isFlippedByHorizontal)
                    $.extend(contentPosition, {
                        my: contentPosition.at,
                        at: contentPosition.my
                    });
                contentPosition.offset = this._updateContentOffset(isFlippedByVertical, isFlippedByHorizontal, contentPosition.offset);
                DX.position(this._$content, contentPosition);
                this._contentPosition = contentPosition
            },
            _renderArrowPosition: function() {
                var position = this._getDefaultArrowPosition(),
                    arrowPosition = this.option("arrowPosition");
                if (arrowPosition) {
                    var contentPositionAt = this._contentPosition.at.split(" ")[0],
                        arrowPositionAt = arrowPosition.at,
                        isFlipped = arrowPositionAt && arrowPositionAt.split(" ")[0] === contentPositionAt;
                    if (isFlipped) {
                        arrowPosition.at = arrowPosition.my;
                        arrowPosition.my = arrowPositionAt
                    }
                    var fullOffset = this._mergeOffsets(ARROW_OFFSET_CORRECTION[contentPositionAt], arrowPosition.offset);
                    $.extend(position, arrowPosition, {
                        of: this._$content,
                        offset: fullOffset
                    })
                }
                DX.position(this._$arrow, position)
            },
            _getDefaultArrowPosition: function() {
                var isPopoverLarger = this._isPopoverLargerThanTarget(),
                    contentPositionMy = this._contentPosition.my.split(" ")[0],
                    contentPositionAt = this._contentPosition.at.split(" ")[0];
                var position;
                if (isPopoverLarger)
                    position = {
                        my: contentPositionMy,
                        at: contentPositionAt,
                        of: $(this.option("target"))
                    };
                else
                    position = {
                        my: contentPositionAt,
                        at: contentPositionMy,
                        of: this._$content,
                        offset: ARROW_OFFSET_CORRECTION[contentPositionAt]
                    };
                position.my += " center";
                position.at += " center";
                return position
            },
            _mergeOffsets: function(baseOffset, additionalOffset) {
                if (!additionalOffset)
                    return baseOffset;
                var base = this._getOffsetObject(baseOffset),
                    addition = this._getOffsetObject(additionalOffset);
                return base.h + addition.h + " " + (base.v + addition.v)
            },
            _renderShadingPosition: function() {
                if (this.option("shading"))
                    this._$wrapper.css({
                        top: 0,
                        left: 0
                    })
            },
            _renderShadingDimensions: function() {
                if (this.option("shading"))
                    this._$wrapper.css({
                        width: "100%",
                        height: "100%"
                    })
            },
            _togglePositionClass: function(positionClass) {
                this._$wrapper.removeClass("dx-position-left dx-position-right dx-position-top dx-position-bottom");
                this._$wrapper.addClass(positionClass)
            },
            _normalizePosition: function() {
                var position = this.option("position");
                if (DX.utils.isString(position))
                    position = $.extend({}, POSITION_ALIASES[position]);
                if (!position.of)
                    position.of = this.option("target");
                if (!position.collision)
                    position.collision = "flip";
                if (!position.boundaryOffset)
                    position.boundaryOffset = DEFAULT_VIEWPORT_OFFSET;
                this._positionAlias = position.at.split(" ")[0];
                this._position = position
            },
            _getOffsetObject: function(offset) {
                return DX.utils.stringPairToObject(offset)
            },
            _updateContentOffset: function(isFlippedByVertical, isFlippedByHorizontal, offsetString) {
                var position = this._positionAlias,
                    offset = this._getOffsetObject(offsetString),
                    signCorrectionH = isFlippedByHorizontal ? -1 : 1,
                    signCorrectionV = isFlippedByVertical ? -1 : 1;
                var isTopPosition = position === "top" && !isFlippedByVertical || position === "bottom" && isFlippedByVertical,
                    isBottomPosition = position === "bottom" && !isFlippedByVertical || position === "top" && isFlippedByVertical,
                    isLeftPosition = position === "left" && !isFlippedByHorizontal || position === "right" && isFlippedByHorizontal,
                    isRightPosition = position === "right" && !isFlippedByHorizontal || position === "left" && isFlippedByHorizontal;
                if (isTopPosition)
                    return offset.h + " " + (offset.v * signCorrectionV - (this._$arrow.height() - 1));
                if (isBottomPosition)
                    return offset.h + " " + (offset.v * signCorrectionV + (this._$arrow.height() - 1));
                if (isLeftPosition)
                    return offset.h * signCorrectionH - (this._$arrow.width() - 1) + " " + offset.v;
                if (isRightPosition)
                    return offset.h * signCorrectionH + (this._$arrow.width() - 1) + " " + offset.v
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"showTitle":
                    case"title":
                    case"titleTemplate":
                        this.callBase(args);
                        this._normalizePosition();
                        this._renderPosition();
                        break;
                    case"target":
                        this._normalizePosition();
                        this._renderPosition();
                        break;
                    case"arrowPosition":
                        this._renderArrowPosition();
                        break;
                    case"fullScreen":
                        if (args.value)
                            this.option("fullScreen", false);
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }));
        ui.dxPopover.__internals = {
            POPOVER_CLASS: POPOVER_CLASS,
            POPOVER_WRAPPER_CLASS: POPOVER_WRAPPER_CLASS,
            POPOVER_ARROW_CLASS: POPOVER_ARROW_CLASS,
            POPOVER_WITHOUT_TITLE_CLASS: POPOVER_WITHOUT_TITLE_CLASS,
            DEFAULT_VIEWPORT_OFFSET: DEFAULT_VIEWPORT_OFFSET
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.tooltip.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            TOOLTIP_CLASS = "dx-tooltip",
            TOOLTIP_WRAPPER_CLASS = TOOLTIP_CLASS + "-wrapper",
            Z_INDEX_STACK = [],
            FIRST_Z_INDEX = 500;
        DX.registerComponent("dxTooltip", ui, ui.dxPopover.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    showTitle: false,
                    title: undefined,
                    titleTemplate: undefined,
                    bottomTemplate: undefined
                })
            },
            _render: function() {
                this.element().addClass(TOOLTIP_CLASS);
                this._wrapper().addClass(TOOLTIP_WRAPPER_CLASS);
                this.callBase()
            },
            _zIndexStack: function() {
                return Z_INDEX_STACK
            },
            _zIndexInitValue: function() {
                return FIRST_Z_INDEX
            }
        }));
        ui.dxTooltip.__internals = {
            TOOLTIP_CLASS: TOOLTIP_CLASS,
            TOOLTIP_WRAPPER_CLASS: TOOLTIP_WRAPPER_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.dateUtils.js */
    (function($, DX, undefined) {
        var dateCopmotents = function() {
                return ["year", "day", "month", "day"]
            };
        var dateUtils = DX.ui.dateUtils = {
                SUPPORTED_FORMATS: ["date", "time", "datetime"],
                DEFAULT_FORMATTER: function(value) {
                    return value
                },
                DATE_COMPONENT_TEXT_FORMATTER: function(value, name) {
                    var $container = $("<div>").addClass("dx-dateview-formatter-container");
                    $("<span>").text(value).addClass("dx-dateview-value-formatter").appendTo($container);
                    $("<span>").text(name).addClass("dx-dateview-name-formatter").appendTo($container);
                    return $container
                },
                ONE_MINUTE: 1000 * 60,
                ONE_DAY: 1000 * 60 * 60 * 24,
                TEN_YEARS: 1000 * 60 * 60 * 24 * 365 * 10,
                FORMATS_INFO: {
                    date: {
                        standardPattern: "yyyy-MM-dd",
                        components: dateCopmotents()
                    },
                    time: {
                        standardPattern: "HH:mm",
                        components: ["hours", "minutes"]
                    },
                    datetime: {
                        standardPattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss'Z'",
                        components: dateCopmotents().concat(["hours", "minutes", "seconds", "milliseconds"])
                    },
                    "datetime-local": {
                        standardPattern: "yyyy'-'MM'-'dd'T'HH':'mm",
                        components: dateCopmotents().concat(["hours", "minutes", "seconds"])
                    }
                },
                FORMATS_MAP: {
                    date: "d",
                    time: "t",
                    datetime: "S",
                    "datetime-local": "f"
                },
                toStandardDateFormat: function(date, mode, pattern) {
                    pattern = pattern || dateUtils.FORMATS_INFO[mode].standardPattern;
                    var datePattern = dateUtils.FORMATS_INFO[mode].standardPattern;
                    return Globalize.format(date, pattern)
                },
                fromStandardDateFormat: function(date) {
                    return Globalize.parseDate(date, dateUtils.FORMATS_INFO["datetime"].standardPattern) || Globalize.parseDate(date, dateUtils.FORMATS_INFO["datetime-local"].standardPattern) || Globalize.parseDate(date, dateUtils.FORMATS_INFO["time"].standardPattern) || Globalize.parseDate(date, dateUtils.FORMATS_INFO["date"].standardPattern) || Date.parse && Date.parse(date) && new Date(Date.parse(date))
                },
                getMaxMonthDay: function(year, month) {
                    return new Date(year, month + 1, 0).getDate()
                },
                mergeDates: function(target, source, format) {
                    if (!source)
                        return undefined;
                    if (isNaN(target.getTime()))
                        target = new Date(0, 0, 0, 0, 0, 0);
                    var formatInfo = dateUtils.FORMATS_INFO[format];
                    $.each(formatInfo.components, function() {
                        var componentInfo = dateUtils.DATE_COMPONENTS_INFO[this];
                        target[componentInfo.setter](source[componentInfo.getter]())
                    });
                    return target
                },
                getLongestCaptionIndex: function(captionArray) {
                    var longestIndex = 0,
                        longestCaptionLength = 0,
                        i;
                    for (i = 0; i < captionArray.length; ++i)
                        if (captionArray[i].length > longestCaptionLength) {
                            longestIndex = i;
                            longestCaptionLength = captionArray[i].length
                        }
                    return longestIndex
                },
                expandPattern: function(pattern) {
                    return pattern.length === 1 ? Globalize.culture().calendar.patterns[pattern] : pattern
                },
                formatUsesMonthName: function(format) {
                    return dateUtils.expandPattern(format).indexOf("MMMM") !== -1
                },
                formatUsesDayName: function(format) {
                    return dateUtils.expandPattern(format).indexOf("dddd") !== -1
                },
                getLongestDate: function(format, monthNames, dayNames) {
                    var longestDate = new Date(1888, dateUtils.formatUsesMonthName(format) ? dateUtils.getLongestCaptionIndex(monthNames) : 9, 28 - 7, 23, 59, 59, 999);
                    if (dateUtils.formatUsesDayName(format))
                        longestDate.setDate(longestDate.getDate() - longestDate.getDay() + dateUtils.getLongestCaptionIndex(dayNames));
                    return longestDate
                },
                calculateMaximumDateFormatWidth: function(format, customFontStyles, rootElement) {
                    if (!rootElement || $(rootElement).is(":visible")) {
                        var width,
                            ieRoundingError = 2,
                            longestTextDiv = $("<div>" + Globalize.format(dateUtils.getLongestDate(format, Globalize.culture().calendar.months.names, Globalize.culture().calendar.days.names), format) + "</div>").css({
                                visibility: "hidden",
                                "white-space": "nowrap",
                                position: "absolute",
                                float: "left"
                            });
                        if (customFontStyles)
                            longestTextDiv.css(customFontStyles);
                        longestTextDiv.appendTo(rootElement ? $(rootElement) : $("body"));
                        width = longestTextDiv.width() + ieRoundingError;
                        longestTextDiv.remove();
                        return width
                    }
                }
            };
        dateUtils.DATE_COMPONENTS_INFO = {
            year: {
                getter: "getFullYear",
                setter: "setFullYear",
                possibleFormats: ["yy", "yyyy"],
                formatter: dateUtils.DEFAULT_FORMATTER,
                startValue: undefined,
                endValue: undefined
            },
            day: {
                getter: "getDate",
                setter: "setDate",
                possibleFormats: ["d", "dd"],
                formatter: function(value, showNames, date) {
                    if (!showNames)
                        return value;
                    var formatDate = new Date(date.getTime());
                    formatDate.setDate(value);
                    return dateUtils.DATE_COMPONENT_TEXT_FORMATTER(value, Globalize.culture().calendar.days.names[formatDate.getDay()])
                },
                startValue: 1,
                endValue: undefined
            },
            month: {
                getter: "getMonth",
                setter: "setMonth",
                possibleFormats: ["M", "MM", "MMM", "MMMM"],
                formatter: function(value, showNames) {
                    var monthName = Globalize.culture().calendar.months.names[value];
                    return showNames ? dateUtils.DATE_COMPONENT_TEXT_FORMATTER(value + 1, monthName) : monthName
                },
                startValue: 0,
                endValue: 11
            },
            hours: {
                getter: "getHours",
                setter: "setHours",
                possibleFormats: ["H", "HH", "h", "hh"],
                formatter: function(value) {
                    return Globalize.format(new Date(0, 0, 0, value), "HH")
                },
                startValue: 0,
                endValue: 23
            },
            minutes: {
                getter: "getMinutes",
                setter: "setMinutes",
                possibleFormats: ["m", "mm"],
                formatter: function(value) {
                    return Globalize.format(new Date(0, 0, 0, 0, value), "mm")
                },
                startValue: 0,
                endValue: 59
            },
            seconds: {
                getter: "getSeconds",
                setter: "setSeconds",
                possibleFormats: ["s", "ss"],
                formatter: function(value) {
                    return Globalize.format(new Date(0, 0, 0, 0, 0, value), "ss")
                },
                startValue: 0,
                endValue: 59
            },
            milliseconds: {
                getter: "getMilliseconds",
                setter: "setMilliseconds",
                possibleFormats: ["f", "ff", "fff"],
                formatter: function(value) {
                    return Globalize.format(new Date(0, 0, 0, 0, 0, 0, value), "fff")
                },
                startValue: 0,
                endValue: 999
            }
        };
        (function androidFormatDetection() {
            var androidFormatPattern = "yyyy'-'MM'-'dd'T'HH':'mm'Z'";
            var $input = $("<input>").attr("type", "datetime");
            $input.val(dateUtils.toStandardDateFormat(new Date, "datetime", androidFormatPattern));
            if (!$input.val())
                dateUtils.FORMATS_INFO.datetime.standardPattern = androidFormatPattern
        })()
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.calendar.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx,
            support = DX.support,
            events = ui.events,
            utils = DX.utils,
            CALENDAR_CLASS = "dx-calendar",
            CALENDAR_BODY_CLASS = CALENDAR_CLASS + "-body",
            CALENDAR_NAVIGATOR_CLASS = CALENDAR_CLASS + "-navigator",
            CALENDAR_OTHER_MONTH_CLASS = CALENDAR_CLASS + "-other-month",
            CALENDAR_CELL_CLASS = CALENDAR_CLASS + "-cell",
            CALENDAR_EMPTY_CELL_CLASS = CALENDAR_CLASS + "-empty-cell",
            CALENDAR_DISABLED_NAVIGATOR_LINK_CLASS = CALENDAR_CLASS + "-disabled-navigator-link",
            CALENDAR_TODAY_CLASS = CALENDAR_CLASS + "-today",
            CALENDAR_SELECTED_DATE_CLASS = CALENDAR_CLASS + "-selected-date",
            CALENDAR_CONTOURED_DATE_CLASS = CALENDAR_CLASS + "-contoured-date",
            CALENDAR_NAVIGATOR_PREVIOUS_YEAR_CLASS = CALENDAR_NAVIGATOR_CLASS + "-previous-year",
            CALENDAR_NAVIGATOR_PREVIOUS_MONTH_CLASS = CALENDAR_NAVIGATOR_CLASS + "-previous-month",
            CALENDAR_NAVIGATOR_NEXT_MONTH_CLASS = CALENDAR_NAVIGATOR_CLASS + "-next-month",
            CALENDAR_NAVIGATOR_NEXT_YEAR_CLASS = CALENDAR_NAVIGATOR_CLASS + "-next-year",
            CALENDAR_MONTHVIEW_VALUECHANGED_EVENT_NAME = "dxCalendar.MonthView.ValueChanged",
            CALENDAR_MONTHVIEW_CONTOUREDDATECHANGED_EVENT_NAME = "dxCalendar.MonthView.ContouredDateChanged",
            CALENDAR_DXCLICK_EVENT_NAME = events.addNamespace("dxclick", "dxCalendar"),
            CALENDAR_BLUR_EVENT_NAME = events.addNamespace("blur", "dxCalendar");
        var MONTH_VIEW_ANIMATION_DURATION = 300;
        var SwipePosition = {
                LEFT: -1,
                RIGHT: 1
            };
        var BaseView = DX.Class.inherit({
                ctor: function(options) {
                    this.date = options.date || new Date;
                    this.rtl = options.rtl
                },
                render: function(rootElement) {
                    this.rootElement = $(rootElement);
                    this.renderCore()
                },
                renderCore: $.noop
            });
        var views = {MonthView: BaseView.inherit({
                    ctor: function(options) {
                        options = options || {};
                        this.callBase(options);
                        this.firstDayOfWeek = options.firstDayOfWeek || 0;
                        if (options.keyDownProcessor && !options.disabled)
                            this.keyDownProcessor = options.keyDownProcessor.reinitialize(this.keyDownHandler, this);
                        if (options.contouredDate)
                            this.contouredDate = this.calculateContouredDate(options.contouredDate, options.value);
                        this.weeks = 6;
                        this.days = 7;
                        this.initialValue = options.value;
                        this.value = new Date(options.value);
                        if (!this.value.valueOf())
                            this.value = new Date(0, 0, 0, 0, 0, 0);
                        this.keyboardNavigationUsed = options.keyboardNavigationUsed;
                        this.min = options.min;
                        this.max = options.max;
                        this.disabled = options.disabled
                    },
                    dispose: function() {
                        if (this.keyDownProcessor)
                            this.keyDownProcessor.dispose();
                        this.table.remove()
                    },
                    detachKeyDownProcessor: function() {
                        var processor = this.keyDownProcessor;
                        this.keyDownProcessor = undefined;
                        return processor
                    },
                    renderCore: function() {
                        var that = this;
                        this.table = $("<table>");
                        this.renderHeader();
                        this.renderBody();
                        this.setValue(this.initialValue);
                        if (!this.disabled)
                            this.table.off(CALENDAR_DXCLICK_EVENT_NAME).on(CALENDAR_DXCLICK_EVENT_NAME, "td", function(e) {
                                that.cellClickHandler(e)
                            });
                        if (!this.keyDownProcessor && !this.disabled)
                            this.keyDownProcessor = new ui.KeyboardProcessor({
                                element: this.table,
                                handler: this.keyDownHandler,
                                context: this
                            });
                        this.setContouredDate(this.contouredDate, true);
                        this.rootElement.append(this.table)
                    },
                    renderHeader: function() {
                        var that = this,
                            $header = $("<thead>").appendTo(this.table),
                            $headerRow = $("<tr>").appendTo($header);
                        this.iterateDays(function(i) {
                            $("<th>").text(that.getDayCaption(that.firstDayOfWeek + i)).appendTo($headerRow)
                        })
                    },
                    renderBody: function() {
                        var that = this,
                            $tbody = $("<tbody>").appendTo(this.table),
                            $row,
                            cellDate,
                            today = new Date;
                        for (var i = 0; i < this.weeks; ++i) {
                            $row = $("<tr>").appendTo($tbody);
                            this.iterateDays(function(j) {
                                cellDate = that.getDate(i, j);
                                $("<td>").appendTo($row).addClass(CALENDAR_CELL_CLASS).toggleClass(CALENDAR_TODAY_CLASS, utils.sameMonthAndYear(cellDate, today) && cellDate.getDate() === today.getDate()).toggleClass(CALENDAR_EMPTY_CELL_CLASS, !utils.dateInRange(cellDate, that.min, that.max)).toggleClass(CALENDAR_OTHER_MONTH_CLASS, cellDate.getMonth() !== that.date.getMonth()).attr("data-value", that.getShortDate(cellDate)).text(cellDate.getDate())
                            })
                        }
                    },
                    getDayCaption: function(day) {
                        day = day < 7 ? day : Math.abs(day % 7);
                        return Globalize.culture().calendar.days.namesShort[day]
                    },
                    getNavigatorCaption: function() {
                        var navigatorMonth = Globalize.culture().calendar.months.names[this.date.getMonth()],
                            navigatorYear = this.date.getFullYear();
                        return this.rtl ? navigatorYear + " " + navigatorMonth : navigatorMonth + " " + navigatorYear
                    },
                    getDate: function(week, day) {
                        var firstDay = utils.getFirstMonthDate(this.date),
                            firstMonthDayPosition = firstDay.getDay() - this.firstDayOfWeek,
                            firstWeekDay = 7 * week - firstMonthDayPosition;
                        firstWeekDay = firstMonthDayPosition < 0 ? firstWeekDay - 7 : firstWeekDay;
                        firstDay.setDate(firstDay.getDate() + firstWeekDay + day);
                        return firstDay
                    },
                    getShortDate: function(date) {
                        return date.getFullYear() + "/" + date.getMonth() + "/" + date.getDate()
                    },
                    getDateFromShortDate: function(shortDate) {
                        var dateParts = shortDate.split("/");
                        return new Date(dateParts[0], dateParts[1], dateParts[2])
                    },
                    iterateDays: function(delegate) {
                        var i = this.rtl ? this.days - 1 : 0;
                        while (this.rtl ? i >= 0 : i < this.days) {
                            delegate(i);
                            this.rtl ? --i : ++i
                        }
                    },
                    cellClickHandler: function(e) {
                        var cellDate = this.getDateFromShortDate($(e.target).attr("data-value"));
                        if (utils.dateInRange(cellDate, this.min, this.max))
                            this.setValue(cellDate, e.target)
                    },
                    keyDownHandler: function(options) {
                        var dayDifference,
                            contouredDate;
                        switch (options.key) {
                            case"leftArrow":
                                this.keyboardNavigationUsed = true;
                                dayDifference = this.rtl ? 1 : -1;
                                break;
                            case"rightArrow":
                                this.keyboardNavigationUsed = true;
                                dayDifference = this.rtl ? -1 : 1;
                                break;
                            case"upArrow":
                                this.keyboardNavigationUsed = true;
                                dayDifference = -7;
                                break;
                            case"downArrow":
                                this.keyboardNavigationUsed = true;
                                dayDifference = 7;
                                break;
                            case"enter":
                                this.keyboardNavigationUsed = true;
                                if (this.contouredDate)
                                    this.setValue(this.contouredDate, this.tryGetCell(this.contouredDate));
                                return;
                            default:
                                return
                        }
                        options.originalEvent.stopPropagation();
                        options.originalEvent.stopImmediatePropagation();
                        options.originalEvent.preventDefault();
                        contouredDate = this.calculateContouredDate(this.contouredDate, this.value);
                        this.setContouredDate(new Date(contouredDate.getFullYear(), contouredDate.getMonth(), contouredDate.getDate() + dayDifference))
                    },
                    calculateContouredDate: function(contouredDate, value) {
                        var calculatedContouredDate;
                        if (utils.sameMonthAndYear(contouredDate, this.date))
                            calculatedContouredDate = contouredDate;
                        if (!calculatedContouredDate && utils.sameMonthAndYear(value, this.date))
                            calculatedContouredDate = value;
                        return calculatedContouredDate || utils.getFirstMonthDate(this.date)
                    },
                    setContouredDate: function(date, suppressChangedEvent) {
                        if (this.keyboardNavigationUsed) {
                            date = utils.normalizeDate(date, this.min, this.max);
                            var dateCell;
                            if (this.contouredDate) {
                                dateCell = this.tryGetCell(this.contouredDate);
                                if (dateCell)
                                    dateCell.removeClass(CALENDAR_CONTOURED_DATE_CLASS)
                            }
                            this.contouredDate = date;
                            dateCell = this.tryGetCell(this.contouredDate);
                            if (dateCell)
                                dateCell.addClass(CALENDAR_CONTOURED_DATE_CLASS);
                            if (!suppressChangedEvent)
                                this.table.trigger(CALENDAR_MONTHVIEW_CONTOUREDDATECHANGED_EVENT_NAME, date)
                        }
                    },
                    setValue: function(value, cell) {
                        if (value && this.value !== value) {
                            this.value.setYear(value.getFullYear());
                            this.value.setDate(value.getDate());
                            this.value.setMonth(value.getMonth());
                            this.value.setDate(value.getDate());
                            this.onValueChanged(new Date(this.value), cell)
                        }
                    },
                    tryGetCell: function(date) {
                        var foundCell = date ? this.table.find("td[data-value='" + this.getShortDate(date) + "']") : [];
                        return foundCell.length > 0 ? foundCell : undefined
                    },
                    onValueChanged: function(newValue, selectedCell) {
                        $(this.selectedCell).removeClass(CALENDAR_SELECTED_DATE_CLASS);
                        this.selectedCell = selectedCell || this.tryGetCell(newValue);
                        $(this.selectedCell).addClass(CALENDAR_SELECTED_DATE_CLASS);
                        if (selectedCell) {
                            this.setContouredDate(newValue);
                            this.rootElement.trigger(CALENDAR_MONTHVIEW_VALUECHANGED_EVENT_NAME, newValue)
                        }
                    }
                })};
        DX.registerComponent("dxCalendar", ui, ui.Editor.inherit({
            _activeStateUnit: "." + CALENDAR_CELL_CLASS,
            _supportedKeys: function() {
                var isRTL = this.option("rtlEnabled");
                return $.extend(this.callBase(), {
                        rightArrow: function(e) {
                            if (e.ctrlKey)
                                this._navigate(isRTL ? -1 : 1);
                            else
                                return true
                        },
                        leftArrow: function(e) {
                            if (e.ctrlKey)
                                this._navigate(isRTL ? 1 : -1);
                            else
                                return true
                        },
                        pageUp: function(e) {
                            this._navigate(-1)
                        },
                        pageDown: function(e) {
                            this._navigate(1)
                        },
                        tab: $.noop
                    })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    monthViewType: views.MonthView,
                    firstDayOfWeek: 1,
                    min: undefined,
                    max: undefined
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {
                                focusStateEnabled: true,
                                hoverStateEnabled: true
                            }
                        }])
            },
            _initOptions: function(options) {
                options.currentDate = utils.normalizeDate(options.currentDate || options.value || new Date, options.min, options.max);
                this.callBase(options)
            },
            _clean: function() {
                this.callBase();
                if (this._view)
                    this._view.dispose()
            },
            _refresh: function() {
                this._cleanFocusState();
                this._render()
            },
            _render: function() {
                this.callBase();
                if (this._view) {
                    this._view.detachKeyDownProcessor();
                    this._view.dispose()
                }
                this.element().addClass(CALENDAR_CLASS);
                this._initView()
            },
            _initView: function() {
                this._view = this._initializeMonthView();
                this._renderNavigator();
                this._renderBody();
                this._renderMonthView();
                this._renderSwipeable()
            },
            _renderBody: function() {
                if (!this._body) {
                    this._body = $("<div />").addClass(CALENDAR_BODY_CLASS);
                    this.element().append(this._body)
                }
            },
            _renderSwipeable: function() {
                var that = this;
                if (!this._swipeable)
                    this._swipeable = this.element().dxSwipeable({
                        elastic: false,
                        onStart: function(e) {
                            that._swipeStartHandler(e)
                        },
                        onUpdated: function(e) {
                            that._swipeUpdateHandler(e)
                        },
                        onEnd: function(e) {
                            that._swipeEndHandler(e)
                        },
                        itemWidthFunc: function() {
                            return this.element().width()
                        }
                    }).dxSwipeable("instance")
            },
            _focusTarget: function() {
                return this.element()
            },
            _focusOutHandler: function() {
                this.callBase.apply(this, arguments);
                this._view.setContouredDate(undefined)
            },
            _attachKeyboardEvents: function() {
                this.callBase.apply(this, arguments);
                this._oldView = this._view;
                if (this._oldView)
                    this._viewKeyboardProcessor = this._keyboardProcessor.push(this._oldView.detachKeyDownProcessor());
                else
                    this._viewKeyboardProcessor = this._keyboardProcessor.attachChildProcessor()
            },
            _swipeStartHandler: function(e) {
                if (this._viewsAnimating) {
                    e.jQueryEvent.cancel = true;
                    return
                }
                this._swipeInProgress = true;
                this._viewsOnLeft = [this._view];
                this._viewsOnRight = [this._view]
            },
            _swipeUpdateHandler: function(e) {
                if (e.jQueryEvent.offset - this._swipeOffset > 1)
                    this._swipeOffset += 1;
                else
                    this._swipeOffset = e.jQueryEvent.offset;
                if (this._swipeOffset >= 0)
                    this._renderViews(this._viewsOnLeft, SwipePosition.RIGHT);
                else
                    this._renderViews(this._viewsOnRight, SwipePosition.LEFT)
            },
            _renderViews: function(viewsArray, swipePosition) {
                var arrayInsertIndex = Math.ceil(swipePosition * this._swipeOffset),
                    monthOffset = -swipePosition * arrayInsertIndex;
                this._initalizeViewDimensions();
                if (!viewsArray[arrayInsertIndex]) {
                    this._generateNewDate(monthOffset);
                    this._initView();
                    viewsArray[arrayInsertIndex] = this._view
                }
                this._translateViews(viewsArray, swipePosition)
            },
            _translateViews: function(viewsArray, swipePosition) {
                var prevView = viewsArray[Math.floor(swipePosition * this._swipeOffset)],
                    nextView = viewsArray[Math.ceil(swipePosition * this._swipeOffset)],
                    localOffset = this._swipeOffset % 1;
                this._normalizeViewsPosition();
                DX.translator.move(prevView.table, {left: localOffset * this._viewWidth});
                if (swipePosition * localOffset >= 0.05)
                    DX.translator.move(nextView.table, {left: (localOffset - swipePosition) * this._viewWidth});
                this._view = this._isInView(prevView, this._viewWidth / 2) ? prevView : nextView;
                this._renderNavigator()
            },
            _normalizeViewsPosition: function() {
                for (var i = 0; i < this._viewsOnLeft.length; i++)
                    DX.translator.move(this._viewsOnLeft[i].table, {left: -this._viewWidth});
                for (var i = 0; i < this._viewsOnRight.length; i++)
                    DX.translator.move(this._viewsOnRight[i].table, {left: this._viewWidth})
            },
            _generateNewDate: function(monthOffset) {
                this._newDate = new Date(this.option("currentDate"));
                this._newDate.setMonth(this.option("currentDate").getMonth() + monthOffset)
            },
            _swipeEndHandler: function(e) {
                var that = this,
                    targetOffset = e.jQueryEvent.targetOffset;
                this._viewsAnimating = true;
                var isShortSwipe = false;
                if (Math.abs(e.jQueryEvent.offset) < 0.5)
                    if (targetOffset == 1 || targetOffset == -1)
                        isShortSwipe = true;
                var animation = this._alignViews(isShortSwipe);
                animation.done(function() {
                    that._disposeViews()
                });
                this._swipeInProgress = false
            },
            _alignViews: function(isShortSwipe) {
                this._animation = $.Deferred();
                var firstVisibleView,
                    secondVisibleView;
                this._swipeOffset = this._swipeOffset || 0;
                if (this._swipeOffset > 0)
                    firstVisibleView = this._viewsOnLeft[Math.floor(Math.abs(this._swipeOffset))],
                    secondVisibleView = this._viewsOnLeft[Math.ceil(Math.abs(this._swipeOffset))];
                else if (this._swipeOffset <= 0)
                    firstVisibleView = this._viewsOnRight[Math.ceil(Math.abs(this._swipeOffset))],
                    secondVisibleView = this._viewsOnRight[Math.floor(Math.abs(this._swipeOffset))];
                if (this._isInView(firstVisibleView, this._viewWidth / 2))
                    if (isShortSwipe)
                        this._arrangeViews(secondVisibleView, firstVisibleView, SwipePosition.RIGHT);
                    else
                        this._arrangeViews(firstVisibleView, secondVisibleView, SwipePosition.LEFT);
                else if (isShortSwipe)
                    this._arrangeViews(firstVisibleView, secondVisibleView, SwipePosition.LEFT);
                else
                    this._arrangeViews(secondVisibleView, firstVisibleView, SwipePosition.RIGHT);
                return this._animation.promise()
            },
            _arrangeViews: function(firstView, secondView, swipePosition) {
                this._centerView(firstView);
                this._animateView(secondView, swipePosition * this._viewWidth)
            },
            _disposeViews: function() {
                for (var i = 0; i < this._viewsOnLeft.length; i++)
                    if (this._viewsOnLeft[i] != this._view) {
                        this._viewsOnLeft[i].detachKeyDownProcessor();
                        this._viewsOnLeft[i].dispose()
                    }
                for (var i = 0; i < this._viewsOnRight.length; i++)
                    if (this._viewsOnRight[i] != this._view) {
                        this._viewsOnRight[i].detachKeyDownProcessor();
                        this._viewsOnRight[i].dispose()
                    }
                this._viewsOnLeft = [];
                this._viewsOnRight = [];
                this.option("currentDate", this._view.date);
                this._viewsAnimating = false
            },
            _animateView: function(view, to) {
                var that = this;
                fx.animate($(view.table), {
                    type: "slide",
                    from: {left: $(view.table).position("left")},
                    to: {left: to},
                    duration: MONTH_VIEW_ANIMATION_DURATION,
                    complete: function() {
                        that._animation.resolve()
                    }
                })
            },
            _centerView: function(view) {
                this._animateView(view, 0);
                this._view = view
            },
            _isInView: function(view, point) {
                var $table = $(view.table);
                if (point > $table.position().left && point <= $table.position().left + $table.width())
                    return true
            },
            _initializeMonthView: function() {
                var monthViewType = this.option("monthViewType");
                return new monthViewType({
                        date: this._swipeInProgress ? this._newDate : this.option("currentDate"),
                        min: this.option("min"),
                        max: this.option("max"),
                        firstDayOfWeek: this.option("firstDayOfWeek"),
                        value: this.option("value"),
                        rtl: this.option("rtlEnabled"),
                        disabled: this.option("disabled") || DevExpress.designMode,
                        keyDownProcessor: this._viewKeyboardProcessor,
                        contouredDate: this._oldView ? this._oldView.contouredDate : undefined,
                        keyboardNavigationUsed: this._oldView ? this._oldView.keyboardNavigationUsed : undefined
                    })
            },
            _renderNavigator: function() {
                var that = this,
                    previousYearLinkDelta = this.option("rtlEnabled") ? 12 : -12,
                    previousMonthLinkDelta = this.option("rtlEnabled") ? 1 : -1,
                    nextMonthLinkDelta = this.option("rtlEnabled") ? -1 : 1,
                    nextYearLinkDelta = this.option("rtlEnabled") ? -12 : 12;
                if (this._navigator)
                    this._navigatorCaption.html(this._view.getNavigatorCaption());
                else {
                    this._previousYearLink = $("<a>").dxButton({
                        focusStateEnabled: false,
                        onClick: function() {
                            that._navigate(previousYearLinkDelta)
                        }
                    }).addClass(CALENDAR_NAVIGATOR_PREVIOUS_YEAR_CLASS);
                    this._previousMonthLink = $("<a>").dxButton({
                        focusStateEnabled: false,
                        onClick: function() {
                            that._navigate(previousMonthLinkDelta)
                        }
                    }).addClass(CALENDAR_NAVIGATOR_PREVIOUS_MONTH_CLASS);
                    this._navigatorCaption = $("<span />").html(this._view.getNavigatorCaption()),
                    this._nextMonthLink = $("<a>").dxButton({
                        focusStateEnabled: false,
                        onClick: function() {
                            that._navigate(nextMonthLinkDelta)
                        }
                    }).addClass(CALENDAR_NAVIGATOR_NEXT_MONTH_CLASS);
                    this._nextYearLink = $("<a>").dxButton({
                        focusStateEnabled: false,
                        onClick: function() {
                            that._navigate(nextYearLinkDelta)
                        }
                    }).addClass(CALENDAR_NAVIGATOR_NEXT_YEAR_CLASS);
                    this._navigator = $("<div>").addClass(CALENDAR_NAVIGATOR_CLASS).append(this._previousYearLink).append(this._previousMonthLink).append(this._navigatorCaption).append(this._nextMonthLink).append(this._nextYearLink);
                    this.element().append(this._navigator)
                }
                this._applyNavigatorLinkVisibility(this._previousYearLink, previousYearLinkDelta);
                this._applyNavigatorLinkVisibility(this._previousMonthLink, previousMonthLinkDelta);
                this._applyNavigatorLinkVisibility(this._nextMonthLink, nextMonthLinkDelta);
                this._applyNavigatorLinkVisibility(this._nextYearLink, nextYearLinkDelta)
            },
            _applyNavigatorLinkVisibility: function(link, monthDifference) {
                if (this._canNavigate(monthDifference))
                    link.removeClass(CALENDAR_DISABLED_NAVIGATOR_LINK_CLASS);
                else
                    link.addClass(CALENDAR_DISABLED_NAVIGATOR_LINK_CLASS)
            },
            _renderMonthView: function() {
                var that = this,
                    transitions;
                this._view.render(this._body[0]);
                this.element().off(CALENDAR_MONTHVIEW_VALUECHANGED_EVENT_NAME).on(CALENDAR_MONTHVIEW_VALUECHANGED_EVENT_NAME, function(event, newValue) {
                    that.option("value", newValue)
                });
                this.element().off(CALENDAR_MONTHVIEW_CONTOUREDDATECHANGED_EVENT_NAME).on(CALENDAR_MONTHVIEW_CONTOUREDDATECHANGED_EVENT_NAME, function(event, date) {
                    if (date)
                        if (!utils.sameMonthAndYear(that.option("currentDate"), date)) {
                            var difference = utils.getFirstMonthDate(date) - that.option("currentDate");
                            that._changeMonth(utils.getFirstMonthDate(date), difference)
                        }
                })
            },
            _initalizeViewDimensions: function() {
                this._viewWidth = this._viewWidth || this._body.width();
                this._viewHeight = this._viewHeight || this._body.height()
            },
            _canNavigate: function(monthDifference) {
                var date = this.option("currentDate"),
                    testCurrentDate = monthDifference < 0 ? new Date(date.getFullYear(), date.getMonth() + monthDifference + 1, 0) : new Date(date.getFullYear(), date.getMonth() + monthDifference, 1);
                return utils.dateInRange(testCurrentDate, this.option("min"), this.option("max"))
            },
            _navigate: function(monthDifference) {
                if (this._canNavigate(monthDifference)) {
                    var newDate = new Date(this.option("currentDate").getFullYear(), this.option("currentDate").getMonth() + monthDifference, 1);
                    this._changeMonth(newDate, monthDifference)
                }
            },
            _changeMonth: function(newDate, difference) {
                var that = this;
                if (fx.isAnimating(this._view.table)) {
                    this._stopCurrentAnimation();
                    this._prevView.detachKeyDownProcessor();
                    this._prevView.dispose()
                }
                this._prevView = this._view;
                this.option("currentDate", newDate);
                this._body.append(this._prevView.table);
                var animation = this._animateNavigation(difference);
                animation.done(function() {
                    that._prevView.detachKeyDownProcessor();
                    that._prevView.dispose()
                })
            },
            _stopCurrentAnimation: function() {
                fx.stop($(this._prevView.table), true);
                fx.stop($(this._view.table), true)
            },
            _animateNavigation: function(monthDifference) {
                this._animation = $.Deferred();
                this._initalizeViewDimensions();
                var navDirection = monthDifference < 0 ? -1 : 1;
                DX.translator.move(this._view.table, {left: navDirection * this._viewWidth});
                this._animateView(this._view, 0);
                this._animateView(this._prevView, -navDirection * this._viewWidth);
                return this._animation.promise()
            },
            _stopAnimationCallback: function() {
                this._forceStopAnimation();
                this._oldView.dispose();
                this._oldView = undefined
            },
            _forceStopAnimation: function() {
                if (this.animating) {
                    fx.stop($(this._oldView.table), true);
                    fx.stop($(this._view.table), true);
                    this.animating = false
                }
            },
            _invalidate: function() {
                this._forceStopAnimation();
                this.callBase()
            },
            _optionChanged: function(args) {
                var value = args.value;
                var normalizedDate;
                switch (args.name) {
                    case"monthViewType":
                        break;
                    case"currentDate":
                        this._forceStopAnimation();
                        normalizedDate = utils.normalizeDate(value, this.option("min"), this.option("max"));
                        this.option("currentDate", new Date(normalizedDate.getFullYear(), normalizedDate.getMonth(), 1));
                    case"min":
                    case"max":
                    case"firstDayOfWeek":
                        this._invalidate();
                        break;
                    case"value":
                        if (!value || utils.sameMonthAndYear(this._view.date, value)) {
                            normalizedDate = utils.normalizeDate(value, this.option("min"), this.option("max"));
                            this._view.setValue(normalizedDate);
                            this._view.value = new Date(value);
                            this.option("value", normalizedDate)
                        }
                        else
                            this.option("currentDate", utils.getFirstMonthDate(value));
                    default:
                        this.callBase(args)
                }
            }
        }));
        ui.dxCalendar.__internals = {
            BaseView: BaseView,
            views: views,
            CALENDAR_CLASS: CALENDAR_CLASS,
            CALENDAR_BODY_CLASS: CALENDAR_BODY_CLASS,
            CALENDAR_NAVIGATOR_CLASS: CALENDAR_NAVIGATOR_CLASS,
            CALENDAR_OTHER_MONTH_CLASS: CALENDAR_OTHER_MONTH_CLASS,
            CALENDAR_DISABLED_NAVIGATOR_LINK_CLASS: CALENDAR_DISABLED_NAVIGATOR_LINK_CLASS,
            CALENDAR_EMPTY_CELL_CLASS: CALENDAR_EMPTY_CELL_CLASS,
            CALENDAR_TODAY_CLASS: CALENDAR_TODAY_CLASS,
            CALENDAR_SELECTED_DATE_CLASS: CALENDAR_SELECTED_DATE_CLASS,
            CALENDAR_CONTOURED_DATE_CLASS: CALENDAR_CONTOURED_DATE_CLASS,
            CALENDAR_NAVIGATOR_PREVIOUS_YEAR_CLASS: CALENDAR_NAVIGATOR_PREVIOUS_YEAR_CLASS,
            CALENDAR_NAVIGATOR_PREVIOUS_MONTH_CLASS: CALENDAR_NAVIGATOR_PREVIOUS_MONTH_CLASS,
            CALENDAR_NAVIGATOR_NEXT_MONTH_CLASS: CALENDAR_NAVIGATOR_NEXT_MONTH_CLASS,
            CALENDAR_NAVIGATOR_NEXT_YEAR_CLASS: CALENDAR_NAVIGATOR_NEXT_YEAR_CLASS,
            CALENDAR_MONTHVIEW_VALUECHANGED_EVENT_NAME: CALENDAR_MONTHVIEW_VALUECHANGED_EVENT_NAME,
            CALENDAR_MONTHVIEW_CONTOUREDDATECHANGED_EVENT_NAME: CALENDAR_MONTHVIEW_CONTOUREDDATECHANGED_EVENT_NAME
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.timeView.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            browser = DX.browser,
            isBuggyIE = browser.msie && browser.version.split(".")[0] == 8;
        var TIMEVIEW_CLASS = "dx-timeview",
            TIMEVIEW_CLOCK_CLASS = "dx-timeview-clock",
            TIMEVIEW_FIELD_CLASS = "dx-timeview-field",
            TIMEVIEW_HOURARROW_CLASS = "dx-timeview-hourarrow",
            TIMEVIEW_MINUTEARROW_CLASS = "dx-timeview-minutearrow";
        var rotateArrow = function($arrow, angle, offset) {
                if (isBuggyIE)
                    filterRotate($arrow, angle, offset);
                else
                    cssRotate($arrow, angle, offset)
            };
        var filterRotate = function($arrow, angle, offset) {
                angle = angle / 180 * Math.PI;
                var sin = Math.sin(angle),
                    cos = Math.cos(angle);
                $arrow.css("filter", "none");
                var originalWidth = $arrow.width(),
                    originalHeight = $arrow.height();
                $arrow.css("filter", 'progid:DXImageTransform.Microsoft.Matrix' + '(sizingMethod="auto expand", M11 = ' + cos + ', M12 = ' + -sin + ', M21 = ' + sin + ', M22 = ' + cos + ')');
                var width = $arrow.width(),
                    height = $arrow.height();
                var sx = (width - originalWidth) / 2,
                    sy = (height - originalHeight) / 2;
                $arrow.css("margin-left", -originalWidth / 2 + (originalHeight / 2 - offset) * sin - sx);
                $arrow.css("margin-top", originalHeight / 2 - (originalHeight / 2 - offset) * cos - sy)
            };
        var cssRotate = function($arrow, angle, offset) {
                $arrow.css("transform", "rotate(" + angle + "deg)" + " translate(0," + offset + "px)")
            };
        DX.registerComponent("dxTimeView", ui, ui.Editor.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    value: new Date($.now()),
                    _arrowOffset: 0
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return device.platform === "ios" && device.version[0] < 7
                            },
                            options: {_arrowOffset: 30}
                        }, {
                            device: {platform: "android"},
                            options: {_arrowOffset: 15}
                        }, {
                            device: {platform: "generic"},
                            options: {_arrowOffset: 5}
                        }])
            },
            _getValue: function() {
                return this.option("value") || new Date
            },
            _init: function() {
                this.callBase();
                this.element().addClass(TIMEVIEW_CLASS)
            },
            _render: function() {
                this.callBase();
                this._renderBox();
                this._updateTime()
            },
            _renderBox: function() {
                $("<div>").appendTo(this.element()).dxBox({
                    height: "100%",
                    width: "100%",
                    direction: "col",
                    items: [{
                            ratio: 1,
                            name: "clock"
                        }, {
                            ratio: 0,
                            baseSize: 50,
                            name: "field"
                        }],
                    itemTemplate: $.proxy(this._boxItemTemplate, this)
                })
            },
            _boxItemTemplate: function(data, _, $content) {
                if (data.name === "clock")
                    this._renderClock($content);
                else
                    this._renderField($content)
            },
            _renderClock: function($content) {
                this._$hourArrow = $("<div>").addClass(TIMEVIEW_HOURARROW_CLASS);
                this._$minuteArrow = $("<div>").addClass(TIMEVIEW_MINUTEARROW_CLASS);
                return $content.addClass(TIMEVIEW_CLOCK_CLASS).append(this._$hourArrow).append(this._$minuteArrow)
            },
            _updateClock: function() {
                var time = this._getValue(),
                    hourArrowAngle = time.getHours() / 12 * 360 + time.getMinutes() / 60 * 30,
                    minuteArrowAngle = time.getMinutes() / 60 * 360;
                rotateArrow(this._$hourArrow, hourArrowAngle, this.option("_arrowOffset"));
                rotateArrow(this._$minuteArrow, minuteArrowAngle, this.option("_arrowOffset"))
            },
            _renderField: function($content) {
                $content.addClass(TIMEVIEW_FIELD_CLASS).dxBox({
                    direction: "row",
                    align: "center",
                    crossAlign: "center",
                    items: [{
                            ratio: 0,
                            baseSize: "auto",
                            name: "hour"
                        }, {
                            ratio: 0,
                            baseSize: "auto",
                            name: "separator"
                        }, {
                            ratio: 0,
                            baseSize: "auto",
                            name: "minute"
                        }],
                    itemTemplate: $.proxy(this._fieldBoxItemTemplate, this)
                })
            },
            _fieldBoxItemTemplate: function(data, _, $content) {
                if (data.name === "hour") {
                    this._createHourBox();
                    $content.append(this._hourBox.element())
                }
                if (data.name === "separator")
                    $content.text(Globalize.culture().calendar[":"]);
                if (data.name === "minute") {
                    this._createMinuteBox();
                    $content.append(this._minuteBox.element())
                }
            },
            _createHourBox: function() {
                this._hourBox = $("<div>").dxNumberBox($.extend({
                    min: -1,
                    max: 24,
                    value: this._getValue().getHours(),
                    onValueChanged: $.proxy(function(args) {
                        var newHours = (24 + args.value) % 24;
                        this._hourBox.option("value", newHours);
                        var time = new Date(this._getValue());
                        time.setHours(newHours);
                        this.option("value", time)
                    }, this)
                }, this._getNumberBoxConfig())).dxNumberBox("instance")
            },
            _createMinuteBox: function() {
                this._minuteBox = $("<div>").dxNumberBox($.extend({
                    min: -1,
                    max: 60,
                    value: this._getValue().getMinutes(),
                    onValueChanged: $.proxy(function(args) {
                        var newMinutes = (60 + args.value) % 60;
                        this._minuteBox.option("value", newMinutes);
                        var time = new Date(this._getValue());
                        time.setMinutes(newMinutes);
                        this.option("value", time)
                    }, this)
                }, this._getNumberBoxConfig())).dxNumberBox("instance")
            },
            _getNumberBoxConfig: function() {
                return {
                        width: 70,
                        showSpinButtons: true
                    }
            },
            _updateField: function() {
                this._hourBox.option("value", this._getValue().getHours());
                this._minuteBox.option("value", this._getValue().getMinutes())
            },
            _updateTime: function() {
                this._updateClock();
                this._updateField()
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._updateTime()
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"value":
                        this._updateTime();
                        this.callBase(args);
                        break;
                    case"_arrowOffset":
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.dateView.js */
    (function($, DX) {
        var ui = DX.ui,
            events = ui.events,
            dateUtils = ui.dateUtils,
            DATEVIEW_CLASS = "dx-dateview",
            DATEVIEW_WRAPPER_CLASS = "dx-dateview-wrapper",
            DATEVIEW_ROLLER_CONTAINER_CLASS = "dx-dateview-rollers",
            DATEVIEW_ROLLER_CLASS = "dx-dateview-roller",
            DATEVIEW_ROLLER_ACTIVE_CLASS = "dx-state-active",
            DATEVIEW_ROLLER_CURRENT_CLASS = "dx-dateview-roller-current",
            DATEVIEW_ROLLER_ITEM_CLASS = "dx-dateview-item",
            DATEVIEW_ROLLER_ITEM_SELECTED_CLASS = "dx-dateview-item-selected",
            DATEVIEW_ROLLER_ITEM_SELECTED_FRAME_CLASS = "dx-dateview-item-selected-frame",
            DATEVIEW_ROLLER_ITEM_SELECTED_BORDER_CLASS = "dx-dateview-item-selected-border",
            DATEVIEW_ROLLER_BUTTON_UP_CLASS = "dx-dateview-button-up",
            DATEVIEW_ROLLER_BUTTON_DOWN_CLASS = "dx-dateview-button-down";
        DX.registerComponent("dxDatePickerRoller", ui, ui.dxScrollable.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    clickableItems: false,
                    showScrollbar: false,
                    useNative: false,
                    selectedIndex: 0,
                    bounceEnabled: false,
                    items: []
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "win8"},
                            options: {clickableItems: true}
                        }, {
                            device: {platform: "generic"},
                            options: {scrollByContent: true}
                        }])
            },
            _init: function() {
                this.callBase();
                this._renderSelectedItemFrame();
                this._renderControlButtons()
            },
            _render: function() {
                this.callBase();
                $.each(this._strategy._scrollers, function(index, scroller) {
                    scroller._correctLocation = $.noop
                });
                this.element().addClass(DATEVIEW_ROLLER_CLASS);
                this._renderItems();
                this._renderSelectedValue();
                this._renderItemsClick();
                this._wrapAction("_endAction", $.proxy(this._endActionHandler, this))
            },
            _wrapAction: function(actionName, callback) {
                var strategy = this._strategy,
                    originalAction = strategy[actionName];
                strategy[actionName] = function() {
                    callback.apply(this, arguments);
                    return originalAction.apply(this, arguments)
                }
            },
            _renderItems: function() {
                var items = this.option("items") || [],
                    $items = $();
                this._$content.empty();
                $.each(items, function() {
                    $items = $items.add($("<div>").addClass(DATEVIEW_ROLLER_ITEM_CLASS).append(this))
                });
                this._$content.append($items);
                this._$items = $items;
                this.update()
            },
            _renderSelectedItemFrame: function() {
                $("<div>").addClass(DATEVIEW_ROLLER_ITEM_SELECTED_FRAME_CLASS).append($("<div>").addClass(DATEVIEW_ROLLER_ITEM_SELECTED_BORDER_CLASS)).appendTo(this._$container)
            },
            _renderControlButtons: function() {
                $("<div>").addClass(DATEVIEW_ROLLER_BUTTON_UP_CLASS).insertAfter(this._$container).dxButton({onClick: $.proxy(this._upButtonClickHandler, this)});
                $("<div>").addClass(DATEVIEW_ROLLER_BUTTON_DOWN_CLASS).insertAfter(this._$container).dxButton({onClick: $.proxy(this._downButtonClickHandler, this)})
            },
            _renderSelectedValue: function(selectedIndex) {
                if (selectedIndex === undefined)
                    selectedIndex = this.option("selectedIndex");
                selectedIndex = this._fitIndex(selectedIndex);
                var correctedPosition = this._getItemPosition(selectedIndex);
                this.option().selectedIndex = selectedIndex;
                this._moveTo({top: correctedPosition});
                this._renderActiveStateItem()
            },
            _fitIndex: function(index) {
                var items = this.option("items") || [],
                    itemCount = items.length;
                if (index >= itemCount)
                    return itemCount - 1;
                if (index < 0)
                    return 0;
                return index
            },
            _renderItemsClick: function() {
                var itemSelector = "." + DATEVIEW_ROLLER_ITEM_CLASS,
                    eventName = events.addNamespace("dxclick", this.NAME);
                this.element().off(eventName, itemSelector);
                if (this.option("clickableItems"))
                    this.element().on(eventName, itemSelector, $.proxy(this._itemClickHandler, this))
            },
            _itemClickHandler: function(e) {
                this._renderSelectedValue(this._itemElementIndex(this._closestItemElement(e)))
            },
            _itemElementIndex: function(itemElement) {
                return this._itemElements().index(itemElement)
            },
            _closestItemElement: function(e) {
                return e.currentTarget
            },
            _itemElements: function() {
                return this.element().find("." + DATEVIEW_ROLLER_ITEM_CLASS)
            },
            _renderActiveStateItem: function() {
                var selectedIndex = this.option("selectedIndex");
                $.each(this._$items, function(index) {
                    $(this).toggleClass(DATEVIEW_ROLLER_ITEM_SELECTED_CLASS, selectedIndex === index)
                })
            },
            _upButtonClickHandler: function() {
                this._animation = true;
                this.option("selectedIndex", this.option("selectedIndex") - 1)
            },
            _downButtonClickHandler: function() {
                this._animation = true;
                this.option("selectedIndex", this.option("selectedIndex") + 1)
            },
            _getItemPosition: function(index) {
                return Math.round(this._itemHeight() * index)
            },
            _moveTo: function(targetLocation) {
                targetLocation = this._normalizeLocation(targetLocation);
                var location = this._location(),
                    delta = {
                        x: -(location.left - targetLocation.left),
                        y: -(location.top - targetLocation.top)
                    };
                if (this._isVisible() && (delta.x || delta.y)) {
                    this._strategy._prepareDirections(true);
                    if (this._animation) {
                        DX.fx.stop(this._$content);
                        DX.fx.animate(this._$content, {
                            duration: 200,
                            type: "slide",
                            to: {top: targetLocation.top}
                        });
                        delete this._animation
                    }
                    else
                        this._strategy.handleMove({delta: delta})
                }
            },
            _validate: function(e) {
                return this._strategy.validate(e)
            },
            _endActionHandler: function() {
                if (this._changedByIndex) {
                    this._changedByIndex = false;
                    this._renderSelectedValue();
                    return
                }
                var ratio = -this._location().top / this._itemHeight(),
                    selectedIndex = Math.round(ratio);
                this._animation = true;
                this._renderSelectedValue(selectedIndex)
            },
            _itemHeight: function() {
                var $item = this._$items.first(),
                    height = $item.outerHeight() + parseFloat($item.css("margin-top") || 0);
                return height
            },
            _toggleActive: function(state) {
                this.element().toggleClass(DATEVIEW_ROLLER_ACTIVE_CLASS, state)
            },
            _isVisible: function() {
                return this._$container.is(":visible")
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"selectedIndex":
                        this._renderSelectedValue();
                        this._changedByIndex = true;
                        this._strategy.update();
                        this._strategy.handleEnd({velocity: {
                                x: 0,
                                y: 0
                            }});
                        break;
                    case"items":
                        this._renderItems();
                        this._renderSelectedValue();
                        break;
                    case"clickableItems":
                        this._renderItemsClick();
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }), ui);
        DX.registerComponent("dxDateView", ui, ui.Editor.inherit({
            _valueOption: function() {
                return new Date(this.option("value")) == "Invalid Date" ? new Date : new Date(this.option("value"))
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    minDate: new Date(1),
                    maxDate: new Date($.now() + dateUtils.TEN_YEARS),
                    format: "date",
                    value: new Date,
                    culture: Globalize.culture().name,
                    activeStateEnabled: true,
                    showNames: false
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "win8"},
                            options: {showNames: true}
                        }])
            },
            _render: function() {
                this._value = this._valueOption();
                this.callBase();
                this.element().addClass(DATEVIEW_CLASS)
            },
            _wrapper: function() {
                return this._$wrapper
            },
            _renderContentImpl: function() {
                this._$wrapper = $("<div />").appendTo(this.element()).addClass(DATEVIEW_WRAPPER_CLASS);
                this._renderRollers()
            },
            _renderRollers: function() {
                var that = this;
                if (!that._$rollersContainer)
                    that._$rollersContainer = $("<div>").appendTo(that._wrapper()).addClass(DATEVIEW_ROLLER_CONTAINER_CLASS);
                that._$rollersContainer.empty();
                that._createRollerConfigs();
                that._rollers = {};
                $.each(that._rollerConfigs, function(name) {
                    var $roller = $("<div>").appendTo(that._$rollersContainer).addClass(DATEVIEW_ROLLER_CLASS + "-" + that._rollerConfigs[name].type).dxDatePickerRoller({
                            items: that._rollerConfigs[name].displayItems,
                            selectedIndex: that._rollerConfigs[name].selectedIndex,
                            showScrollbar: false,
                            onStart: function(e) {
                                var roller = e.component;
                                roller._toggleActive(true);
                                that._setActiveRoller(that._rollerConfigs[name], roller.option("selectedIndex"))
                            },
                            onEnd: function(e) {
                                var roller = e.component;
                                that._setRollerState(that._rollerConfigs[name], roller.option("selectedIndex"));
                                roller._toggleActive(false)
                            }
                        });
                    that._rollers[that._rollerConfigs[name].type] = $roller.dxDatePickerRoller("instance")
                })
            },
            _setActiveRoller: function(currentRoller) {
                var activeRoller = currentRoller && this._rollers[currentRoller.type];
                $.each(this._rollers, function() {
                    this._$element.toggleClass(DATEVIEW_ROLLER_CURRENT_CLASS, this === activeRoller)
                })
            },
            _refreshRollers: function() {
                var that = this;
                $.each(this._rollers, function(type) {
                    var correctIndex = that._rollerConfigs[type].getIndex(that._value);
                    this.update();
                    this._renderSelectedValue(correctIndex)
                })
            },
            _setRollerState: function(roller, selectedIndex) {
                if (selectedIndex !== roller.selectedIndex) {
                    var value = roller.valueItems[selectedIndex],
                        setValue = roller.setValue,
                        currentDate = this._value.getDate();
                    if (roller.type === "month") {
                        currentDate = Math.min(currentDate, dateUtils.getMaxMonthDay(this._value.getFullYear(), value));
                        this._value.setDate(currentDate)
                    }
                    else if (roller.type === "year") {
                        currentDate = Math.min(currentDate, dateUtils.getMaxMonthDay(value, this._value.getMonth()));
                        this._value.setDate(currentDate)
                    }
                    this._value[setValue](value);
                    roller.selectedIndex = selectedIndex
                }
                if (roller.type === "year") {
                    this._refreshMonthRoller();
                    this._refreshDayRoller()
                }
                if (roller.type === "month")
                    this._refreshDayRoller()
            },
            _refreshMonthRoller: function() {
                var monthRoller = this._rollers["month"];
                if (monthRoller) {
                    this._createRollerConfig("month");
                    var monthRollerConfig = this._rollerConfigs["month"];
                    this._deferredRenderMonthTimeout = window.setTimeout(function() {
                        if (monthRollerConfig.displayItems.length === monthRoller.option("items").length)
                            return;
                        monthRoller.option({
                            items: monthRollerConfig.displayItems,
                            selectedIndex: monthRollerConfig.selectedIndex
                        })
                    }, 100)
                }
            },
            _refreshDayRoller: function() {
                var dayRoller = this._rollers["day"];
                if (dayRoller) {
                    this._createRollerConfig("day");
                    var dayRollerConfig = this._rollerConfigs["day"];
                    this._deferredRenderDayTimeout = window.setTimeout(function() {
                        if (dayRollerConfig.displayItems.length === dayRoller.option("items").length)
                            return;
                        dayRoller.option({
                            items: dayRollerConfig.displayItems,
                            selectedIndex: dayRollerConfig.selectedIndex
                        })
                    }, 100)
                }
            },
            _createRollerConfigs: function(format) {
                var that = this;
                format = format || that.option("format");
                that._rollerConfigs = {};
                $.each(that._getFormatPattern(format).split(/\W+/), function(_, formatPart) {
                    $.each(dateUtils.DATE_COMPONENTS_INFO, function(componentName, componentInfo) {
                        if ($.inArray(formatPart, componentInfo.possibleFormats) > -1)
                            that._createRollerConfig(componentName)
                    })
                })
            },
            _getFormatPattern: function(format) {
                var culture = Globalize.culture(this.option("culture")),
                    result = "";
                if (format === "date")
                    result = culture.calendar.patterns.d;
                else if (format === "time")
                    result = culture.calendar.patterns.t;
                else if (format === "datetime")
                    result = [culture.calendar.patterns.d, culture.calendar.patterns.t].join(" ");
                return result
            },
            _createRollerConfig: function(componentName) {
                var componentInfo = dateUtils.DATE_COMPONENTS_INFO[componentName],
                    valueRange = this._calculateRollerConfigValueRange(componentName),
                    startValue = valueRange.startValue,
                    endValue = valueRange.endValue,
                    formatter = componentInfo.formatter,
                    showNames = this.option("showNames"),
                    curDate = this._value;
                var config = {
                        type: componentName,
                        setValue: componentInfo.setter,
                        valueItems: [],
                        displayItems: [],
                        getIndex: function(value) {
                            return value[componentInfo.getter]() - startValue
                        }
                    };
                for (var i = startValue; i <= endValue; i++) {
                    config.valueItems.push(i);
                    config.displayItems.push(formatter(i, showNames, curDate))
                }
                config.selectedIndex = config.getIndex(this._value);
                this._rollerConfigs[componentName] = config
            },
            _calculateRollerConfigValueRange: function(componentName) {
                var curDate = this._value,
                    minDate = this.option("minDate"),
                    maxDate = this.option("maxDate"),
                    minYear = curDate.getFullYear() === minDate.getFullYear(),
                    minMonth = minYear && curDate.getMonth() === minDate.getMonth(),
                    maxYear = curDate.getFullYear() === maxDate.getFullYear(),
                    maxMonth = maxYear && curDate.getMonth() === maxDate.getMonth(),
                    componentInfo = dateUtils.DATE_COMPONENTS_INFO[componentName],
                    startValue = componentInfo.startValue,
                    endValue = componentInfo.endValue;
                if (componentName === "year") {
                    startValue = minDate.getFullYear();
                    endValue = maxDate.getFullYear()
                }
                if (componentName === "month") {
                    if (minYear)
                        startValue = minDate.getMonth();
                    if (maxYear)
                        endValue = maxDate.getMonth()
                }
                if (componentName === "day") {
                    endValue = dateUtils.getMaxMonthDay(curDate.getFullYear(), curDate.getMonth());
                    if (minMonth)
                        startValue = minDate.getDate();
                    if (maxYear)
                        endValue = maxDate.getDate()
                }
                return {
                        startValue: startValue,
                        endValue: endValue
                    }
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"showNames":
                    case"minDate":
                    case"maxDate":
                    case"culture":
                    case"format":
                        this._renderRollers();
                        break;
                    case"visible":
                        this.callBase(args);
                        if (args.value) {
                            this._refreshRollers();
                            this._setActiveRoller()
                        }
                        break;
                    case"value":
                        this._value = this._valueOption();
                        this._renderRollers();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _clean: function() {
                this.callBase();
                delete this._$rollersContainer
            },
            _dispose: function() {
                clearTimeout(this._deferredRenderDayTimeout);
                clearTimeout(this._deferredRenderMonthTimeout);
                this.callBase()
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.dateBox.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            support = DX.support,
            devices = DX.devices,
            dateUtils = ui.dateUtils,
            utils = DX.utils,
            DATEBOX_CLASS = "dx-datebox",
            DATEBOX_OVERLAY_CLASS = "dx-datebox-overlay",
            IE_ROUNDING_ERROR = 10;
        var realWidthSetted = function($element) {
                var explicitWidth = $element[0].style.width;
                if (explicitWidth && explicitWidth !== "auto" && explicitWidth !== "inherit")
                    return true;
                return false
            };
        var calculateWidth = function(value, $input, $element) {
                var $longestValueElement = $("<div>").text(value).css({
                        "font-style": $input.css("font-style"),
                        "font-variant": $input.css("font-variant"),
                        "font-weight": $input.css("font-weight"),
                        "font-size": $input.css("font-size"),
                        "font-family": $input.css("font-family"),
                        "letter-spacing": $input.css("letter-spacing"),
                        "padding-left": $input.css("padding-left"),
                        "padding-right": $input.css("padding-right"),
                        border: $input.css("border"),
                        visibility: "hidden",
                        "white-space": "nowrap",
                        position: "absolute",
                        float: "left"
                    });
                $longestValueElement.appendTo($element);
                var width = $longestValueElement.outerWidth() + IE_ROUNDING_ERROR;
                $longestValueElement.remove();
                return width
            };
        DX.registerComponent("dxDateBox", ui, ui.dxDropDownEditor.inherit({
            ctor: function(element, options) {
                options = options || {};
                var preferCalendar = devices.current().platform === "generic",
                    useCalendar = options && options.useCalendar;
                if (useCalendar === undefined)
                    useCalendar = preferCalendar;
                var strategy = useCalendar ? "Calendar" : "DateView";
                if (useCalendar && options.format === "datetime")
                    strategy = "CalendarWithTime";
                if (useCalendar && options.format === "time")
                    strategy = "Time";
                this._strategy = new ui.dxDateBox.renderStrategies[strategy](this);
                this.callBase(element, options)
            },
            _supportedKeys: function() {
                return this._strategy._supportedKeys()
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    format: "date",
                    value: new Date,
                    min: undefined,
                    max: undefined,
                    useCalendar: false,
                    useNative: true,
                    openOnFieldClick: true
                });
                this._strategy._setDefaultOptions()
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "generic"},
                            options: {useCalendar: true}
                        }].concat(this._strategy._defaultOptionsRules()))
            },
            _init: function() {
                this.callBase();
                this._strategy._initFormat()
            },
            _attachKeyboardEvents: function() {
                this.callBase.apply(this, arguments);
                this._strategy._attachKeyboardEvents()
            },
            _render: function() {
                this.element().addClass(DATEBOX_CLASS);
                this.callBase();
                this._strategy._render();
                this._updateSize()
            },
            _popupShowingHandler: function() {
                this.callBase();
                this._strategy._popupShowingHandler()
            },
            _popupConfig: function() {
                return this._strategy._popupConfig()
            },
            _renderPopup: function() {
                this._$popup.addClass(DATEBOX_OVERLAY_CLASS);
                this.callBase()
            },
            _renderPopupContent: function() {
                this._strategy._renderPopupContent()
            },
            _popupHiddenHandler: function() {
                this.callBase();
                this._strategy._popupHiddenHandler()
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._updateSize()
            },
            _updateSize: function() {
                var $element = this.element(),
                    widthSetted = this.option("width") || realWidthSetted($element),
                    isElementVisible = $element.is(":visible"),
                    shouldCalculateWidth = this.option("useCalendar") && devices.current().platform === "generic";
                if (widthSetted || !(shouldCalculateWidth && isElementVisible))
                    return;
                var $input = this._input(),
                    calendar = Globalize.culture().calendar,
                    format = this.option("formatString"),
                    longestValue = Globalize.format(dateUtils.getLongestDate(format, calendar.months.names, calendar.days.names), format);
                $element.width(calculateWidth(longestValue, $input, this.element()))
            },
            _usingNativeDatePicker: function() {
                return support.inputType(this.option("mode")) && this.option("useNative")
            },
            _readOnlyPropValue: function() {
                if (this._usingNativeDatePicker())
                    return this.callBase();
                return true
            },
            _valueChangeEventHandler: function() {
                this._strategy._valueChangeEventHandler.apply(this._strategy, arguments)
            },
            _renderValue: function() {
                this._strategy._renderValue()
            },
            _renderProps: function() {
                this.callBase();
                this._input().attr("autocomplete", "off")
            },
            _renderOpenedState: function() {
                if (!this._isNativeView())
                    this.callBase();
                this._strategy._renderOpenedState()
            },
            _isNativeView: function() {
                return this.option("useNative") && !this.option("useCalendar")
            },
            _renderPlaceholder: function() {
                this.callBase();
                this._strategy._renderPlaceholder()
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"format":
                        this._strategy._initFormat();
                        this._renderValue();
                        break;
                    case"placeholder":
                        this._renderPlaceholder();
                        break;
                    case"readOnly":
                    case"min":
                    case"max":
                    case"interval":
                    case"formatString":
                    case"calendarOptions":
                    case"useNative":
                        this._invalidate();
                        break;
                    case"type":
                        throw DX.Error("E1020");
                        break;
                    case"useCalendar":
                    case"formatWidthCalculator":
                    case"closeOnValueChange":
                        break;
                    case"value":
                        var value = args.value;
                        if (value && this.option("useCalendar")) {
                            value = utils.normalizeDate(value, this.option("min"), this.option("max"));
                            this.option("value", value)
                        }
                        this.callBase.apply(this, arguments);
                        break;
                    default:
                        this.callBase.apply(this, arguments)
                }
            }
        }));
        ui.dxDateBox.renderStrategies = {}
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.dateBox.calendar.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            dateUtils = ui.dateUtils,
            CALENDAR_PICKER_CLASS = "dx-calendar-picker",
            CALENDAR_PICKER_CALENDAR_CONTAINER_CLASS = "dx-calendar-picker-calendar-container",
            CALENDAR_PICKER_OVERLAY = "dx-calendar-picker-overlay",
            CALENDAR_PICKER_INPUT_WRAPPER_CLASS = "dx-calendar-picker-input-wrapper",
            CALENDAR_PICKER_INPUT_WIDER_THAN_CALENDAR_CONTAINER_CLASS = "dx-calendar-picker-input-wider-than-calendar-container";
        ui.dxDateBox.renderStrategies["Calendar"] = DX.Class.inherit({
            ctor: function(dateBox) {
                this.dateBox = dateBox
            },
            _supportedKeys: function() {
                return $.extend(this.dateBox.callBase(), {
                        tab: function() {
                            this.close()
                        },
                        rightArrow: function() {
                            if (this.option("opened"))
                                return true
                        },
                        leftArrow: function() {
                            if (this.option("opened"))
                                return true
                        }
                    })
            },
            _setDefaultOptions: function() {
                this.dateBox.option({
                    formatString: Globalize.culture().calendar.patterns["d"],
                    closeOnValueChange: true
                })
            },
            _defaultOptionsRules: function() {
                return [{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }]
            },
            _render: function() {
                this.dateBox.element().addClass(CALENDAR_PICKER_CLASS)
            },
            _attachKeyboardEvents: function() {
                this._calendarKeyboardProcessor = this.dateBox._keyboardProcessor.attachChildProcessor()
            },
            _renderPopupContent: function() {
                this.dateBox.callBase();
                this.dateBox._popup._wrapper().addClass(CALENDAR_PICKER_OVERLAY);
                this.dateBox._calendarContainer = $("<div>").addClass(CALENDAR_PICKER_CALENDAR_CONTAINER_CLASS);
                this.dateBox._calendar = this.dateBox._calendarContainer.dxCalendar($.extend(this.dateBox.option("calendarOptions"), {
                    value: this.dateBox.option("value"),
                    rtlEnabled: this.dateBox.option("rtlEnabled"),
                    _keyboardProcessor: this._calendarKeyboardProcessor,
                    min: this.dateBox.option("min"),
                    max: this.dateBox.option("max")
                })).dxCalendar("instance");
                this.dateBox._calendarContainer.appendTo(this._calenderContainer())
            },
            _calenderContainer: function() {
                return this.dateBox._popup.content()
            },
            _popupConfig: function() {
                return this.dateBox.callBase()
            },
            _popupShowingHandler: function(){},
            _popupHiddenHandler: function(){},
            _renderOpenedState: function() {
                if (this.dateBox.option("opened"))
                    this.dateBox._calendar.off("valueChanged").on("valueChanged", $.proxy(function(args) {
                        this.dateBox.option("value", args.value)
                    }, this))
            },
            _initFormat: function(){},
            _renderPlaceholder: function(){},
            _renderValue: function(formattedValue) {
                var that = this,
                    value = formattedValue || this.dateBox.option("value");
                if (this.dateBox._calendar)
                    this.dateBox._calendar.option("value", value);
                if (this.dateBox.option("opened") && this.dateBox.option("closeOnValueChange"))
                    setTimeout(function() {
                        that.dateBox.option("opened", false)
                    }, 50);
                this.dateBox.callBase(Globalize.format(this.dateBox.option("value"), this.dateBox.option("formatString")))
            },
            _valueChangeEventHandler: function(e, formattedValue) {
                this.dateBox._suppressUpdateValue();
                var date = Globalize.parseDate(this.dateBox._input().val(), this.dateBox.option("formatString"));
                this.dateBox.callBase(e, date);
                this.dateBox._resumeUpdateValue()
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.dateBox.calendarWithTime.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            dateUtils = ui.dateUtils,
            CALENDAR_PICKER_CLASS = "dx-calendar-picker",
            CALENDAR_PICKER_CALENDAR_CONTAINER_CLASS = "dx-calendar-picker-calendar-container",
            CALENDAR_PICKER_OVERLAY = "dx-calendar-picker-overlay",
            CALENDAR_PICKER_INPUT_WRAPPER_CLASS = "dx-calendar-picker-input-wrapper",
            CALENDAR_PICKER_INPUT_WIDER_THAN_CALENDAR_CONTAINER_CLASS = "dx-calendar-picker-input-wider-than-calendar-container",
            CALENDAR_WITH_TIME_PICKER_CLASS = "dx-calendar-with-time-picker",
            CALENDAR_WITH_TIME_PICKER_CONTAINER_CLASS = "dx-calendar-with-time-picker-container";
        ui.dxDateBox.renderStrategies.CalendarWithTime = ui.dxDateBox.renderStrategies.Calendar.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.dateBox.option({
                    formatString: Globalize.culture().calendar.patterns["d"] + " " + Globalize.culture().calendar.patterns["t"],
                    closeOnValueChange: false
                })
            },
            _renderPopupContent: function() {
                this.dateBox.element().addClass(CALENDAR_WITH_TIME_PICKER_CLASS);
                $("<div>").appendTo(this.dateBox._popup.content()).addClass(CALENDAR_WITH_TIME_PICKER_CONTAINER_CLASS).dxBox({
                    direction: "row",
                    crossAlign: "center",
                    items: [{
                            ratio: 0,
                            baseSize: "auto",
                            name: "calendar"
                        }, {
                            ratio: 0,
                            baseSize: "auto",
                            name: "time"
                        }],
                    itemTemplate: $.proxy(function(data, _, $container) {
                        if (data.name === "calendar")
                            this._$calendarContainer = $container;
                        if (data.name === "time") {
                            this._timeView = $("<div>").dxTimeView({
                                value: this.dateBox.option("value"),
                                onValueChanged: $.proxy(function(args) {
                                    this.dateBox.option("value", args.value)
                                }, this)
                            }).dxTimeView("instance");
                            $container.append(this._timeView.element())
                        }
                    }, this)
                });
                this.callBase()
            },
            _calenderContainer: function() {
                return this._$calendarContainer
            },
            _renderValue: function(formattedValue) {
                this.callBase(formattedValue);
                var value = formattedValue || this.dateBox.option("value");
                if (this._timeView)
                    this._timeView.option("value", value)
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.dateBox.dateView.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            support = DX.support,
            dateUtils = ui.dateUtils;
        ui.dxDateBox.renderStrategies["DateView"] = DX.Class.inherit({
            ctor: function(dateBox) {
                this.dateBox = dateBox
            },
            _popupShowingHandler: function() {
                this._renderDateView()
            },
            _popupHiddenHandler: function() {
                this.dateBox.option("value", this.dateBox._dateView.option("value"))
            },
            _setDefaultOptions: function() {
                this.dateBox.option({
                    min: new Date(1),
                    max: new Date($.now() + dateUtils.TEN_YEARS)
                })
            },
            _renderPopupContent: function() {
                this.dateBox.callBase()
            },
            _popupConfig: function() {
                return {
                        title: this._getDataPickerTitle(),
                        buttons: [{
                                shortcut: "done",
                                onClick: $.proxy(function() {
                                    this.dateBox.option("value", new Date(this.dateBox._dateView._value));
                                    this.dateBox.close()
                                }, this)
                            }, {
                                shortcut: "cancel",
                                onClick: $.proxy(function() {
                                    this.dateBox._dateView._value = this.dateBox._dateView._valueOption();
                                    this.dateBox.close()
                                }, this)
                            }],
                        defaultOptionsRules: [{
                                device: {platform: "win8"},
                                options: {showNames: true}
                            }, {
                                device: {
                                    platform: "win8",
                                    phone: true
                                },
                                options: {fullScreen: true}
                            }, {
                                device: function(device) {
                                    return device.platform !== "win8"
                                },
                                options: {
                                    width: 333,
                                    height: 331
                                }
                            }, {
                                device: {platform: "generic"},
                                options: {
                                    width: "auto",
                                    height: "auto"
                                }
                            }, {
                                device: {platform: "ios"},
                                options: {
                                    width: "auto",
                                    height: "auto"
                                }
                            }, {
                                device: {
                                    platform: "ios",
                                    phone: true
                                },
                                options: {
                                    width: "100%",
                                    position: {
                                        my: "bottom",
                                        at: "bottom",
                                        of: window
                                    }
                                }
                            }]
                    }
            },
            _getDataPickerTitle: function() {
                var result = this.dateBox.option("placeholder");
                if (!result) {
                    var format = this.dateBox.option("format");
                    if (format === "time")
                        result = Globalize.localize("dxDateBox-simulatedDataPickerTitleTime");
                    else if (format === "date")
                        result = Globalize.localize("dxDateBox-simulatedDataPickerTitleDate");
                    else if (format === "datetime")
                        result = Globalize.localize("dxDateBox-simulatedDataPickerTitleDateTime")
                }
                return result
            },
            _renderOpenedState: $.noop,
            _renderValue: function() {
                var mode = this.dateBox.option("mode"),
                    patternKey = dateUtils.FORMATS_MAP[mode],
                    pattern = support.inputType(mode) ? false : Globalize.culture().calendar.patterns[patternKey],
                    value = dateUtils.toStandardDateFormat(this.dateBox.option("value"), mode, pattern);
                this.dateBox._input().val(value);
                this.dateBox._togglePlaceholder(value === "" || value === null);
                this._renderDateView()
            },
            _renderDateView: function() {
                if (this.dateBox._usingNativeDatePicker() || this.dateBox.option("readOnly")) {
                    if (this.dateBox._dateView) {
                        this.dateBox._dateView.element().remove();
                        this.dateBox._dateView = null
                    }
                    return
                }
                var dateViewOptions = {
                        value: this.dateBox.option("value"),
                        format: this.dateBox.option("format"),
                        minDate: this.dateBox.option("min"),
                        maxDate: this.dateBox.option("max")
                    };
                var popup = this.dateBox._popup;
                if (!popup)
                    return;
                if (this.dateBox._dateView) {
                    this.dateBox._dateView.option(dateViewOptions);
                    this.dateBox._dateView._renderRollers()
                }
                else
                    this.dateBox._dateView = $("<div>").appendTo(popup.content()).dxDateView($.extend(dateViewOptions, {onHiding: $.proxy(function(e) {
                            this.dateBox.option("value", e.component.option("value"))
                        }, this)})).dxDateView("instance");
                popup.option("title", this._getDataPickerTitle())
            },
            _valueChangeEventHandler: function() {
                var value = dateUtils.fromStandardDateFormat(this.dateBox._input().val()),
                    modelValue = new Date(this.dateBox.option("value") && this.dateBox.option("value").valueOf()),
                    newValue = dateUtils.mergeDates(modelValue, value, this.dateBox.option("mode"));
                this.dateBox.option({value: newValue});
                if (newValue !== modelValue)
                    this._renderValue()
            },
            _defaultOptionsRules: function() {
                return [{
                            device: function() {
                                var realDevice = DX.devices.real(),
                                    platform = realDevice.platform,
                                    version = realDevice.version;
                                return platform === "generic" || platform === "win8" || platform === "android" && !(version[0] > 4 || version[0] == 4 && version[1] >= 4)
                            },
                            options: {useNative: false}
                        }]
            },
            _render: function(){},
            _renderPlaceholder: function() {
                if (this.dateBox._popup)
                    this.dateBox._popup.option("title", this._getDataPickerTitle())
            },
            _initFormat: function() {
                var format = this.dateBox.option("format");
                if ($.inArray(format, dateUtils.SUPPORTED_FORMATS) === -1) {
                    format = "date";
                    this.dateBox.option("format", format)
                }
                else if (format === "datetime" && !support.inputType(format))
                    format = "datetime-local";
                this.dateBox.option({
                    mode: format,
                    formatString: dateUtils.FORMATS_MAP[format]
                })
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.dateBox.time.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            dateUtils = ui.dateUtils,
            TIMEBOX_CLASS = "dx-timebox",
            TIMELIST_CLASS = "dx-timebox-list",
            TIMEBOX_POPUP_WRAPPER_CLASS = "dx-timebox-popup-wrapper";
        ui.dxDateBox.renderStrategies["Time"] = DX.Class.inherit({
            ctor: function(dateBox) {
                this.dateBox = dateBox
            },
            _supportedKeys: function() {
                return $.extend(this.dateBox.callBase(), {
                        tab: function(e) {
                            if (this.option("opened"))
                                this.close()
                        },
                        space: $.noop
                    })
            },
            _setDefaultOptions: function() {
                this.dateBox.option({
                    formatString: Globalize.culture().calendar.patterns["t"],
                    closeOnValueChange: true,
                    interval: 30
                })
            },
            _defaultOptionsRules: function() {
                return [{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }]
            },
            _render: function() {
                this.dateBox.element().addClass(TIMEBOX_CLASS)
            },
            _renderPopupContent: function() {
                this.dateBox._popup._wrapper().addClass(TIMEBOX_POPUP_WRAPPER_CLASS);
                this._renderList()
            },
            _popupConfig: function() {
                return $.extend(this.dateBox.callBase(), {width: this.dateBox.element().outerWidth()})
            },
            _popupShowingHandler: function() {
                this._dimensionChanged()
            },
            _popupHiddenHandler: $.noop,
            _renderList: function() {
                this.dateBox._$timeList = $("<div>").addClass(TIMELIST_CLASS);
                this.dateBox._timeList = this.dateBox._$timeList.dxList(this._listConfig()).dxList("instance");
                this._refreshItems();
                this.dateBox._$timeList.appendTo(this.dateBox._popup.content())
            },
            _refreshItems: function() {
                var items = this._getTimeListItems();
                this.dateBox._timeList.option("items", items)
            },
            _getTimeListItems: function() {
                var min = this.dateBox.option("min") || new Date(0, 0, 0, 0, 0),
                    max = this.dateBox.option("max") || new Date(0, 0, 0, 23, 59),
                    interval = this.dateBox.option("interval"),
                    result = [],
                    current = new Date(min),
                    delta = max - min;
                if (delta < 0)
                    return [];
                if (delta > dateUtils.ONE_DAY)
                    delta = dateUtils.ONE_DAY;
                while (current - min < delta) {
                    result.push(new Date(current));
                    current.setMinutes(current.getMinutes() + interval)
                }
                return result
            },
            _listConfig: function() {
                return {
                        rtlEnabled: this.dateBox.option("rtlEnabled"),
                        itemTemplate: $.proxy(this._timeListItemTemplate, this),
                        onItemClick: $.proxy(this._listItemClickHandler, this),
                        focusStateEnabled: this.dateBox.option("focusStateEnabled"),
                        tabIndex: -1
                    }
            },
            _timeListItemTemplate: function(itemData, itemIndex, itemElement) {
                return Globalize.format(itemData, this.dateBox.option("formatString"))
            },
            _listItemClickHandler: function(e) {
                this.dateBox.option("opened", false);
                this.dateBox.option("value", e.itemData)
            },
            _attachKeyboardEvents: function() {
                var child = this.dateBox._keyboardProcessor.attachChildProcessor();
                if (this.dateBox._timeList) {
                    this.dateBox._timeList.option("_keyboardProcessor", child);
                    return
                }
                var config = this._listConfig();
                this._listConfig = function() {
                    return $.extend(config, {_keyboardProcessor: child})
                }
            },
            _dimensionChanged: function() {
                this.dateBox._popup && this._updatePopupDimensions()
            },
            _updatePopupDimensions: function() {
                this._updatePopupWidth();
                this._updatePopupHeight()
            },
            _updatePopupWidth: function() {
                this.dateBox._setPopupOption("width", this.dateBox.element().outerWidth())
            },
            _updatePopupHeight: function() {
                this.dateBox._setPopupOption("height", "auto");
                var popupHeight = this.dateBox._popup.overlayContent().outerHeight();
                var maxHeight = $(window).height() * 0.45;
                this.dateBox._setPopupOption("height", Math.min(popupHeight, maxHeight));
                this.dateBox._timeList && this.dateBox._timeList.updateDimensions()
            },
            _renderOpenedState: $.noop,
            _initFormat: $.noop,
            _renderPlaceholder: $.noop,
            _renderValue: function(formattedValue) {
                this.dateBox.callBase(Globalize.format(this.dateBox.option("value"), this.dateBox.option("formatString")))
            },
            _valueChangeEventHandler: function(e, formattedValue) {
                this.dateBox._suppressUpdateValue();
                var time = Globalize.parseDate(this.dateBox._input().val(), this.dateBox.option("formatString"));
                this.dateBox.callBase(e, time);
                this.dateBox._resumeUpdateValue()
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.loadIndicator.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var LOADINDICATOR_CLASS = "dx-loadindicator",
            LOADINDICATOR_WRAPPER = "dx-loadindicator-wrapper",
            LOADINDICATOR_ICON = "dx-loadindicator-icon",
            LOADINDICATOR_SEGMENT = "dx-loadindicator-segment",
            LOADINDICATOR_SEGMENT_N = "dx-loadindicator-segment",
            LOADINDICATOR_SEGMENT_WIN8 = "dx-loadindicator-win8-segment",
            LOADINDICATOR_SEGMENT_N_WIN8 = "dx-loadindicator-win8-segment",
            LOADINDICATOR_INNER_SEGMENT_WIN8 = "dx-loadindicator-win8-inner-segment",
            LOADINDICATOR_IMAGE = "dx-loadindicator-image";
        DX.registerComponent("dxLoadIndicator", ui, ui.Widget.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    indicatorSrc: "",
                    hoverStateEnabled: false
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function() {
                                var realDevice = DevExpress.devices.real(),
                                    obsoleteAndroid = realDevice.platform === "android" && !/chrome/i.test(navigator.userAgent);
                                return DevExpress.browser.msie && DevExpress.browser.version < 10 || obsoleteAndroid
                            },
                            options: {viaImage: true}
                        }])
            },
            _init: function() {
                this.callBase();
                this.element().addClass(LOADINDICATOR_CLASS)
            },
            _render: function() {
                this._renderWrapper();
                this._renderMarkup();
                this.callBase()
            },
            _renderWrapper: function() {
                this._$wrapper = $("<div>").addClass(LOADINDICATOR_WRAPPER);
                this.element().append(this._$wrapper)
            },
            _renderMarkup: function() {
                if (DX.support.animation && !this.option("viaImage") && !this.option("indicatorSrc"))
                    this._renderMarkupForAnimation();
                else
                    this._renderMarkupForImage()
            },
            _renderMarkupForAnimation: function() {
                this._$indicator = $("<div>").addClass(LOADINDICATOR_ICON);
                for (var i = 15; i >= 0; --i) {
                    var $segment = $("<div>").addClass(LOADINDICATOR_SEGMENT).addClass(LOADINDICATOR_SEGMENT_N + i);
                    this._$indicator.append($segment)
                }
                for (var i = 1; i <= 5; ++i) {
                    var $innerSegment = $("<div>").addClass(LOADINDICATOR_INNER_SEGMENT_WIN8),
                        $segment = $("<div>").addClass(LOADINDICATOR_SEGMENT_WIN8).addClass(LOADINDICATOR_SEGMENT_N_WIN8 + i);
                    $segment.append($innerSegment);
                    this._$indicator.append($segment)
                }
                this._$wrapper.append(this._$indicator)
            },
            _renderMarkupForImage: function() {
                var indicatorSrc = this.option("indicatorSrc");
                this._$wrapper.addClass(LOADINDICATOR_IMAGE);
                if (indicatorSrc)
                    this._$wrapper.css("background-image", "url(" + indicatorSrc + ")")
            },
            _renderDimensions: function() {
                this.callBase();
                this._updateContentSize()
            },
            _updateContentSize: function() {
                var $element = this.element(),
                    width = this.option("width"),
                    height = this.option("height");
                if (width || height) {
                    width = this.element().width();
                    height = this.element().height();
                    var minDimention = Math.min(height, width);
                    this._$wrapper.css({
                        height: minDimention,
                        width: minDimention,
                        "margin-top": (height - minDimention) / 2,
                        "margin-left": (width - minDimention) / 2
                    });
                    if (this._$indicator)
                        if (DX.ui.themes.current().split(".")[0] === "android5") {
                            var $segment2 = this._$indicator.find("." + LOADINDICATOR_SEGMENT_N + "2"),
                                $segment3 = this._$indicator.find("." + LOADINDICATOR_SEGMENT_N + "3");
                            $segment2.css("border-width", 0.13 * minDimention);
                            $segment3.css("border-width", 0.17 * minDimention)
                        }
                        else
                            this._$indicator.find("." + LOADINDICATOR_SEGMENT).css("border-width", 0.125 * minDimention)
                }
            },
            _clean: function() {
                this.callBase();
                this._removeMarkupForAnimation();
                this._removeMarkupForImage()
            },
            _removeMarkupForAnimation: function() {
                if (this._$indicator)
                    this._$indicator.remove()
            },
            _removeMarkupForImage: function() {
                this._$wrapper.css("background-image", "none")
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"indicatorSrc":
                        this._invalidate();
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.loadPanel.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var LOADPANEL_CLASS = "dx-loadpanel",
            LOADPANEL_WRAPPER_CLASS = "dx-loadpanel-wrapper",
            LOADPANEL_INDICATOR_CLASS = "dx-loadpanel-indicator",
            LOADPANEL_MESSAGE_CLASS = "dx-loadpanel-message",
            LOADPANEL_CONTENT_CLASS = "dx-loadpanel-content",
            LOADPANEL_CONTENT_WRAPPER_CLASS = "dx-loadpanel-content-wrapper",
            LOADPANEL_PANE_HIDDEN_CLASS = "dx-loadpanel-pane-hidden";
        DX.registerComponent("dxLoadPanel", ui, ui.dxOverlay.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    message: Globalize.localize("Loading"),
                    width: 222,
                    height: 90,
                    animation: null,
                    showIndicator: true,
                    indicatorSrc: "",
                    showPane: true,
                    delay: 0,
                    closeOnBackButton: false
                })
            },
            _init: function() {
                this.callBase.apply(this, arguments);
                this._$contentWrapper = $("<div>").addClass(LOADPANEL_CONTENT_WRAPPER_CLASS);
                this._$contentWrapper.appendTo(this._$content)
            },
            _render: function() {
                this.callBase();
                this.element().addClass(LOADPANEL_CLASS);
                this._wrapper().addClass(LOADPANEL_WRAPPER_CLASS)
            },
            _renderContentImpl: function() {
                this.callBase();
                this.content().addClass(LOADPANEL_CONTENT_CLASS);
                this._togglePaneVisible();
                this._cleanPreviousContent();
                this._renderLoadIndicator();
                this._renderMessage()
            },
            _show: function() {
                var delay = this.option("delay");
                if (!delay)
                    return this.callBase();
                var deferred = $.Deferred();
                var callBase = $.proxy(this.callBase, this);
                this._clearShowTimeout();
                this._showTimeout = setTimeout(function() {
                    callBase().done(function() {
                        deferred.resolve()
                    })
                }, delay);
                return deferred.promise()
            },
            _hide: function() {
                this._clearShowTimeout();
                return this.callBase()
            },
            _clearShowTimeout: function() {
                clearTimeout(this._showTimeout)
            },
            _renderMessage: function() {
                var message = this.option("message");
                if (!message)
                    return;
                var $message = $("<div>").addClass(LOADPANEL_MESSAGE_CLASS).text(message);
                this._$contentWrapper.append($message)
            },
            _renderLoadIndicator: function() {
                if (!this.option("showIndicator"))
                    return;
                this._$indicator = $("<div>").addClass(LOADPANEL_INDICATOR_CLASS).dxLoadIndicator({indicatorSrc: this.option("indicatorSrc")}).appendTo(this._$contentWrapper)
            },
            _cleanPreviousContent: function() {
                this.content().find("." + LOADPANEL_MESSAGE_CLASS).remove();
                this.content().find("." + LOADPANEL_INDICATOR_CLASS).remove()
            },
            _togglePaneVisible: function() {
                this.content().toggleClass(LOADPANEL_PANE_HIDDEN_CLASS, !this.option("showPane"))
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"delay":
                        break;
                    case"message":
                    case"showIndicator":
                        this._cleanPreviousContent();
                        this._renderLoadIndicator();
                        this._renderMessage();
                        break;
                    case"showPane":
                        this._togglePaneVisible();
                        break;
                    case"indicatorSrc":
                        if (this._$indicator)
                            this._$indicator.dxLoadIndicator({indicatorSrc: this.option("indicatorSrc")});
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _dispose: function() {
                this._clearShowTimeout();
                this.callBase()
            }
        }));
        ui.dxLoadPanel.__internals = {
            LOADPANEL_CLASS: LOADPANEL_CLASS,
            LOADPANEL_WRAPPER_CLASS: LOADPANEL_WRAPPER_CLASS,
            LOADPANEL_MESSAGE_CLASS: LOADPANEL_MESSAGE_CLASS,
            LOADPANEL_CONTENT_CLASS: LOADPANEL_CONTENT_CLASS,
            LOADPANEL_PANE_HIDDEN_CLASS: LOADPANEL_PANE_HIDDEN_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.lookup.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events;
        var LOOKUP_CLASS = "dx-lookup",
            LOOKUP_SELECTED_CLASS = "dx-lookup-selected",
            LOOKUP_SEARCH_CLASS = "dx-lookup-search",
            LOOKUP_SEARCH_WRAPPER_CLASS = "dx-lookup-search-wrapper",
            LOOKUP_FIELD_CLASS = "dx-lookup-field",
            LOOKUP_FIELD_WRAPPER_CLASS = "dx-lookup-field-wrapper",
            LOOKUP_POPUP_CLASS = "dx-lookup-popup",
            LOOKUP_POPUP_WRAPPER_CLASS = "dx-lookup-popup-wrapper",
            LOOKUP_POPUP_SEARCH_CLASS = "dx-lookup-popup-search",
            LOOKUP_POPOVER_MODE = "dx-lookup-popover-mode",
            LOOKUP_EMPTY_CLASS = "dx-lookup-empty",
            LIST_ITEM_SELECTOR = ".dx-list-item",
            LIST_ITEM_DATA_KEY = "dxListItemData",
            POPUP_HIDE_TIMEOUT = 200;
        var POPUP_OPTION_MAP = {
                popupWidth: "width",
                popupHeight: "height"
            };
        DX.registerComponent("dxLookup", ui, ui.dxDropDownList.inherit({
            _supportedKeys: function() {
                return $.extend(this.callBase(), {
                        space: function(e) {
                            this._validatedOpening()
                        },
                        enter: function(e) {
                            this._validatedOpening()
                        }
                    })
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    minFilterLength: {
                        since: "14.2",
                        alias: "minSearchLength"
                    },
                    scrollAction: {
                        since: "14.2",
                        alias: "onScroll"
                    },
                    autoPagingEnabled: {
                        since: "14.2",
                        alias: "pagingEnabled"
                    },
                    pullRefreshAction: {
                        since: "14.2",
                        alias: "onPullRefresh"
                    },
                    pageLoadingAction: {
                        since: "14.2",
                        alias: "onPageLoading"
                    },
                    contentReadyAction: {
                        since: "14.2",
                        alias: "onContentReady"
                    },
                    titleRender: {
                        since: "14.2",
                        alias: "titleTemplate"
                    },
                    groupRender: {
                        since: "14.2",
                        alias: "groupTemplate"
                    }
                })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    title: "",
                    titleTemplate: "title",
                    onTitleRendered: null,
                    placeholder: Globalize.localize("Select"),
                    searchPlaceholder: Globalize.localize("Search"),
                    searchEnabled: true,
                    noDataText: Globalize.localize("dxCollectionWidget-noDataText"),
                    fullScreen: false,
                    showCancelButton: true,
                    cancelButtonText: Globalize.localize("Cancel"),
                    showClearButton: false,
                    clearButtonText: Globalize.localize("Clear"),
                    showDoneButton: false,
                    doneButtonText: Globalize.localize("Done"),
                    popupWidth: function() {
                        return $(window).width() * 0.8
                    },
                    popupHeight: function() {
                        return $(window).height() * 0.8
                    },
                    shading: true,
                    closeOnOutsideClick: false,
                    position: undefined,
                    animation: undefined,
                    pullRefreshEnabled: false,
                    pagingEnabled: true,
                    useNativeScrolling: true,
                    pullingDownText: Globalize.localize("dxList-pullingDownText"),
                    pulledDownText: Globalize.localize("dxList-pulledDownText"),
                    refreshingText: Globalize.localize("dxList-refreshingText"),
                    pageLoadingText: Globalize.localize("dxList-pageLoadingText"),
                    onScroll: null,
                    onPullRefresh: null,
                    onPageLoading: null,
                    showNextButton: false,
                    nextButtonText: Globalize.localize("dxList-nextButtonText"),
                    grouped: false,
                    groupTemplate: "group",
                    usePopover: false,
                    activeStateEnabled: true,
                    showDropButton: false
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return !DX.support.nativeScrolling
                            },
                            options: {useNativeScrolling: false}
                        }, {
                            device: function(device) {
                                return !DX.support.nativeScrolling && !DX.devices.isSimulator() && DX.devices.real().platform === "generic" && device.platform === "generic"
                            },
                            options: {
                                showNextButton: true,
                                pagingEnabled: false
                            }
                        }, {
                            device: {
                                platform: "win8",
                                phone: true
                            },
                            options: {
                                showCancelButton: false,
                                fullScreen: true
                            }
                        }, {
                            device: {
                                platform: "win8",
                                phone: false
                            },
                            options: {popupWidth: function() {
                                    return $(window).width()
                                }}
                        }, {
                            device: {
                                platform: "ios",
                                phone: true
                            },
                            options: {fullScreen: true}
                        }, {
                            device: {
                                platform: "ios",
                                tablet: true
                            },
                            options: {
                                popupWidth: function() {
                                    return Math.min($(window).width(), $(window).height()) * 0.4
                                },
                                popupHeight: function() {
                                    return Math.min($(window).width(), $(window).height()) * 0.4
                                },
                                usePopover: true
                            }
                        }])
            },
            _dataSourceOptions: function() {
                return $.extend(this.callBase(), {paginate: this.option("pagingEnabled") || this.option("showNextButton")})
            },
            _inputWrapper: function() {
                return this.element().find("." + LOOKUP_FIELD_WRAPPER_CLASS)
            },
            _render: function() {
                this.callBase();
                this.element().addClass(LOOKUP_CLASS).toggleClass(LOOKUP_POPOVER_MODE, this.option("usePopover"))
            },
            _fireContentReadyAction: $.noop,
            _popupWrapperClass: function() {
                return ""
            },
            _renderInput: function() {
                var fieldClickAction = this._createAction($.proxy(function() {
                        this._validatedOpening()
                    }, this));
                this._$field = $("<div>").addClass(LOOKUP_FIELD_CLASS).on(events.addNamespace("dxclick", this.NAME), function(e) {
                    fieldClickAction({jQueryEvent: e})
                });
                this._$fieldWrapper = $("<div>").addClass(LOOKUP_FIELD_WRAPPER_CLASS).append(this._$field).appendTo(this.element())
            },
            _renderPopup: function() {
                if (this.option("usePopover") && !this.option("fullScreen"))
                    this._renderPopover();
                else
                    this.callBase();
                this._$popup.addClass(LOOKUP_POPUP_CLASS);
                this._popup._wrapper().addClass(LOOKUP_POPUP_WRAPPER_CLASS)
            },
            _popupOptionMap: function(optionName) {
                return POPUP_OPTION_MAP[optionName] || optionName
            },
            _renderPopover: function() {
                this._popup = this._$popup.dxPopover($.extend(this._popupConfig(), {
                    target: this.element(),
                    fullScreen: false,
                    shading: false,
                    closeOnTargetScroll: true,
                    closeOnOutsideClick: true
                })).dxPopover("instance");
                this._popup.on({
                    showing: $.proxy(this._popupShowingHandler, this),
                    shown: $.proxy(this._popupShownHandler, this),
                    hiding: $.proxy(this._popupHidingHandler, this),
                    hidden: $.proxy(this._popupHiddenHandler, this)
                });
                this._popup.option("onContentReady", $.proxy(this._contentReadyHandler, this));
                this._contentReadyHandler()
            },
            _popupConfig: function() {
                var result = $.extend(this.callBase(), {
                        onShowing: null,
                        showTitle: true,
                        title: this.option("title"),
                        titleTemplate: this._getTemplateByOption("titleTemplate"),
                        onTitleRendered: this.option("onTitleRendered"),
                        buttons: this._getPopupButtonsConfig(),
                        fullScreen: this.option("fullScreen"),
                        shading: this.option("shading"),
                        closeOnTargetScroll: false,
                        closeOnOutsideClick: this.option("closeOnOutsideClick")
                    });
                delete result.animation;
                delete result.position;
                $.each(["position", "animation", "popupWidth", "popupHeight"], $.proxy(function(_, optionName) {
                    if (this.option(optionName) !== undefined)
                        result[this._popupOptionMap(optionName)] = this.option(optionName)
                }, this));
                return result
            },
            _renderPopupButtons: function() {
                this._setPopupOption("buttons", this._getPopupButtonsConfig())
            },
            _getPopupButtonsConfig: function() {
                var buttonsConfig = [];
                $.each(["Cancel", "Clear", "Done"], $.proxy(function(_, buttonName) {
                    var button = this["_get" + buttonName + "ButtonConfig"]();
                    if (button)
                        buttonsConfig.push(button)
                }, this));
                return buttonsConfig
            },
            _getCancelButtonConfig: function() {
                return this.option("showCancelButton") ? {
                        shortcut: "cancel",
                        onClick: $.proxy(this._cancelValue, this),
                        options: {text: this.option("cancelButtonText")}
                    } : null
            },
            _getDoneButtonConfig: function() {
                return this.option("showDoneButton") ? {
                        shortcut: "done",
                        onClick: $.proxy(this._submitValue, this),
                        options: {text: this.option("doneButtonText")}
                    } : null
            },
            _getClearButtonConfig: function() {
                return this.option("showClearButton") ? {
                        shortcut: "clear",
                        onClick: $.proxy(this._resetValue, this),
                        options: {text: this.option("clearButtonText")}
                    } : null
            },
            _refreshPopupVisibility: $.noop,
            _dimensionChanged: $.noop,
            _input: function() {
                return this._$searchBox || this.callBase()
            },
            _renderPopupContent: function() {
                this._renderSearch();
                this.callBase()
            },
            _renderSearch: function() {
                var $searchWrapper = this._$searchWrapper = $("<div>").addClass(LOOKUP_SEARCH_WRAPPER_CLASS);
                var $searchBox = this._$searchBox = $("<div>").addClass(LOOKUP_SEARCH_CLASS).appendTo($searchWrapper);
                var currentDevice = DX.devices.current(),
                    searchMode = currentDevice.android && currentDevice.version[0] >= 5 ? "text" : "search";
                this._searchBox = $searchBox.dxTextBox({
                    focusStateEnabled: this.option("focusStateEnabled"),
                    mode: searchMode,
                    showClearButton: true,
                    valueChangeEvent: this.option("valueChangeEvent"),
                    onValueChanged: $.proxy(this._search, this),
                    rtlEnabled: this.option("rtlEnabled")
                }).dxTextBox("instance");
                $searchWrapper.appendTo(this._popup.content());
                this._renderSearchVisibility();
                this._setSearchPlaceholder()
            },
            _renderSearchVisibility: function() {
                if (this._popup) {
                    var searchEnabled = this.option("searchEnabled");
                    this._popup._wrapper().toggleClass(LOOKUP_POPUP_SEARCH_CLASS, searchEnabled);
                    this._$searchWrapper.toggle(searchEnabled)
                }
            },
            _setSearchPlaceholder: function() {
                if (!this._$searchBox)
                    return;
                var minSearchLength = this.option("minSearchLength");
                var placeholder = this.option("searchPlaceholder");
                if (minSearchLength && placeholder === Globalize.localize("Search"))
                    placeholder = utils.stringFormat(Globalize.localize("dxLookup-searchPlaceholder"), minSearchLength);
                this._searchBox.option("placeholder", placeholder)
            },
            _listConfig: function() {
                return $.extend(this.callBase(), {
                        tabIndex: 0,
                        grouped: this.option("grouped"),
                        groupTemplate: this._getTemplateByOption("groupTemplate"),
                        noDataText: this.option("noDataText"),
                        pullRefreshEnabled: this.option("pullRefreshEnabled"),
                        useNativeScrolling: this.option("useNativeScrolling"),
                        pullingDownText: this.option("pullingDownText"),
                        pulledDownText: this.option("pulledDownText"),
                        refreshingText: this.option("refreshingText"),
                        pageLoadingText: this.option("pageLoadingText"),
                        onScroll: this.option("onScroll"),
                        onPullRefresh: this.option("onPullRefresh"),
                        onPageLoading: this.option("onPageLoading"),
                        showNextButton: this.option("showNextButton"),
                        nextButtonText: this.option("nextButtonText")
                    })
            },
            _setFocusPolicy: function() {
                if (this._$searchBox)
                    this._searchBox.focus();
                else
                    this._$list.focus()
            },
            _attachChildKeyboardEvents: $.noop,
            _focusTarget: function() {
                return this._$field
            },
            _renderFocusTarget: function() {
                this._focusTarget().attr("tabindex", this.option("tabIndex"))
            },
            _selectedItemClass: function() {
                return LOOKUP_SELECTED_CLASS
            },
            _listItemClickHandler: function(e) {
                if (this._currentSelectedItem() === e.itemData)
                    this._submitValue();
                this._setCurrentSelectedClass(e.jQueryEvent.target);
                if (!this.option("showDoneButton"))
                    this._submitValue()
            },
            _currentSelectedItem: function() {
                return this._listSelectedItemElements().data(LIST_ITEM_DATA_KEY)
            },
            _setCurrentSelectedClass: function(target) {
                this._listSelectedItemElements().removeClass(LOOKUP_SELECTED_CLASS);
                $(target).closest(LIST_ITEM_SELECTOR).addClass(LOOKUP_SELECTED_CLASS)
            },
            _submitValue: function() {
                this.option("value", this._valueGetter(this._currentSelectedItem()));
                this.option("opened", false)
            },
            _resetValue: function() {
                this.option("value", undefined);
                this.option("opened", false)
            },
            _cancelValue: function() {
                this._refreshSelected();
                this.option("opened", false)
            },
            _searchValue: function() {
                return this.option("searchEnabled") ? this._searchBox.option("value") : ""
            },
            _renderValue: function() {
                return this.callBase().always($.proxy(function() {
                        this._refreshField()
                    }, this))
            },
            _refreshField: function() {
                this._$field.text(this.option("displayValue"));
                this.element().toggleClass(LOOKUP_EMPTY_CLASS, !this.option("selectedItem"))
            },
            _clean: function() {
                this._$fieldWrapper.remove();
                this._$searchBox = null;
                this.callBase()
            },
            _optionChanged: function(args) {
                var name = args.name;
                var value = args.value;
                switch (name) {
                    case"searchEnabled":
                        this._renderSearchVisibility();
                        break;
                    case"searchPlaceholder":
                        this._setSearchPlaceholder();
                        break;
                    case"minSearchLength":
                        this._setSearchPlaceholder();
                        this.callBase.apply(this, arguments);
                        break;
                    case"title":
                    case"titleTemplate":
                    case"onTitleRendered":
                    case"shading":
                    case"animation":
                    case"position":
                    case"closeOnOutsideClick":
                        this._setPopupOption(name);
                        break;
                    case"fullScreen":
                    case"usePopover":
                        this._invalidate();
                        break;
                    case"clearButtonText":
                    case"showClearButton":
                    case"cancelButtonText":
                    case"showCancelButton":
                    case"doneButtonText":
                    case"showDoneButton":
                        this._renderPopupButtons();
                        break;
                    case"popupWidth":
                        this._setPopupOption("popupWidth", value === "auto" ? this.initialOption("popupWidth") : value);
                        break;
                    case"popupHeight":
                        this._setPopupOption("popupHeight", value === "auto" ? this.initialOption("popupHeight") : value);
                        break;
                    case"pullRefreshEnabled":
                    case"useNativeScrolling":
                    case"pullingDownText":
                    case"pulledDownText":
                    case"refreshingText":
                    case"pageLoadingText":
                    case"onScroll":
                    case"onPullRefresh":
                    case"onPageLoading":
                    case"showNextButton":
                    case"nextButtonText":
                    case"noDataText":
                    case"grouped":
                    case"groupTemplate":
                        this._setListOption(name);
                        break;
                    default:
                        this.callBase.apply(this, arguments)
                }
            },
            focus: function() {
                this.option("opened") ? this._setFocusPolicy() : this._focusTarget().focus()
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.autocomplete.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            utils = DX.utils;
        var AUTOCOMPLETE_CLASS = "dx-autocomplete",
            AUTOCOMPLETE_POPUP_WRAPPER_CLASS = "dx-autocomplete-popup-wrapper",
            AUTOCOMPLETE_SELECTED_ITEM_CLASS = "dx-autocomplete-selected",
            LIST_ITEM_DATA_KEY = "dxListItemData";
        DX.registerComponent("dxAutocomplete", ui, ui.dxDropDownList.inherit({
            _supportedKeys: function() {
                var item = this._list ? this._list._$focusedItem : null;
                return $.extend(this.callBase(), {
                        upArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (item && !item.prev().length) {
                                this._clearFocusedItem();
                                return false
                            }
                            return true
                        },
                        downArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (item && !item.next().length) {
                                this._clearFocusedItem();
                                return false
                            }
                            return true
                        },
                        enter: function(e) {
                            if (!item)
                                this.close();
                            return true
                        }
                    })
            },
            _setOptionAliases: function() {
                this.callBase();
                $.extend(this._optionAliases, {displayExpr: "valueExpr"})
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    minSearchLength: 1,
                    maxItemCount: 10,
                    showDropButton: false
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return device.android && device.version[0] == 5
                            },
                            options: {dropPosition: {offset: {
                                        v: -9,
                                        h: -16
                                    }}}
                        }])
            },
            _render: function() {
                this.callBase();
                this.element().addClass(AUTOCOMPLETE_CLASS)
            },
            _loadValue: function() {
                return $.Deferred().resolve(this.option("value"))
            },
            _popupConfig: function() {
                return $.extend(this.callBase(), {closeOnOutsideClick: $.proxy(function(e) {
                            return !$(e.target).closest(this.element()).length
                        }, this)})
            },
            _renderDimensions: function() {
                this.callBase();
                this._setPopupOption("width")
            },
            _selectedItemClass: function() {
                return AUTOCOMPLETE_SELECTED_ITEM_CLASS
            },
            _hasItemsToShow: function() {
                var resultItems = this._dataSource && this._dataSource.items() || [];
                var value = this.option("value");
                var firstResultValue = this._displayGetter(resultItems[0]) || "";
                var firstResultValueShorterThanValue = firstResultValue.length < (value || "").length;
                return this.callBase() && !firstResultValueShorterThanValue
            },
            _popupWrapperClass: function() {
                return this.callBase() + " " + AUTOCOMPLETE_POPUP_WRAPPER_CLASS
            },
            _listConfig: function() {
                return $.extend(this.callBase(), {
                        noDataText: "",
                        showNextButton: false,
                        indicateLoading: false
                    })
            },
            _listItemClickHandler: function(e) {
                var value = this._displayGetter(e.itemData);
                this.option("value", value);
                this.close();
                this._input().blur()
            },
            _refreshSelected: $.noop,
            _searchCanceled: function() {
                this.callBase();
                this.close()
            },
            _dataSourceOptions: function() {
                return {paginate: true}
            },
            _searchDataSource: function() {
                this._dataSource.pageSize(this.option("maxItemCount"));
                this.callBase();
                this._clearFocusedItem()
            },
            _clearFocusedItem: function() {
                var list = this._list;
                if (list) {
                    list._removeFocusedItem();
                    delete list._$focusedItem;
                    list.option("selectedIndex", -1)
                }
            },
            _valueChangeEventHandler: function() {
                var prevValue = this.option("value");
                this.callBase.apply(this, arguments);
                if (prevValue !== this.option("value"))
                    this._search()
            },
            _optionChanged: function(args) {
                if (args.name === "maxItemCount")
                    this._searchDataSource();
                else
                    this.callBase(args)
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.selectBox.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            SELECTBOX = "dxSelectBox",
            SELECTBOX_CLASS = "dx-selectbox",
            SELECTBOX_POPUP_CLASS = "dx-selectbox-popup",
            SELECTBOX_SELECTED_CLASS = "dx-selectbox-selected",
            SELECTBOX_CONTAINER_CLASS = "dx-selectbox-container",
            SELECTBOX_POPUP_WRAPPER_CLASS = "dx-selectbox-popup-wrapper",
            BLUR_EVENT_NAME = events.addNamespace("blur", SELECTBOX),
            CLICK_EVENT_NAME = events.addNamespace("dxclick", SELECTBOX),
            CONTROL_KEY = {
                "9": "tab",
                "13": "enter",
                "16": "shift",
                "17": "ctrl",
                "18": "alt",
                "27": "escape",
                "33": "pageUp",
                "34": "pageDown",
                "35": "end",
                "36": "home",
                "37": "leftArrow",
                "38": "upArrow",
                "39": "rightArrow",
                "40": "downArrow"
            };
        DX.registerComponent(SELECTBOX, ui, ui.dxDropDownList.inherit({
            _supportedKeys: function() {
                var parent = this.callBase();
                return $.extend(parent, {enter: function(e) {
                            this._keyboardProcessor._childProcessors[0].process(e)
                        }})
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    placeholder: Globalize.localize("Select"),
                    fieldTemplate: null,
                    valueChangeEvent: "keypress keyup",
                    showSelectionControls: false,
                    editEnabled: false,
                    tooltipEnabled: false,
                    openOnFieldClick: true,
                    showDropButton: true,
                    displayCustomValue: false
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "win8"},
                            options: {dropPosition: {
                                    at: "left top",
                                    offset: {
                                        h: 0,
                                        v: 0
                                    }
                                }}
                        }, {
                            device: function(device) {
                                return device.platform === "android" && device.version[0] == 5
                            },
                            options: {dropPosition: {
                                    my: "top left",
                                    at: "top left",
                                    offset: {
                                        h: -16,
                                        v: -8
                                    }
                                }}
                        }])
            },
            _selectedItemClass: function() {
                return SELECTBOX_SELECTED_CLASS
            },
            _render: function() {
                this.callBase();
                this.element().addClass(SELECTBOX_CLASS);
                this._renderTooltip()
            },
            _createPopup: function() {
                this.callBase();
                this._popup.element().addClass(SELECTBOX_POPUP_CLASS)
            },
            _popupWrapperClass: function() {
                return this.callBase() + " " + SELECTBOX_POPUP_WRAPPER_CLASS
            },
            _renderOpenedState: function() {
                this.callBase();
                if (this.option("opened")) {
                    this._updatePopupHeight();
                    this._list.scrollToItem(this._$list.find("." + this._selectedItemClass()))
                }
            },
            _renderValue: function() {
                return this.callBase().always($.proxy(function() {
                        this._renderTooltip();
                        this._renderInputAddons()
                    }, this))
            },
            _setSelectedItem: function(item) {
                var currentDisplayValue = this._displayValue(item);
                if (!this.option("editEnabled") && !this.option("displayCustomValue") && !item)
                    item = this.option("selectedItem");
                this.callBase(item);
                if ((this.option("editEnabled") || this.option("displayCustomValue")) && !currentDisplayValue)
                    this.option("displayValue", this.option("value"))
            },
            _displayValue: function(item) {
                return item === undefined && this.option("editEnabled") ? this.option("value") : this.callBase(item)
            },
            _listConfig: function() {
                var result = $.extend(this.callBase(), {showNextButton: false});
                if (this.option("showSelectionControls"))
                    $.extend(result, {
                        editEnabled: true,
                        selectionMode: "single",
                        editConfig: {
                            selectionEnabled: true,
                            selectionType: "item"
                        },
                        onSelectionChanged: $.proxy(this._selectionChangeHandler, this)
                    });
                return result
            },
            _selectionChangeHandler: function(e) {
                $.each(e.addedItems || [], $.proxy(function(_, addedItem) {
                    this._setValue(this._valueGetter(addedItem))
                }, this))
            },
            _toggleOpenState: function() {
                this.callBase.apply(this, arguments);
                if (this.option("opened") && (this.option("searchEnabled") || this.option("editEnabled")))
                    this._filterDataSource("")
            },
            _renderTooltip: function() {
                this.element().prop("title", this.option("tooltipEnabled") ? this.option("displayValue") : "")
            },
            _renderDimensions: function() {
                this.callBase();
                this._setPopupOption("width")
            },
            _renderInput: function() {
                this.callBase();
                this._$container.addClass(SELECTBOX_CONTAINER_CLASS);
                this._input().off(BLUR_EVENT_NAME).on(BLUR_EVENT_NAME, $.proxy(this._fieldBlurHandler, this))
            },
            _fieldBlurHandler: function() {
                if (this.option("searchEnabled") && !this.option("editEnabled"))
                    this._renderValue()
            },
            _renderValueChangeEvent: function() {
                if (this._isEditable())
                    this.callBase()
            },
            _isEditable: function() {
                return this.option("editEnabled") || this.option("searchEnabled")
            },
            _fieldRenderData: function() {
                return this.option("selectedItem")
            },
            _readOnlyPropValue: function() {
                return !this._isEditable() || this.option("readOnly")
            },
            _isSelectedValue: function(value) {
                return this._valueEquals(value, this.option("value"))
            },
            _listItemClickHandler: function(e) {
                this._completeSelection(this._valueGetter(e.itemData))
            },
            _completeSelection: function(value) {
                if (value === undefined)
                    value = this.option("editEnabled") && this._searchValue() ? this._searchValue() : this.option("value");
                this.option("opened", false);
                this._clearFilter();
                this._setValue(value)
            },
            _setValue: function(value) {
                this.option("value", value)
            },
            _clearValueHandler: function() {
                this._clearSelectedItem();
                this.option("value", undefined)
            },
            _valueChangeEventHandler: function(e) {
                if (CONTROL_KEY[e.which])
                    return;
                if (this.option("editEnabled")) {
                    this._valueUpdateSuppressed = true;
                    this.callBase.apply(this, arguments);
                    this._valueUpdateSuppressed = false
                }
                if (this.option("searchEnabled"))
                    this._search()
            },
            _createClearButton: function() {
                return this.callBase().on(CLICK_EVENT_NAME, function() {
                        return false
                    })
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"tooltipEnabled":
                        this._renderTooltip();
                        break;
                    case"displayCustomValue":
                    case"editEnabled":
                    case"showSelectionControls":
                        this._invalidate();
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.tagBox.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            TAGBOX = "dxTagBox",
            TAGBOX_TAG_DATA_KEY = "dxTagData",
            TAGBOX_CLASS = "dx-tagbox",
            TAGBOX_TAG_CONTAINER_CLASS = "dx-tag-container",
            TAGBOX_TAG_CLASS = "dx-tag",
            TAGBOX_TAG_CONTENT_CLASS = "dx-tag-content",
            TAGBOX_TAG_REMOVE_BUTTON_CLASS = "dx-tag-remove-button",
            TAGBOX_ONLY_SELECT_CLASS = "dx-tagbox-only-select",
            EMPTY_INPUT_CLASS = "dx-texteditor-empty",
            TAGBOX_TAG_REMOVE_CLICK_EVENT_NAME = events.addNamespace("dxclick", TAGBOX + "TagRemove");
        var dxTagRemoveButton = ui.Widget.inherit({
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({activeStateEnabled: true})
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(TAGBOX_TAG_REMOVE_BUTTON_CLASS)
                }
            });
        DX.registerComponent(TAGBOX, ui, ui.dxSelectBox.inherit({
            _supportedKeys: function() {
                var parent = this.callBase();
                return $.extend(parent, {
                        backspace: function(e) {
                            if (this._searchValue().length)
                                return;
                            e.preventDefault();
                            e.stopPropagation();
                            var values = this.option("values");
                            this._removeTag(values[values.length - 1]);
                            this._renderMultiSelect()
                        },
                        enter: function(e) {
                            if (this.option("editEnabled") && !this._$list.find(".dx-state-focused").length)
                                this._completeSelection();
                            else
                                this._keyboardProcessor._childProcessors[0].process(e)
                        }
                    })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    values: [],
                    value: undefined,
                    onValuesChanged: null,
                    showDropButton: false,
                    selectAllText: Globalize.localize("dxList-selectAll")
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return device.platform === "android" && device.version[0] < 5
                            },
                            options: {showDropButton: true}
                        }])
            },
            _init: function() {
                this.callBase();
                this._initValuesChangedAction()
            },
            _initValuesChangedAction: function() {
                this._valuesChangedAction = this._createActionByOption("onValuesChanged");
                this._removeTagAction = this._createAction(this._removeTagHandler)
            },
            _render: function() {
                this.callBase();
                this.element().addClass(TAGBOX_CLASS);
                this.element().toggleClass(TAGBOX_ONLY_SELECT_CLASS, !(this.option("searchEnabled") || this.option("editEnabled")));
                this.element().find(".dx-texteditor-container").off(TAGBOX_TAG_REMOVE_CLICK_EVENT_NAME).on(TAGBOX_TAG_REMOVE_CLICK_EVENT_NAME, "." + TAGBOX_TAG_REMOVE_BUTTON_CLASS, $.proxy(function(e) {
                    this._removeTagAction({jQueryEvent: e})
                }, this))
            },
            _renderValue: function() {
                return this.callBase().always($.proxy(function() {
                        this._renderMultiSelect()
                    }, this))
            },
            _listContentReadyHandler: function() {
                this._suppressingSelectionChanged(function() {
                    this._setListOption("selectedItems", this._selectedItems)
                });
                this.callBase()
            },
            _suppressingSelectionChanged: function(callback) {
                this._setListOption("onSelectionChanged", $.noop);
                callback.call(this);
                this._setListOption("onSelectionChanged", $.proxy(this._selectionChangeHandler, this))
            },
            _listConfig: function() {
                var config = this.callBase();
                if (this.option("showSelectionControls"))
                    $.extend(config, {
                        selectionMode: "all",
                        selectAllText: this.option("selectAllText")
                    });
                return config
            },
            _renderMultiSelect: function() {
                this._$tagsContainer = this.element().find(".dx-texteditor-container").addClass(TAGBOX_TAG_CONTAINER_CLASS);
                this._renderInputSize();
                this._clearFilter();
                this._renderTags();
                this._popup && this._popup.repaint()
            },
            _renderInputSize: function() {
                var $input = this._input();
                $input.prop("size", $input.val() ? $input.val().length + 2 : 1)
            },
            _renderTags: function() {
                this._cleanTags();
                var $tagsBag = $("<div>");
                this._selectedItems = [];
                var itemLoadDeferreds = $.map(this._values(), $.proxy(function(value) {
                        return this._renderTag(value, $tagsBag)
                    }, this));
                $tagsBag.children().insertBefore(this._input());
                $.when.apply($, itemLoadDeferreds).done($.proxy(this._renderInputAddons, this));
                this._renderEmptyState()
            },
            _renderEmptyState: function() {
                var hasNoValues = !this._values().length;
                this.element().toggleClass(EMPTY_INPUT_CLASS, hasNoValues);
                this._input().val("");
                this._renderInputSize();
                this._placeholder().toggle(hasNoValues)
            },
            _cleanTags: function() {
                var $tags = this._tagElements();
                var values = this.option("values");
                $.each($tags, function(_, tag) {
                    var $tag = $(tag);
                    if ($.inArray($tag.data(TAGBOX_TAG_DATA_KEY), values) < 0)
                        $tag.remove()
                })
            },
            _tagElements: function() {
                return this.element().find("." + TAGBOX_TAG_CLASS)
            },
            _renderTag: function(value, $container) {
                if (this._isTagRendered(value))
                    return $.Deferred().resolve();
                var $tag = $("<div>").addClass(TAGBOX_TAG_CLASS).data(TAGBOX_TAG_DATA_KEY, value).appendTo($container);
                var $tagContent = $("<div>").addClass(TAGBOX_TAG_CONTENT_CLASS).appendTo($tag);
                var $removeButton = $("<div>").dxTagRemoveButton().appendTo($tag);
                return this._loadValue(value).always($.proxy(function(item) {
                        $tagContent.append(DX.utils.isDefined(item) ? this._displayGetter(item) : value);
                        this._selectedItems.push(DX.utils.isDefined(item) ? item : value)
                    }, this))
            },
            _isTagRendered: function(value) {
                var $tags = this._tagElements();
                var result = false;
                $.each($tags, function(_, tag) {
                    var $tag = $(tag);
                    if (value === $tag.data(TAGBOX_TAG_DATA_KEY)) {
                        result = true;
                        return false
                    }
                });
                return result
            },
            _toggleEmptinessEventHandler: function() {
                this._toggleEmptiness(!this.option("values").length && !this._searchValue().length)
            },
            _removeTagHandler: function(args) {
                var component = args.component;
                var e = args.jQueryEvent;
                e.stopPropagation();
                var $tag = $(e.target).closest("." + TAGBOX_TAG_CLASS);
                var itemValue = $tag.data(TAGBOX_TAG_DATA_KEY);
                component._removeTag(itemValue);
                component._suppressingSelectionChanged(function() {
                    component._updateValues()
                });
                component.option("values", component.option("values"))
            },
            _selectionChangeHandler: function(e) {
                $.each(e.removedItems || [], $.proxy(function(_, removedItem) {
                    this._removeTag(this._valueGetter(removedItem))
                }, this));
                $.each(e.addedItems || [], $.proxy(function(_, addedItem) {
                    this._addTag(this._valueGetter(addedItem))
                }, this));
                this.callBase(e);
                this._updateValues();
                this._valuesChangedAction(e)
            },
            _removeTag: function(value) {
                this.option().value = value;
                var values = this.option("values"),
                    index = this._valueIndex(value);
                if (index >= 0)
                    values.splice(index, 1)
            },
            _addTag: function(value) {
                var values = this.option("values"),
                    index = this._valueIndex(value);
                if (index < 0)
                    values.push(value)
            },
            _fieldRenderData: function() {
                return this._selectedItems
            },
            _setValue: function(value) {
                if (value === undefined || this._isSelectedValue(value))
                    return;
                var values = this.option("values");
                values.push(value);
                this.option("values", values)
            },
            _isSelectedValue: function(value) {
                return this._valueIndex(value) > -1
            },
            _valueIndex: function(value) {
                var result = -1;
                $.each(this._values(), $.proxy(function(index, selectedValue) {
                    if (this._valueEquals(value, selectedValue)) {
                        result = index;
                        return false
                    }
                }, this));
                return result
            },
            _values: function() {
                return this.option("values") || []
            },
            _clearValueHandler: function() {
                this.option("values", []);
                this.callBase()
            },
            _updateValues: function() {
                this.option("value", this._lastValue())
            },
            _lastValue: function() {
                return this._values().slice(-1).pop()
            },
            _valueChangeEventHandler: function(e) {
                this._renderInputSize();
                if (this.option("editEnabled"))
                    return;
                this.callBase(e)
            },
            _valueChangeArgs: function() {
                var result = this.callBase.apply(this, arguments);
                delete result.previousValue;
                return $.extend(result, {values: this.option("values")})
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"values":
                        this._updateValues();
                        break;
                    case"onValuesChanged":
                        this._initValuesChangedAction();
                        break;
                    case"selectAllText":
                        this._setListOption("selectAllText", this.option("selectAllText"));
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }));
        DX.registerComponent("dxTagRemoveButton", ui[TAGBOX], dxTagRemoveButton)
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.multiView.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            utils = DX.utils,
            fx = DX.fx,
            translator = DX.translator;
        var MULTIVIEW_CLASS = "dx-multiview",
            MULTIVIEW_WRAPPER_CLASS = "dx-multiview-wrapper",
            MULTIVIEW_ITEM_CONTAINER_CLASS = "dx-multiview-item-container",
            MULTIVIEW_ITEM_CLASS = "dx-multiview-item",
            MULTIVIEW_ITEM_HIDDEN_CLASS = "dx-multiview-item-hidden",
            MULTIVIEW_ITEM_DATA_KEY = "dxMultiViewItemData";
        var position = function($element) {
                return translator.locate($element).left
            };
        var move = function($element, position) {
                translator.move($element, {left: position})
            };
        var animation = {
                moveTo: function($element, position, completeAction) {
                    fx.animate($element, {
                        type: "slide",
                        to: {left: position},
                        duration: 200,
                        complete: completeAction
                    })
                },
                complete: function($element) {
                    fx.stop($element, true)
                }
            };
        DX.registerComponent("dxMultiView", ui, ui.CollectionWidget.inherit({
            _activeStateUnit: "." + MULTIVIEW_ITEM_CLASS,
            _supportedKeys: function() {
                return $.extend(this.callBase(), {
                        pageUp: $.noop,
                        pageDown: $.noop
                    })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    selectedIndex: 0,
                    swipeEnabled: true,
                    animationEnabled: true,
                    loop: false,
                    loopItemFocus: false,
                    selectOnFocus: true,
                    selectionMode: "single",
                    selectionRequired: true,
                    selectionByClick: false
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }])
            },
            _itemClass: function() {
                return MULTIVIEW_ITEM_CLASS
            },
            _itemDataKey: function() {
                return MULTIVIEW_ITEM_DATA_KEY
            },
            _itemContainer: function() {
                return this._$itemContainer
            },
            _itemWidth: function() {
                if (!this._itemWidthValue)
                    this._itemWidthValue = this._$wrapper.width();
                return this._itemWidthValue
            },
            _clearItemWidthCache: function() {
                delete this._itemWidthValue
            },
            _itemsCount: function() {
                return this.option("items").length
            },
            _normalizeIndex: function(index) {
                var count = this._itemsCount();
                if (index < 0)
                    index = index + count;
                if (index >= count)
                    index = index - count;
                return index
            },
            _init: function() {
                this.callBase.apply(this, arguments);
                var $element = this.element();
                $element.addClass(MULTIVIEW_CLASS);
                this._$wrapper = $("<div>").addClass(MULTIVIEW_WRAPPER_CLASS);
                this._$wrapper.appendTo($element);
                this._$itemContainer = $("<div>").addClass(MULTIVIEW_ITEM_CONTAINER_CLASS);
                this._$itemContainer.appendTo(this._$wrapper);
                this._initSwipeable()
            },
            _render: function() {
                this.callBase();
                this._updateContainerDimensions()
            },
            _renderDimensions: function() {
                this.callBase();
                this._updateContainerDimensions()
            },
            _updateContainerDimensions: function() {
                if (this.option("height") !== "auto") {
                    this.element().find("." + MULTIVIEW_ITEM_CLASS).css("height", "100%");
                    return
                }
                var itemHeightCache = [],
                    $element = this.element();
                $element.css("height", "100%");
                $.each(this.element().find("." + MULTIVIEW_ITEM_CLASS), function(index, value) {
                    var $item = $(value);
                    $item.css("height", "auto");
                    itemHeightCache.push($item.outerHeight())
                });
                var height = itemHeightCache[this.option("selectedIndex")];
                $element.height(height)
            },
            _dimensionChanged: function() {
                this._clearItemWidthCache()
            },
            _renderSelection: function(addedSelection) {
                this._updateItems(addedSelection[0])
            },
            _updateItems: function(selectedIndex, newIndex) {
                this._updateItemsPosition(selectedIndex, newIndex);
                this._updateItemsVisibility(selectedIndex, newIndex)
            },
            _updateItemsVisibility: function(selectedIndex, newIndex) {
                var $itemElements = this._itemElements();
                $itemElements.each(function(itemIndex, item) {
                    var $item = $(item),
                        isHidden = itemIndex !== selectedIndex && itemIndex !== newIndex;
                    $item.toggleClass(MULTIVIEW_ITEM_HIDDEN_CLASS, isHidden)
                })
            },
            _updateItemsPosition: function(selectedIndex, newIndex) {
                var $itemElements = this._itemElements(),
                    positionSign = -this._animationDirection(newIndex, selectedIndex);
                move($itemElements.eq(selectedIndex), 0);
                move($itemElements.eq(newIndex), positionSign * 100 + "%")
            },
            _updateSelection: function(addedSelection, removedSelection) {
                var newIndex = addedSelection[0],
                    prevIndex = removedSelection[0];
                animation.complete(this._$itemContainter);
                this._updateItems(prevIndex, newIndex);
                var animationDirection = this._animationDirection(newIndex, prevIndex);
                this._animateItemContainer(animationDirection * this._itemWidth(), $.proxy(function() {
                    move(this._$itemContainer, 0);
                    this._updateItems(newIndex);
                    this._$itemContainer.width()
                }, this))
            },
            _animateItemContainer: function(position, completeCallback) {
                if (this.option("animationEnabled"))
                    animation.moveTo(this._$itemContainer, position, completeCallback);
                else
                    completeCallback()
            },
            _animationDirection: function(newIndex, prevIndex) {
                var containerPosition = position(this._$itemContainer),
                    indexDifference = (prevIndex - newIndex) * this._getRTLSignCorrection(),
                    isSwipePresent = containerPosition !== 0,
                    directionSignVariable = isSwipePresent ? containerPosition : indexDifference;
                return utils.sign(directionSignVariable)
            },
            _initSwipeable: function() {
                this.element().dxSwipeable({
                    disabled: !this.option("swipeEnabled"),
                    elastic: false,
                    itemSizeFunc: $.proxy(this._itemWidth, this),
                    onStart: $.proxy(function(args) {
                        this._swipeStartHandler(args.jQueryEvent)
                    }, this),
                    onUpdated: $.proxy(function(args) {
                        this._swipeUpdateHandler(args.jQueryEvent)
                    }, this),
                    onEnd: $.proxy(function(args) {
                        this._swipeEndHandler(args.jQueryEvent)
                    }, this)
                })
            },
            _swipeStartHandler: function(e) {
                animation.complete(this._$itemContainer);
                var selectedIndex = this.option("selectedIndex"),
                    loop = this.option("loop"),
                    lastIndex = this._itemsCount() - 1,
                    rtl = this.option("rtlEnabled");
                e.maxLeftOffset = +(loop || (rtl ? selectedIndex > 0 : selectedIndex < lastIndex));
                e.maxRightOffset = +(loop || (rtl ? selectedIndex < lastIndex : selectedIndex > 0))
            },
            _swipeUpdateHandler: function(e) {
                var offset = e.offset,
                    swipeDirection = utils.sign(offset) * this._getRTLSignCorrection();
                move(this._$itemContainer, offset * 100 + "%");
                if (swipeDirection !== this._swipeDirection) {
                    this._swipeDirection = swipeDirection;
                    var selectedIndex = this.option("selectedIndex"),
                        newIndex = this._normalizeIndex(selectedIndex - swipeDirection);
                    this._updateItems(selectedIndex, newIndex)
                }
            },
            _swipeEndHandler: function(e) {
                var targetOffset = e.targetOffset * this._getRTLSignCorrection();
                if (targetOffset)
                    this.option("selectedIndex", this._normalizeIndex(this.option("selectedIndex") - targetOffset));
                else
                    this._animateItemContainer(0, $.noop);
                delete this._swipeDirection
            },
            _getRTLSignCorrection: function() {
                return this.option("rtlEnabled") ? -1 : 1
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._clearItemWidthCache()
            },
            _optionChanged: function(args) {
                var value = args.value;
                switch (args.name) {
                    case"selectedIndex":
                        this.callBase.apply(this, arguments);
                        this._updateContainerDimensions();
                        break;
                    case"loop":
                        this.option("loopItemFocus", value);
                        break;
                    case"animationEnabled":
                        break;
                    case"swipeEnabled":
                        this.element().dxSwipeable("option", "disabled", !value);
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }));
        ui.dxMultiView.__internals = {animation: animation}
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.validator.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            validationEngine = DX.validationEngine;
        var VALIDATOR_CLASS = "dx-validator";
        DevExpress.ui.validation.defaultAdapter = DX.Class.inherit({
            ctor: function(editor, validator) {
                var that = this;
                that.editor = editor;
                that.validator = validator;
                that.validationRequestsCallbacks = $.Callbacks();
                var handler = function(params) {
                        that.validationRequestsCallbacks.fire()
                    };
                editor.validationRequest.add(handler);
                editor.on("disposing", function() {
                    editor.validationRequest.remove(handler)
                })
            },
            getValue: function() {
                return this.editor.option("value")
            },
            applyValidationResults: function(params) {
                this.editor.option({
                    isValid: params.isValid,
                    validationError: params.brokenRule
                })
            },
            focus: function() {
                this.editor.focus()
            }
        });
        var dxValidator = DX.DOMComponent.inherit({
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({validationRules: []})
                },
                _init: function() {
                    this.callBase();
                    var group = this._findGroup();
                    validationEngine.registerValidatorInGroup(group, this);
                    this.on("disposing", function() {
                        validationEngine.removeRegistredValidator(group, this)
                    });
                    this.focused = $.Callbacks();
                    this._initAdapter()
                },
                _setOptionsByReference: function() {
                    this.callBase();
                    $.extend(this._optionsByReference, {validationGroup: true})
                },
                _initAdapter: function() {
                    var that = this,
                        dxStandardEditor = that.element().data("dx-validation-target"),
                        adapter = that.option("adapter");
                    if (!adapter) {
                        if (dxStandardEditor) {
                            adapter = new DevExpress.ui.validation.defaultAdapter(dxStandardEditor, this);
                            adapter.validationRequestsCallbacks.add(function() {
                                that.validate()
                            });
                            this.option("adapter", adapter);
                            return
                        }
                        throw DX.Error("E0120");
                    }
                    if (adapter.validationRequestsCallbacks)
                        adapter.validationRequestsCallbacks.add(function() {
                            that.validate()
                        })
                },
                _findGroup: DX.ui.validation.findGroup,
                _render: function() {
                    this.element().addClass(VALIDATOR_CLASS);
                    this.callBase()
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"validationRules":
                            return;
                        case"adapter":
                            this._initAdapter();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                validate: function() {
                    var that = this,
                        adapter = that.option("adapter"),
                        name = that.option("name"),
                        validatedAction = that._createActionByOption("onValidated"),
                        value = adapter.getValue(),
                        rules = $.map(that.option("validationRules"), function(rule) {
                            rule.validator = that;
                            return rule
                        }),
                        result = validationEngine.validate(value, rules, name);
                    adapter.applyValidationResults && adapter.applyValidationResults(result);
                    validatedAction(result);
                    this.option({
                        isValid: result.isValid,
                        validationError: result.brokenRule
                    });
                    return result
                },
                focus: function() {
                    var adapter = this.option("adapter");
                    adapter.focus()
                }
            });
        DX.registerComponent("dxValidator", ui, dxValidator)
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.validationGroup.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var VALIDATION_ENGINE_CLASS = "dx-validation-group";
        DX.registerComponent("dxValidationGroup", ui, DX.DOMComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({})
            },
            _init: function() {
                this.callBase()
            },
            _render: function() {
                this.element().addClass(VALIDATION_ENGINE_CLASS);
                this.callBase()
            },
            validate: function() {
                return DX.validationEngine.validateGroup(this)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    default:
                        this.callBase(args)
                }
            },
            _dispose: function() {
                DX.validationEngine.removeGroup(this);
                this.callBase()
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.validationSummary.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var VALIDATION_SUMMARY_CLASS = "dx-validation-summary",
            ITEM_CLASS = VALIDATION_SUMMARY_CLASS + "-item",
            ITEM_DATA_KEY = VALIDATION_SUMMARY_CLASS + "-item-data";
        DX.registerComponent("dxValidationSummary", ui, ui.CollectionWidget.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    focusStateEnabled: false,
                    noDataText: null
                })
            },
            _findGroup: DX.ui.validation.findGroup,
            _init: function() {
                this.callBase();
                this._subscribeGroup()
            },
            _subscribeGroup: function() {
                var group = this._findGroup(),
                    groupConfig = DX.validationEngine.getGroupConfig(group);
                if (groupConfig) {
                    this.groupSubscription = $.proxy(this._groupValidationHandler, this);
                    groupConfig.on("validated", this.groupSubscription)
                }
            },
            _unsubscribeGroup: function() {
                var group = this._findGroup(),
                    groupConfig = DX.validationEngine.getGroupConfig(group);
                if (groupConfig && this.groupSubscription)
                    groupConfig.off("validated", this.groupSubscription)
            },
            _getOrderedItems: function(validators, items) {
                var orderedItems = [];
                $.each(validators, function(_, validator) {
                    var firstItem = $.grep(items, function(item) {
                            if (item.validator === validator)
                                return true
                        })[0];
                    if (firstItem)
                        orderedItems.push(firstItem)
                });
                return orderedItems
            },
            _groupValidationHandler: function(params) {
                var that = this,
                    items = that._getOrderedItems(params.validators, $.map(params.brokenRules, function(rule) {
                        return {
                                text: rule.message,
                                validator: rule.validator
                            }
                    }));
                that.validators = params.validators;
                $.each(that.validators, function(_, validator) {
                    var handler = $.proxy(that._itemValidationHandler, that),
                        disposingHandler = function() {
                            validator.off("validated", handler);
                            handler = null
                        };
                    validator.on("validated", handler);
                    validator.on("disposing", disposingHandler)
                });
                this.option("items", items)
            },
            _itemValidationHandler: function(itemValidationResult) {
                var items = this.option("items"),
                    isValid = itemValidationResult.isValid,
                    elementIndex,
                    replacementFound = false,
                    newMessage = itemValidationResult.brokenRule && itemValidationResult.brokenRule.message,
                    validator = itemValidationResult.validationRules[0] && itemValidationResult.validationRules[0].validator;
                if (isValid) {
                    $.each(items, function(index, item) {
                        if (item.validator === validator) {
                            elementIndex = index;
                            replacementFound = true;
                            return false
                        }
                    });
                    if (replacementFound)
                        items.splice(elementIndex, 1)
                }
                else {
                    $.each(items, function(index, item) {
                        if (item.validator === validator) {
                            item.text = newMessage;
                            replacementFound = true;
                            return false
                        }
                    });
                    if (!replacementFound)
                        items.push({
                            text: newMessage,
                            validator: validator
                        })
                }
                items = this._getOrderedItems(this.validators, items);
                this.option("items", items)
            },
            _render: function() {
                this.element().addClass(VALIDATION_SUMMARY_CLASS);
                this.callBase()
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    default:
                        this.callBase(args)
                }
            },
            _itemClass: function() {
                return ITEM_CLASS
            },
            _itemDataKey: function() {
                return ITEM_DATA_KEY
            },
            _postprocessRenderItem: function(params) {
                params.itemElement.on("dxclick", function() {
                    params.itemData.validator.focus()
                })
            },
            _dispose: function() {
                this.callBase();
                this._unsubscribeGroup()
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.fileUploader.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils;
        var FILEUPLOADER_CLASS = "dx-fileuploader",
            FILEUPLOADER_EMPTY_CLASS = "dx-fileuploader-empty",
            FILEUPLOADER_DRAGOVER = "dx-fileuploader-dragover",
            FILEUPLOADER_FILEINPUT_TAG = "<input type='file'>",
            FILEUPLOADER_WRAPPER_CLASS = "dx-fileuploader-wrapper",
            FILEUPLOADER_CONTAINER_CLASS = "dx-fileuploader-container",
            FILEUPLOADER_CONTENT_CLASS = "dx-fileuploader-content",
            FILEUPLOADER_INPUT_WRAPPER_CLASS = "dx-fileuploader-input-wrapper",
            FILEUPLOADER_BUTTON_CLASS = "dx-fileuploader-button",
            FILEUPLOADER_INPUT_CONTAINER_CLASS = "dx-fileuploader-input-container",
            FILEUPLOADER_INPUT_LABEL_CLASS = "dx-fileuploader-input-label",
            FILEUPLOADER_FILES_CONTAINER_CLASS = "dx-fileuploader-files-container",
            FILEUPLOADER_FILE_CLASS = "dx-fileuploader-file",
            FILEUPLOADER_FILE_NAME_CLASS = "dx-fileuploader-file-name",
            FILEUPLOADER_FILE_SIZE_CLASS = "dx-fileuploader-file-size";
        DX.registerComponent("dxFileUploader", ui, ui.Editor.inherit({
            _supportedKeys: function() {
                var click = function(e) {
                        if (this._$button)
                            this._$button.click()
                    };
                return $.extend(this.callBase(), {
                        space: click,
                        enter: click
                    })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    value: null,
                    values: [],
                    buttonText: Globalize.localize("dxFileUploader-selectFile"),
                    labelText: Globalize.localize("dxFileUploader-dropFile"),
                    name: "files[]",
                    multiple: false,
                    accept: ""
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }])
            },
            _init: function() {
                this.option("value", null);
                this.option("values", []);
                this.callBase.apply(this, arguments);
                this._initFileInput();
                this._initLabel();
                this._initDragEvents();
                this.element().addClass(FILEUPLOADER_CLASS)
            },
            _initFileInput: function() {
                if (!this._$fileInput) {
                    this._$fileInput = $(FILEUPLOADER_FILEINPUT_TAG);
                    this._$fileInput.on("change", $.proxy(this._inputChangeHandler, this));
                    this._$fileInput.on("click", $.proxy(function(e) {
                        var isCustomEvent = this._isCustomEvent || false;
                        this._isCustomEvent = false;
                        return isCustomEvent
                    }, this))
                }
                this._$fileInput.prop({
                    multiple: this.option("multiple"),
                    name: this.option("name"),
                    accept: this.option("accept")
                })
            },
            _inputChangeHandler: function(e) {
                var fileName = this._$fileInput.val().replace(/^.*\\/, ''),
                    files = this._$fileInput.prop("files") || [{name: fileName}];
                this._shouldChangeValue = true;
                this.option("values", $.map(files, function(file) {
                    return $.extend({}, {
                            name: file.name,
                            size: file.size,
                            type: file.type,
                            lastModifiedDate: file.lastModifiedDate
                        })
                }));
                delete this._shouldChangeValue
            },
            _initLabel: function() {
                if (!this._$inputLabel)
                    this._$inputLabel = $("<div>");
                this._$inputLabel.text(this.option("labelText"))
            },
            _initDragEvents: function() {
                if (DX.devices.current().platform !== "generic")
                    return;
                this._dragEventsCount = 0;
                this.element().on("dragenter", $.proxy(this._dragEnterHandler, this)).on("dragleave", $.proxy(this._dragLeaveHandler, this)).on("drop", $.proxy(this._dropHandler, this))
            },
            _dragEnterHandler: function() {
                if (this.option("disabled"))
                    return false;
                this._dragEventsCount++;
                this.element().addClass(FILEUPLOADER_DRAGOVER)
            },
            _dragLeaveHandler: function() {
                this._dragEventsCount--;
                if (this._dragEventsCount <= 0)
                    this.element().removeClass(FILEUPLOADER_DRAGOVER)
            },
            _dropHandler: function() {
                this._dragEventsCount = 0;
                this.element().removeClass(FILEUPLOADER_DRAGOVER)
            },
            _focusTarget: function() {
                return this.element().find("." + FILEUPLOADER_BUTTON_CLASS)
            },
            _render: function() {
                this._renderFilesContainer();
                this._renderButton();
                this._renderInputContainer();
                this._renderInputWrapper();
                this._renderWrapper();
                this.callBase.apply(this, arguments)
            },
            _renderFilesContainer: function() {
                var that = this,
                    values = this.option("values") || [];
                this._$filesContainer = this._$filesContainer || $("<div>").addClass(FILEUPLOADER_FILES_CONTAINER_CLASS);
                this._$filesContainer.empty();
                $.each(values, function(_, value) {
                    var $name = $("<div>").addClass(FILEUPLOADER_FILE_NAME_CLASS).text(value.name);
                    var $file = $("<div>").addClass(FILEUPLOADER_FILE_CLASS).append($name);
                    if (utils.isDefined(value.size))
                        var $size = $("<div>").addClass(FILEUPLOADER_FILE_SIZE_CLASS).text(that._getFileSize(value.size)).appendTo($file);
                    that._$filesContainer.append($file)
                });
                this.element().toggleClass(FILEUPLOADER_EMPTY_CLASS, !values.length)
            },
            _getFileSize: function(size) {
                var i = 0,
                    labels = [Globalize.localize("dxFileUploader-bytes"), Globalize.localize("dxFileUploader-kb"), Globalize.localize("dxFileUploader-Mb"), Globalize.localize("dxFileUploader-Gb")],
                    count = labels.length - 1;
                while (i < count && size >= 1024) {
                    size /= 1024;
                    i++
                }
                return "(" + Math.round(size) + labels[i] + ")"
            },
            _renderButton: function() {
                this._$button = this._$button || $("<div>");
                this._$button.addClass(FILEUPLOADER_BUTTON_CLASS).dxButton({
                    text: this.option("buttonText"),
                    focusStateEnabled: false
                }).off("click").on("click", $.proxy(this._buttonClickHandler, this));
                this._button = this._$button.dxButton("instance")
            },
            _buttonClickHandler: function() {
                if (this.option("disabled"))
                    return false;
                this._isCustomEvent = true;
                this._$fileInput.click()
            },
            _renderInputContainer: function() {
                this._$inputContainer = $("<div>").addClass(FILEUPLOADER_INPUT_CONTAINER_CLASS);
                if (DX.browser.msie)
                    this._$inputContainer.css("display", "none");
                this._$fileInput.addClass("dx-fileuploader-input").appendTo(this._$inputContainer);
                this._$inputLabel.addClass(FILEUPLOADER_INPUT_LABEL_CLASS).appendTo(this._$inputContainer)
            },
            _renderInputWrapper: function() {
                this._$inputWrapper = $("<div>").addClass(FILEUPLOADER_INPUT_WRAPPER_CLASS).append(this._$button).append(this._$inputContainer)
            },
            _renderWrapper: function() {
                var $wrapper = $("<div>").addClass(FILEUPLOADER_WRAPPER_CLASS).appendTo(this.element());
                var $container = $("<div>").addClass(FILEUPLOADER_CONTAINER_CLASS).appendTo($wrapper);
                var $content = $("<div>").addClass(FILEUPLOADER_CONTENT_CLASS).appendTo($container).append(this._$inputWrapper).append(this._$filesContainer)
            },
            _clean: function() {
                this._$fileInput.detach();
                this.callBase.apply(this, arguments)
            },
            _optionChanged: function(args) {
                var value = args.value;
                switch (args.name) {
                    case"disabled":
                        this._button.option(args.name, args.value);
                        this.callBase(args);
                        break;
                    case"value":
                        if (!this._shouldChangeValue) {
                            this._$fileInput.val("");
                            this.option("values", [])
                        }
                        this.callBase(args);
                        break;
                    case"values":
                        if (value.length && !this._shouldChangeValue)
                            this.option("values", []);
                        else {
                            this._renderFilesContainer();
                            this.option("value", value[0] || null)
                        }
                        break;
                    case"name":
                    case"accept":
                        this._initFileInput();
                        break;
                    case"multiple":
                        this._initFileInput();
                        if (!args.value)
                            this.option("values", []);
                        break;
                    case"buttonText":
                        this._button.option("text", value);
                        break;
                    case"labelText":
                        this._$inputLabel.text(value);
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _valueChangeArgs: function() {
                return $.extend(this.callBase.apply(this, arguments), {values: this.option("values")})
            }
        }));
        ui.dxFileUploader.__internals = {
            changeFileInputTag: function(tag) {
                FILEUPLOADER_FILEINPUT_TAG = tag
            },
            resetFileInputTag: function() {
                FILEUPLOADER_FILEINPUT_TAG = "<input type='file'>"
            }
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.tabPanel.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var TABPANEL_CLASS = "dx-tabpanel";
        DX.registerComponent("dxTabPanel", ui, ui.dxMultiView.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    titleTemplate: "title",
                    onTitleClick: null,
                    onTitleHold: null,
                    onTitleRendered: null
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }, {
                            device: function(device) {
                                return !DX.support.touch
                            },
                            options: {swipeEnabled: false}
                        }])
            },
            _init: function() {
                this.callBase();
                this.element().addClass(TABPANEL_CLASS)
            },
            _render: function() {
                this.callBase.apply(this, arguments);
                this._renderTabs();
                this._resizeMultiView()
            },
            _renderTabs: function() {
                if (this._$tabs)
                    return;
                this._$tabs = $("<div>").dxTabs(this._tabConfig());
                this.element().prepend(this._$tabs)
            },
            _resizeMultiView: function() {
                var multiviewHeight = this.element().height() - this._$tabs.outerHeight(true);
                this._$wrapper.height(multiviewHeight)
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._dimensionChanged()
            },
            _dimensionChanged: function() {
                if (this._$tabs)
                    this._resizeMultiView()
            },
            _tabConfig: function() {
                return {
                        _templates: this.option("_templates"),
                        selectOnFocus: true,
                        focusStateEnabled: this.option("focusStateEnabled"),
                        selectedIndex: this.option("selectedIndex"),
                        onItemClick: this.option("onTitleClick"),
                        onItemHold: this.option("onTitleHold"),
                        itemHoldTimeout: this.option("itemHoldTimeout"),
                        onSelectionChanged: $.proxy(function(e) {
                            this.option("selectedIndex", e.component.option("selectedIndex"))
                        }, this),
                        onItemRendered: this.option("onTitleRendered"),
                        itemTemplate: this._getTemplateByOption("titleTemplate"),
                        dataSource: this.option("dataSource"),
                        items: this.option("items"),
                        scrollingEnabled: false,
                        itemTemplateProperty: "tabTemplate"
                    }
            },
            _setTabsOption: function(name, value) {
                if (this._$tabs)
                    this._$tabs.dxTabs("option", name, value)
            },
            _optionChanged: function(args) {
                var name = args.name,
                    value = args.value;
                switch (name) {
                    case"dataSource":
                    case"items":
                    case"selectedIndex":
                    case"selectedItem":
                    case"itemHoldTimeout":
                    case"focusStateEnabled":
                        this._setTabsOption(name, value);
                        this.callBase(args);
                        break;
                    case"titleTemplate":
                        this._setTabsOption("itemTemplate", this._getTemplateByOption("titleTemplate"));
                        break;
                    case"onTitleClick":
                        this._setTabsOption("onItemClick", value);
                        break;
                    case"onTitleHold":
                        this._setTabsOption("onItemHold", value);
                        break;
                    case"onTitleRendered":
                        this._setTabsOption("onItemRendered", value);
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    DevExpress.MOD_WIDGETS_BASE = true
}
if (!DevExpress.MOD_WIDGETS_MOBILE) {
    if (!DevExpress.MOD_WIDGETS_BASE)
        throw Error('Required module is not referenced: widgets-base');
    /*! Module widgets-mobile, file ui.pivotTabs.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx,
            utils = DX.utils,
            translator = DX.translator,
            events = ui.events;
        var PIVOT_TABS_CLASS = "dx-pivottabs",
            PIVOT_TAB_CLASS = "dx-pivottabs-tab",
            PIVOT_TAB_SELECTED_CLASS = "dx-pivottabs-tab-selected",
            PIVOT_GHOST_TAB_CLASS = "dx-pivottabs-ghosttab",
            PIVOT_TAB_DATA_KEY = "dxPivotTabData",
            PIVOT_TAB_MOVE_DURATION = 200,
            PIVOT_TAB_MOVE_EASING = "cubic-bezier(.40, .80, .60, 1)";
        var animation = {
                moveTo: function($tab, position, completeAction) {
                    return fx.animate($tab, {
                            type: "slide",
                            to: {left: position},
                            duration: PIVOT_TAB_MOVE_DURATION,
                            easing: PIVOT_TAB_MOVE_EASING,
                            complete: completeAction
                        })
                },
                slideAppear: function($tab, position) {
                    return fx.animate($tab, {
                            type: "slide",
                            to: {
                                left: position,
                                opacity: 1
                            },
                            duration: PIVOT_TAB_MOVE_DURATION,
                            easing: PIVOT_TAB_MOVE_EASING
                        })
                },
                slideDisappear: function($tab, position) {
                    return fx.animate($tab, {
                            type: "slide",
                            to: {
                                left: position,
                                opacity: 0
                            },
                            duration: PIVOT_TAB_MOVE_DURATION,
                            easing: PIVOT_TAB_MOVE_EASING
                        })
                },
                complete: function(elements) {
                    if (!elements)
                        return;
                    $.each(elements, function(_, $element) {
                        fx.stop($element, true)
                    })
                },
                stop: function(elements) {
                    if (!elements)
                        return;
                    $.each(elements, function(_, $element) {
                        fx.stop($element)
                    })
                }
            };
        DX.registerComponent("dxPivotTabs", ui, ui.CollectionWidget.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    selectedIndex: 0,
                    onPrepare: null,
                    onUpdatePosition: null,
                    onRollback: null,
                    focusStateEnabled: false,
                    selectionMode: "single",
                    selectionRequired: true
                })
            },
            _itemClass: function() {
                return PIVOT_TAB_CLASS
            },
            _itemDataKey: function() {
                return PIVOT_TAB_DATA_KEY
            },
            _itemContainer: function() {
                return this.element()
            },
            _elementWidth: function() {
                if (!this._elementWidthCache)
                    this._elementWidthCache = this.element().width();
                return this._elementWidthCache
            },
            _clearElementWidthCache: function() {
                delete this._elementWidthCache
            },
            _itemWidths: function() {
                if (!this._itemWidthsCache) {
                    var $tabs = this._itemElements(),
                        widths = [];
                    $tabs.each(function() {
                        widths.push($(this).outerWidth())
                    });
                    this._itemWidthsCache = widths
                }
                return this._itemWidthsCache
            },
            _init: function() {
                this.callBase();
                this._initGhostTab();
                this._initSwipeHandlers();
                this._initActions()
            },
            _dimensionChanged: function() {
                this._clearElementWidthCache();
                this._cleanPositionCache();
                this._updateTabsPositions()
            },
            _initGhostTab: function() {
                this._$ghostTab = $("<div>").addClass(PIVOT_GHOST_TAB_CLASS)
            },
            _initActions: function() {
                this._updatePositionAction = this._createActionByOption("onUpdatePosition");
                this._rollbackAction = this._createActionByOption("onRollback");
                this._prepareAction = this._createActionByOption("onPrepare")
            },
            _render: function() {
                this.element().addClass(PIVOT_TABS_CLASS);
                this.callBase();
                this._renderGhostTab()
            },
            _renderGhostTab: function() {
                this._itemContainer().append(this._$ghostTab);
                this._toggleGhostTab(false)
            },
            _toggleGhostTab: function(visible) {
                var $ghostTab = this._$ghostTab;
                if (visible) {
                    this._updateGhostTabContent();
                    $ghostTab.css("opacity", 1)
                }
                else
                    $ghostTab.css("opacity", 0)
            },
            _isGhostTabVisible: function() {
                return this._$ghostTab.css("opacity") == 1
            },
            _updateGhostTabContent: function(prevIndex) {
                prevIndex = prevIndex === undefined ? this._previousIndex() : prevIndex;
                var $ghostTab = this._$ghostTab,
                    $items = this._itemElements();
                $ghostTab.html($items.eq(prevIndex).html())
            },
            _updateTabsPositions: function(offset) {
                var $tabs = this._allTabElements(),
                    offset = this._applyOffsetBoundaries(offset),
                    isPrevSwipeHandled = this.option("rtlEnabled") ^ offset > 0 && offset !== 0,
                    tabPositions = this._calculateTabPositions(isPrevSwipeHandled ? "replace" : "append");
                this._moveTabs(tabPositions, offset);
                this._toggleGhostTab(isPrevSwipeHandled)
            },
            _moveTabs: function(positions, offset) {
                offset = offset || 0;
                var $tabs = this._allTabElements();
                $tabs.each(function(index) {
                    translator.move($(this), {left: positions[index] + offset})
                })
            },
            _applyOffsetBoundaries: function(offset) {
                offset = offset || 0;
                var maxOffset = offset > 0 ? this._maxRightOffset : this._maxLeftOffset;
                return offset * maxOffset
            },
            _animateRollback: function() {
                var that = this,
                    $tabs = this._itemElements(),
                    positions = this._calculateTabPositions("prepend");
                if (this._isGhostTabVisible()) {
                    this._swapGhostWithTab($tabs.eq(this._previousIndex()));
                    animation.moveTo(this._$ghostTab, positions[this._indexBoundary()], function() {
                        that._toggleGhostTab(false)
                    })
                }
                $tabs.each(function(index) {
                    animation.moveTo($(this), positions[index])
                })
            },
            _animateComplete: function(newIndex, currentIndex) {
                var that = this,
                    $tabs = this._itemElements(),
                    isPrevSwipeHandled = this._isGhostTabVisible();
                $tabs.eq(currentIndex).removeClass(PIVOT_TAB_SELECTED_CLASS);
                var animations = isPrevSwipeHandled ? this._animateIndexDecreasing(newIndex) : this._animateIndexIncreasing(newIndex);
                $tabs.eq(newIndex).addClass(PIVOT_TAB_SELECTED_CLASS)
            },
            _animateIndexDecreasing: function(newIndex) {
                var $tabs = this._itemElements(),
                    positions = this._calculateTabPositions("append", newIndex),
                    animations = [];
                $tabs.each(function(index) {
                    animations.push(animation.moveTo($(this), positions[index]))
                });
                animations.push(animation.slideDisappear(this._$ghostTab, positions[this._indexBoundary()]));
                return $.when.apply($, animations)
            },
            _animateIndexIncreasing: function(newIndex) {
                var that = this,
                    $tabs = this._itemElements(),
                    positions = this._calculateTabPositions("prepend", newIndex),
                    previousIndex = this._previousIndex(newIndex),
                    $prevTab = $tabs.eq(previousIndex),
                    prevTabPosition = translator.locate($prevTab).left,
                    rtl = this.option("rtlEnabled"),
                    bound = rtl ? this._elementWidth() - this._itemWidths()[previousIndex] : 0,
                    isNextSwipeHandled = (prevTabPosition - bound) * this._getRTLSignCorrection() < 0,
                    animations = [];
                if (!isNextSwipeHandled)
                    this._moveTabs(this._calculateTabPositions("append", previousIndex));
                this._updateGhostTabContent(previousIndex);
                this._swapGhostWithTab($tabs.eq(previousIndex));
                $tabs.each(function(index) {
                    var $tab = $(this),
                        newPosition = positions[index];
                    animations.push(index === previousIndex ? animation.slideAppear($tab, newPosition) : animation.moveTo($tab, newPosition))
                });
                animations.push(animation.moveTo(this._$ghostTab, positions[this._indexBoundary()], function() {
                    that._toggleGhostTab(false)
                }));
                return $.when.apply($, animations)
            },
            _swapGhostWithTab: function($tab) {
                var $ghostTab = this._$ghostTab,
                    lastTabPosition = translator.locate($tab).left,
                    lastTabOpacity = $tab.css("opacity");
                translator.move($tab, {left: translator.locate($ghostTab).left});
                $tab.css("opacity", $ghostTab.css("opacity"));
                translator.move($ghostTab, {left: lastTabPosition});
                $ghostTab.css("opacity", lastTabOpacity)
            },
            _calculateTabPositions: function(ghostPosition, index) {
                index = index === undefined ? this.option("selectedIndex") : index;
                var mark = index + ghostPosition;
                if (this._calculetedPositionsMark !== mark) {
                    this._calculetedPositions = this._calculateTabPositionsImpl(index, ghostPosition);
                    this._calculetedPositionsMark = mark
                }
                return this._calculetedPositions
            },
            _calculateTabPositionsImpl: function(currentIndex, ghostPosition) {
                var prevIndex = this._normalizeIndex(currentIndex - 1),
                    $tabs = this._itemElements(),
                    widths = this._itemWidths();
                var rtl = this.option("rtlEnabled"),
                    signCorrection = this._getRTLSignCorrection(),
                    tabsContainerWidth = this._elementWidth(),
                    nextPosition = rtl ? tabsContainerWidth : 0,
                    positions = [];
                var calculateTabPosition = function(currentIndex, width) {
                        var rtlOffset = rtl * width;
                        positions.splice(currentIndex, 0, nextPosition - rtlOffset);
                        nextPosition += width * signCorrection
                    };
                $.each(widths.slice(currentIndex), calculateTabPosition);
                $.each(widths.slice(0, currentIndex), calculateTabPosition);
                switch (ghostPosition) {
                    case"replace":
                        var lastTabPosition = positions[prevIndex];
                        positions.splice(prevIndex, 1, rtl ? tabsContainerWidth : -widths[prevIndex]);
                        positions.push(lastTabPosition);
                        break;
                    case"prepend":
                        positions.push(rtl ? tabsContainerWidth : -widths[prevIndex]);
                        break;
                    case"append":
                        positions.push(nextPosition - widths[currentIndex] * rtl);
                        break
                }
                return positions
            },
            _allTabElements: function() {
                return this._itemContainer().find("." + PIVOT_TAB_CLASS + ", ." + PIVOT_GHOST_TAB_CLASS)
            },
            _initSwipeHandlers: function() {
                this.element().on(events.addNamespace("dxswipestart", this.NAME), {itemSizeFunc: $.proxy(this._elementWidth, this)}, $.proxy(this._swipeStartHandler, this)).on(events.addNamespace("dxswipe", this.NAME), $.proxy(this._swipeUpdateHandler, this)).on(events.addNamespace("dxswipeend", this.NAME), $.proxy(this._swipeEndHandler, this))
            },
            _swipeStartHandler: function(e) {
                this._prepareAnimation();
                this._prepareAction();
                e.maxLeftOffset = 1;
                e.maxRightOffset = 1;
                if (DX.designMode || this.option("disabled") || this._indexBoundary() <= 1)
                    e.cancel = true;
                else
                    this._swipeGestureRunning = true
            },
            _prepareAnimation: function() {
                this._stopAnimation()
            },
            _stopAnimation: function() {
                animation.complete(this._allTabElements())
            },
            _swipeUpdateHandler: function(e) {
                var offset = e.offset;
                this._updateTabsPositions(offset);
                this._updatePositionAction({offset: offset})
            },
            _swipeEndHandler: function(e) {
                var targetOffset = e.targetOffset * this._getRTLSignCorrection();
                if (targetOffset === 0) {
                    this._animateRollback();
                    this._rollbackAction()
                }
                else {
                    var newIndex = this._normalizeIndex(this.option("selectedIndex") - targetOffset);
                    this.option("selectedIndex", newIndex)
                }
                this._swipeGestureRunning = false
            },
            _previousIndex: function(atIndex) {
                atIndex = atIndex === undefined ? this.option("selectedIndex") : atIndex;
                return this._normalizeIndex(atIndex - 1)
            },
            _normalizeIndex: function(index) {
                var boundary = this._indexBoundary();
                if (index < 0)
                    index = boundary + index;
                if (index >= boundary)
                    index = index - boundary;
                return index
            },
            _indexBoundary: function() {
                return this.option("items").length
            },
            _renderSelection: function(current) {
                this._calculateMaxOffsets(current);
                this._updateTabsPositions();
                this._itemElements().eq(current).addClass(PIVOT_TAB_SELECTED_CLASS)
            },
            _updateSelection: function(addedItems, removedItems) {
                var newIndex = addedItems[0],
                    oldIndex = removedItems[0];
                this._calculateMaxOffsets(newIndex);
                if (!this._swipeGestureRunning)
                    this._prepareAnimation();
                if (this._itemElements().length)
                    this._animateComplete(newIndex, oldIndex)
            },
            _calculateMaxOffsets: function(index) {
                var $tabs = this._itemElements(),
                    currentTabWidth = this._itemWidths()[index],
                    prevTabWidth = this._itemWidths()[this._previousIndex(index)],
                    rtl = this.option("rtlEnabled");
                this._maxLeftOffset = rtl ? prevTabWidth : currentTabWidth;
                this._maxRightOffset = rtl ? currentTabWidth : prevTabWidth
            },
            _getRTLSignCorrection: function() {
                return this.option("rtlEnabled") ? -1 : 1
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._dimensionChanged()
            },
            _clean: function() {
                animation.stop(this._allTabElements());
                this._clearElementWidthCache();
                this._cleanPositionCache();
                this.callBase()
            },
            _cleanPositionCache: function() {
                delete this._itemWidthsCache;
                delete this._calculetedPositionsMark
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"items":
                    case"rtlEnabled":
                        this._cleanPositionCache();
                        this.callBase(args);
                        break;
                    case"onPrepare":
                    case"onUpdatePosition":
                    case"onRollback":
                        this._initActions();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            prepare: function() {
                this._prepareAnimation()
            },
            updatePosition: function(offset) {
                this._updateTabsPositions(offset)
            },
            rollback: function() {
                this._animateRollback()
            }
        }));
        ui.dxPivotTabs.__internals = {animation: animation}
    })(jQuery, DevExpress);
    /*! Module widgets-mobile, file ui.pivot.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            fx = DX.fx,
            translator = DX.translator;
        var PIVOT_CLASS = "dx-pivot",
            PIVOT_WRAPPER_CLASS = "dx-pivot-wrapper",
            PIVOT_TABS_CONTAINER_CLASS = "dx-pivottabs-container",
            PIVOT_ITEM_CONTAINER_CLASS = "dx-pivot-itemcontainer",
            PIVOT_ITEM_WRAPPER_CLASS = "dx-pivot-itemwrapper",
            PIVOT_ITEM_CLASS = "dx-pivot-item",
            PIVOT_ITEM_HIDDEN_CLASS = "dx-pivot-item-hidden",
            PIVOT_ITEM_DATA_KEY = "dxPivotItemData",
            PIVOT_RETURN_BACK_DURATION = 200,
            PIVOT_SLIDE_AWAY_DURATION = 50,
            PIVOT_SLIDE_BACK_DURATION = 250,
            PIVOT_SLIDE_BACK_EASING = "cubic-bezier(.10, 1, 0, 1)";
        var animation = {
                returnBack: function($element) {
                    fx.animate($element, {
                        type: "slide",
                        to: {left: 0},
                        duration: PIVOT_RETURN_BACK_DURATION
                    })
                },
                slideAway: function($element, position, complete) {
                    fx.animate($element, {
                        type: "slide",
                        to: {left: position},
                        duration: PIVOT_SLIDE_AWAY_DURATION,
                        complete: complete
                    })
                },
                slideBack: function($element) {
                    fx.animate($element, {
                        type: "slide",
                        to: {left: 0},
                        easing: PIVOT_SLIDE_BACK_EASING,
                        duration: PIVOT_SLIDE_BACK_DURATION
                    })
                },
                complete: function($element) {
                    fx.stop($element, true)
                },
                stop: function($element) {
                    fx.stop($element)
                }
            };
        DX.registerComponent("dxPivot", ui, ui.CollectionWidget.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    selectedIndex: 0,
                    focusStateEnabled: false,
                    selectionMode: "single",
                    selectionRequired: true,
                    selectionByClick: false
                })
            },
            _itemClass: function() {
                return PIVOT_ITEM_CLASS
            },
            _itemDataKey: function() {
                return PIVOT_ITEM_DATA_KEY
            },
            _itemContainer: function() {
                return this._$itemWrapper
            },
            _elementWidth: function() {
                if (!this._elementWidthCache)
                    this._elementWidthCache = this.element().width();
                return this._elementWidthCache
            },
            _clearElementWidthCache: function() {
                delete this._elementWidthCache
            },
            _init: function() {
                this.callBase();
                this._initWrapper();
                this._initTabs();
                this._initItemContainer();
                this._clearItemsCache();
                this._initSwipeHandlers()
            },
            _dimensionChanged: function() {
                this._clearElementWidthCache()
            },
            _initWrapper: function() {
                this._$wrapper = $("<div>").addClass(PIVOT_WRAPPER_CLASS).appendTo(this.element())
            },
            _initItemContainer: function() {
                var $itemContainer = $("<div>").addClass(PIVOT_ITEM_CONTAINER_CLASS);
                this._$wrapper.append($itemContainer);
                this._$itemWrapper = $("<div>").addClass(PIVOT_ITEM_WRAPPER_CLASS);
                $itemContainer.append(this._$itemWrapper)
            },
            _clearItemsCache: function() {
                this._itemsCache = []
            },
            _initTabs: function() {
                var that = this,
                    $tabsContainer = $("<div>").addClass(PIVOT_TABS_CONTAINER_CLASS);
                this._$wrapper.append($tabsContainer);
                $tabsContainer.dxPivotTabs({
                    items: this.option("items"),
                    selectedIndex: this.option("selectedIndex"),
                    onPrepare: function() {
                        that._prepareAnimation()
                    },
                    onUpdatePosition: function(args) {
                        that._updateContentPosition(args.offset)
                    },
                    onRollback: function() {
                        that._animateRollback()
                    },
                    onSelectionChanged: function(args) {
                        that.option("selectedItem", args.addedItems[0])
                    }
                });
                this._tabs = $tabsContainer.dxPivotTabs("instance")
            },
            _render: function() {
                this.element().addClass(PIVOT_CLASS);
                this.callBase();
                var selectedIndex = this.option("selectedIndex");
                this._renderCurrentContent(selectedIndex, selectedIndex)
            },
            _renderCurrentContent: function(currentIndex, previousIndex) {
                var itemsCache = this._itemsCache;
                itemsCache[previousIndex] = this._selectedItemElement();
                itemsCache[previousIndex].addClass(PIVOT_ITEM_HIDDEN_CLASS);
                if (itemsCache[currentIndex])
                    itemsCache[currentIndex].removeClass(PIVOT_ITEM_HIDDEN_CLASS);
                else
                    this._renderContent();
                this._selectionChangePromise && this._selectionChangePromise.resolve();
                this._selectionChangePromise = $.Deferred()
            },
            _updateContentPosition: function(offset) {
                translator.move(this._$itemWrapper, {left: this._calculatePixelOffset(offset)})
            },
            _animateRollback: function() {
                animation.returnBack(this._$itemWrapper)
            },
            _animateComplete: function(newIndex, currentIndex) {
                var $itemWrapper = this._$itemWrapper,
                    rtlSignCorrection = this._getRTLSignCorrection(),
                    intermediatePosition = this._elementWidth() * (this._isPrevSwipeHandled() ? 1 : -1) * rtlSignCorrection;
                animation.slideAway($itemWrapper, intermediatePosition, $.proxy(function() {
                    translator.move($itemWrapper, {left: -intermediatePosition});
                    this._renderCurrentContent(newIndex, currentIndex)
                }, this));
                animation.slideBack($itemWrapper)
            },
            _calculatePixelOffset: function(offset) {
                offset = offset || 0;
                return offset * this._elementWidth()
            },
            _isPrevSwipeHandled: function() {
                var wrapperOffset = translator.locate(this._$itemWrapper).left,
                    rtl = this.option("rtlEnabled");
                return rtl ^ wrapperOffset > 0 && wrapperOffset !== 0
            },
            _initSwipeHandlers: function() {
                this.element().on(events.addNamespace("dxswipestart", this.NAME), {itemSizeFunc: $.proxy(this._elementWidth, this)}, $.proxy(this._swipeStartHandler, this)).on(events.addNamespace("dxswipe", this.NAME), $.proxy(this._swipeUpdateHandler, this)).on(events.addNamespace("dxswipeend", this.NAME), $.proxy(this._swipeEndHandler, this))
            },
            _swipeStartHandler: function(e) {
                this._prepareAnimation();
                this._tabs.prepare();
                if (DX.designMode || this.option("disabled") || this._indexBoundary() <= 1)
                    e.cancel = true;
                else
                    this._swipeGestureRunning = true;
                e.maxLeftOffset = 1;
                e.maxRightOffset = 1
            },
            _prepareAnimation: function() {
                this._stopAnimation()
            },
            _stopAnimation: function() {
                animation.complete(this._$itemWrapper)
            },
            _swipeUpdateHandler: function(e) {
                var offset = e.offset;
                this._updateContentPosition(offset);
                this._tabs.updatePosition(offset)
            },
            _swipeEndHandler: function(e) {
                var targetOffset = e.targetOffset * this._getRTLSignCorrection();
                if (targetOffset === 0) {
                    this._animateRollback();
                    this._tabs.rollback()
                }
                else {
                    var newIndex = this._normalizeIndex(this.option("selectedIndex") - targetOffset);
                    this.option("selectedIndex", newIndex)
                }
                this._swipeGestureRunning = false
            },
            _normalizeIndex: function(index) {
                var boundary = this._indexBoundary();
                if (index < 0)
                    index = boundary + index;
                if (index >= boundary)
                    index = index - boundary;
                return index
            },
            _indexBoundary: function() {
                return this.option("items").length
            },
            _renderContentImpl: function() {
                var items = this.option("items"),
                    selectedIndex = this.option("selectedIndex");
                if (items.length)
                    this._renderItems([items[selectedIndex]])
            },
            _selectedItemElement: function() {
                return this._$itemWrapper.children(":not(." + PIVOT_ITEM_HIDDEN_CLASS + ")")
            },
            _getRTLSignCorrection: function() {
                return this.option("rtlEnabled") ? -1 : 1
            },
            _clean: function() {
                animation.stop(this._$itemWrapper);
                this.callBase()
            },
            _refresh: function() {
                this._tabs._refresh();
                this.callBase()
            },
            _updateSelection: function(addedItems, removedItems) {
                var newIndex = addedItems[0],
                    oldIndex = removedItems[0];
                if (!this._swipeGestureRunning)
                    this._prepareAnimation();
                this._animateComplete(newIndex, oldIndex);
                this._tabs.option("selectedIndex", newIndex)
            },
            _optionChanged: function(args) {
                var value = args.value;
                switch (args.name) {
                    case"disabled":
                        this._tabs.option("disabled", value);
                        this.callBase(args);
                        break;
                    case"items":
                        this._tabs.option("items", value);
                        this._clearItemsCache();
                        this.callBase(args);
                        break;
                    case"rtlEnabled":
                        this._tabs.option("rtlEnabled", value);
                        this._clearItemsCache();
                        this.callBase(args);
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }));
        ui.dxPivot.__internals = {animation: animation}
    })(jQuery, DevExpress);
    /*! Module widgets-mobile, file ui.actionSheet.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var ACTION_SHEET_CLASS = "dx-action-sheet",
            ACTION_SHEET_CONTAINER_CLASS = "dx-action-sheet-container",
            ACTION_SHEET_POPUP_WRAPPER_CLASS = "dx-action-sheet-popup-wrapper",
            ACTION_SHEET_POPOVER_WRAPPER_CLASS = "dx-action-sheet-popover-wrapper",
            ACTION_SHEET_CANCEL_BUTTON_CLASS = "dx-action-sheet-cancel",
            ACTION_SHEET_ITEM_CLASS = "dx-action-sheet-item",
            ACTION_SHEET_ITEM_DATA_KEY = "dxActionSheetItemData",
            ACTION_SHEET_WITHOUT_TITLE_CLASS = "dx-action-sheet-without-title";
        DX.registerComponent("dxActionSheet", ui, ui.CollectionWidget.inherit({
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {cancelClickAction: {
                        since: "14.2",
                        alias: "onCancelClick"
                    }})
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    usePopover: false,
                    target: null,
                    title: "",
                    showTitle: true,
                    showCancelButton: true,
                    cancelText: Globalize.localize("Cancel"),
                    onCancelClick: null,
                    visible: false,
                    noDataText: "",
                    focusStateEnabled: false,
                    selectionByClick: false
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {
                                platform: "ios",
                                tablet: true
                            },
                            options: {usePopover: true}
                        }])
            },
            _itemContainer: function() {
                return this._$itemContainer
            },
            _itemClass: function() {
                return ACTION_SHEET_ITEM_CLASS
            },
            _itemDataKey: function() {
                return ACTION_SHEET_ITEM_DATA_KEY
            },
            _toggleVisibility: $.noop,
            _renderDimensions: $.noop,
            _render: function() {
                this.element().addClass(ACTION_SHEET_CLASS);
                this._createItemContainer();
                this._renderPopup()
            },
            _createItemContainer: function() {
                this._$itemContainer = $("<div>").addClass(ACTION_SHEET_CONTAINER_CLASS);
                this._renderDisabled()
            },
            _renderDisabled: function() {
                this._$itemContainer.toggleClass("dx-state-disabled", this.option("disabled"))
            },
            _renderPopup: function() {
                this._$popup = $("<div>").appendTo(this.element());
                this._popup = this._isPopoverMode() ? this._createPopover() : this._createPopup();
                this._renderPopupTitle();
                this._mapPopupOption("visible")
            },
            _mapPopupOption: function(optionName) {
                this._popup.option(optionName, this.option(optionName))
            },
            _isPopoverMode: function() {
                return this.option("usePopover") && this.option("target")
            },
            _renderPopupTitle: function() {
                this._mapPopupOption("showTitle");
                this._popup._wrapper().toggleClass(ACTION_SHEET_WITHOUT_TITLE_CLASS, !this.option("showTitle"))
            },
            _clean: function() {
                if (this._$popup)
                    this._$popup.remove();
                this.callBase()
            },
            _createPopover: function() {
                var popover = this._$popup.dxPopover({
                        _templates: this.option("_templates"),
                        rtlEnabled: this.option("rtlEnabled"),
                        showTitle: true,
                        title: this.option("title"),
                        width: this.option("width") || 200,
                        height: this.option("height") || "auto",
                        target: this.option("target"),
                        onHidden: $.proxy(this.hide, this),
                        onContentReady: $.proxy(this._popupContentReadyAction, this)
                    }).dxPopover("instance");
                popover._wrapper().addClass(ACTION_SHEET_POPOVER_WRAPPER_CLASS);
                return popover
            },
            _createPopup: function() {
                var popup = this._$popup.dxPopup({
                        _templates: this.option("_templates"),
                        rtlEnabled: this.option("rtlEnabled"),
                        dragEnabled: false,
                        title: this.option("title"),
                        width: this.option("width") || "100%",
                        height: this.option("height") || "auto",
                        onContentReady: $.proxy(this._popupContentReadyAction, this),
                        position: {
                            my: "bottom",
                            at: "bottom",
                            of: window
                        },
                        animation: {
                            show: {
                                type: "slide",
                                duration: 400,
                                from: {position: {
                                        my: "top",
                                        at: "bottom",
                                        of: window
                                    }},
                                to: {position: {
                                        my: "bottom",
                                        at: "bottom",
                                        of: window
                                    }}
                            },
                            hide: {
                                type: "slide",
                                duration: 400,
                                from: {position: {
                                        my: "bottom",
                                        at: "bottom",
                                        of: window
                                    }},
                                to: {position: {
                                        my: "top",
                                        at: "bottom",
                                        of: window
                                    }}
                            }
                        }
                    }).dxPopup("instance");
                popup.on("optionChanged", $.proxy(function(args) {
                    if (args.name !== "visible")
                        return;
                    this.option("visible", args.value)
                }, this));
                popup._wrapper().addClass(ACTION_SHEET_POPUP_WRAPPER_CLASS);
                return popup
            },
            _popupContentReadyAction: function() {
                this._popup.content().append(this._$itemContainer);
                this._attachClickEvent();
                this._attachHoldEvent();
                this._renderContent();
                this._renderCancelButton()
            },
            _renderCancelButton: function() {
                if (this._isPopoverMode())
                    return;
                if (this._$cancelButton)
                    this._$cancelButton.remove();
                if (this.option("showCancelButton")) {
                    var cancelClickAction = this._createActionByOption("onCancelClick") || $.noop,
                        that = this;
                    this._$cancelButton = $("<div>").addClass(ACTION_SHEET_CANCEL_BUTTON_CLASS).appendTo(this._popup.content()).dxButton({
                        text: this.option("cancelText"),
                        onClick: function(e) {
                            var hidingArgs = {
                                    jQueryEvent: e,
                                    cancel: false
                                };
                            cancelClickAction(hidingArgs);
                            if (!hidingArgs.cancel)
                                that.hide()
                        }
                    })
                }
            },
            _itemClickHandler: function(e) {
                this.callBase(e);
                if (!$(e.target).is(".dx-state-disabled, .dx-state-disabled *"))
                    this.hide()
            },
            _itemHoldHandler: function(e) {
                this.callBase(e);
                if (!$(e.target).is(".dx-state-disabled, .dx-state-disabled *"))
                    this.hide()
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"width":
                    case"height":
                    case"visible":
                    case"title":
                        this._mapPopupOption(args.name);
                        break;
                    case"disabled":
                        this._renderDisabled();
                        break;
                    case"showTitle":
                        this._renderPopupTitle();
                        break;
                    case"showCancelButton":
                    case"onCancelClick":
                    case"cancelText":
                        this._renderCancelButton();
                        break;
                    case"target":
                    case"usePopover":
                    case"items":
                        this._invalidate();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            toggle: function(showing) {
                var that = this,
                    d = $.Deferred();
                that._popup.toggle(showing).done(function() {
                    that.option("visible", showing);
                    d.resolveWith(that)
                });
                return d.promise()
            },
            show: function() {
                return this.toggle(true)
            },
            hide: function() {
                return this.toggle(false)
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-mobile, file ui.dropDownMenu.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events;
        var DROP_DOWN_MENU_CLASS = "dx-dropdownmenu",
            DROP_DOWN_MENU_POPUP_CLASS = "dx-dropdownmenu-popup",
            DROP_DOWN_MENU_POPUP_WRAPPER_CLASS = DROP_DOWN_MENU_POPUP_CLASS + "-wrapper",
            DROP_DOWN_MENU_LIST_CLASS = "dx-dropdownmenu-list",
            DROP_DOWN_MENU_BUTTON_CLASS = "dx-dropdownmenu-button";
        var POPUP_OPTION_MAP = {
                popupWidth: "width",
                popupHeight: "height"
            };
        var BUTTON_OPTION_MAP = {
                buttonIcon: "icon",
                buttonIconSrc: "iconSrc",
                buttonText: "text"
            };
        DX.registerComponent("dxDropDownMenu", ui, ui.Widget.inherit({
            _supportedKeys: function() {
                return $.extend(this.callBase(), {tab: function(e) {
                            this._popup.hide()
                        }})
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    itemClickAction: {
                        since: "14.2",
                        alias: "onItemClick"
                    },
                    buttonClickAction: {
                        since: "14.2",
                        alias: "onButtonClick"
                    },
                    itemRender: {
                        since: "14.2",
                        alias: "itemTemplate"
                    }
                })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    items: [],
                    onItemClick: null,
                    dataSource: null,
                    itemTemplate: "item",
                    buttonText: "",
                    buttonIcon: "overflow",
                    buttonIconSrc: null,
                    onButtonClick: null,
                    usePopover: false,
                    popupWidth: "auto",
                    popupHeight: "auto",
                    hoverStateEnabled: true
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: [{platform: "ios"}],
                            options: {usePopover: true}
                        }, {
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }])
            },
            _init: function() {
                this.callBase();
                this._initDataSource();
                this._initItemClickAction();
                this._initButtonClickAction()
            },
            _initItemClickAction: function() {
                this._itemClickAction = this._createActionByOption("onItemClick")
            },
            _initButtonClickAction: function() {
                this._buttonClickAction = this._createActionByOption("onButtonClick")
            },
            _render: function() {
                this.element().addClass(DROP_DOWN_MENU_CLASS);
                this._renderButton();
                this.callBase()
            },
            _clean: function() {
                this._cleanFocusState();
                this._popup.element().remove()
            },
            _renderContentImpl: function() {
                this._renderPopup()
            },
            _renderButton: function() {
                var that = this;
                this._button = this.element().addClass(DROP_DOWN_MENU_BUTTON_CLASS).dxButton({
                    text: this.option("buttonText"),
                    icon: this.option("buttonIcon"),
                    iconSrc: this.option("buttonIconSrc"),
                    onClick: function(e) {
                        that._popup.toggle();
                        that._buttonClickAction(e)
                    },
                    focusStateEnabled: false
                }).dxButton("instance");
                var keys = this._supportedKeys(),
                    buttonKeys = this._button._supportedKeys();
                this._supportedKeys = function() {
                    return $.extend(keys, buttonKeys)
                }
            },
            _renderPopup: function() {
                var $popup = this._$popup = $("<div>").appendTo(this.element());
                var popupOptions = {
                        onContentReady: $.proxy(this._popupContentReadyHandler, this),
                        deferRendering: false
                    };
                var currentDevice = DX.devices.current();
                if (currentDevice.android && currentDevice.version[0] == 5) {
                    var location = "top " + (this.option("rtlEnabled") ? "left" : "right");
                    $.extend(popupOptions, {position: {
                            my: location,
                            at: location
                        }})
                }
                this._popup = this._createPopover($popup, popupOptions);
                this._popup._wrapper().addClass(DROP_DOWN_MENU_POPUP_WRAPPER_CLASS);
                this._popup._wrapper().toggleClass(DROP_DOWN_MENU_POPUP_CLASS, !this.option("usePopover"))
            },
            _popupContentReadyHandler: function() {
                var popup = this._$popup.dxPopover("instance");
                this._renderList(popup)
            },
            _createPopover: function($element, popupOptions) {
                return $element.dxPopover($.extend(popupOptions, {
                        target: this.element(),
                        rtlEnabled: this.option("rtlEnabled"),
                        height: this.option("popupHeight"),
                        width: this.option("popupWidth")
                    })).dxPopover("instance")
            },
            _renderList: function(instance) {
                var $content = instance.content(),
                    that = this;
                that._list = $content.addClass(DROP_DOWN_MENU_LIST_CLASS).dxList({
                    _keyboardProcessor: that._listProcessor,
                    _templates: that.option("_templates"),
                    autoPagingEnabled: false,
                    indicateLoading: false,
                    noDataText: "",
                    itemTemplate: that._getTemplateByOption("itemTemplate"),
                    onItemClick: function(e) {
                        that._popup.hide();
                        that._itemClickAction(e)
                    },
                    tabIndex: -1,
                    focusStateEnabled: this.option("focusStateEnabled")
                }).data("dxList");
                that._setListDataSource();
                var listMaxHeight = $(window).height() * 0.5;
                if ($content.height() > listMaxHeight)
                    $content.height(listMaxHeight)
            },
            _setListDataSource: function() {
                if (this._list)
                    this._list.option("dataSource", this._dataSource || this.option("items"))
            },
            _attachKeyboardEvents: function() {
                this.callBase.apply(this, arguments);
                this._listProcessor = this._keyboardProcessor.attachChildProcessor();
                if (this._list)
                    this._list.option("_keyboardProcessor", this._listProcessor)
            },
            _cleanFocusState: function() {
                this.callBase.apply(this, arguments);
                delete this._listProcessor
            },
            _toggleVisibility: function(visible) {
                this.callBase(visible);
                this._button.option("visible", visible)
            },
            _optionChanged: function(args) {
                var name = args.name;
                var value = args.value;
                switch (name) {
                    case"items":
                    case"dataSource":
                        this._refreshDataSource();
                        this._setListDataSource();
                        break;
                    case"itemTemplate":
                        if (this._list)
                            this._list.option(name, this._getTemplate(value));
                        break;
                    case"onItemClick":
                        this._initItemClickAction();
                        break;
                    case"onButtonClick":
                        this._buttonClickAction();
                        break;
                    case"buttonIcon":
                    case"buttonIconSrc":
                    case"buttonText":
                        this._button.option(BUTTON_OPTION_MAP[name], value);
                        break;
                    case"popupWidth":
                    case"popupHeight":
                        this._popup.option(POPUP_OPTION_MAP[name], value);
                        break;
                    case"usePopover":
                        this._invalidate();
                        break;
                    case"focusStateEnabled":
                        if (this._list)
                            this._list.option(name, value);
                        this.callBase(args);
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }).include(ui.DataHelperMixin))
    })(jQuery, DevExpress);
    /*! Module widgets-mobile, file ui.panorama.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            fx = DX.fx,
            translator = DX.translator,
            utils = DX.utils;
        var PANORAMA_CLASS = "dx-panorama",
            PANORAMA_WRAPPER_CLASS = "dx-panorama-wrapper",
            PANORAMA_TITLE_CLASS = "dx-panorama-title",
            PANORAMA_GHOST_TITLE_CLASS = "dx-panorama-ghosttitle",
            PANORAMA_ITEMS_CONTAINER_CLASS = "dx-panorama-itemscontainer",
            PANORAMA_ITEM_CLASS = "dx-panorama-item",
            PANORAMA_GHOST_ITEM_CLASS = "dx-panorama-ghostitem",
            PANORAMA_ITEM_DATA_KEY = "dxPanoramaItemData",
            PANORAMA_ITEM_MARGIN_SCALE = .02,
            PANORAMA_TITLE_MARGIN_SCALE = .02,
            PANORAMA_BACKGROUND_MOVE_DURATION = 300,
            PANORAMA_BACKGROUND_MOVE_EASING = "cubic-bezier(.40, .80, .60, 1)",
            PANORAMA_TITLE_MOVE_DURATION = 300,
            PANORAMA_TITLE_MOVE_EASING = "cubic-bezier(.40, .80, .60, 1)",
            PANORAMA_ITEM_MOVE_DURATION = 300,
            PANORAMA_ITEM_MOVE_EASING = "cubic-bezier(.40, .80, .60, 1)";
        var moveBackground = function($element, position) {
                $element.css("background-position", position + "px 0%")
            };
        var position = function($element) {
                return translator.locate($element).left
            };
        var move = function($element, position) {
                translator.move($element, {left: position})
            };
        var animation = {
                backgroundMove: function($element, position, completeAction) {
                    return fx.animate($element, {
                            to: {"background-position": position + "px 0%"},
                            duration: PANORAMA_BACKGROUND_MOVE_DURATION,
                            easing: PANORAMA_BACKGROUND_MOVE_EASING,
                            complete: completeAction
                        })
                },
                titleMove: function($title, position, completeAction) {
                    return fx.animate($title, {
                            type: "slide",
                            to: {left: position},
                            duration: PANORAMA_TITLE_MOVE_DURATION,
                            easing: PANORAMA_TITLE_MOVE_EASING,
                            complete: completeAction
                        })
                },
                itemMove: function($item, position, completeAction) {
                    return fx.animate($item, {
                            type: "slide",
                            to: {left: position},
                            duration: PANORAMA_ITEM_MOVE_DURATION,
                            easing: PANORAMA_ITEM_MOVE_EASING,
                            complete: completeAction
                        })
                }
            };
        var endAnimation = function(elements) {
                if (!elements)
                    return;
                $.each(elements, function(_, element) {
                    fx.stop(element, true)
                })
            };
        var PanoramaItemsRenderStrategy = DX.Class.inherit({
                ctor: function(panorama) {
                    this._panorama = panorama
                },
                init: $.noop,
                render: $.noop,
                allItemElements: function() {
                    return this._panorama._itemElements()
                },
                updatePositions: DX.abstract,
                animateRollback: DX.abstract,
                detectBoundsTransition: DX.abstract,
                animateComplete: DX.abstract,
                _getRTLSignCorrection: function() {
                    return this._panorama._getRTLSignCorrection()
                },
                _isRTLEnabled: function() {
                    return this._panorama.option("rtlEnabled")
                },
                _itemMargin: function() {
                    return this._containerWidth() * PANORAMA_ITEM_MARGIN_SCALE
                },
                _containerWidth: function() {
                    return this._panorama._elementWidth()
                },
                _itemWidth: function() {
                    return this._panorama._itemWidth()
                },
                _indexBoundary: function() {
                    return this._panorama._indexBoundary()
                },
                _normalizeIndex: function(index) {
                    return this._panorama._normalizeIndex(index)
                },
                _startNextPosition: function() {
                    if (this._isRTLEnabled())
                        return this._containerWidth() - (this._itemMargin() + this._itemWidth());
                    else
                        return this._itemMargin()
                },
                _startPrevPosition: function() {
                    if (this._isRTLEnabled())
                        return this._containerWidth();
                    else
                        return -this._itemWidth()
                }
            });
        var PanoramaOneAndLessItemsRenderStrategy = PanoramaItemsRenderStrategy.inherit({
                updatePositions: function() {
                    var $items = this._panorama._itemElements(),
                        startPosition = this._startNextPosition();
                    $items.each(function() {
                        move($(this), startPosition)
                    })
                },
                animateRollback: $.noop,
                detectBoundsTransition: $.noop,
                animateComplete: $.noop
            });
        var PanoramaTwoItemsRenderStrategy = PanoramaItemsRenderStrategy.inherit({
                init: function() {
                    this._initGhostItem()
                },
                render: function() {
                    this._renderGhostItem()
                },
                _initGhostItem: function() {
                    this._$ghostItem = $("<div>").addClass(PANORAMA_GHOST_ITEM_CLASS)
                },
                _renderGhostItem: function() {
                    this._panorama._itemContainer().append(this._$ghostItem);
                    this._toggleGhostItem(false)
                },
                _toggleGhostItem: function(visible) {
                    var $ghostItem = this._$ghostItem;
                    if (visible)
                        $ghostItem.css("opacity", 1);
                    else
                        $ghostItem.css("opacity", 0)
                },
                _updateGhostItemContent: function(index) {
                    if (index !== false && index !== this._prevGhostIndex) {
                        this._$ghostItem.html(this._panorama._itemElements().eq(index).html());
                        this._prevGhostIndex = index
                    }
                },
                _isGhostItemVisible: function() {
                    return this._$ghostItem.css("opacity") == 1
                },
                _swapGhostWithItem: function($item) {
                    var $ghostItem = this._$ghostItem,
                        lastItemPosition = position($item);
                    move($item, position($ghostItem));
                    move($ghostItem, lastItemPosition)
                },
                allItemElements: function() {
                    return this._panorama._itemContainer().find("." + PANORAMA_ITEM_CLASS + ", ." + PANORAMA_GHOST_ITEM_CLASS)
                },
                updatePositions: function(offset) {
                    var $items = this.allItemElements(),
                        selectedIndex = this._panorama.option("selectedIndex"),
                        adjustedOffset = offset * this._getRTLSignCorrection(),
                        isGhostReplaceLast = adjustedOffset > 0 && selectedIndex === 0 || adjustedOffset < 0 && selectedIndex === 1,
                        isGhostReplaceFirst = adjustedOffset < 0 && selectedIndex === 0 || adjustedOffset > 0 && selectedIndex === 1,
                        ghostPosition = isGhostReplaceLast && "replaceLast" || isGhostReplaceFirst && "replaceFirst",
                        ghostContentIndex = isGhostReplaceLast && 1 || isGhostReplaceFirst && 0,
                        positions = this._calculateItemPositions(selectedIndex, ghostPosition);
                    this._updateGhostItemContent(ghostContentIndex);
                    this._toggleGhostItem(isGhostReplaceLast || isGhostReplaceFirst);
                    $items.each(function(index) {
                        move($(this), positions[index] + offset)
                    })
                },
                animateRollback: function(currentIndex) {
                    var that = this,
                        $items = this._panorama._itemElements(),
                        startPosition = this._startNextPosition(),
                        signCorrection = this._getRTLSignCorrection(),
                        offset = (position($items.eq(currentIndex)) - startPosition) * signCorrection,
                        ghostOffset = (position(this._$ghostItem) - startPosition) * signCorrection,
                        positions = this._calculateItemPositions(currentIndex, ghostOffset > 0 ? "prepend" : "append"),
                        isLastReplasedByGhost = currentIndex === 0 && offset > 0 && ghostOffset > 0 || currentIndex === 1 && ghostOffset < 0;
                    if (isLastReplasedByGhost)
                        this._swapGhostWithItem($items.eq(1));
                    else
                        this._swapGhostWithItem($items.eq(0));
                    $items.each(function(index) {
                        animation.itemMove($(this), positions[index])
                    });
                    animation.itemMove(this._$ghostItem, positions[2], function() {
                        that._toggleGhostItem(false)
                    })
                },
                detectBoundsTransition: function(newIndex, currentIndex) {
                    var ghostLocation = position(this._$ghostItem),
                        startPosition = this._startNextPosition(),
                        rtl = this._isRTLEnabled();
                    if (newIndex === 0 && rtl ^ ghostLocation < startPosition)
                        return "left";
                    if (currentIndex === 0 && rtl ^ ghostLocation > startPosition)
                        return "right"
                },
                animateComplete: function(boundCross, newIndex, currentIndex) {
                    var that = this,
                        ghostPosition = !boundCross ^ !(currentIndex === 0) ? "prepend" : "append",
                        $items = this._panorama._itemElements(),
                        positions = this._calculateItemPositions(newIndex, ghostPosition),
                        animations = [];
                    $items.each(function(index) {
                        animations.push(animation.itemMove($(this), positions[index]))
                    });
                    animations.push(animation.itemMove(this._$ghostItem, positions[2], function() {
                        that._toggleGhostItem(false)
                    }));
                    return $.when.apply($, animations)
                },
                _calculateItemPositions: function(atIndex, ghostPosition) {
                    var positions = [],
                        $items = this._panorama._itemElements(),
                        itemMargin = this._itemMargin(),
                        itemWidth = this._itemWidth(),
                        itemPositionOffset = (itemWidth + itemMargin) * this._getRTLSignCorrection(),
                        normalFlow = atIndex === 0,
                        prevPosition = this._startPrevPosition(),
                        nextPosition = this._startNextPosition();
                    positions.push(nextPosition);
                    nextPosition += itemPositionOffset;
                    if (normalFlow)
                        positions.push(nextPosition);
                    else
                        positions.splice(0, 0, nextPosition);
                    nextPosition += itemPositionOffset;
                    switch (ghostPosition) {
                        case"replaceFirst":
                            positions.push(positions[0]);
                            if (normalFlow)
                                positions[0] = nextPosition;
                            else
                                positions[0] = prevPosition;
                            break;
                        case"replaceLast":
                            if (normalFlow)
                                positions.splice(1, 0, prevPosition);
                            else
                                positions.splice(1, 0, nextPosition);
                            break;
                        case"prepend":
                            positions.push(prevPosition);
                            break;
                        case"append":
                            positions.push(nextPosition);
                            break
                    }
                    return positions
                }
            });
        var PanoramaThreeAndMoreItemsRenderStrategy = PanoramaItemsRenderStrategy.inherit({
                updatePositions: function(offset) {
                    var $items = this._panorama._itemElements(),
                        movingBack = offset * this._getRTLSignCorrection() < 0,
                        positions = this._calculateItemPositions(this._panorama.option("selectedIndex"), movingBack);
                    $items.each(function(index) {
                        move($(this), positions[index] + offset)
                    })
                },
                animateRollback: function(selectedIndex) {
                    var $items = this._panorama._itemElements(),
                        positions = this._calculateItemPositions(selectedIndex),
                        animatingItems = [selectedIndex, this._normalizeIndex(selectedIndex + 1)];
                    if (this._isRTLEnabled() ^ position($items.eq(selectedIndex)) > this._startNextPosition())
                        animatingItems.push(this._normalizeIndex(selectedIndex - 1));
                    $items.each(function(index) {
                        var $item = $(this);
                        if ($.inArray(index, animatingItems) !== -1)
                            animation.itemMove($item, positions[index]);
                        else
                            move($item, positions[index])
                    })
                },
                detectBoundsTransition: function(newIndex, currentIndex) {
                    var lastIndex = this._indexBoundary() - 1;
                    if (currentIndex === lastIndex && newIndex === 0)
                        return "left";
                    if (currentIndex === 0 && newIndex === lastIndex)
                        return "right"
                },
                animateComplete: function(boundCross, newIndex, currentIndex) {
                    var animations = [],
                        $items = this._panorama._itemElements(),
                        positions = this._calculateItemPositions(newIndex);
                    var transitionBack = this._normalizeIndex(currentIndex - 1) === newIndex,
                        cyclingItemIndex = $items.length === 3 && transitionBack ? this._normalizeIndex(currentIndex + 1) : null,
                        cyclingItemPosition = positions[this._indexBoundary()];
                    var animatingItems = [newIndex, currentIndex],
                        backAnimatedItemIndex = transitionBack ? currentIndex : newIndex;
                    if (!transitionBack)
                        animatingItems.push(this._normalizeIndex(backAnimatedItemIndex + 1));
                    $items.each(function(index) {
                        var $item = $(this);
                        if ($.inArray(index, animatingItems) === -1) {
                            move($item, positions[index]);
                            return
                        }
                        animations.push(index !== cyclingItemIndex ? animation.itemMove($item, positions[index]) : animation.itemMove($item, cyclingItemPosition, function() {
                            move($item, positions[index])
                        }))
                    });
                    return $.when.apply($, animations)
                },
                _calculateItemPositions: function(atIndex, movingBack) {
                    var previousIndex = this._normalizeIndex(atIndex - 1),
                        $items = this._panorama._itemElements(),
                        itemMargin = this._itemMargin(),
                        itemWidth = this._itemWidth(),
                        itemPositionOffset = (itemWidth + itemMargin) * this._getRTLSignCorrection(),
                        positions = [],
                        prevPosition = this._startPrevPosition(),
                        nextPosition = this._startNextPosition();
                    for (var i = atIndex; i !== previousIndex; i = this._normalizeIndex(i + 1)) {
                        positions[i] = nextPosition;
                        nextPosition += itemPositionOffset
                    }
                    if (movingBack) {
                        positions[previousIndex] = nextPosition;
                        nextPosition += itemPositionOffset
                    }
                    else
                        positions[previousIndex] = prevPosition;
                    positions.push(nextPosition);
                    return positions
                }
            });
        DX.registerComponent("dxPanorama", ui, ui.CollectionWidget.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    selectedIndex: 0,
                    title: "panorama",
                    backgroundImage: {
                        url: null,
                        width: 0,
                        height: 0
                    },
                    focusStateEnabled: false,
                    selectionMode: "single",
                    selectionRequired: true,
                    selectionByClick: false
                })
            },
            _itemClass: function() {
                return PANORAMA_ITEM_CLASS
            },
            _itemDataKey: function() {
                return PANORAMA_ITEM_DATA_KEY
            },
            _itemContainer: function() {
                return this._$itemsContainer
            },
            _itemWidth: function() {
                if (!this._itemWidthCache)
                    this._itemWidthCache = this._itemElements().eq(0).outerWidth();
                return this._itemWidthCache
            },
            _clearItemWidthCache: function() {
                delete this._itemWidthCache
            },
            _elementWidth: function() {
                if (!this._elementWidthCache)
                    this._elementWidthCache = this.element().width();
                return this._elementWidthCache
            },
            _clearElementWidthCache: function() {
                delete this._elementWidthCache
            },
            _titleWidth: function() {
                if (!this._titleWidthCache)
                    this._titleWidthCache = this._$title.outerWidth();
                return this._titleWidthCache
            },
            _clearTitleWidthCache: function() {
                delete this._titleWidthCache
            },
            _init: function() {
                this.callBase();
                this._initItemsRenderStrategy();
                this._initWrapper();
                this._initTitle();
                this._initItemsContainer();
                this._initSwipeHandlers()
            },
            _dimensionChanged: function() {
                this._clearItemWidthCache();
                this._clearElementWidthCache();
                this._clearTitleWidthCache();
                this._updatePositions()
            },
            _initWrapper: function() {
                this._$wrapper = $("<div>").addClass(PANORAMA_WRAPPER_CLASS).appendTo(this.element())
            },
            _initItemsRenderStrategy: function() {
                var itemsRenderStrategy;
                switch (this.option("items").length) {
                    case 0:
                    case 1:
                        itemsRenderStrategy = PanoramaOneAndLessItemsRenderStrategy;
                        break;
                    case 2:
                        itemsRenderStrategy = PanoramaTwoItemsRenderStrategy;
                        break;
                    default:
                        itemsRenderStrategy = PanoramaThreeAndMoreItemsRenderStrategy
                }
                this._itemsRenderStrategy = new itemsRenderStrategy(this);
                this._itemsRenderStrategy.init()
            },
            _initBackgroundImage: function() {
                var bgUrl = this.option("backgroundImage.url");
                if (bgUrl)
                    this.element().css("background-image", "url(" + bgUrl + ")")
            },
            _initTitle: function() {
                this._$title = $("<div>").addClass(PANORAMA_TITLE_CLASS);
                this._$ghostTitle = $("<div>").addClass(PANORAMA_GHOST_TITLE_CLASS);
                this._$wrapper.append(this._$title);
                this._$wrapper.append(this._$ghostTitle);
                this._updateTitle()
            },
            _updateTitle: function() {
                var title = this.option("title");
                this._$title.text(title);
                this._$ghostTitle.text(title);
                this._toggleGhostTitle(false)
            },
            _toggleGhostTitle: function(visible) {
                var $ghostTitle = this._$ghostTitle;
                if (visible)
                    $ghostTitle.css("opacity", 1);
                else
                    $ghostTitle.css("opacity", 0)
            },
            _getRTLSignCorrection: function() {
                return this.option("rtlEnabled") ? -1 : 1
            },
            _initItemsContainer: function() {
                this._$itemsContainer = $("<div>").addClass(PANORAMA_ITEMS_CONTAINER_CLASS);
                this._$wrapper.append(this._$itemsContainer)
            },
            _render: function() {
                this.element().addClass(PANORAMA_CLASS);
                this.callBase();
                this._initBackgroundImage();
                this._itemsRenderStrategy.render()
            },
            _updatePositions: function(offset) {
                offset = offset || 0;
                this._updateBackgroundPosition(offset * this._calculateBackgroundStep());
                this._updateTitlePosition(offset * this._calculateTitleStep());
                this._itemsRenderStrategy.updatePositions(offset * this._elementWidth())
            },
            _updateBackgroundPosition: function(offset) {
                moveBackground(this.element(), this._calculateBackgroundPosition(this.option("selectedIndex")) + offset)
            },
            _updateTitlePosition: function(offset) {
                move(this._$title, this._calculateTitlePosition(this.option("selectedIndex")) + offset)
            },
            _animateRollback: function(currentIndex) {
                this._animateBackgroundMove(currentIndex);
                this._animateTitleMove(currentIndex);
                this._itemsRenderStrategy.animateRollback(currentIndex)
            },
            _animateBackgroundMove: function(toIndex) {
                return animation.backgroundMove(this.element(), this._calculateBackgroundPosition(toIndex))
            },
            _animateTitleMove: function(toIndex) {
                return animation.titleMove(this._$title, this._calculateTitlePosition(toIndex))
            },
            _animateComplete: function(newIndex, currentIndex) {
                var that = this,
                    boundCross = this._itemsRenderStrategy.detectBoundsTransition(newIndex, currentIndex);
                var backgroundAnimation = this._performBackgroundAnimation(boundCross, newIndex);
                var titleAnimation = this._performTitleAnimation(boundCross, newIndex);
                var itemsAnimation = this._itemsRenderStrategy.animateComplete(boundCross, newIndex, currentIndex);
                $.when(backgroundAnimation, titleAnimation, itemsAnimation).done(function() {
                    that._indexChangeOnAnimation = true;
                    that.option("selectedIndex", newIndex);
                    that._indexChangeOnAnimation = false
                })
            },
            _performBackgroundAnimation: function(boundCross, newIndex) {
                if (boundCross)
                    return this._animateBackgroundBoundsTransition(boundCross, newIndex);
                return this._animateBackgroundMove(newIndex)
            },
            _animateBackgroundBoundsTransition: function(bound, newIndex) {
                var that = this,
                    isLeft = bound === "left",
                    afterAnimationPosition = this._calculateBackgroundPosition(newIndex),
                    animationEndPositionShift = isLeft ^ this.option("rtlEnabled") ? -this._calculateBackgroundScaledWidth() : this._calculateBackgroundScaledWidth(),
                    animationEndPosition = afterAnimationPosition + animationEndPositionShift;
                return animation.backgroundMove(this.element(), animationEndPosition, function() {
                        moveBackground(that.element(), afterAnimationPosition)
                    })
            },
            _performTitleAnimation: function(boundCross, newIndex) {
                if (boundCross)
                    return this._animateTitleBoundsTransition(boundCross, newIndex);
                return this._animateTitleMove(newIndex)
            },
            _animateTitleBoundsTransition: function(bound, newIndex) {
                var that = this,
                    $ghostTitle = this._$ghostTitle,
                    ghostWidth = this._titleWidth(),
                    panoramaWidth = this._elementWidth(),
                    isLeft = bound === "left",
                    rtl = this.option("rtlEnabled"),
                    ghostTitleStartPosition = isLeft ^ rtl ? panoramaWidth : -ghostWidth,
                    ghostTitleEndPosition = isLeft ^ rtl ? -(panoramaWidth + ghostWidth) : panoramaWidth;
                move($ghostTitle, ghostTitleStartPosition);
                this._toggleGhostTitle(true);
                this._swapGhostWithTitle();
                var ghostAnimation = animation.titleMove($ghostTitle, ghostTitleEndPosition, function() {
                        that._toggleGhostTitle(false)
                    });
                var titleAnimation = animation.titleMove(this._$title, this._calculateTitlePosition(newIndex));
                return $.when(ghostAnimation, titleAnimation)
            },
            _swapGhostWithTitle: function() {
                var $ghostTitle = this._$ghostTitle,
                    $title = this._$title,
                    lastTitlePosition = position($title);
                move($title, position($ghostTitle));
                move($ghostTitle, lastTitlePosition)
            },
            _calculateTitlePosition: function(atIndex) {
                var panoramaWidth = this._elementWidth(),
                    titleWidth = this._titleWidth(),
                    titleMargin = panoramaWidth * PANORAMA_TITLE_MARGIN_SCALE,
                    titleStartPosition = this.option("rtlEnabled") ? panoramaWidth - titleMargin - titleWidth : titleMargin,
                    titleStep = atIndex * this._calculateTitleStep() * this._getRTLSignCorrection();
                return titleStartPosition - titleStep
            },
            _calculateTitleStep: function() {
                var panoramaWidth = this._elementWidth(),
                    titleWidth = this._titleWidth(),
                    indexBoundary = this._indexBoundary() || 1;
                return Math.max((titleWidth - panoramaWidth) / indexBoundary, titleWidth / indexBoundary)
            },
            _calculateBackgroundPosition: function(atIndex) {
                var panoramaWidth = this._elementWidth(),
                    backgroundScaledWidth = this._calculateBackgroundScaledWidth(),
                    backgroundStartPosition = this.option("rtlEnabled") ? panoramaWidth - backgroundScaledWidth : 0,
                    backgroundOffset = atIndex * this._calculateBackgroundStep() * this._getRTLSignCorrection();
                return backgroundStartPosition - backgroundOffset
            },
            _calculateBackgroundStep: function() {
                var itemWidth = this._itemWidth(),
                    backgroundScaledWidth = this._calculateBackgroundScaledWidth();
                return Math.max((backgroundScaledWidth - itemWidth) / (this._indexBoundary() || 1), 0)
            },
            _calculateBackgroundScaledWidth: function() {
                return this.element().height() * this.option("backgroundImage.width") / (this.option("backgroundImage.height") || 1)
            },
            _initSwipeHandlers: function() {
                this.element().on(events.addNamespace("dxswipestart", this.NAME), {itemSizeFunc: $.proxy(this._elementWidth, this)}, $.proxy(this._swipeStartHandler, this)).on(events.addNamespace("dxswipe", this.NAME), $.proxy(this._swipeUpdateHandler, this)).on(events.addNamespace("dxswipeend", this.NAME), $.proxy(this._swipeEndHandler, this))
            },
            _swipeStartHandler: function(e) {
                this._stopAnimations();
                e.maxLeftOffset = 1;
                e.maxRightOffset = 1;
                if (DX.designMode || this.option("disabled") || this._indexBoundary() <= 1)
                    e.cancel = true
            },
            _stopAnimations: function() {
                endAnimation([this.element(), this._$ghostTitle, this._$title]);
                endAnimation(this._itemsRenderStrategy.allItemElements())
            },
            _swipeUpdateHandler: function(e) {
                this._updatePositions(e.offset)
            },
            _swipeEndHandler: function(e) {
                var currentIndex = this.option("selectedIndex"),
                    targetOffset = e.targetOffset * this._getRTLSignCorrection();
                if (targetOffset === 0)
                    this._animateRollback(currentIndex);
                else
                    this._animateComplete(this._normalizeIndex(currentIndex - targetOffset), currentIndex)
            },
            _renderSelection: function(current, previous) {
                if (!this._indexChangeOnAnimation)
                    this._updatePositions()
            },
            _normalizeIndex: function(index) {
                var boundary = this._indexBoundary();
                if (index < 0)
                    index = boundary + index;
                if (index >= boundary)
                    index = index - boundary;
                return index
            },
            _indexBoundary: function() {
                return this.option("items").length
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._dimensionChanged()
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"width":
                        this.callBase(args);
                        this._dimensionChanged();
                        break;
                    case"backgroundImage":
                        this._invalidate();
                        break;
                    case"title":
                        this._updateTitle();
                        break;
                    case"items":
                        this._initItemsRenderStrategy();
                        this.callBase(args);
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }));
        ui.dxPanorama.__internals = {animation: animation}
    })(jQuery, DevExpress);
    /*! Module widgets-mobile, file ui.slideout.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            fx = DX.fx,
            utils = DX.utils,
            translator = DX.translator;
        var SLIDEOUT_CLASS = "dx-slideout",
            SLIDEOUT_WRAPPER_CLASS = "dx-slideout-wrapper",
            SLIDEOUT_ITEM_CONTAINER_CLASS = "dx-slideout-item-container",
            SLIDEOUT_MENU = "dx-slideout-menu",
            SLIDEOUT_SHIELD = "dx-slideout-shield",
            SLIDEOUT_ITEM_CLASS = "dx-slideout-item",
            SLIDEOUT_ITEM_DATA_KEY = "dxSlideoutItemData",
            INVISIBLE_STATE_CLASS = "dx-state-invisible",
            CONTENT_OFFSET = 45,
            ANIMATION_DURATION = 400;
        DX.registerComponent("dxSlideOut", ui, ui.CollectionWidget.inherit({
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    menuItemRender: {
                        since: "14.2",
                        alias: "menuItemTemplate"
                    },
                    menuGroupRender: {
                        since: "14.2",
                        alias: "menuGroupTemplate"
                    }
                })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    activeStateEnabled: false,
                    menuItemTemplate: "menuItem",
                    swipeEnabled: true,
                    menuVisible: false,
                    menuGrouped: false,
                    menuGroupTemplate: "menuGroup",
                    selectionMode: "single",
                    selectionRequired: true
                })
            },
            _itemClass: function() {
                return SLIDEOUT_ITEM_CLASS
            },
            _itemDataKey: function() {
                return SLIDEOUT_ITEM_DATA_KEY
            },
            _init: function() {
                this.callBase();
                this._deferredAnimate = undefined
            },
            _render: function() {
                this._renderWrapper();
                this._renderItemsContainer();
                this._renderShield();
                this._renderList();
                this._initSwipeHandlers();
                this.element().addClass(SLIDEOUT_CLASS);
                this.callBase();
                this._renderPosition(this.option("menuVisible"), false)
            },
            _renderWrapper: function() {
                this._wrapper = $("<div>").addClass(SLIDEOUT_WRAPPER_CLASS);
                this.element().append(this._wrapper)
            },
            _renderShield: function() {
                this._$shield = $("<div>").addClass(SLIDEOUT_SHIELD);
                this._$shield.appendTo(this._$container);
                this._$shield.on("dxclick", $.proxy(this.hideMenu, this));
                this._toggleShieldVisibility()
            },
            _dimensionChanged: function() {
                this._renderPosition(this.option("menuVisible"), false);
                this._clearListWidthCache()
            },
            _renderItemsContainer: function() {
                this._$container = $("<div>").addClass(SLIDEOUT_ITEM_CONTAINER_CLASS).appendTo(this._wrapper);
                this._$container.on("MSPointerDown", function(e){})
            },
            _selectedItemElement: function(index) {
                return this._itemElements().eq(0)
            },
            _renderContentImpl: function(template) {
                var items = this.option("items"),
                    selectedIndex = this.option("selectedIndex");
                if (items.length && selectedIndex > -1) {
                    var selectedItem = this._$list.dxList("instance").getItemByIndex(selectedIndex);
                    this._renderItems([selectedItem])
                }
            },
            _renderList: function() {
                this._$list = $("<div>").addClass(SLIDEOUT_MENU).prependTo(this._wrapper);
                this._renderItemClickAction();
                var list = this._$list.dxList().dxList("instance");
                this._$list.dxList({
                    _templates: this.option("_templates"),
                    itemTemplateProperty: "menuTemplate",
                    height: "100%",
                    indicateLoading: false,
                    onItemClick: $.proxy(this._listItemClickHandler, this),
                    items: this.option("items"),
                    dataSource: this.option("dataSource"),
                    itemTemplate: this._getTemplateByOption("menuItemTemplate"),
                    grouped: this.option("menuGrouped"),
                    groupTemplate: this.option("menuGroupTemplate")
                })
            },
            _listItemClickHandler: function(e) {
                var selectedIndex = this._$list.find(".dx-list-item").index(e.itemElement);
                this.option("selectedIndex", selectedIndex);
                this._itemClickAction(e)
            },
            _itemClickHandler: $.noop,
            _renderItemClickAction: function() {
                this._itemClickAction = this._createActionByOption("onItemClick")
            },
            _renderItem: function(index, item, container) {
                this._$container.find("." + SLIDEOUT_ITEM_CLASS).remove();
                this.callBase(index, item, this._$container)
            },
            _renderSelection: function() {
                this._renderContent()
            },
            _initSwipeHandlers: function() {
                this._$container.dxSwipeable({
                    elastic: false,
                    itemSizeFunc: $.proxy(this._getListWidth, this),
                    onStart: $.proxy(this.option("swipeEnabled") ? this._swipeStartHandler : function(e) {
                        e.jQueryEvent.cancel = true
                    }, this),
                    onUpdated: $.proxy(this._swipeUpdateHandler, this),
                    onEnd: $.proxy(this._swipeEndHandler, this)
                })
            },
            _swipeStartHandler: function(e) {
                this._$shield.addClass(INVISIBLE_STATE_CLASS);
                fx.stop(this._$container);
                var menuVisible = this.option("menuVisible"),
                    rtl = this.option("rtlEnabled");
                e.jQueryEvent.maxLeftOffset = +(rtl ? !menuVisible : menuVisible);
                e.jQueryEvent.maxRightOffset = +(rtl ? menuVisible : !menuVisible)
            },
            _swipeUpdateHandler: function(e) {
                var offset = this.option("menuVisible") ? e.jQueryEvent.offset + 1 * this._getRTLSignCorrection() : e.jQueryEvent.offset;
                offset *= this._getRTLSignCorrection();
                this._renderPosition(offset, false)
            },
            _swipeEndHandler: function(e) {
                var targetOffset = e.jQueryEvent.targetOffset * this._getRTLSignCorrection() + this.option("menuVisible"),
                    menuVisible = targetOffset !== 0;
                if (this.option("menuVisible") === menuVisible)
                    this._renderPosition(this.option("menuVisible"), true);
                else
                    this.option("menuVisible", targetOffset !== 0)
            },
            _menuButtonClickHandler: function() {
                this.option("menuVisible", !this.option("menuVisible"))
            },
            _toggleMenuVisibility: function(visible, animate) {
                this.option("menuVisible", visible)
            },
            _renderPosition: function(offset, animate) {
                var pos = this._calculatePixelOffset(offset) * this._getRTLSignCorrection();
                if (animate) {
                    this._$shield.addClass(INVISIBLE_STATE_CLASS);
                    fx.animate(this._$container, {
                        type: "slide",
                        to: {left: pos},
                        duration: ANIMATION_DURATION,
                        complete: $.proxy(this._animationCompleteHandler, this)
                    })
                }
                else
                    translator.move(this._$container, {left: pos})
            },
            _calculatePixelOffset: function(offset) {
                var offset = offset || 0,
                    maxOffset = this._getListWidth();
                return offset * maxOffset
            },
            _getListWidth: function() {
                if (!this._listWidth) {
                    var maxListWidth = this.element().width() - CONTENT_OFFSET;
                    this._$list.css("max-width", maxListWidth);
                    var currentListWidth = this._$list.width();
                    this._listWidth = Math.min(currentListWidth, maxListWidth)
                }
                return this._listWidth
            },
            _clearListWidthCache: function() {
                delete this._listWidth
            },
            _getRTLSignCorrection: function() {
                return this.option("rtlEnabled") ? -1 : 1
            },
            _changeMenuOption: function(name, value) {
                this._$list.dxList("instance").option(name, value);
                this._clearListWidthCache()
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._dimensionChanged()
            },
            _optionChanged: function(args) {
                var name = args.name;
                var value = args.value;
                switch (name) {
                    case"menuVisible":
                        this._renderPosition(value, true);
                        break;
                    case"swipeEnabled":
                        this._initSwipeHandlers();
                        break;
                    case"menuItemTemplate":
                        this._changeMenuOption("itemTemplate", this._getTemplate(value));
                        break;
                    case"items":
                    case"dataSource":
                        this._changeMenuOption(name, value);
                        break;
                    case"menuGrouped":
                        this._changeMenuOption("grouped", value);
                        break;
                    case"menuGroupTemplate":
                        this._changeMenuOption("groupTemplate", this._getTemplate(value));
                        break;
                    case"onItemClick":
                        this._renderItemClickAction();
                        break;
                    case"rtlEnabled":
                        this.callBase(args);
                        this._renderPosition(this.option("menuVisible"), false);
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _toggleShieldVisibility: function() {
                this._$shield.toggleClass(INVISIBLE_STATE_CLASS, !this.option("menuVisible"))
            },
            _animationCompleteHandler: function() {
                this._toggleShieldVisibility();
                if (this._deferredAnimate)
                    this._deferredAnimate.resolveWith(this)
            },
            showMenu: function() {
                return this.toggleMenuVisibility(true)
            },
            hideMenu: function() {
                return this.toggleMenuVisibility(false)
            },
            toggleMenuVisibility: function(showing) {
                showing = showing === undefined ? !this.option("menuVisible") : showing;
                this._deferredAnimate = $.Deferred();
                this.option("menuVisible", showing);
                return this._deferredAnimate.promise()
            }
        }))
    })(jQuery, DevExpress);
    DevExpress.MOD_WIDGETS_MOBILE = true
}
if (!DevExpress.MOD_WIDGETS_WEB) {
    if (!DevExpress.MOD_WIDGETS_BASE)
        throw Error('Required module is not referenced: widgets-base');
    /*! Module widgets-web, file ui.accordion.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            fx = DX.fx,
            utils = DX.utils,
            translator = DX.translator;
        var ACCORDION_CLASS = "dx-accordion",
            ACCORDION_WRAPPER_CLASS = "dx-accordion-wrapper",
            ACCORDION_ITEM_CLASS = "dx-accordion-item",
            ACCORDION_ITEM_OPENED_CLASS = "dx-accordion-item-opened",
            ACCORDION_ITEM_TITLE_CLASS = "dx-accordion-item-title",
            ACCORDION_ITEM_BODY_CLASS = "dx-accordion-item-body",
            ACCORDION_ITEM_DATA_KEY = "dxAccordionItemData",
            ACCORDION_ITEM_TITLE_DATA_KEY = "dxAccordionItemTitleData",
            ACCORDION_ITEM_CONTENT_DATA_KEY = "dxAccordionItemContentData";
        DX.registerComponent("dxAccordion", ui, ui.CollectionWidget.inherit({
            _activeStateUnit: "." + ACCORDION_ITEM_CLASS,
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    height: undefined,
                    itemTitleTemplate: "title",
                    onItemTitleClick: null,
                    onItemTitleHold: null,
                    selectedIndex: 0,
                    collapsible: false,
                    multiple: false,
                    animationDuration: 300,
                    selectionByClick: true,
                    activeStateEnabled: true
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {
                                hoverStateEnabled: true,
                                focusStateEnabled: true
                            }
                        }])
            },
            _init: function() {
                this.callBase();
                this.option("selectionRequired", !this.option("collapsible"));
                this.option("selectionMode", this.option("multiple") ? "multi" : "single");
                var $element = this.element();
                $element.addClass(ACCORDION_CLASS);
                this._$container = $("<div>").addClass(ACCORDION_WRAPPER_CLASS);
                $element.append(this._$container)
            },
            _render: function() {
                this.callBase();
                this._attachItemTitleClickAction()
            },
            _itemDataKey: function() {
                return ACCORDION_ITEM_DATA_KEY
            },
            _itemClass: function() {
                return ACCORDION_ITEM_CLASS
            },
            _itemContainer: function() {
                return this._$container
            },
            _itemTitles: function() {
                return this._itemElements().find("." + ACCORDION_ITEM_TITLE_CLASS)
            },
            _itemContents: function() {
                return this._itemElements().find("." + ACCORDION_ITEM_BODY_CLASS)
            },
            _getItemData: function(target) {
                return $(target).parent().data(this._itemDataKey()) || this.callBase.apply(this, arguments)
            },
            _getItemRenderer: function(itemData) {
                switch (itemData.type) {
                    case"title":
                        this._itemTitleRender = this._itemTitleRender || this.option("itemTitleRender");
                        return this._itemTitleRender;
                    case"content":
                        this._itemContentRender = this._itemContentRender || this.option("itemContentRender");
                        return this._itemContentRender;
                    default:
                        return this.callBase()
                }
            },
            _executeItemRenderAction: function(itemData, itemElement) {
                if (itemData.type)
                    return;
                this.callBase.apply(this, arguments)
            },
            _itemSelectHandler: function(e) {
                if ($(e.target).closest("." + ACCORDION_ITEM_BODY_CLASS).length)
                    return;
                this.callBase.apply(this, arguments)
            },
            _renderItemContent: function(index, itemData, $container) {
                $container = $container || this._itemContainer();
                var $itemContent = this.callBase.apply(this, [index, $.extend({
                            type: "content",
                            template: this.option("itemTemplate")
                        }, itemData), $container]);
                var $item = $itemContent.parent(),
                    $itemTitle = $("<div>").prependTo($item);
                this.callBase.apply(this, [index, $.extend({
                        type: "title",
                        template: this.option("itemTitleTemplate")
                    }, itemData), $itemTitle]);
                return $item
            },
            _addItemContentClasses: function($container, itemData) {
                switch (itemData.type) {
                    case"title":
                        $container.addClass(ACCORDION_ITEM_TITLE_CLASS).data(ACCORDION_ITEM_TITLE_DATA_KEY, itemData);
                        break;
                    case"content":
                        $container.addClass(ACCORDION_ITEM_BODY_CLASS).data(ACCORDION_ITEM_CONTENT_DATA_KEY, itemData);
                        break;
                    default:
                        this.callBase.apply(this, arguments)
                }
            },
            _attachItemTitleClickAction: function() {
                var itemSelector = "." + ACCORDION_ITEM_TITLE_CLASS,
                    eventName = events.addNamespace("dxclick", this.NAME);
                this._itemContainer().off(eventName, itemSelector).on(eventName, itemSelector, $.proxy(this._itemTitleClickHandler, this))
            },
            _itemTitleClickHandler: function(e) {
                this._itemJQueryEventHandler(e, "onItemTitleClick")
            },
            _renderSelection: function(addedSelection, removedSelection) {
                this._updateItems(addedSelection, removedSelection, true)
            },
            _updateSelection: function(addedSelection, removedSelection) {
                this._updateItems(addedSelection, removedSelection, false)
            },
            _updateItems: function(addedSelection, removedSelection, skipAnimation) {
                var $items = this._itemElements();
                $.each(addedSelection, function(_, index) {
                    $items.eq(index).addClass(ACCORDION_ITEM_OPENED_CLASS)
                });
                $.each(removedSelection, function(_, index) {
                    $items.eq(index).removeClass(ACCORDION_ITEM_OPENED_CLASS)
                });
                this._updateItemHeights(skipAnimation)
            },
            _updateItemHeights: function(skipAnimation) {
                var $items = this._itemElements();
                var itemHeight = this._splitFreeSpace(this._calculateFreeSpace());
                $.each($items, $.proxy(function(_, item) {
                    var $item = $(item),
                        $title = $item.children("." + ACCORDION_ITEM_TITLE_CLASS);
                    var startItemHeight = $item.outerHeight();
                    var finalItemHeight = $item.hasClass(ACCORDION_ITEM_OPENED_CLASS) ? itemHeight + $title.outerHeight() || $item.height("auto").outerHeight() : $title.outerHeight();
                    if (!skipAnimation)
                        this._animateItem($item, startItemHeight, finalItemHeight);
                    else
                        $item.css("height", finalItemHeight)
                }, this))
            },
            _animateItem: function(element, startHeight, endHeight) {
                DevExpress.fx.animate(element, {
                    type: "slide",
                    from: {height: startHeight},
                    to: {height: endHeight},
                    duration: this.option("animationDuration"),
                    complete: $.proxy(function() {
                        if (this._deferredAnimate)
                            this._deferredAnimate.resolveWith(this)
                    }, this)
                })
            },
            _splitFreeSpace: function(freeSpace) {
                if (!freeSpace)
                    return freeSpace;
                return freeSpace / this.option("selectedItems").length
            },
            _calculateFreeSpace: function() {
                var height = this.option("height");
                if (height === undefined || height === "auto")
                    return;
                var $titles = this._itemTitles(),
                    itemsHeight = 0;
                $.each($titles, function(_, title) {
                    itemsHeight += $(title).outerHeight()
                });
                return this.element().height() - itemsHeight
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._dimensionChanged()
            },
            _dimensionChanged: function() {
                this._updateItemHeights(true)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"animationDuration":
                    case"onItemTitleClick":
                        break;
                    case"collapsible":
                        this.option("selectionRequired", !this.option("collapsible"));
                        break;
                    case"itemTitleTemplate":
                    case"itemContentTemplate":
                    case"onItemTitleHold":
                    case"height":
                        this._invalidate();
                        break;
                    case"itemTitleRender":
                        this._itemTitleRender = null;
                        this._invalidate();
                        break;
                    case"itemContentRender":
                        this._itemContentRender = null;
                        this._invalidate();
                        break;
                    case"multiple":
                        this.option("selectionMode", args.value ? "multi" : "single");
                        break;
                    default:
                        this.callBase(args)
                }
            },
            expandItem: function(index) {
                this._deferredAnimate = $.Deferred();
                this.selectItem(index);
                return this._deferredAnimate.promise()
            },
            collapseItem: function(index) {
                this._deferredAnimate = $.Deferred();
                this.unselectItem(index);
                return this._deferredAnimate.promise()
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pager.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            Class = DX.Class;
        var PAGES_LIMITER = 4,
            PAGER_CLASS = 'dx-pager',
            PAGER_PAGE_CLASS = 'dx-page',
            PAGER_PAGES_CLASS = 'dx-pages',
            PAGER_SELECTION_CLASS = 'dx-selection',
            PAGER_PAGE_SEPARATOR_CLASS = 'dx-separator',
            PAGER_PAGE_SIZES_CLASS = 'dx-page-sizes',
            PAGER_PAGE_SIZE_CLASS = 'dx-page-size',
            PAGER_NAVIGATE_BUTTON = 'dx-navigate-button',
            PAGER_PREV_BUTTON_CLASS = "dx-prev-button",
            PAGER_NEXT_BUTTON_CLASS = "dx-next-button",
            PAGER_INFO_CLASS = "dx-info",
            PAGER_BUTTON_DISABLE_CLASS = "dx-button-disable";
        var Page = Class.inherit({
                ctor: function(value, index) {
                    var that = this;
                    that.index = index;
                    that._$page = $('<div />').text(value).addClass(PAGER_PAGE_CLASS)
                },
                value: function(value) {
                    var that = this;
                    if (utils.isDefined(value))
                        that._$page.text(value);
                    else {
                        var text = that._$page.text();
                        if (utils.isNumber(text))
                            return parseInt(text);
                        else
                            return text
                    }
                },
                select: function(value) {
                    this._$page.toggleClass(PAGER_SELECTION_CLASS, value)
                },
                render: function(rootElement, rtlEnabled) {
                    rtlEnabled ? this._$page.prependTo(rootElement) : this._$page.appendTo(rootElement)
                }
            });
        DX.registerComponent("dxPager", ui, DX.DOMComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    visible: true,
                    pageIndex: 1,
                    maxPagesCount: 10,
                    pageCount: 10,
                    pageSize: 5,
                    showPageSizes: true,
                    pageSizes: [5, 10],
                    hasKnownLastPage: true,
                    showNavigationButtons: false,
                    showInfo: false,
                    infoText: Globalize.localize("dxPager-infoText"),
                    rtlEnabled: false,
                    pageIndexChanged: $.noop,
                    pageSizeChanged: $.noop
                })
            },
            _toggleVisibility: function(value) {
                var $element = this.element();
                if ($element)
                    $element.css("display", value ? "" : "none")
            },
            _getPages: function(currentPage, count) {
                var pages = [],
                    showMoreButton = !this.option("hasKnownLastPage"),
                    firstValue,
                    i;
                this._testPagesCount = count;
                this._testShowMoreButton = showMoreButton;
                if (count > 0 || showMoreButton)
                    if (count <= this.option("maxPagesCount")) {
                        for (i = 1; i <= count; i++)
                            pages.push(new Page(i, i - 1));
                        if (showMoreButton)
                            pages.push(new Page('>', i - 1))
                    }
                    else {
                        pages.push(new Page(1, 0));
                        firstValue = currentPage ? currentPage.value() - currentPage.index : 1;
                        for (i = 1; i <= PAGES_LIMITER; i++)
                            pages.push(new Page(firstValue + i, i));
                        pages.push(new Page(count, PAGES_LIMITER + 1));
                        if (showMoreButton)
                            pages.push(new Page('>', PAGES_LIMITER + 1))
                    }
                return pages
            },
            _getPageByValue: function(value) {
                var that = this,
                    page,
                    i;
                for (i = 0; i < that._pages.length; i++) {
                    page = that._pages[i];
                    if (page.value() === value)
                        return page
                }
            },
            _processSelectedPage: function(maxPagesCount, pageIndex, pageCount) {
                var that = this,
                    isPageIndexValid = false,
                    selectedPageIndex;
                if (that._pages) {
                    $.each(that._pages, function(key, page) {
                        if (pageIndex === page.value())
                            isPageIndexValid = true
                    });
                    if (!isPageIndexValid)
                        that.selectedPage = null
                }
                if (utils.isDefined(that.selectedPage)) {
                    if (pageIndex === pageCount && pageCount > maxPagesCount && that.selectedPage.index !== PAGES_LIMITER + 1)
                        that.selectedPage.index = PAGES_LIMITER + 1
                }
                else if (pageIndex > PAGES_LIMITER && pageIndex < pageCount) {
                    selectedPageIndex = pageCount - PAGES_LIMITER < pageIndex ? PAGES_LIMITER - (pageCount - pageIndex) + 1 : 2;
                    that.selectedPage = new Page(pageIndex, selectedPageIndex)
                }
            },
            _selectPageByValue: function(value) {
                var that = this,
                    i,
                    page = that._getPageByValue(value),
                    pages = that._pages,
                    pagesLength = pages.length,
                    prevPage,
                    nextPage,
                    morePage;
                if (!utils.isDefined(page))
                    return;
                prevPage = that._pages[page.index - 1];
                nextPage = that._pages[page.index + 1];
                if (nextPage && nextPage.value() === '>') {
                    morePage = nextPage;
                    nextPage = undefined;
                    pagesLength--;
                    pages.pop()
                }
                if (that.selectedPage)
                    that.selectedPage.select(false);
                page.select(true);
                that.selectedPage = page;
                if (nextPage && nextPage.value() - value > 1)
                    if (page.index !== 0) {
                        prevPage.value(value + 1);
                        that._pages.splice(page.index, 1);
                        that._pages.splice(page.index - 1, 0, page);
                        that._pages[page.index].index = page.index;
                        page.index = page.index - 1;
                        for (i = page.index - 1; i > 0; i--)
                            that._pages[i].value(that._pages[i + 1].value() - 1)
                    }
                    else
                        for (i = 0; i < pagesLength - 1; i++)
                            that._pages[i].value(i + 1);
                if (prevPage && value - prevPage.value() > 1)
                    if (page.index !== pagesLength - 1) {
                        nextPage.value(value - 1);
                        that._pages.splice(page.index, 1);
                        that._pages.splice(page.index + 1, 0, page);
                        that._pages[page.index].index = page.index;
                        page.index = page.index + 1;
                        for (i = page.index + 1; i < pagesLength - 1; i++)
                            that._pages[i].value(that._pages[i - 1].value() + 1)
                    }
                    else
                        for (i = 1; i <= pagesLength - 2; i++)
                            that._pages[pagesLength - 1 - i].value(that._pages[pagesLength - 1].value() - i);
                if (morePage)
                    pages.push(morePage)
            },
            _nextPage: function(direction) {
                var pageIndex = this.selectedPage && this.selectedPage.value(),
                    pageCount = this.option("pageCount");
                if (utils.isDefined(pageIndex)) {
                    pageIndex = direction === "next" ? ++pageIndex : --pageIndex;
                    if (pageIndex > 0 && pageIndex <= pageCount)
                        this.option("pageIndex", pageIndex)
                }
            },
            _renderPages: function(pages) {
                var that = this,
                    $separator,
                    pageslength = pages.length,
                    clickPagesIndexAction = that._createAction(function(args) {
                        var e = args.jQueryEvent,
                            pageNumber = $(e.target).text(),
                            pageIndex = pageNumber === '>' ? that.option("pageCount") + 1 : Number(pageNumber);
                        that._testPageIndex = pageIndex;
                        that.option("pageIndex", pageIndex)
                    }),
                    page;
                if (pageslength > 1) {
                    that._pageClickHandler = function(e) {
                        clickPagesIndexAction({jQueryEvent: e})
                    };
                    that.$pagesChooser.on(events.addNamespace("dxclick", that.Name + "Pages"), '.' + PAGER_PAGE_CLASS, that._pageClickHandler)
                }
                for (var i = 0; i < pageslength; i++) {
                    page = pages[i];
                    page.render(that.$pagesChooser, that.option('rtlEnabled'));
                    if (pages[i + 1] && pages[i + 1].value() - page.value() > 1) {
                        $separator = $("<div>. . .</div>").addClass(PAGER_PAGE_SEPARATOR_CLASS);
                        that.option('rtlEnabled') ? $separator.prependTo(that.$pagesChooser) : $separator.appendTo(that.$pagesChooser)
                    }
                }
            },
            _renderPagesChooser: function() {
                var that = this,
                    $element = that.element();
                if (!$element)
                    return;
                if (that._pages.length === 0) {
                    that.selectedPage = null;
                    return
                }
                if (utils.isDefined(that.$pagesChooser))
                    that.$pagesChooser.empty();
                else
                    that.$pagesChooser = $('<div />').addClass(PAGER_PAGES_CLASS);
                that._renderInfo();
                that._renderNavigateButton("prev");
                that._renderPages(that._pages);
                that._renderNavigateButton("next");
                if (!utils.isDefined(that.$pagesChooser[0].parentElement))
                    that.$pagesChooser.appendTo($element)
            },
            _renderPagesSizeChooser: function() {
                var that = this,
                    i,
                    $pageSize,
                    currentPageSize = that.option("pageSize"),
                    pageSizes = that.option("pageSizes"),
                    showPageSizes = that.option("showPageSizes"),
                    pageSizeValue,
                    pagesSizesLength = pageSizes && pageSizes.length,
                    $element = that.element();
                if (!$element)
                    return;
                that._clickPagesSizeAction = that._createAction(function(args) {
                    var e = args.jQueryEvent;
                    pageSizeValue = parseInt($(e.target).text());
                    that._testPageSizeIndex = pageSizeValue;
                    that.option("pageSize", pageSizeValue)
                });
                if (utils.isDefined(that.pagesSizeChooserElement))
                    that.pagesSizeChooserElement.empty();
                else
                    that.pagesSizeChooserElement = $('<div />').addClass(PAGER_PAGE_SIZES_CLASS).on(events.addNamespace("dxclick", that.Name + "PageSize"), '.' + PAGER_PAGE_SIZE_CLASS, function(e) {
                        that._clickPagesSizeAction({jQueryEvent: e})
                    });
                if (!showPageSizes || !pagesSizesLength)
                    return;
                that._testCurrentPageSize = currentPageSize;
                for (i = 0; i < pagesSizesLength; i++) {
                    $pageSize = $('<div />').text(pageSizes[i]).addClass(PAGER_PAGE_SIZE_CLASS);
                    if (currentPageSize === pageSizes[i])
                        $pageSize.addClass(PAGER_SELECTION_CLASS);
                    that.option('rtlEnabled') ? that.pagesSizeChooserElement.prepend($pageSize) : that.pagesSizeChooserElement.append($pageSize)
                }
                if (!utils.isDefined(that.pagesSizeChooserElement[0].parentElement))
                    that.pagesSizeChooserElement.appendTo($element)
            },
            _renderInfo: function() {
                var infoText = this.option("infoText");
                if (this.option("showInfo") && utils.isDefined(infoText))
                    $("<div>").addClass(PAGER_INFO_CLASS).text(utils.stringFormat(infoText, this.selectedPage && this.selectedPage.value(), this.option("pageCount"))).appendTo(this.$pagesChooser)
            },
            _renderNavigateButton: function(direction) {
                var that = this,
                    currentPageIndex,
                    clickAction = that._createAction(function(e) {
                        that._nextPage(direction)
                    }),
                    $button,
                    enabled;
                if (that.option("showNavigationButtons")) {
                    currentPageIndex = that.option("pageIndex");
                    enabled = currentPageIndex > 1 && direction === "prev" || currentPageIndex < that.option("pageCount") && direction === "next";
                    $button = $("<div>").addClass(PAGER_NAVIGATE_BUTTON).addClass(!enabled ? PAGER_BUTTON_DISABLE_CLASS : "").on(events.addNamespace("dxclick", that.Name + "Pages"), function(e) {
                        clickAction({jQueryEvent: e})
                    });
                    if (that.option("rtlEnabled")) {
                        $button.addClass(direction === "prev" ? PAGER_NEXT_BUTTON_CLASS : PAGER_PREV_BUTTON_CLASS);
                        $button.prependTo(this.$pagesChooser)
                    }
                    else {
                        $button.addClass(direction === "prev" ? PAGER_PREV_BUTTON_CLASS : PAGER_NEXT_BUTTON_CLASS);
                        $button.appendTo(this.$pagesChooser)
                    }
                }
            },
            _render: function() {
                this._update();
                this.element().addClass(PAGER_CLASS);
                this._toggleVisibility(this.option("visible"));
                this._renderPagesSizeChooser();
                this._renderPagesChooser()
            },
            _update: function() {
                var pageCount = this.option("pageCount"),
                    pageIndex = this.option("pageIndex");
                this._processSelectedPage(this.option("maxPagesCount"), pageIndex, pageCount);
                this._pages = this._getPages(this.selectedPage, pageCount);
                this._selectPageByValue(pageIndex)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"visible":
                        this._toggleVisibility(args.value);
                        break;
                    case"pageIndex":
                        var pageIndexChanged = this.option("pageIndexChanged");
                        if (pageIndexChanged)
                            pageIndexChanged(args.value);
                    case"maxPagesCount":
                    case"pageCount":
                    case"hasKnownLastPage":
                    case"showNavigationButtons":
                        this._update();
                        this._renderPagesChooser();
                        break;
                    case"pageSize":
                        var pageSizeChanged = this.option("pageSizeChanged");
                        if (pageSizeChanged)
                            pageSizeChanged(args.value);
                    case"pageSizes":
                        this._renderPagesSizeChooser();
                        break;
                    default:
                        this._invalidate()
                }
            },
            _clean: function() {
                this.$pagesChooser && this.$pagesChooser.off(events.addNamespace("dxclick", this.Name + "Pages"), '.' + PAGER_PAGE_CLASS, this._pageClickHandler)
            },
            getHeight: function() {
                return this.option("visible") ? this.element().outerHeight() : 0
            }
        }));
        ui.dxPager.__internals = {
            PAGER_CLASS: PAGER_CLASS,
            PAGER_PAGE_CLASS: PAGER_PAGE_CLASS,
            PAGER_PAGES_CLASS: PAGER_PAGES_CLASS,
            PAGER_SELECTION_CLASS: PAGER_SELECTION_CLASS,
            PAGER_PAGE_SEPARATOR_CLASS: PAGER_PAGE_SEPARATOR_CLASS,
            PAGER_PAGE_SIZES_CLASS: PAGER_PAGE_SIZES_CLASS,
            PAGER_PAGE_SIZE_CLASS: PAGER_PAGE_SIZE_CLASS,
            PAGER_NAVIGATE_BUTTON: PAGER_NAVIGATE_BUTTON,
            PAGER_PREV_BUTTON_CLASS: PAGER_PREV_BUTTON_CLASS,
            PAGER_NEXT_BUTTON_CLASS: PAGER_NEXT_BUTTON_CLASS,
            PAGER_INFO_CLASS: PAGER_INFO_CLASS,
            PAGER_BUTTON_DISABLE_CLASS: PAGER_BUTTON_DISABLE_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.colorView.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            utils = DX.utils,
            translator = DX.translator;
        var COLOR_VIEW_CLASS = "dx-colorview",
            COLOR_VIEW_CONTAINER_CLASS = "dx-colorview-container",
            COLOR_VIEW_ROW_CLASS = "dx-colorview-container-row",
            COLOR_VIEW_CELL_CLASS = "dx-colorview-container-cell",
            COLOR_VIEW_PALETTE_CLASS = "dx-colorview-palette",
            COLOR_VIEW_PALETTE_CELL_CLASS = "dx-colorview-palette-cell",
            COLOR_VIEW_PALETTE_HANDLE_CLASS = "dx-colorview-palette-handle",
            COLOR_VIEW_PALETTE_GRADIENT_CLASS = "dx-colorview-palette-gradient",
            COLOR_VIEW_PALETTE_GRADIENT_WHITE_CLASS = "dx-colorview-palette-gradient-white",
            COLOR_VIEW_PALETTE_GRADIENT_BLACK_CLASS = "dx-colorview-palette-gradient-black",
            COLOR_VIEW_HUE_SCALE_CLASS = "dx-colorview-hue-scale",
            COLOR_VIEW_HUE_SCALE_CELL_CLASS = "dx-colorview-hue-scale-cell",
            COLOR_VIEW_HUE_SCALE_HANDLE_CLASS = "dx-colorview-hue-scale-handle",
            COLOR_VIEW_HUE_SCALE_WRAPPER_CLASS = "dx-colorview-hue-scale-wrapper",
            COLOR_VIEW_CONTROLS_CONTAINER_CLASS = "dx-colorview-controls-container",
            COLOR_VIEW_BUTTON_CLASS = "dx-colorview-button-cell",
            COLOR_VIEW_BUTTONS_CONTAINER_CLASS = "dx-colorview-buttons-container",
            COLOR_VIEW_APPLY_BUTTON_CLASS = "dx-colorview-apply-button",
            COLOR_VIEW_CANCEL_BUTTON_CLASS = "dx-colorview-cancel-button",
            COLOR_VIEW_LABEL_PREFIX = "dx-colorview-label",
            COLOR_VIEW_RED_LABEL_CLASS = "dx-colorview-label-red",
            COLOR_VIEW_GREEN_LABEL_CLASS = "dx-colorview-label-green",
            COLOR_VIEW_BLUE_LABEL_CLASS = "dx-colorview-label-blue",
            COLOR_VIEW_HEX_LABEL_CLASS = "dx-colorview-label-hex",
            COLOR_VIEW_ALPHA_CHANNEL_PREFIX = "dx-colorview-alpha-channel",
            COLOR_VIEW_ALPHA_CHANNEL_SCALE_CLASS = "dx-colorview-alpha-channel-scale",
            COLOR_VIEW_APLHA_CHANNEL_ROW_CLASS = "dx-colorview-alpha-channel-row",
            COLOR_VIEW_ALPHA_CHANNEL_SCALE_WRAPPER_CLASS = "dx-colorview-alpha-channel-wrapper",
            COLOR_VIEW_ALPHA_CHANNEL_LABEL_CLASS = "dx-colorview-alpha-channel-label",
            COLOR_VIEW_ALPHA_CHANNEL_HANDLE_CLASS = "dx-colorview-alpha-channel-handle",
            COLOR_VIEW_ALPHA_CHANNEL_CELL_CLASS = "dx-colorview-alpha-channel-cell",
            COLOR_VIEW_ALPHA_CHANNEL_BORDER_CLASS = "dx-colorview-alpha-channel-border",
            COLOR_VIEW_COLOR_PREVIEW = "dx-colorview-color-preview",
            COLOR_VIEW_COLOR_PREVIEW_CONTAINER_CLASS = "dx-colorview-color-preview-container",
            COLOR_VIEW_COLOR_PREVIEW_CONTAINER_INNER_CLASS = "dx-colorview-color-preview-container-inner",
            COLOR_VIEW_COLOR_PREVIEW_COLOR_CURRENT = "dx-colorview-color-preview-color-current",
            COLOR_VIEW_COLOR_PREVIEW_COLOR_NEW = "dx-colorview-color-preview-color-new";
        DX.registerComponent("dxColorView", ui, ui.Editor.inherit({
            _supportedKeys: function() {
                var that = this,
                    getHorizontalPaletteStep = function() {
                        var step = 100 / that._paletteWidth;
                        step = step > 1 ? step : 1;
                        return step
                    },
                    updateHorizontalPaletteValue = function(step) {
                        that._currentColor.hsv.s += step;
                        updatePaletteValue()
                    },
                    getVerticalPaletteStep = function() {
                        var step = 100 / that._paletteHeight;
                        step = step > 1 ? step : 1;
                        return step
                    },
                    updateVerticalPaletteValue = function(step) {
                        that._currentColor.hsv.v += step;
                        updatePaletteValue()
                    },
                    updatePaletteValue = function() {
                        that._placePaletteHandle();
                        var handleLocation = translator.locate(that._$paletteHandle);
                        that._updateColorFromHsv(that._currentColor.hsv.h, that._currentColor.hsv.s, that._currentColor.hsv.v)
                    },
                    getHueScaleStep = function() {
                        var step = 360 / (that._hueScaleWrapperHeight - that._hueScaleHandleHeight);
                        step = step > 1 ? step : 1;
                        return step
                    },
                    updateHueScaleValue = function(step) {
                        that._currentColor.hsv.h += step;
                        that._placeHueScaleHandle();
                        var handleLocation = translator.locate(that._$hueScaleHandle);
                        that._updateColorHue(handleLocation.top + that._hueScaleHandleHeight / 2)
                    },
                    getAlphaScaleStep = function() {
                        var step = 1 / that._alphaChannelScaleWorkWidth;
                        step = step > 0.01 ? step : 0.01;
                        return step
                    },
                    updateAlphaScaleValue = function(step) {
                        that._currentColor.a += step;
                        that._placeAlphaChannelHandle();
                        var handleLocation = translator.locate(that._$alphaChannelHandle);
                        that._calculateColorTransparenceByScaleWidth(handleLocation.left + that._alphaChannelHandleWidth / 2)
                    };
                return $.extend(this.callBase(), {
                        upArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (e.ctrlKey) {
                                if (this._currentColor.hsv.h <= 360 && !this._isTopColorHue)
                                    updateHueScaleValue(getHueScaleStep())
                            }
                            else if (this._currentColor.hsv.v < 100)
                                updateVerticalPaletteValue(getVerticalPaletteStep())
                        },
                        downArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (e.ctrlKey) {
                                if (this._currentColor.hsv.h >= 0) {
                                    if (this._isTopColorHue)
                                        this._currentColor.hsv.h = 360;
                                    updateHueScaleValue(-getHueScaleStep())
                                }
                            }
                            else if (this._currentColor.hsv.v > 0)
                                updateVerticalPaletteValue(-getVerticalPaletteStep())
                        },
                        rightArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (e.ctrlKey) {
                                if (this._currentColor.a > 0)
                                    updateAlphaScaleValue(-getAlphaScaleStep())
                            }
                            else if (this._currentColor.hsv.s < 100)
                                updateHorizontalPaletteValue(getHorizontalPaletteStep())
                        },
                        leftArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (e.ctrlKey) {
                                if (this._currentColor.a < 1)
                                    updateAlphaScaleValue(getAlphaScaleStep())
                            }
                            else if (this._currentColor.hsv.s > 0)
                                updateHorizontalPaletteValue(-getHorizontalPaletteStep())
                        },
                        enter: function(e) {
                            if (this.option("applyValueMode") == "useButtons")
                                this._applyColor()
                        }
                    })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    value: "#000000",
                    editAlphaChannel: false,
                    applyButtonText: Globalize.localize("OK"),
                    cancelButtonText: Globalize.localize("Cancel"),
                    applyValueMode: "useButtons",
                    onCancelButtonClick: null,
                    onApplyButtonClick: null
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }])
            },
            _init: function() {
                this.callBase();
                this._initColorAndOpacity()
            },
            _initColorAndOpacity: function() {
                this._setCurrentColor(this.option("value"))
            },
            _setCurrentColor: function(value) {
                var newColor = new DX.Color(value);
                if (!newColor.colorIsInvalid) {
                    if (!this._currentColor || this._makeRgba(this._currentColor) != this._makeRgba(newColor))
                        this._currentColor = newColor
                }
                else
                    this.option("value", this._currentColor.baseColor)
            },
            _render: function() {
                this.callBase();
                this.element().addClass(COLOR_VIEW_CLASS);
                this._renderColorPickerContainer()
            },
            _makeTransparentBackground: function($el, color) {
                if (!(color instanceof DX.Color))
                    color = new DX.Color(color);
                if (DX.browser.msie && DX.browser.version === "8.0")
                    $el.css({
                        background: color.toHex(),
                        filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=" + color.a * 100 + ")"
                    });
                else
                    $el.css("backgroundColor", this._makeRgba(color))
            },
            _makeRgba: function(color) {
                if (!(color instanceof DX.Color))
                    color = new DX.Color(color);
                return "rgba(" + [color.r, color.g, color.b, color.a].join(", ") + ")"
            },
            _renderValue: function(formattedValue) {
                this.callBase(this.option("editAlphaChannel") ? this._makeRgba(this._currentColor) : this.option("value"))
            },
            _renderColorPickerContainer: function() {
                var $parent = this.element();
                this._$colorPickerContainer = $("<div>", {
                    "class": COLOR_VIEW_CONTAINER_CLASS,
                    appendTo: $parent
                });
                this._renderHtmlRows();
                this._renderPalette();
                this._renderHueScale();
                this._renderControlsContainer();
                this._renderControls();
                this._renderAlphaChannelElements();
                if (this.option("applyValueMode") !== "instantly")
                    this._renderButtons()
            },
            _renderHtmlRows: function(updatedOption) {
                var $renderedRows = this._$colorPickerContainer.find("." + COLOR_VIEW_ROW_CLASS),
                    renderedRowsCount = $renderedRows.length,
                    rowCount = this._calculateRowsCount(),
                    delta = renderedRowsCount - rowCount;
                if (delta > 0) {
                    var index = this._calculateRemovedHtmlRowIndex(renderedRowsCount, updatedOption);
                    $renderedRows.eq(index).remove()
                }
                if (delta < 0) {
                    delta = Math.abs(delta);
                    var rows = [];
                    for (var i = 0; i < delta; i++)
                        rows.push($("<div>", {"class": COLOR_VIEW_ROW_CLASS}));
                    if (renderedRowsCount) {
                        var previousRowIndex = this._calculateHtmlRowIndex(renderedRowsCount, updatedOption);
                        $renderedRows.eq(previousRowIndex).after(rows)
                    }
                    else
                        this._$colorPickerContainer.append(rows)
                }
            },
            _renderHtmlCellInsideRow: function(rowSelector, $rowParent, additionalClass) {
                return $("<div>", {
                        "class": COLOR_VIEW_CELL_CLASS,
                        addClass: additionalClass,
                        appendTo: $rowParent.find("." + COLOR_VIEW_ROW_CLASS + rowSelector)
                    })
            },
            _calculateRowsCount: function() {
                if (this.option("editAlphaChannel"))
                    return this.option("applyValueMode") === "instantly" ? 2 : 3;
                return this.option("applyValueMode") === "instantly" ? 1 : 2
            },
            _calculateRemovedHtmlRowIndex: function(renderedRowsCount, updatedOption) {
                var index = -1;
                if (renderedRowsCount === 3) {
                    if (updatedOption === "editAlphaChannel")
                        index = -2;
                    if (updatedOption === "applyValueMode")
                        index = -1
                }
                return index
            },
            _calculateHtmlRowIndex: function(renderedRowsCount, updatedOption) {
                var index = 0;
                if (renderedRowsCount === 2)
                    if (updatedOption === "applyValueMode")
                        index = 1;
                return index
            },
            _renderPalette: function() {
                var $paletteCell = this._renderHtmlCellInsideRow(":first", this._$colorPickerContainer, COLOR_VIEW_PALETTE_CELL_CLASS),
                    $paletteGradientWhite = $("<div>", {"class": [COLOR_VIEW_PALETTE_GRADIENT_CLASS, COLOR_VIEW_PALETTE_GRADIENT_WHITE_CLASS].join(" ")}),
                    $paletteGradientBlack = $("<div>", {"class": [COLOR_VIEW_PALETTE_GRADIENT_CLASS, COLOR_VIEW_PALETTE_GRADIENT_BLACK_CLASS].join(" ")});
                this._$palette = $("<div>", {
                    "class": COLOR_VIEW_PALETTE_CLASS,
                    css: {backgroundColor: this._currentColor.getPureColor().toHex()},
                    appendTo: $paletteCell
                });
                this._paletteHeight = this._$palette.height();
                this._paletteWidth = this._$palette.width();
                this._renderPaletteHandle();
                this._$palette.append([$paletteGradientWhite, $paletteGradientBlack])
            },
            _renderPaletteHandle: function() {
                this._$paletteHandle = $("<div>", {
                    "class": COLOR_VIEW_PALETTE_HANDLE_CLASS,
                    appendTo: this._$palette
                }).dxDraggable({
                    area: this._$palette,
                    allowMoveByClick: true,
                    boundOffset: $.proxy(function() {
                        return -this._paletteHandleHeight / 2
                    }, this),
                    onDrag: $.proxy(function(e) {
                        var paletteHandlePosition = translator.locate(this._$paletteHandle);
                        this._updateByDrag = true;
                        this._updateColorFromHsv(this._currentColor.hsv.h, this._calculateColorSaturation(paletteHandlePosition), this._calculateColorValue(paletteHandlePosition))
                    }, this)
                });
                this._paletteHandleWidth = this._$paletteHandle.width();
                this._paletteHandleHeight = this._$paletteHandle.height();
                this._placePaletteHandle()
            },
            _placePaletteHandle: function() {
                translator.move(this._$paletteHandle, {
                    left: Math.round(this._paletteWidth * this._currentColor.hsv.s / 100 - this._paletteHandleWidth / 2),
                    top: Math.round(this._paletteHeight - this._paletteHeight * this._currentColor.hsv.v / 100 - this._paletteHandleHeight / 2)
                })
            },
            _calculateColorValue: function(paletteHandlePosition) {
                var value = Math.floor(paletteHandlePosition.top + this._paletteHandleHeight / 2);
                return 100 - Math.round(value * 100 / this._paletteHeight)
            },
            _calculateColorSaturation: function(paletteHandlePosition) {
                var saturation = Math.floor(paletteHandlePosition.left + this._paletteHandleWidth / 2);
                return Math.round(saturation * 100 / this._paletteWidth)
            },
            _updateColorFromHsv: function(hue, saturation, value) {
                var a = this._currentColor.a;
                this._currentColor = new DX.Color("hsv(" + [hue, saturation, value].join(",") + ")");
                this._currentColor.a = a;
                this._updateColorParamsAndColorPreview();
                if (this.option("applyValueMode") === "instantly")
                    this._applyColor()
            },
            _renderHueScale: function() {
                var $hueScaleCell = this._renderHtmlCellInsideRow(":first", this._$colorPickerContainer, COLOR_VIEW_HUE_SCALE_CELL_CLASS);
                this._$hueScaleWrapper = $("<div>", {
                    "class": COLOR_VIEW_HUE_SCALE_WRAPPER_CLASS,
                    appendTo: $hueScaleCell
                });
                this._$hueScale = $("<div>", {
                    "class": COLOR_VIEW_HUE_SCALE_CLASS,
                    appendTo: this._$hueScaleWrapper
                });
                this._hueScaleHeight = this._$hueScale.height();
                this._hueScaleWrapperHeight = this._$hueScaleWrapper.outerHeight();
                this._renderHueScaleHandle()
            },
            _renderHueScaleHandle: function() {
                this._$hueScaleHandle = $("<div>", {
                    "class": COLOR_VIEW_HUE_SCALE_HANDLE_CLASS,
                    appendTo: this._$hueScaleWrapper
                }).dxDraggable({
                    area: this._$hueScaleWrapper,
                    allowMoveByClick: true,
                    direction: "vertical",
                    onDrag: $.proxy(function(e) {
                        this._updateByDrag = true;
                        this._updateColorHue(translator.locate(this._$hueScaleHandle).top + this._hueScaleHandleHeight / 2)
                    }, this)
                });
                this._hueScaleHandleHeight = this._$hueScaleHandle.height();
                this._placeHueScaleHandle()
            },
            _placeHueScaleHandle: function() {
                var hueScaleHeight = this._hueScaleWrapperHeight,
                    handleHeight = this._hueScaleHandleHeight,
                    top = (hueScaleHeight - handleHeight) * (360 - this._currentColor.hsv.h) / 360;
                if (hueScaleHeight < top + handleHeight)
                    top = hueScaleHeight - handleHeight;
                if (top < 0)
                    top = 0;
                translator.move(this._$hueScaleHandle, {top: Math.round(top)})
            },
            _updateColorHue: function(handlePosition) {
                var hue = 360 - Math.round((handlePosition - this._hueScaleHandleHeight / 2) * 360 / (this._hueScaleWrapperHeight - this._hueScaleHandleHeight)),
                    saturation = this._currentColor.hsv.s,
                    value = this._currentColor.hsv.v;
                this._isTopColorHue = false;
                hue = hue < 0 ? 0 : hue;
                if (hue >= 360) {
                    this._isTopColorHue = true;
                    hue = 0
                }
                this._updateColorFromHsv(hue, saturation, value);
                this._$palette.css("backgroundColor", this._currentColor.getPureColor().toHex())
            },
            _renderControlsContainer: function() {
                var $controlsContainerCell = this._renderHtmlCellInsideRow(":first", this._$colorPickerContainer);
                this._$controlsContainer = $("<div>", {
                    "class": COLOR_VIEW_CONTROLS_CONTAINER_CLASS,
                    appendTo: $controlsContainerCell
                })
            },
            _renderControls: function() {
                this._renderColorsPreview();
                this._renderRgbInputs();
                this._renderHexInput()
            },
            _renderColorsPreview: function() {
                var $colorsPreviewContainer = $("<div>", {
                        "class": COLOR_VIEW_COLOR_PREVIEW_CONTAINER_CLASS,
                        appendTo: this._$controlsContainer
                    }),
                    $colorsPreviewContainerInner = $("<div>", {
                        "class": COLOR_VIEW_COLOR_PREVIEW_CONTAINER_INNER_CLASS,
                        appendTo: $colorsPreviewContainer
                    });
                this._$currentColor = $("<div>", {"class": [COLOR_VIEW_COLOR_PREVIEW, COLOR_VIEW_COLOR_PREVIEW_COLOR_CURRENT].join(" ")});
                this._$newColor = $("<div>", {"class": [COLOR_VIEW_COLOR_PREVIEW, COLOR_VIEW_COLOR_PREVIEW_COLOR_NEW].join(" ")});
                this._makeTransparentBackground(this._$currentColor, this._currentColor);
                this._makeTransparentBackground(this._$newColor, this._currentColor);
                $colorsPreviewContainerInner.append([this._$currentColor, this._$newColor])
            },
            _renderAlphaChannelElements: function() {
                if (this.option("editAlphaChannel")) {
                    this._$colorPickerContainer.find("." + COLOR_VIEW_ROW_CLASS).eq(1).addClass(COLOR_VIEW_APLHA_CHANNEL_ROW_CLASS);
                    this._renderAlphaChannelScale();
                    this._renderAlphaChannelInput()
                }
            },
            _renderRgbInputs: function() {
                this._rgbInputsWithLabels = [this._renderEditorWithLabel({
                        editorType: "dxNumberBox",
                        value: this._currentColor.r,
                        onValueChanged: $.proxy(this._updateColor, this, false),
                        labelText: "R",
                        labelClass: COLOR_VIEW_RED_LABEL_CLASS
                    }), this._renderEditorWithLabel({
                        editorType: "dxNumberBox",
                        value: this._currentColor.g,
                        onValueChanged: $.proxy(this._updateColor, this, false),
                        labelText: "G",
                        labelClass: COLOR_VIEW_GREEN_LABEL_CLASS
                    }), this._renderEditorWithLabel({
                        editorType: "dxNumberBox",
                        value: this._currentColor.b,
                        onValueChanged: $.proxy(this._updateColor, this, false),
                        labelText: "B",
                        labelClass: COLOR_VIEW_BLUE_LABEL_CLASS
                    })];
                this._$controlsContainer.append(this._rgbInputsWithLabels);
                this._rgbInputs = [this._rgbInputsWithLabels[0].find(".dx-numberbox").dxNumberBox("instance"), this._rgbInputsWithLabels[1].find(".dx-numberbox").dxNumberBox("instance"), this._rgbInputsWithLabels[2].find(".dx-numberbox").dxNumberBox("instance")]
            },
            _renderEditorWithLabel: function(options) {
                var $editor = $("<div>"),
                    $label = $("<label>", {
                        "class": options.labelClass,
                        text: options.labelText + ":",
                        append: $editor
                    }),
                    editorType = options.editorType,
                    editorOptions = {
                        value: options.value,
                        onValueChanged: options.onValueChanged
                    };
                if (editorType === "dxNumberBox") {
                    editorOptions.min = options.min || 0;
                    editorOptions.max = options.max || 255;
                    editorOptions.step = options.step || 1
                }
                $editor[editorType](editorOptions);
                return $label
            },
            _renderHexInput: function() {
                this._hexInput = this._renderEditorWithLabel({
                    editorType: "dxTextBox",
                    value: this._currentColor.toHex().replace("#", ""),
                    onValueChanged: $.proxy(this._updateColor, this, true),
                    labelClass: COLOR_VIEW_HEX_LABEL_CLASS,
                    labelText: "#"
                }).appendTo(this._$controlsContainer).find(".dx-textbox").dxTextBox("instance")
            },
            _renderAlphaChannelScale: function() {
                var $alphaChannelScaleCell = this._renderHtmlCellInsideRow(":eq(1)", this._$colorPickerContainer, COLOR_VIEW_ALPHA_CHANNEL_CELL_CLASS),
                    $alphaChannelBorder = $("<div>", {
                        "class": COLOR_VIEW_ALPHA_CHANNEL_BORDER_CLASS,
                        appendTo: $alphaChannelScaleCell
                    }),
                    $alphaChannelScaleWrapper = $("<div>", {
                        "class": COLOR_VIEW_ALPHA_CHANNEL_SCALE_WRAPPER_CLASS,
                        appendTo: $alphaChannelBorder
                    });
                this._$alphaChannelScale = $("<div>", {
                    "class": COLOR_VIEW_ALPHA_CHANNEL_SCALE_CLASS,
                    appendTo: $alphaChannelScaleWrapper
                });
                this._makeCSSLinearGradient(this._$alphaChannelScale);
                this._renderAlphaChannelHandle($alphaChannelScaleCell)
            },
            _makeCSSLinearGradient: function($el) {
                var color = this._currentColor,
                    colorAsRgb = [color.r, color.g, color.b].join(","),
                    colorAsHex = color.toHex().replace("#", "");
                var combineGradientString = function(colorAsRgb, colorAsHex) {
                        var rtlEnabled = this.option("rtlEnabled"),
                            startColor = "rgba(" + colorAsRgb + ", " + (rtlEnabled ? "1" : "0") + ")",
                            finishColor = "rgba(" + colorAsRgb + ", " + (rtlEnabled ? "0" : "1") + ")",
                            startColorIE = "'#" + (rtlEnabled ? "00" : "") + colorAsHex + "'",
                            finishColorIE = "'#" + (rtlEnabled ? "" : "00") + colorAsHex + "'";
                        return ["background-image: -webkit-linear-gradient(180deg, " + startColor + ", " + finishColor + ")", "background-image: -moz-linear-gradient(-90deg, " + startColor + ", " + finishColor + ")", "background-image: -ms-linear-gradient(-90deg, " + startColor + ", " + finishColor + ")", "background-image: -o-linear-gradient(-90deg, " + startColor + ", " + finishColor + ")", "background-image: linear-gradient(-90deg, " + startColor + ", " + finishColor + ")", "filter: progid:DXImageTransform.Microsoft.gradient(GradientType=1,startColorstr=" + startColorIE + ", endColorstr=" + finishColorIE + ")", "-ms-filter: progid:DXImageTransform.Microsoft.gradient(GradientType=1,startColorstr=" + startColorIE + ", endColorstr=" + finishColorIE + ")"].join(";")
                    };
                $el.attr("style", combineGradientString.call(this, colorAsRgb, colorAsHex))
            },
            _renderAlphaChannelInput: function() {
                var that = this,
                    $alphaChannelInputCell = this._renderHtmlCellInsideRow(":eq(1)", this._$colorPickerContainer);
                that._alphaChannelInput = this._renderEditorWithLabel({
                    editorType: "dxNumberBox",
                    value: this._currentColor.a,
                    max: 1,
                    step: 0.1,
                    onValueChanged: function(e) {
                        var value = e.value;
                        value = that._currentColor.isValidAlpha(value) ? value : that._currentColor.a;
                        that._updateColorTransparence(value);
                        that._placeAlphaChannelHandle()
                    },
                    labelClass: COLOR_VIEW_ALPHA_CHANNEL_LABEL_CLASS,
                    labelText: "Alpha"
                }).appendTo($alphaChannelInputCell).find(".dx-numberbox").dxNumberBox("instance")
            },
            _updateColorTransparence: function(transparence) {
                this._currentColor.a = transparence;
                this._makeTransparentBackground(this._$newColor, this._currentColor);
                if (this.option("applyValueMode") === "instantly")
                    this._applyColor()
            },
            _renderAlphaChannelHandle: function($parent) {
                this._$alphaChannelHandle = $("<div>", {
                    "class": COLOR_VIEW_ALPHA_CHANNEL_HANDLE_CLASS,
                    appendTo: $parent
                }).dxDraggable({
                    area: $parent,
                    allowMoveByClick: true,
                    direction: "horizontal",
                    onDrag: $.proxy(function(e) {
                        this._updateByDrag = true;
                        var $alphaChannelHandle = this._$alphaChannelHandle,
                            alphaChannelHandlePosition = translator.locate($alphaChannelHandle).left + this._alphaChannelHandleWidth / 2;
                        this._calculateColorTransparenceByScaleWidth(alphaChannelHandlePosition)
                    }, this)
                });
                this._alphaChannelHandleWidth = this._$alphaChannelHandle.width();
                this._alphaChannelScaleWorkWidth = $parent.width() - this._alphaChannelHandleWidth;
                this._placeAlphaChannelHandle()
            },
            _calculateColorTransparenceByScaleWidth: function(handlePosition) {
                var transparence = (handlePosition - this._alphaChannelHandleWidth / 2) / this._alphaChannelScaleWorkWidth,
                    rtlEnabled = this.option("rtlEnabled");
                transparence = rtlEnabled ? transparence : 1 - transparence;
                if (handlePosition >= this._alphaChannelScaleWorkWidth + this._alphaChannelHandleWidth / 2)
                    transparence = rtlEnabled ? 1 : 0;
                else if (transparence < 1)
                    transparence = transparence.toFixed(2);
                this._alphaChannelInput.option("value", transparence)
            },
            _placeAlphaChannelHandle: function() {
                var left = this._alphaChannelScaleWorkWidth * (1 - this._currentColor.a);
                if (left < 0)
                    left = 0;
                if (this._alphaChannelScaleWorkWidth < left)
                    left = this._alphaChannelScaleWorkWidth;
                translator.move(this._$alphaChannelHandle, {left: this.option("rtlEnabled") ? this._alphaChannelScaleWorkWidth - left : left})
            },
            _renderButtons: function() {
                if (this.option("applyValueMode") !== "instantly") {
                    var $buttonContainerCell = this._renderHtmlCellInsideRow(":last", this._$colorPickerContainer, COLOR_VIEW_BUTTON_CLASS);
                    this._$buttonContainer = $("<div>", {
                        "class": COLOR_VIEW_BUTTONS_CONTAINER_CLASS,
                        appendTo: $buttonContainerCell
                    });
                    this._renderApplyButton();
                    this._renderCancelButton()
                }
            },
            _renderApplyButton: function() {
                this._$applyButton = $("<div>", {
                    "class": COLOR_VIEW_APPLY_BUTTON_CLASS,
                    appendTo: this._$buttonContainer
                }).dxButton({
                    text: this.option("applyButtonText"),
                    onClick: $.proxy(this._applyColor, this)
                })
            },
            _applyColor: function() {
                var colorValue = this.option("editAlphaChannel") ? this._makeRgba(this._currentColor) : this._currentColor.toHex();
                this._makeTransparentBackground(this._$currentColor, this._currentColor);
                if ($.isFunction(this.option("onApplyButtonClick")))
                    this.option("onApplyButtonClick")();
                this.option("value", colorValue)
            },
            _renderCancelButton: function() {
                this._$cancelButton = $("<div>", {
                    "class": COLOR_VIEW_CANCEL_BUTTON_CLASS,
                    appendTo: this._$buttonContainer
                }).dxButton({
                    text: this.option("cancelButtonText"),
                    onClick: $.proxy(this._cancelChanges, this)
                })
            },
            _cancelChanges: function() {
                this._initColorAndOpacity();
                this._refreshMarkup();
                if ($.isFunction(this.option("onCancelButtonClick")))
                    this.option("onCancelButtonClick")()
            },
            _updateColor: function(isHex) {
                var rgba,
                    newColor;
                if (isHex)
                    newColor = this._validateHex("#" + this._hexInput.option("value"));
                else {
                    rgba = this._validateRgb();
                    if (this._alphaChannelInput) {
                        rgba.push(this._alphaChannelInput.option("value"));
                        newColor = "rgba(" + rgba.join(", ") + ")"
                    }
                    else
                        newColor = "rgb(" + rgba.join(", ") + ")"
                }
                if (!this._suppressEditorsValueUpdating) {
                    this._currentColor = new DX.Color(newColor);
                    this._refreshMarkup();
                    if (this.option("applyValueMode") === "instantly")
                        this._applyColor()
                }
            },
            _validateHex: function(hex) {
                return this._currentColor.isValidHex(hex) ? hex : this._currentColor.toHex()
            },
            _validateRgb: function() {
                var r = this._rgbInputs[0].option("value"),
                    g = this._rgbInputs[1].option("value"),
                    b = this._rgbInputs[2].option("value");
                if (!this._currentColor.isValidRGB(r, g, b)) {
                    r = this._currentColor.r;
                    g = this._currentColor.g;
                    b = this._currentColor.b
                }
                return [r, g, b]
            },
            _refreshMarkup: function() {
                this._placeHueScaleHandle();
                this._placePaletteHandle();
                this._updateColorParamsAndColorPreview();
                this._$palette.css("backgroundColor", this._currentColor.getPureColor().toHex());
                if (this._$alphaChannelHandle) {
                    this._updateColorTransparence(this._currentColor.a);
                    this._placeAlphaChannelHandle()
                }
            },
            _updateColorParamsAndColorPreview: function() {
                this._suppressEditorsValueUpdating = true;
                this._hexInput.option("value", this._currentColor.toHex().replace("#", ""));
                this._rgbInputs[0].option("value", this._currentColor.r);
                this._rgbInputs[1].option("value", this._currentColor.g);
                this._rgbInputs[2].option("value", this._currentColor.b);
                this._suppressEditorsValueUpdating = false;
                this._makeTransparentBackground(this._$newColor, this._currentColor);
                if (this.option("editAlphaChannel")) {
                    this._makeCSSLinearGradient.call(this, this._$alphaChannelScale);
                    this._alphaChannelInput.option("value", this._currentColor.a)
                }
            },
            _optionChanged: function(args) {
                var value = args.value;
                switch (args.name) {
                    case"value":
                        this._setCurrentColor(value);
                        if (!this._updateByDrag)
                            this._refreshMarkup();
                        this._updateByDrag = false;
                        this.callBase(args);
                        break;
                    case"applyButtonText":
                        if (this._$applyButton)
                            this._$applyButton.dxButton("option", "text", value);
                        break;
                    case"cancelButtonText":
                        if (this._$cancelButton)
                            this._$cancelButton.dxButton("option", "text", value);
                        break;
                    case"editAlphaChannel":
                        if (this._$colorPickerContainer) {
                            this._renderHtmlRows("editAlphaChannel");
                            this._renderAlphaChannelElements()
                        }
                        break;
                    case"applyValueMode":
                        if (this._$colorPickerContainer) {
                            this._renderHtmlRows("applyValueMode");
                            this._renderButtons()
                        }
                        break;
                    case"onCancelButtonClick":
                    case"onApplyButtonClick":
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.colorBox.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var COLOR_BOX_CLASS = "dx-colorbox",
            COLOR_BOX_INPUT_CLASS = COLOR_BOX_CLASS + "-input",
            COLOR_BOX_INPUT_CONTAINER_CLASS = COLOR_BOX_INPUT_CLASS + "-container",
            COLOR_BOX_COLOR_RESULT_PREVIEW_CLASS = COLOR_BOX_CLASS + "-color-result-preview",
            COLOR_BOX_OVERLAY_CLASS = COLOR_BOX_CLASS + "-overlay";
        var colorEditorPrototype = ui.dxColorView.prototype,
            colorUtils = {
                makeTransparentBackground: $.proxy(colorEditorPrototype._makeTransparentBackground, colorEditorPrototype),
                makeRgba: $.proxy(colorEditorPrototype._makeRgba, colorEditorPrototype)
            };
        DX.registerComponent("dxColorBox", ui, ui.dxDropDownEditor.inherit({
            _supportedKeys: function() {
                return $.extend(this.callBase(), {tab: function(e) {
                            if (this.option("opened") === true) {
                                e.preventDefault();
                                this._colorView._rgbInputs[0].focus()
                            }
                        }})
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    value: "#000000",
                    editAlphaChannel: false,
                    applyButtonText: Globalize.localize("OK"),
                    cancelButtonText: Globalize.localize("Cancel"),
                    applyValueMode: "useButtons",
                    onApplyButtonClick: null,
                    onCancelButtonClick: null
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }])
            },
            _popupConfig: function() {
                return $.extend(this.callBase(), {
                        height: "auto",
                        width: ""
                    })
            },
            _contentReadyHandler: function() {
                this._createColorView()
            },
            _createColorView: function() {
                var that = this,
                    $popupContent = this._popup.content();
                $popupContent.addClass(COLOR_BOX_OVERLAY_CLASS);
                this._colorView = $("<div />").appendTo($popupContent).dxColorView(this._colorViewConfig()).dxColorView("instance");
                this._colorView.element().on("focus", $.proxy(function() {
                    this.focus()
                }, this))
            },
            _colorViewConfig: function() {
                var that = this,
                    isAttachKeyboardEvent = that.option("focusStateEnabled") && !that.option("disabled");
                return {
                        value: that.option("value"),
                        editAlphaChannel: that.option("editAlphaChannel"),
                        applyValueMode: that.option("applyValueMode"),
                        applyButtonText: that.option("applyButtonText"),
                        onApplyButtonClick: that.option("onApplyButtonClick"),
                        cancelButtonText: that.option("cancelButtonText"),
                        rtlEnabled: that.option("rtlEnabled"),
                        focusStateEnabled: that.option("focusStateEnabled"),
                        onValueChanged: function(args) {
                            var value = args.value;
                            if (that.option("opened"))
                                that.option("value", value);
                            colorUtils.makeTransparentBackground(that._$colorResultPreview, value);
                            that._closePopup()
                        },
                        onCancelButtonClick: function() {
                            if ($.isFunction(that.option("onCancelButtonClick")))
                                that.option("onCancelButtonClick")();
                            that._closePopup()
                        },
                        _keyboardProcessor: isAttachKeyboardEvent ? that._keyboardProcessor.attachChildProcessor() : null
                    }
            },
            _attachKeyboardEvents: function() {
                this.callBase.apply(this, arguments);
                this._attachChildKeyboardEvents()
            },
            _attachChildKeyboardEvents: function() {
                var child = this._keyboardProcessor.attachChildProcessor();
                if (this._colorView) {
                    this._colorView.option("_keyboardProcessor", child);
                    return
                }
            },
            _closePopup: function() {
                if (this.option("applyValueMode") !== "instantly")
                    this.option("opened", false)
            },
            _init: function() {
                this.callBase()
            },
            _render: function() {
                this.callBase();
                this.element().addClass(COLOR_BOX_CLASS)
            },
            _renderInput: function() {
                this.callBase();
                this.element().wrapInner($("<div/>").addClass(COLOR_BOX_INPUT_CONTAINER_CLASS));
                this._$colorBoxInputContainer = this.element().children().eq(0);
                this._$colorResultPreview = $("<div>", {
                    "class": COLOR_BOX_COLOR_RESULT_PREVIEW_CLASS,
                    appendTo: this._$colorBoxInputContainer
                });
                colorUtils.makeTransparentBackground(this._$colorResultPreview, this.option("value"));
                this._input().addClass(COLOR_BOX_INPUT_CLASS)
            },
            _renderValue: function() {
                var value = this.option("value");
                this.callBase(this.option("editAlphaChannel") ? colorUtils.makeRgba(value) : value)
            },
            _valueChangeEventHandler: function(e) {
                var value = this._input().val(),
                    newColor = new DX.Color(value);
                if (newColor.colorIsInvalid) {
                    value = this.option("value");
                    this._input().val(value)
                }
                if (this._colorView) {
                    this._colorView._setCurrentColor(value);
                    this._colorView._refreshMarkup()
                }
                colorUtils.makeTransparentBackground(this._$colorResultPreview, value);
                this.callBase(e, value)
            },
            _optionChanged: function(args) {
                var value = args.value,
                    name = args.name;
                switch (name) {
                    case"value":
                        colorUtils.makeTransparentBackground(this._$colorResultPreview, value);
                        if (this._colorView)
                            this._colorView.option("value", value);
                        this.callBase(args);
                        break;
                    case"applyButtonText":
                    case"cancelButtonText":
                    case"editAlphaChannel":
                    case"applyValueMode":
                    case"onCancelButtonClick":
                    case"onApplyButtonClick":
                        if (this._colorView)
                            this._colorView.option(name, value);
                        break;
                    case"rtlEnabled":
                        if (this._colorView)
                            this._colorView.option(name, value);
                        this.callBase(args);
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }));
        DX.registerComponent("dxColorPicker", ui, ui.dxColorBox.inherit({ctor: function() {
                DX.log("W0000", this.NAME, "14.2", "Use 'dxColorBox' instead");
                this.callBase.apply(this, arguments)
            }}));
        ui.dxColorBox.__internals = {
            COLOR_BOX_CLASS: COLOR_BOX_CLASS,
            COLOR_BOX_INPUT_CLASS: COLOR_BOX_INPUT_CLASS,
            COLOR_BOX_INPUT_CONTAINER_CLASS: COLOR_BOX_INPUT_CONTAINER_CLASS,
            COLOR_BOX_COLOR_RESULT_PREVIEW_CLASS: COLOR_BOX_COLOR_RESULT_PREVIEW_CLASS,
            COLOR_BOX_OVERLAY_CLASS: COLOR_BOX_OVERLAY_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.menuBase.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events;
        var DX_MENU_CLASS = 'dx-menu',
            DX_MENU_BASE_CLASS = 'dx-menu-base',
            DX_MENU_ITEM_CLASS = DX_MENU_CLASS + '-item',
            DX_MENU_SELECTED_ITEM_CLASS = DX_MENU_ITEM_CLASS + '-selected',
            DX_MENU_ITEM_WRAPPER_CLASS = DX_MENU_ITEM_CLASS + '-wrapper',
            DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + '-items-container',
            DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + '-expanded',
            DX_MENU_SEPARATOR_CLASS = DX_MENU_CLASS + '-separator',
            DX_STATE_DISABLED_CLASS = "dx-state-disabled",
            DX_MENU_ITEM_CLASS_SELECTOR = '.' + DX_MENU_ITEM_CLASS,
            DX_ITEM_SELECTED_SELECTOR = '.' + DX_MENU_SELECTED_ITEM_CLASS,
            SINGLE_SELECTION_MODE = 'single',
            NONE_SELECTION_MODE = 'none',
            FIRST_SUBMENU_LEVEL = 1;
        var dxMenuBase = ui.CollectionWidget.inherit({
                NAME: "dxMenuBase",
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        items: [],
                        cssClass: '',
                        activeStateEnabled: true,
                        showSubmenuMode: 'auto',
                        animation: {
                            show: {
                                type: "fade",
                                from: 0,
                                to: 1,
                                duration: 100
                            },
                            hide: {
                                type: 'fade',
                                from: 1,
                                to: 0,
                                duration: 100
                            }
                        },
                        selectionByClick: false,
                        selectionMode: 'none',
                        _remoteSelectionSync: false
                    })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return DX.devices.real().generic && !DX.devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }])
                },
                _activeStateUnit: DX_MENU_ITEM_CLASS_SELECTOR,
                _itemDataKey: function() {
                    return 'dxMenuItemDataKey'
                },
                _itemClass: function() {
                    return DX_MENU_ITEM_CLASS
                },
                _selectedItemClass: function() {
                    return DX_MENU_SELECTED_ITEM_CLASS
                },
                _focusTarget: function() {
                    return this._itemContainer()
                },
                _eventBindingTarget: function() {
                    return this._itemContainer()
                },
                _supportedKeys: function() {
                    var selectItem = function(e) {
                            var $item = this._$focusedItem;
                            if (!$item || !this._isSelectionEnabled())
                                return;
                            this.selectItem($item)
                        };
                    return $.extend(this.callBase(), {
                            space: selectItem,
                            pageUp: $.noop,
                            pageDown: $.noop
                        })
                },
                _isSelectionEnabled: function() {
                    return this._getSelectionMode() === SINGLE_SELECTION_MODE
                },
                _getSelectionMode: function() {
                    return this.option('selectionMode') === SINGLE_SELECTION_MODE ? SINGLE_SELECTION_MODE : NONE_SELECTION_MODE
                },
                _init: function() {
                    this.callBase();
                    this._initActions()
                },
                _initActions: $.noop,
                _render: function() {
                    var $element = this.element(),
                        isDesktopDevice = DX.devices.real().deviceType === "desktop";
                    this.callBase(arguments);
                    this._addCustomCssClass($element);
                    this._itemContainer().addClass(DX_MENU_BASE_CLASS);
                    isDesktopDevice && this._attachItemMouseEvents()
                },
                _getShowSubmenuMode: function() {
                    var isDesktop = DX.devices.real().deviceType === "desktop";
                    return isDesktop ? this.option("showSubmenuMode") : "onClick"
                },
                _initEditStrategy: function() {
                    var strategy = ui.CollectionWidget.MenuBaseEditStrategy;
                    this._editStrategy = new strategy(this)
                },
                _addCustomCssClass: function($element) {
                    $element.addClass(this.option('cssClass'))
                },
                _attachItemMouseEvents: function() {
                    var itemSelector = this._itemWrapperSelector(),
                        mouseEnterEventName = events.addNamespace('mouseenter', this.NAME),
                        mouseLeaveEventName = events.addNamespace('mouseleave', this.NAME),
                        itemMouseEnterAction = this._createAction($.proxy(function(e) {
                            this._itemMouseEnterHandler(e.jQueryEvent)
                        }, this)),
                        itemMouseLeaveAction = this._createAction($.proxy(function(e) {
                            this._itemMouseLeaveHandler(e.jQueryEvent)
                        }, this));
                    this._itemContainer().off(mouseEnterEventName, itemSelector).on(mouseEnterEventName, itemSelector, $.proxy(function(e) {
                        itemMouseEnterAction({jQueryEvent: e})
                    }, this));
                    this._itemContainer().off(mouseLeaveEventName, itemSelector).on(mouseLeaveEventName, itemSelector, $.proxy(function(e) {
                        itemMouseLeaveAction({jQueryEvent: e})
                    }, this))
                },
                _itemWrapperSelector: function() {
                    return '.' + DX_MENU_ITEM_WRAPPER_CLASS
                },
                _itemMouseEnterHandler: function(e) {
                    var showSubmenuMode = this._getShowSubmenuMode(),
                        $itemElement = this._getItemElementByEventArgs(e),
                        isItemDisabled = $itemElement.hasClass(DX_STATE_DISABLED_CLASS);
                    !isItemDisabled ? this._resetFocusedItem($itemElement) : this._removeFocusedItem();
                    if (showSubmenuMode === 'onHover')
                        this._showSubmenu($itemElement);
                    else if (showSubmenuMode === 'onHoverStay')
                        setTimeout($.proxy(this._showSubmenu, this), 300, $itemElement)
                },
                _showSubmenu: function($itemElement) {
                    $itemElement.addClass(DX_MENU_ITEM_EXPANDED_CLASS)
                },
                _getItemElementByEventArgs: function(eventArgs) {
                    return $(eventArgs.currentTarget).children(this._itemSelector()).first()
                },
                _itemMouseLeaveHandler: $.noop,
                _hasSubmenu: function(item) {
                    return item.items && item.items.length > 0
                },
                _renderItems: function(items, submenuLevel, submenuContainer) {
                    var that = this,
                        $itemsContainer,
                        submenuLevel = submenuLevel || FIRST_SUBMENU_LEVEL;
                    if (items.length) {
                        $itemsContainer = this._renderContainer(submenuLevel, submenuContainer);
                        $.each(items, function(index, item) {
                            that._renderItem(index, item, $itemsContainer, submenuLevel)
                        })
                    }
                    this._setSelectionFromItems()
                },
                _renderContainer: function(submenuLevel, smContainer) {
                    var $container = this._createItemsContainer();
                    $container.addClass(DX_MENU_ITEMS_CONTAINER_CLASS);
                    return $container
                },
                _createItemsContainer: function() {
                    var $rootGroup = $('<div>').appendTo(this.element());
                    return $('<ul>').appendTo($rootGroup)
                },
                _renderItem: function(index, item, $itemsContainer, submenuLevel) {
                    var that = this,
                        $itemWrapper = $('<li>'),
                        $item;
                    that._renderSeparator(item, index, $itemsContainer);
                    $itemWrapper.appendTo($itemsContainer).addClass(DX_MENU_ITEM_WRAPPER_CLASS);
                    if (!utils.isObject(item))
                        item = {text: item};
                    if (!utils.isDefined(item.selected))
                        item.selected = false;
                    $item = that.callBase(index, item, $itemWrapper);
                    that._renderSubmenuItems(item, $item, submenuLevel)
                },
                _setSelectionFromItems: function() {
                    var selectedIndex = this.option('selectedIndex'),
                        searchSelectedFromItems = !selectedIndex || selectedIndex === -1;
                    if (this.option('_remoteSelectionSync') || !searchSelectedFromItems)
                        return;
                    $.each(this._editStrategy._getPlainItems(), function(index, item) {
                        if (item.selected && item.selectable !== false)
                            selectedIndex = index
                    });
                    selectedIndex && this.option("selectedIndex", selectedIndex)
                },
                _renderSeparator: function(item, index, $itemsContainer) {
                    if (item.beginGroup && index > 0)
                        $('<li>').appendTo($itemsContainer).addClass(DX_MENU_SEPARATOR_CLASS)
                },
                _renderSubmenuItems: $.noop,
                _itemClickHandler: function(e) {
                    var itemClickActionHandler = this._createAction($.proxy(this._updateOverlayVisibilityOnClick, this));
                    this._itemJQueryEventHandler(e, "onItemClick", {}, {afterExecute: $.proxy(itemClickActionHandler, this)})
                },
                _updateOverlayVisibilityOnClick: function(actionArgs) {
                    this._updateSelectedItemOnClick(actionArgs);
                    if (this._getShowSubmenuMode() === 'onClick')
                        this._showSubmenu(actionArgs.args[0].itemElement)
                },
                _updateSelectedItemOnClick: function(actionArgs) {
                    var args = actionArgs.args ? actionArgs.args[0] : actionArgs,
                        isSelectionByClickEnabled = this._isSelectionEnabled() && this.option('selectionByClick'),
                        $selectedItem,
                        selectedItemData;
                    if (isSelectionByClickEnabled && args.itemData.selectable !== false && !this._hasSubmenu(args.itemData)) {
                        $selectedItem = this._itemContainer().find(DX_ITEM_SELECTED_SELECTOR);
                        if ($selectedItem.length) {
                            selectedItemData = this._getItemData($selectedItem);
                            $selectedItem.removeClass(DX_MENU_SELECTED_ITEM_CLASS);
                            if (selectedItemData)
                                selectedItemData.selected = false
                        }
                        args.itemData.selected = true;
                        this.option('selectedItems', [args.itemData])
                    }
                },
                _syncSelectionOptions: function(byOption) {
                    var items = this._editStrategy._getPlainItems() || [],
                        selectedItems = this.option("selectedItems") || [],
                        selectedItem = this.option("selectedItem"),
                        selectedIndex = this.option("selectedIndex");
                    byOption = byOption || this._chooseSelectOption();
                    switch (byOption) {
                        case"selectedItems":
                            this._setOptionSilent("selectedItem", selectedItems[0]);
                            this._setOptionSilent("selectedIndex", $.inArray(selectedItems[0], items));
                            break;
                        case"selectedItem":
                            if (utils.isDefined(selectedItem)) {
                                this._setOptionSilent("selectedItems", [selectedItem]);
                                this._setOptionSilent("selectedIndex", $.inArray(selectedItem, items))
                            }
                            else {
                                this._setOptionSilent("selectedItems", []);
                                this._setOptionSilent("selectedIndex", -1)
                            }
                            break;
                        case"selectedIndex":
                            if (utils.isDefined(items[selectedIndex])) {
                                this._setOptionSilent("selectedItems", [items[selectedIndex]]);
                                this._setOptionSilent("selectedItem", items[selectedIndex])
                            }
                            else {
                                this._setOptionSilent("selectedItems", []);
                                this._setOptionSilent("selectedItem", null)
                            }
                            break
                    }
                },
                _getStringifiedArray: function(array) {
                    return $.map(array, function(item) {
                            return JSON.stringify(item)
                        })
                },
                _isOwnItem: function(item) {
                    var plainItems = this._editStrategy._getPlainItems();
                    return $.inArray(JSON.stringify(item), this._getStringifiedArray(plainItems)) >= 0
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case'visible':
                            this._toggleVisibility(args.value);
                            break;
                        case"_remoteSelectionSync":
                        case"showSubmenuMode":
                        case"cssClass":
                        case"position":
                        case"selectionByClick":
                        case"animation":
                            this._invalidate();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                selectItem: function(itemElement) {
                    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
                    if (itemIndex === -1)
                        return;
                    var itemSelectionIndex = $.inArray(itemIndex, this._selectedItemIndices);
                    if (itemSelectionIndex !== -1)
                        return;
                    if (this.option("selectionMode") === "single") {
                        var items = this._editStrategy.fetchSelectedItems([itemIndex]);
                        items[0].selected = true;
                        this.option("selectedItems", items)
                    }
                },
                unselectItem: function(itemElement) {
                    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
                    if (itemIndex === -1)
                        return;
                    var itemSelectionIndex = $.inArray(itemIndex, this._selectedItemIndices);
                    if (itemSelectionIndex === -1)
                        return;
                    var items = this._editStrategy.fetchSelectedItems([itemSelectionIndex]);
                    items[0].selected = false;
                    this.option("selectedItems", [])
                }
            });
        ui.dxMenuBase = dxMenuBase
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.menuBase.edit.strategy.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        ui.CollectionWidget.MenuBaseEditStrategy = ui.CollectionWidget.PlainEditStrategy.inherit({
            _getPlainItems: function() {
                return $.map(this._collectionWidget.option("items"), function getMenuItems(item) {
                        return item.items ? [item].concat($.map(item.items, getMenuItems)) : item
                    })
            },
            _getStringifiedArray: function(array) {
                return $.map(array, function(item) {
                        return JSON.stringify(item)
                    })
            },
            selectedItemIndices: function() {
                var selectedIndices = [],
                    items = this._getStringifiedArray(this._getPlainItems()),
                    selectedItems = this._collectionWidget.option("selectedItems");
                $.each(selectedItems, function(_, selectedItem) {
                    var index = $.inArray(JSON.stringify(selectedItem), items);
                    if (index !== -1)
                        selectedIndices.push(index);
                    else
                        DX.log("W1002", selectedItem)
                });
                return selectedIndices
            },
            fetchSelectedItems: function(indices) {
                indices = indices || this._collectionWidget._selectedItemIndices;
                var items = this._getPlainItems(),
                    selectedItems = [];
                $.each(indices, function(_, index) {
                    selectedItems.push(items[index])
                });
                return selectedItems
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.contextMenu.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            fx = DX.fx;
        var DX_MENU_CLASS = 'dx-menu',
            DX_MENU_ITEM_CLASS = DX_MENU_CLASS + '-item',
            DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + '-expanded',
            DX_MENU_PHONE_CLASS = 'dx-menu-phone-overlay',
            DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + '-items-container',
            DX_MENU_ITEM_WRAPPER_CLASS = DX_MENU_ITEM_CLASS + '-wrapper',
            DX_SUBMENU_CLASS = 'dx-submenu',
            DX_CONTEXT_MENU_CLASS = 'dx-context-menu',
            DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS = DX_CONTEXT_MENU_CLASS + '-content-delimiter',
            DX_HAS_CONTEXT_MENU_CLASS = 'dx-has-context-menu',
            DX_SUBMENU_LEVEL_ID = 'dxSubmenuLevel',
            FOCUS_UP = "up",
            FOCUS_DOWN = "down",
            FOCUS_LEFT = "left",
            FOCUS_RIGHT = "right",
            FOCUS_FIRST = "first",
            FOCUS_LAST = "last",
            ACTIONS = ["onShowing", "onShown", "onHiding", "onHidden", "onPositioning", "onLeftFirstItem", "onLeftLastItem", "onCloseRootSubmenu", "onExpandLastSubmenu"],
            LOCAL_SUBMENU_DIRECTIONS = [FOCUS_UP, FOCUS_DOWN, FOCUS_FIRST, FOCUS_LAST];
        DX.registerComponent("dxContextMenu", ui, ui.dxMenuBase.inherit({
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    direction: {
                        since: "14.1",
                        alias: "submenuDirection"
                    },
                    allowSelectItem: {
                        since: "14.1",
                        alias: "allowSelection"
                    },
                    showingAction: {
                        since: "14.1",
                        alias: "onShowing"
                    },
                    shownAction: {
                        since: "14.1",
                        alias: "onShown"
                    },
                    hiddenAction: {
                        since: "14.1",
                        alias: "onHidden"
                    },
                    hidingAction: {
                        since: "14.1",
                        alias: "onHiding"
                    },
                    positioningAction: {
                        since: "14.1",
                        alias: "onPositioning"
                    }
                })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    showSubmenuMode: 'onHover',
                    invokeOnlyFromCode: false,
                    position: {
                        at: 'top left',
                        my: 'top left'
                    },
                    onShowing: null,
                    onShown: null,
                    onHiding: null,
                    onHidden: null,
                    onPositioning: null,
                    submenuDirection: 'auto',
                    visible: false,
                    target: window,
                    onLeftFirstItem: null,
                    onLeftLastItem: null,
                    onCloseRootSubmenu: null,
                    onExpandLastSubmenu: null
                })
            },
            _initActions: function() {
                this._actions = {};
                $.each(ACTIONS, $.proxy(function(index, action) {
                    this._actions[action] = this._createActionByOption(action) || $.noop
                }, this))
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {
                    animation: true,
                    position: true,
                    selectedItem: true
                })
            },
            _itemContainer: function() {
                return this._overlay.content()
            },
            _supportedKeys: function() {
                return $.extend(this.callBase(), {esc: this.hide})
            },
            _moveFocus: function(location) {
                var $items = this._getItemsByLocation(location),
                    $oldTarget = this._getActiveItem(true),
                    $newTarget;
                switch (location) {
                    case FOCUS_UP:
                        $newTarget = this._prevItem($items);
                        if ($oldTarget.is($items.first()))
                            this._actions.onLeftFirstItem($oldTarget);
                        break;
                    case FOCUS_DOWN:
                        $newTarget = this._nextItem($items);
                        if ($oldTarget.is($items.last()))
                            this._actions.onLeftLastItem($oldTarget);
                        break;
                    case FOCUS_RIGHT:
                        $newTarget = this.option("rtlEnabled") ? this._hideSubmenuHandler($items) : this._expandSubmenuHandler($items);
                        break;
                    case FOCUS_LEFT:
                        $newTarget = this.option("rtlEnabled") ? this._expandSubmenuHandler($items) : this._hideSubmenuHandler($items);
                        break;
                    case FOCUS_FIRST:
                        $newTarget = $items.first();
                        break;
                    case FOCUS_LAST:
                        $newTarget = $items.last();
                        break;
                    default:
                        return this.callBase(location)
                }
                this._resetFocusedItem($newTarget)
            },
            _getItemsByLocation: function(location) {
                var $items,
                    $activeItem = this._getActiveItem(true),
                    expandedLocation = this.option("rtlEnabled") ? FOCUS_LEFT : FOCUS_RIGHT;
                if ($.inArray(location, LOCAL_SUBMENU_DIRECTIONS) >= 0)
                    $items = $activeItem.closest('.' + DX_MENU_ITEMS_CONTAINER_CLASS).children().children();
                else {
                    $items = this._itemElements();
                    if (location !== expandedLocation)
                        $items = $items.filter(":visible")
                }
                return $items
            },
            _hideSubmenuHandler: function($items) {
                var $curItem = this._getActiveItem(true),
                    $parentItem = $curItem.parents("." + DX_MENU_ITEM_EXPANDED_CLASS).first();
                if ($parentItem.length) {
                    this._hideSubmenusOnSameLevel($parentItem);
                    return $parentItem
                }
                this._actions.onCloseRootSubmenu($curItem);
                return $curItem
            },
            _expandSubmenuHandler: function($items) {
                var $curItem = this._getActiveItem(true),
                    $submenu = $curItem.children('.' + DX_SUBMENU_CLASS);
                if ($submenu.length) {
                    if (!$submenu.is(":visible"))
                        this._showSubmenu($curItem);
                    return this._nextItem($items)
                }
                this._actions.onExpandLastSubmenu($curItem);
                return $curItem
            },
            _render: function() {
                this._target = $(this.option('target'));
                this.element().addClass(DX_HAS_CONTEXT_MENU_CLASS);
                this.callBase()
            },
            _renderContentImpl: function() {
                this._renderContextMenuOverlay();
                this._renderAdditionGraphicsElements();
                this._attachShowContextMenuEvents();
                this.callBase()
            },
            _renderContextMenuOverlay: function() {
                var overlayOptions = this._getOverlayOptions(),
                    $overlayElement = $('<div>'),
                    $overlayContent;
                $overlayElement.appendTo(this._$element).dxOverlay(overlayOptions);
                this._overlay = $overlayElement.dxOverlay('instance');
                $overlayContent = this._overlay.content();
                $overlayContent.addClass(DX_CONTEXT_MENU_CLASS);
                this._addCustomCssClass($overlayContent);
                this._addPlatformDependentClass($overlayContent);
                if (this.option('visible'))
                    this.show()
            },
            _addPlatformDependentClass: function($element) {
                if (DX.devices.current().phone)
                    $element.addClass(DX_MENU_PHONE_CLASS)
            },
            _renderAdditionGraphicsElements: function() {
                if (this.option('showAdditionalElements')) {
                    this.$contentDelimiter = $('<div>');
                    this.$contentDelimiter.appendTo(this._itemContainer()).addClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS).css({
                        position: 'absolute',
                        display: 'none',
                        'z-index': '2000'
                    })
                }
            },
            _attachShowContextMenuEvents: function() {
                var that = this,
                    holdEventName = events.addNamespace('dxhold', this.NAME),
                    rightClickEventName = events.addNamespace('contextmenu', this.NAME),
                    holdAction = this._createAction($.proxy(function(e) {
                        if (!that.option('invokeOnlyFromCode'))
                            !events.isMouseEvent(e.jQueryEvent) && that.show(e.jQueryEvent)
                    }, this)),
                    contextMenuAction = this._createAction($.proxy(function(e) {
                        if (!that.option('invokeOnlyFromCode'))
                            if (that.show(e.jQueryEvent)) {
                                e.jQueryEvent.preventDefault();
                                if (e.jQueryEvent.originalEvent)
                                    e.jQueryEvent.originalEvent.returnValue = false
                            }
                    }, this));
                this._target.off(holdEventName).on(holdEventName, $.proxy(function(e) {
                    holdAction({jQueryEvent: e})
                }, this));
                this._target.off(rightClickEventName).on(rightClickEventName, $.proxy(function(e) {
                    contextMenuAction({jQueryEvent: e})
                }, this))
            },
            _renderDimensions: $.noop,
            _renderContainer: function(submenuLevel, submenuContainer) {
                var $submenu = $('<div>'),
                    $itemsContainer = $('<ul>'),
                    $holder = submenuLevel === 1 ? this._itemContainer() : submenuContainer;
                $submenu.appendTo($holder).addClass(DX_SUBMENU_CLASS).data(DX_SUBMENU_LEVEL_ID, submenuLevel).css('display', submenuLevel === 1 ? 'block' : 'none');
                $itemsContainer.appendTo($submenu).addClass(DX_MENU_ITEMS_CONTAINER_CLASS);
                if (submenuLevel === 1) {
                    if (this.option('width'))
                        $itemsContainer.css('min-width', this.option('width'));
                    if (this.option('height'))
                        $itemsContainer.css('min-height', this.option('height'))
                }
                return $itemsContainer
            },
            _renderSubmenuItems: function(item, $item, submenuLevel) {
                if (this._hasSubmenu(item))
                    this._renderItems(item.items, ++submenuLevel, $item)
            },
            _getOverlayOptions: function() {
                var that = this,
                    position = that.option('position'),
                    overlayAnimation = that.option('animation'),
                    overlayOptions = {
                        focusStateEnabled: that.option('focusStateEnabled'),
                        animation: overlayAnimation,
                        closeOnOutsideClick: $.proxy(that._closeOnOutsideClickHandler, that),
                        closeOnTargetScroll: true,
                        deferRendering: false,
                        disabled: that.option('disabled'),
                        position: {
                            at: position.at,
                            my: position.my,
                            of: that._target
                        },
                        shading: false,
                        showTitle: false,
                        height: 'auto',
                        width: 'auto',
                        rtlEnabled: that.option('rtlEnabled'),
                        onShowing: $.proxy(that._overlayShowingActionHandler, that),
                        onShown: $.proxy(that._overlayShownActionHandler, that),
                        onHiding: $.proxy(that._overlayHidingActionHandler, that),
                        onHidden: $.proxy(that._overlayHiddenActionHandler, that),
                        onPositioned: $.proxy(that._overlayPositionedActionHandler, that)
                    };
                return overlayOptions
            },
            _overlayShowingActionHandler: function(arg) {
                this._actions.onShowing(arg)
            },
            _overlayShownActionHandler: function(arg) {
                this._actions.onShown(arg)
            },
            _overlayHidingActionHandler: function(arg) {
                this._actions.onHiding(arg);
                this._hideAllShownSubmenus()
            },
            _overlayHiddenActionHandler: function(arg) {
                this._actions.onHidden(arg);
                this._setOptionSilent('visible', false)
            },
            _overlayPositionedActionHandler: function() {
                this._showAdditionalGraphicsElements()
            },
            _closeOnOutsideClickHandler: function(e) {
                var $clickedItem,
                    $clickedOverlay,
                    $allOverlays;
                if (e.target === document)
                    return true;
                $clickedOverlay = $(e.target).closest('.' + DX_MENU_ITEMS_CONTAINER_CLASS);
                $allOverlays = this._overlay._$content.find('.' + DX_MENU_ITEMS_CONTAINER_CLASS);
                $clickedItem = this._searchActiveItem(e.target);
                if (this._isIncludeOverlay($clickedOverlay, $allOverlays) && $clickedItem.length) {
                    if (this._getShowSubmenuMode() === 'onClick')
                        this._hideAllShownChildSubmenus($clickedItem);
                    return false
                }
                return true
            },
            _searchActiveItem: function(target) {
                return $(target).closest('.' + DX_MENU_ITEM_CLASS).eq(0)
            },
            _isIncludeOverlay: function($activeOverlay, $allOverlays) {
                var isSame = false;
                $.each($allOverlays, function(index, $overlay) {
                    if ($activeOverlay.is($overlay) && !isSame)
                        isSame = true
                });
                return isSame
            },
            _hideAllShownChildSubmenus: function($clickedItem) {
                var that = this,
                    $submenuElements = $clickedItem.find('.' + DX_SUBMENU_CLASS),
                    shownSubmenus = $.extend([], this._shownSubmenus),
                    $context;
                if ($submenuElements.length > 0)
                    $.each(shownSubmenus, function(index, $submenu) {
                        $context = that._searchActiveItem($submenu.context).parent();
                        if ($context.parent().is($clickedItem.parent().parent()) && !$context.is($clickedItem.parent()))
                            that._hideChildrenSubmenus($submenu)
                    })
            },
            _showAdditionalGraphicsElements: function() {
                var $submenu = this._itemContainer().children('.' + DX_SUBMENU_CLASS).eq(0),
                    $rootItem = this.option('position').of,
                    positionAt = this.option('position').at,
                    positionMy = this.option('position').my,
                    position = {of: $submenu},
                    containerOffset,
                    rootOffset;
                if (this.$contentDelimiter) {
                    containerOffset = this._itemContainer().offset();
                    rootOffset = $rootItem.offset();
                    this.$contentDelimiter.css('display', 'block');
                    if (this.option('orientation') === 'horizontal') {
                        this.$contentDelimiter.width($rootItem.width() < $submenu.width() ? $rootItem.width() - 2 : $submenu.width() - 2);
                        this.$contentDelimiter.height(2);
                        if (containerOffset.top > rootOffset.top)
                            if (Math.round(containerOffset.left) === Math.round(rootOffset.left)) {
                                position.offset = '1 -1';
                                position.at = 'left top';
                                position.my = 'left top'
                            }
                            else {
                                position.offset = '-1 -1';
                                position.at = 'right top';
                                position.my = 'right top'
                            }
                        else {
                            this.$contentDelimiter.height(4);
                            if (Math.round(containerOffset.left) === Math.round(rootOffset.left)) {
                                position.offset = '1 2';
                                position.at = 'left bottom';
                                position.my = 'left bottom'
                            }
                            else {
                                position.offset = '-1 2';
                                position.at = 'right bottom';
                                position.my = 'right bottom'
                            }
                        }
                    }
                    else if (this.option('orientation') === 'vertical') {
                        this.$contentDelimiter.width(2);
                        this.$contentDelimiter.height($rootItem.height() < $submenu.height() ? $rootItem.height() - 2 : $submenu.height() - 2);
                        if (containerOffset.left > rootOffset.left)
                            if (Math.round(containerOffset.top) === Math.round(rootOffset.top)) {
                                position.offset = '-1 1';
                                position.at = 'left top';
                                position.my = 'left top'
                            }
                            else {
                                position.offset = '-1 -1';
                                position.at = 'left bottom';
                                position.my = 'left bottom'
                            }
                        else if (Math.round(containerOffset.top) === Math.round(rootOffset.top)) {
                            position.offset = '1 1';
                            position.at = 'right top';
                            position.my = 'right top'
                        }
                        else {
                            position.offset = '1 -1';
                            position.at = 'right bottom';
                            position.my = 'right bottom'
                        }
                    }
                    DX.position(this.$contentDelimiter, position)
                }
            },
            _showSubmenu: function($item) {
                var $submenuElement = $item.children('.' + DX_SUBMENU_CLASS);
                this._hideSubmenusOnSameLevel($item);
                this.callBase($item);
                this._showSubmenuGroup($submenuElement, $item)
            },
            _hideSubmenusOnSameLevel: function($item) {
                var $expandedItems = $item.closest('.' + DX_MENU_ITEMS_CONTAINER_CLASS).find('.' + DX_MENU_ITEM_EXPANDED_CLASS);
                if ($expandedItems.length) {
                    $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                    this._hideChildrenSubmenus($expandedItems.find('.' + DX_SUBMENU_CLASS))
                }
            },
            _hideSubmenuGroup: function($submenu) {
                if (this._isSubmenuVisible($submenu))
                    this._hideSubmenuCore($submenu)
            },
            _isSubmenuVisible: function($submenu) {
                return $submenu.css('display') !== 'none'
            },
            _showSubmenuGroup: function($submenu, $itemElement, forceRestartTimer) {
                var $expandedItems = $itemElement.closest('.' + DX_MENU_ITEMS_CONTAINER_CLASS).find('.' + DX_MENU_ITEM_EXPANDED_CLASS).removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                if (forceRestartTimer || !this._isSubmenuVisible($submenu)) {
                    $itemElement.addClass(DX_MENU_ITEM_EXPANDED_CLASS);
                    this._showSubmenuCore($submenu, this._getSubmenuPosition($itemElement))
                }
            },
            _showSubmenuCore: function($submenu, position) {
                var animation = this.option('animation') ? this.option('animation').show : {};
                if (this._overlay && this._overlay.option('visible')) {
                    if (!utils.isDefined(this._shownSubmenus))
                        this._shownSubmenus = [];
                    if ($.inArray($submenu, this._shownSubmenus))
                        this._shownSubmenus.push($submenu);
                    $submenu.css('display', 'block');
                    DX.position($submenu, position);
                    this._stopAnimate($submenu);
                    this._animate($submenu, animation)
                }
            },
            _animate: function($container, options) {
                fx.animate($container, options)
            },
            _getSubmenuPosition: function($rootItem) {
                var submenuDirection = this.option('submenuDirection').toLowerCase(),
                    rtlEnabled = this.option('rtlEnabled'),
                    $rootItemWrapper = $rootItem.parent('.' + DX_MENU_ITEM_WRAPPER_CLASS),
                    position = {
                        collision: 'flip',
                        of: $rootItemWrapper,
                        offset: {
                            h: 0,
                            v: -1
                        }
                    };
                switch (submenuDirection) {
                    case'left':
                        position.at = 'left top';
                        position.my = 'right top';
                        break;
                    case'right':
                        position.at = 'right top';
                        position.my = 'left top';
                        break;
                    default:
                        if (rtlEnabled) {
                            position.at = 'left top';
                            position.my = 'right top'
                        }
                        else {
                            position.at = 'right top';
                            position.my = 'left top'
                        }
                        break
                }
                return position
            },
            _itemMouseLeaveHandler: function(e) {
                var $itemElement = $(e.target),
                    $submenuElement = $itemElement.closest('.' + DX_SUBMENU_CLASS),
                    $lastShownSubmenu = this._shownSubmenus && this._shownSubmenus[this._shownSubmenus.length - 1];
                if (!$submenuElement.is($lastShownSubmenu))
                    this._hideChildrenSubmenus($lastShownSubmenu)
            },
            _updateOverlayVisibilityOnClick: function(actionArgs) {
                var $itemElement,
                    $submenuElement;
                if (actionArgs.args.length && actionArgs.args[0]) {
                    actionArgs.args[0].jQueryEvent.stopPropagation();
                    $itemElement = actionArgs.args[0].itemElement;
                    $submenuElement = $itemElement.children('.' + DX_SUBMENU_CLASS);
                    if ($itemElement.context === $submenuElement.context && $submenuElement.is(":visible"))
                        return;
                    if (!$itemElement.data(this._itemDataKey()) || $itemElement.data(this._itemDataKey()).disabled)
                        return;
                    this._updateSelectedItemOnClick(actionArgs);
                    if ($submenuElement.length === 0) {
                        var $prevSubmenu = $($itemElement.parents('.' + DX_SUBMENU_CLASS)[0]);
                        this._hideChildrenSubmenus($prevSubmenu);
                        if (!actionArgs.canceled && this._overlay && this._overlay.option('visible'))
                            this.option('visible', false)
                    }
                    else {
                        if (this._shownSubmenus && this._shownSubmenus.length > 0)
                            if (this._shownSubmenus[0].is($submenuElement) || this._shownSubmenus[0].has($submenuElement).length === 1)
                                this._hideChildrenSubmenus($submenuElement);
                            else
                                this._hideAllShownSubmenus();
                        this._showSubmenuGroup($submenuElement, $itemElement)
                    }
                }
            },
            _hideChildrenSubmenus: function($curSubmenu) {
                var that = this,
                    shownSubmenus = $.extend([], that._shownSubmenus);
                $.each(shownSubmenus, function(index, $submenu) {
                    if ($curSubmenu.is($submenu) || $curSubmenu.has($submenu).length)
                        that._hideSubmenuCore($submenu)
                })
            },
            _hideSubmenuCore: function($submenu) {
                var index = $.inArray($submenu, this._shownSubmenus),
                    animation = this.option('animation') ? this.option('animation').hide : {};
                if (index >= 0)
                    this._shownSubmenus.splice(index, 1);
                this._stopAnimate($submenu);
                this._animate($submenu, animation.hide);
                $submenu.css('display', 'none')
            },
            _stopAnimate: function($container) {
                fx.stop($container, true)
            },
            _hideAllShownSubmenus: function() {
                var that = this,
                    shownSubmenus = $.extend([], that._shownSubmenus),
                    $expandedItems = this._overlay.content().find('.' + DX_MENU_ITEM_EXPANDED_CLASS);
                $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                $.each(shownSubmenus, function(_, $submenu) {
                    that._hideSubmenuCore($submenu)
                })
            },
            _optionChanged: function(args) {
                if (this._cancelOptionChange)
                    return;
                if ($.inArray(args.name, ACTIONS) > -1) {
                    this._initActions();
                    return
                }
                switch (args.name) {
                    case'invokeOnlyFromCode':
                        break;
                    case'items':
                        if (this._overlay.option('visible'))
                            this._overlay.hide();
                        this.callBase(args);
                        break;
                    case"position":
                    case"submenuDirection":
                    case"target":
                        this._invalidate();
                        break;
                    default:
                        if (this._overlay)
                            if (this._overlay.option('visible'))
                                this._overlay.hide();
                        this.callBase(args)
                }
            },
            _clean: function() {
                if (this._overlay) {
                    this._overlay.element().remove();
                    this._overlay = null
                }
                this._target.off(events.addNamespace('dxhold', this.NAME));
                this._target.off(events.addNamespace('contextmenu', this.NAME))
            },
            _toggleVisibility: function(value) {
                value ? this.show() : this.hide()
            },
            show: function(jqueryEvent) {
                var position = this.option('position'),
                    positioningAction = this._createActionByOption('onPositioning', actionArgs),
                    actionArgs;
                if (jqueryEvent && jqueryEvent.preventDefault)
                    position = {
                        at: 'top left',
                        my: 'top left',
                        of: jqueryEvent
                    };
                if (!position.of)
                    position.of = this._target;
                actionArgs = {
                    position: position,
                    jQueryEvent: jqueryEvent
                };
                positioningAction(actionArgs);
                if (!actionArgs.canceled && this._overlay) {
                    if (position) {
                        this._overlay.option('position', null);
                        this._overlay.option('position', position)
                    }
                    this._resetFocusedItem(this._itemElements().first());
                    this._overlay.show();
                    this._setOptionSilent('visible', true)
                }
                return this.option('visible')
            },
            hide: function() {
                if (this._overlay) {
                    this._overlay.hide();
                    this._setOptionSilent('visible', false)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.menu.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            fx = DX.fx;
        var DX_MENU_CLASS = 'dx-menu',
            DX_MENU_VERTICAL_CLASS = DX_MENU_CLASS + '-vertical',
            DX_MENU_HORIZONTAL_CLASS = DX_MENU_CLASS + '-horizontal',
            DX_MENU_ITEM_CLASS = DX_MENU_CLASS + '-item',
            DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + '-items-container',
            DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + "-expanded",
            DX_CONTEXT_MENU_CLASS = 'dx-context-menu',
            DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS = DX_CONTEXT_MENU_CLASS + '-container-border',
            DX_MENU_SELECTED_ITEM_CLASS = DX_MENU_ITEM_CLASS + '-selected',
            DX_ITEM_SELECTED_SELECTOR = '.' + DX_MENU_SELECTED_ITEM_CLASS,
            DX_MENU_HOVERSTAY_TIMEOUT = 300,
            DX_MENU_HOVER_TIMEOUT = 50,
            FOCUS_UP = "up",
            FOCUS_DOWN = "down",
            FOCUS_LEFT = "left",
            FOCUS_RIGHT = "right",
            SHOW_SUBMENU_OPERATION = "showSubmenu",
            NEXTITEM_OPERATION = "nextItem",
            PREVITEM_OPERATION = "prevItem",
            ACTIONS = ["onSubmenuShowing", "onSubmenuShown", "onSubmenuHiding", "onSubmenuHidden"];
        DX.registerComponent("dxMenu", ui, ui.dxMenuBase.inherit({
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    firstSubMenuDirection: {
                        since: "14.1",
                        alias: "submenuDirection"
                    },
                    showPopupMode: {
                        since: "14.1",
                        alias: "showFirstSubmenuMode"
                    },
                    allowSelectItem: {
                        since: "14.1",
                        alias: "allowSelection"
                    },
                    allowSelection: {
                        since: "14.2",
                        message: "Use the 'selectionMode' option instead"
                    },
                    submenuHiddenAction: {
                        since: "14.2",
                        alias: "onSubmenuHidden"
                    },
                    submenuHidingAction: {
                        since: "14.2",
                        alias: "onSubmenuHiding"
                    },
                    submenuShowingAction: {
                        since: "14.2",
                        alias: "onSubmenuShowing"
                    },
                    submenuShownAction: {
                        since: "14.2",
                        alias: "onSubmenuShown"
                    }
                })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    orientation: 'horizontal',
                    submenuDirection: 'auto',
                    showFirstSubmenuMode: 'onClick',
                    onSubmenuShowing: null,
                    onSubmenuShown: null,
                    onSubmenuHiding: null,
                    onSubmenuHidden: null
                })
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {
                    animation: true,
                    selectedItem: true
                })
            },
            _focusTarget: function() {
                return this.element()
            },
            _eventBindingTarget: function() {
                return this.element()
            },
            _getOrientation: function() {
                return this.option("orientation") === "vertical" ? "vertical" : "horizontal"
            },
            _isMenuHorizontal: function() {
                return this._getOrientation() === "horizontal"
            },
            _moveFocus: function(location) {
                var $items = this._itemElements().filter(":visible"),
                    isMenuHorizontal = this._isMenuHorizontal(),
                    argument,
                    $activeItem = this._getActiveItem(true),
                    operation,
                    navigationAction,
                    $newTarget;
                switch (location) {
                    case FOCUS_UP:
                        operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(PREVITEM_OPERATION);
                        argument = isMenuHorizontal ? $activeItem : $items;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    case FOCUS_DOWN:
                        argument ? $activeItem : $items;
                        operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(NEXTITEM_OPERATION);
                        argument = isMenuHorizontal ? $activeItem : $items;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    case FOCUS_RIGHT:
                        operation = isMenuHorizontal ? this._getItemsNavigationOperation(NEXTITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
                        argument = isMenuHorizontal ? $items : $activeItem;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    case FOCUS_LEFT:
                        operation = isMenuHorizontal ? this._getItemsNavigationOperation(PREVITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
                        argument = isMenuHorizontal ? $items : $activeItem;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    default:
                        return this.callBase(location)
                }
                $newTarget && this._resetFocusedItem($newTarget)
            },
            _getItemsNavigationOperation: function(operation) {
                var navOperation = operation;
                if (this.option("rtlEnabled"))
                    navOperation = operation === PREVITEM_OPERATION ? NEXTITEM_OPERATION : PREVITEM_OPERATION;
                return navOperation
            },
            _getKeyboardNavigationAction: function(operation, argument) {
                var action;
                switch (operation) {
                    case SHOW_SUBMENU_OPERATION:
                        action = $.proxy(this._showSubmenu, this, argument);
                        break;
                    case NEXTITEM_OPERATION:
                        action = $.proxy(this._nextItem, this, argument);
                        break;
                    case PREVITEM_OPERATION:
                        action = $.proxy(this._prevItem, this, argument);
                        break
                }
                return action
            },
            _init: function() {
                this.callBase();
                this._submenus = []
            },
            _initActions: function() {
                this._actions = {};
                $.each(ACTIONS, $.proxy(function(index, action) {
                    this._actions[action] = this._createActionByOption(action) || $.noop
                }, this))
            },
            _render: function() {
                this.callBase();
                this.element().addClass(DX_MENU_CLASS)
            },
            _renderContainer: function() {
                var isVerticalMenu = this.option('orientation') === 'vertical',
                    $rootGroup,
                    $itemsContainer;
                $rootGroup = $('<div>');
                $rootGroup.appendTo(this.element()).addClass(isVerticalMenu ? DX_MENU_VERTICAL_CLASS : DX_MENU_HORIZONTAL_CLASS);
                $itemsContainer = $('<ul>');
                $itemsContainer.appendTo($rootGroup).addClass(DX_MENU_ITEMS_CONTAINER_CLASS).css('min-height', this._getValueHeight($rootGroup));
                return $itemsContainer
            },
            _renderSubmenuItems: function(item, $item) {
                if (this._hasSubmenu(item)) {
                    var submenu = this._createSubmenu(item.items, $item);
                    this._submenus.push(submenu);
                    this._renderBorderElement($item)
                }
            },
            _createSubmenu: function(items, $rootItem) {
                var that = this,
                    $submenuContainer = $('<div>'),
                    submenuOptions = $.extend(this._getSubmenuOptions(), {
                        items: items,
                        position: that.getSubmenuPosition($rootItem)
                    }),
                    instance;
                $submenuContainer.addClass(DX_CONTEXT_MENU_CLASS).dxContextMenu(submenuOptions).appendTo($rootItem);
                instance = $submenuContainer.dxContextMenu('instance');
                this._attachSubmenuHandlers($rootItem, instance);
                return instance
            },
            _getSubmenuOptions: function() {
                var $submenuTarget = $('<div>'),
                    isMenuHorizontal = this._isMenuHorizontal();
                return {
                        _templates: this.option("_templates"),
                        target: $submenuTarget,
                        showAdditionalElements: true,
                        orientation: this.option('orientation'),
                        selectionMode: this.option('selectionMode'),
                        selectionByClick: this.option('selectionByClick'),
                        cssClass: this.option('cssClass'),
                        hoverStateEnabled: this.option('hoverStateEnabled'),
                        activeStateEnabled: this.option('activeStateEnabled'),
                        focusStateEnabled: this.option('focusStateEnabled'),
                        animation: this.option('animation'),
                        rtlEnabled: this.option('rtlEnabled'),
                        disabled: this.option('disabled'),
                        showSubmenuMode: this._getShowSubmenuMode() === 'auto' ? this._getShowFirstSubmenuMode() : this._getShowSubmenuMode(),
                        onSelectionChanged: $.proxy(this._nestedItemOnSelectionChangedHandler, this),
                        onItemClick: $.proxy(this._nestedItemOnItemClickHandler, this),
                        onLeftFirstItem: isMenuHorizontal ? null : $.proxy(this._moveMainMenuFocus, this, PREVITEM_OPERATION),
                        onLeftLastItem: isMenuHorizontal ? null : $.proxy(this._moveMainMenuFocus, this, NEXTITEM_OPERATION),
                        onCloseRootSubmenu: isMenuHorizontal ? $.proxy(this._moveMainMenuFocus, this, PREVITEM_OPERATION) : null,
                        onExpandLastSubmenu: isMenuHorizontal ? $.proxy(this._moveMainMenuFocus, this, NEXTITEM_OPERATION) : null,
                        _remoteSelectionSync: true
                    }
            },
            _getShowFirstSubmenuMode: function() {
                var isDesktop = DX.devices.real().deviceType === "desktop";
                return isDesktop ? this.option("showFirstSubmenuMode") : "onClick"
            },
            _moveMainMenuFocus: function(direction) {
                var $expandedItem = this.element().find("." + DX_MENU_ITEM_EXPANDED_CLASS).first(),
                    $newItem;
                switch (direction) {
                    case PREVITEM_OPERATION:
                        $newItem = $expandedItem.parent().prev();
                        if (!$newItem.length)
                            $newItem = $expandedItem.parent().siblings().last();
                        $newItem = $newItem.children();
                        break;
                    case NEXTITEM_OPERATION:
                        $newItem = $expandedItem.parent().next();
                        if (!$newItem.length)
                            $newItem = $expandedItem.parent().siblings().first();
                        $newItem = $newItem.children();
                        break
                }
                this._visibleSubmenu && this._hideSubmenu(this._visibleSubmenu);
                this.focus();
                this._resetFocusedItem($newItem)
            },
            _nestedItemOnSelectionChangedHandler: function(args) {
                var selectedItems = args.addedItems,
                    submenu = args.element.dxContextMenu("instance");
                this._clearSelectionInSubmenus(selectedItems[0], submenu);
                this._clearRootSelection();
                this.option("selectedItems", selectedItems)
            },
            _clearSelectionInSubmenus: function(item, targetSubmenu) {
                var that = this,
                    cleanAllSubmenus = !arguments.length;
                $.each(this._submenus, function(index, submenu) {
                    var $submenu = submenu._itemContainer(),
                        isOtherItem = !$submenu.is(targetSubmenu && targetSubmenu._itemContainer()),
                        $selectedItem = $submenu.find(DX_ITEM_SELECTED_SELECTOR);
                    if (isOtherItem && $selectedItem.length || cleanAllSubmenus) {
                        var selectedItemData;
                        $selectedItem.removeClass(DX_MENU_SELECTED_ITEM_CLASS);
                        selectedItemData = that._getItemData($selectedItem);
                        if (selectedItemData)
                            selectedItemData.selected = false;
                        submenu._clearSelectedItems()
                    }
                })
            },
            _clearRootSelection: function() {
                var $prevSelectedItem = this.element().find("." + DX_MENU_ITEMS_CONTAINER_CLASS).first().children().children().filter("." + DX_MENU_SELECTED_ITEM_CLASS);
                if ($prevSelectedItem.length) {
                    var prevSelectedItemData;
                    prevSelectedItemData = this._getItemData($prevSelectedItem);
                    prevSelectedItemData.selected = false;
                    $prevSelectedItem.removeClass(DX_MENU_SELECTED_ITEM_CLASS)
                }
                this._clearSelectedItems()
            },
            _nestedItemOnItemClickHandler: function(arg) {
                var $selectedItem,
                    onItemClick = this._createActionByOption('onItemClick', {});
                onItemClick(arg)
            },
            _updateSelectedItemOnClick: function(actionArgs) {
                var selectedIndex = this.option("selectedIndex");
                this.callBase(actionArgs);
                if (selectedIndex !== this.option("selectedIndex"))
                    this._clearSelectionInSubmenus()
            },
            _attachSubmenuHandlers: function($rootItem, submenu) {
                var $submenuOverlayContent = submenu._overlay.content(),
                    submenuMouseEnterName = events.addNamespace('mouseenter', this.NAME + '_submenu'),
                    submenuMouseLeaveName = events.addNamespace('mouseleave', this.NAME + '_submenu');
                submenu.option({
                    onShowing: $.proxy(this._submenuOnShowingHandler, this, $rootItem, submenu),
                    onShown: $.proxy(this._submenuOnShownHandler, this, $rootItem, submenu),
                    onHiding: $.proxy(this._submenuOnHidingHandler, this, $rootItem, submenu),
                    onHidden: $.proxy(this._submenuOnHiddenHandler, this, $rootItem, submenu)
                });
                $submenuOverlayContent.off(submenuMouseEnterName).off(submenuMouseLeaveName).on(submenuMouseEnterName, null, $.proxy(this._submenuMouseEnterHandler, this, $rootItem)).on(submenuMouseLeaveName, null, $.proxy(this._submenuMouseLeaveHandler, this, $rootItem))
            },
            _submenuOnShowingHandler: function($rootItem, submenu) {
                var $border = $rootItem.children('.' + DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS),
                    animation = this.option('animation') ? this.option('animation').show : {};
                this._actions.onSubmenuShowing({
                    rootItem: $rootItem,
                    submenu: submenu
                });
                if (this._options.width !== undefined)
                    if (this._options.rtlEnabled)
                        $border.width(this._$element.width() - $rootItem.position().right);
                    else
                        $border.width(this._$element.width() - $rootItem.position().left);
                $border.css('display', 'block');
                DX.fx.stop($border, true);
                DX.fx.animate($border, animation);
                $rootItem.addClass(DX_MENU_ITEM_EXPANDED_CLASS)
            },
            _submenuOnShownHandler: function($rootItem, submenu) {
                this._actions.onSubmenuShown({
                    rootItem: $rootItem,
                    submenu: submenu
                })
            },
            _submenuOnHidingHandler: function($rootItem, submenu) {
                var $border = $rootItem.children('.' + DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS),
                    animation = this.option('animation') ? this.option('animation').hide : {};
                this._actions.onSubmenuHiding({
                    rootItem: $rootItem,
                    submenu: submenu
                });
                DX.fx.animate($border, animation);
                $border.css('display', 'none');
                $rootItem.removeClass(DX_MENU_ITEM_EXPANDED_CLASS)
            },
            _submenuOnHiddenHandler: function($rootItem, submenu) {
                this._actions.onSubmenuHidden({
                    rootItem: $rootItem,
                    submenu: submenu
                })
            },
            _submenuMouseEnterHandler: function($rootItem) {
                this._hoveredContextMenuContainer = $rootItem
            },
            _submenuMouseLeaveHandler: function($rootItem) {
                var that = this,
                    submenu;
                setTimeout(function() {
                    if (!that._hoveredContextMenuContainer || !that._hoveredContextMenuContainer.is(that._hoveredRootItem)) {
                        submenu = that._getSubmenuByRootElement($rootItem);
                        if (submenu)
                            that._hideSubmenu(submenu)
                    }
                    that._hoveredContextMenuContainer = null
                }, DX_MENU_HOVER_TIMEOUT)
            },
            _getSubmenuByRootElement: function($rootItem) {
                var submenu = null,
                    $submenu;
                if ($rootItem) {
                    $submenu = $rootItem.children('.' + DX_CONTEXT_MENU_CLASS);
                    if ($submenu.length > 0)
                        submenu = $submenu.dxContextMenu('instance')
                }
                return submenu
            },
            getSubmenuPosition: function($rootItem) {
                var isVerticalMenu = this.option('orientation').toLowerCase() == 'vertical',
                    submenuDirection = this.option('submenuDirection').toLowerCase(),
                    rtlEnabled = this.option('rtlEnabled'),
                    submenuPosition = {
                        collision: 'flip',
                        of: $rootItem
                    };
                switch (submenuDirection) {
                    case'leftortop':
                        submenuPosition.at = isVerticalMenu ? 'left top' : 'left top';
                        submenuPosition.my = isVerticalMenu ? 'right top' : 'left bottom';
                        break;
                    case'rightorbottom':
                        submenuPosition.at = isVerticalMenu ? 'right top' : 'left bottom';
                        submenuPosition.my = isVerticalMenu ? 'left top' : 'left top';
                        break;
                    case'auto':
                    default:
                        if (isVerticalMenu) {
                            submenuPosition.at = rtlEnabled ? 'left top' : 'right top';
                            submenuPosition.my = rtlEnabled ? 'right top' : 'left top'
                        }
                        else {
                            submenuPosition.at = rtlEnabled ? 'right bottom' : 'left bottom';
                            submenuPosition.my = rtlEnabled ? 'right top' : 'left top'
                        }
                        break
                }
                return submenuPosition
            },
            _renderBorderElement: function($item) {
                $('<div>').appendTo($item).addClass(DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS).css('display', 'none')
            },
            _getValueHeight: function($root) {
                var $div = $("<div>").html("Jj").css({
                        width: "auto",
                        position: "fixed",
                        top: "-3000px",
                        left: "-3000px"
                    }).appendTo($root),
                    height = $div.height();
                $div.remove();
                return height
            },
            _itemMouseEnterHandler: function(eventArg) {
                var that = this,
                    mouseMoveEventName = events.addNamespace('mousemove', that.NAME),
                    $item = that._getItemElementByEventArgs(eventArg),
                    submenu = that._getSubmenuByRootElement($item),
                    showFirstSubmenuMode = this._getShowFirstSubmenuMode(),
                    isHoverStayMode = showFirstSubmenuMode !== 'onHover';
                if ($item.data(this._itemDataKey()).disabled)
                    return;
                if (showFirstSubmenuMode !== 'onClick' && submenu) {
                    clearTimeout(that._hideSubmenuTimer);
                    clearTimeout(that._showSubmenuTimer);
                    if (isHoverStayMode && that._visibleSubmenu == submenu && !submenu._overlay.option('visible')) {
                        $item.off(mouseMoveEventName).on(mouseMoveEventName, $.proxy(that._itemMouseMoveHandler, that));
                        that._showSubmenuTimer = setTimeout(function() {
                            that._showSubmenu($item)
                        }, DX_MENU_HOVERSTAY_TIMEOUT)
                    }
                    else
                        that._showSubmenu($item)
                }
            },
            _itemMouseLeaveHandler: function(eventArg) {
                var that = this,
                    $item = that._getItemElementByEventArgs(eventArg),
                    submenu,
                    showFirstSubmenuMode = this._getShowFirstSubmenuMode(),
                    timeout = this._getShowFirstSubmenuMode() !== 'onHover' ? DX_MENU_HOVERSTAY_TIMEOUT : DX_MENU_HOVER_TIMEOUT;
                if ($item.data(this._itemDataKey()).disabled)
                    return;
                if (showFirstSubmenuMode !== 'onClick') {
                    clearTimeout(that._showSubmenuTimer);
                    clearTimeout(that._hideSubmenuTimer);
                    that._hideSubmenuTimer = setTimeout(function() {
                        submenu = that._getSubmenuByRootElement($item);
                        that._hideSubmenu(submenu);
                        if (that._visibleSubmenu == submenu)
                            that._visibleSubmenu = null
                    }, timeout)
                }
            },
            _showSubmenu: function($itemElement) {
                var submenu = this._getSubmenuByRootElement($itemElement);
                if (utils.isDefined(this._visibleSubmenu) && this._visibleSubmenu !== submenu)
                    this._hideSubmenu(this._visibleSubmenu);
                submenu && submenu.show();
                this._visibleSubmenu = submenu;
                this._hoveredRootItem = $itemElement
            },
            _hideSubmenu: function(submenu) {
                if (!this._hoveredRootItem || !this._hoveredRootItem.is(this._hoveredContextMenuContainer))
                    if (submenu)
                        submenu.hide();
                this._hoveredRootItem = null
            },
            _itemMouseMoveHandler: function(eventArgs) {
                var that = this,
                    $item = that._getItemElementByEventArgs(eventArgs),
                    submenu;
                if (that._showSubmenuTimer) {
                    clearTimeout(that._hideSubmenuTimer);
                    clearTimeout(that._showSubmenuTimer);
                    submenu = that._getSubmenuByRootElement($item),
                    that._showSubmenuTimer = setTimeout(function() {
                        that._showSubmenu($item)
                    }, DX_MENU_HOVERSTAY_TIMEOUT)
                }
            },
            _updateOverlayVisibilityOnClick: function(actionArgs) {
                var that = this,
                    $item,
                    submenu,
                    args = actionArgs.args.length && actionArgs.args[0];
                if (args) {
                    args.jQueryEvent.stopPropagation();
                    $item = args.itemElement;
                    if ($item.data(this._itemDataKey()).disabled)
                        return;
                    submenu = that._getSubmenuByRootElement($item);
                    this._updateSelectedItemOnClick(actionArgs);
                    if (submenu)
                        if (submenu._overlay.option('visible')) {
                            if (this._getShowFirstSubmenuMode() === 'onClick')
                                that._hideSubmenu(submenu)
                        }
                        else
                            that._showSubmenu($item);
                    else if (utils.isDefined(this._visibleSubmenu))
                        this._hideSubmenu(this._visibleSubmenu)
                }
            },
            _optionChanged: function(args) {
                if (this._cancelOptionChange)
                    return;
                if (this._visibleSubmenu)
                    this._hideSubmenu(this._visibleSubmenu);
                switch (args.name) {
                    case'selectedItems':
                        var item = args.value[0];
                        if (JSON.stringify(item) === JSON.stringify(args.previousValue[0]))
                            return;
                        if (this._isItemInSubmenu(item)) {
                            this._syncSelectionOptions(args.name);
                            this._normalizeSelectedItems()
                        }
                        else
                            this.callBase(args);
                        break;
                    case'orientation':
                    case'submenuDirection':
                        this._invalidate();
                        break;
                    case'showFirstSubmenuMode':
                        break;
                    case'onSubmenuShowing':
                    case'onSubmenuShown':
                    case'onSubmenuHiding':
                    case'onSubmenuHidden':
                        this._initActions();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _isItemInSubmenu: function(item) {
                return $.inArray(JSON.stringify(item), this._getStringifiedArray(this.option("items"))) < 0
            },
            selectItem: function(itemElement) {
                var itemData = this._getItemData(itemElement);
                if (this._isItemInSubmenu(itemData))
                    $.each(this._submenus, function(index, submenu) {
                        if (submenu._isOwnItem(itemData))
                            submenu.selectItem(itemElement)
                    });
                else
                    this.callBase(itemElement)
            }
        }));
        ui.dxMenu.__internals = {}
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.treeView.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            dataUtils = DX.data.utils,
            utils = DX.utils;
        var WIDGET_CLASS = "dx-treeview",
            NODE_CONTAINER_CLASS = "dx-treeview-node-container",
            OPENED_NODE_CONTAINER_CLASS = "dx-treeview-node-container-opened",
            NODE_CLASS = "dx-treeview-node",
            FOCUSED_NODE_CLASS = "dx-treeview-focused-node",
            ITEM_CLASS = "dx-treeview-item",
            FOCUSED_ITEM_CLASS = "dx-treeview-focused-item",
            ITEM_WITH_CHECKBOX_CLASS = "dx-treeview-item-with-checkbox",
            ITEM_DATA_KEY = "dx-treeview-item-data",
            IS_LEAF = "dx-treeview-node-is-leaf",
            TOGGLE_ITEM_VISIBILITY_CLASS = "dx-treeview-toggle-item-visibility",
            TOGGLE_ITEM_VISIBILITY_OPENED_CLASS = "dx-treeview-toggle-item-visibility-opened",
            SELECT_ALL_ITEM_CLASS = "dx-treeview-select-all-item",
            DATA_ITEM_ID = "data-item-id";
        var scrollableContainerUpdatedOnInit = $.noop;
        DX.registerComponent("dxTreeView", ui, ui.CollectionWidget.inherit({
            _supportedKeys: function(e) {
                var changeCheckBoxState = function(e) {
                        this._changeCheckBoxState(this._$focusedItem)
                    };
                return $.extend(this.callBase(), {
                        enter: changeCheckBoxState,
                        space: changeCheckBoxState
                    })
            },
            _changeCheckBoxState: function($element) {
                var $checkbox = $element.find("> .dx-checkbox");
                if (!$checkbox.length)
                    return;
                var checkboxInstance = $checkbox.dxCheckBox("instance"),
                    currentState = checkboxInstance.option("value");
                this._updateItemSelection(!currentState, $element.find("." + ITEM_CLASS).get(0), true, $element)
            },
            _activeStateUnit: "." + ITEM_CLASS,
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    dataStructure: "tree",
                    expandedItems: [],
                    keyExpr: "id",
                    displayExpr: null,
                    selectedExpr: "selected",
                    expandedExpr: "expanded",
                    itemsExpr: "items",
                    parentIdExpr: "parentId",
                    showCheckBoxes: false,
                    selectNodesRecursive: true,
                    selectAllEnabled: false,
                    selectAllText: "(" + Globalize.localize("dxList-selectAll") + ")",
                    onItemSelected: null,
                    onItemExpanded: null,
                    onItemCollapsed: null,
                    scrollDirection: "vertical",
                    focusStateEnabled: true,
                    selectionMode: "multi"
                })
            },
            _initSelectedItems: $.noop,
            _syncSelectionOptions: $.noop,
            _fireSelectionChanged: function() {
                var selectionChangePromise = this._selectionChangePromise;
                $.when(selectionChangePromise).done($.proxy(function() {
                    this._createActionByOption("onSelectionChanged", {excludeValidators: ["disabled"]})()
                }, this))
            },
            _initExpressions: function() {
                this._compileKeyAccessors();
                this._compileDisplayAccessors();
                this._compileSelectedAccessors();
                this._compileExpandedAccessors();
                this._compileItemsAccessors();
                this._compileParentIdAccessors()
            },
            _initDynamicTemplates: function() {
                if (this.option("displayExpr"))
                    this._dynamicTemplates["item"] = new ui.DefaultTemplate($.proxy(function(itemData) {
                        var $itemContent = $("<div>");
                        if (itemData.icon)
                            $('<span>').addClass("dx-icon-" + itemData.icon).addClass("dx-icon").appendTo($itemContent);
                        if (itemData.iconSrc)
                            $('<img>').attr("src", itemData.iconSrc).addClass("dx-icon").appendTo($itemContent);
                        $("<span>").text(this._displayGetter(itemData)).appendTo($itemContent);
                        return $itemContent
                    }, this));
                else
                    delete this._dynamicTemplates["item"]
            },
            _compileKeyAccessors: function() {
                this._keyGetter = dataUtils.compileGetter(this.option("keyExpr"));
                this._keySetter = dataUtils.compileSetter(this.option("keyExpr"))
            },
            _compileDisplayAccessors: function() {
                if (!this.option("displayExpr") && this.option("dataStructure") === "plain")
                    this.option("displayExpr", "text");
                this._displayGetter = dataUtils.compileGetter(this.option("displayExpr"));
                this._displaySetter = dataUtils.compileSetter(this.option("displayExpr"))
            },
            _compileSelectedAccessors: function() {
                this._selectedGetter = dataUtils.compileGetter(this.option("selectedExpr"));
                this._selectedSetter = dataUtils.compileSetter(this.option("selectedExpr"))
            },
            _compileExpandedAccessors: function() {
                this._expandedGetter = dataUtils.compileGetter(this.option("expandedExpr"));
                this._expandedSetter = dataUtils.compileSetter(this.option("expandedExpr"))
            },
            _compileItemsAccessors: function() {
                this._itemsGetter = dataUtils.compileGetter(this.option("itemsExpr"));
                this._itemsSetter = dataUtils.compileSetter(this.option("itemsExpr"))
            },
            _compileParentIdAccessors: function() {
                this._parentIdGetter = dataUtils.compileGetter(this.option("parentIdExpr"));
                this._parentIdSetter = dataUtils.compileSetter(this.option("parentIdExpr"))
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {hoverStateEnabled: true}
                        }])
            },
            _optionChanged: function(args) {
                var name = args.name,
                    value = args.value;
                switch (name) {
                    case"selectAllEnabled":
                        if (value) {
                            if (!this._$selectAllItem || !this._$selectAllItem.length)
                                this._renderSelectAllItem()
                        }
                        else if (this._$selectAllItem) {
                            this._$selectAllItem.remove();
                            delete this._$selectAllItem
                        }
                        break;
                    case"selectAllText":
                        if (this._$selectAllItem)
                            this._$selectAllItem.dxCheckBox("instance").option("text", value);
                        break;
                    case"scrollDirection":
                        this._scrollableContainer.option("direction", value);
                        break;
                    case"selectedItems":
                        if (this._$selectAllItem) {
                            var selectAllItem = this._$selectAllItem.dxCheckBox("instance"),
                                selectAllItemValue = selectAllItem.option("value");
                            if (selectAllItemValue && this._itemsCount === value.length)
                                return;
                            this._suppressUpdateSelectAllItemValue = true;
                            this._$selectAllItem.dxCheckBox("instance").option("value", this._calculateSelectAllItemValue());
                            this._suppressUpdateSelectAllItemValue = false
                        }
                        break;
                    case"dataStructure":
                    case"keyExpr":
                    case"displayExpr":
                    case"itemsExpr":
                    case"selectedExpr":
                    case"expandedExpr":
                    case"parentIdExpr":
                    case"showCheckBoxes":
                    case"expandedItems":
                        this._invalidate();
                        break;
                    case"selectNodesRecursive":
                    case"onItemSelected":
                    case"onItemExpanded":
                    case"onItemCollapsed":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {focusedItem: true})
            },
            _nodes: [],
            _init: function() {
                this._initExpressions();
                this.callBase();
                this._initDynamicTemplates()
            },
            _render: function() {
                var that = this;
                this.element().addClass(WIDGET_CLASS);
                this.element().off("dxpointerdown").on("dxpointerdown", function(e) {
                    var $target = $(e.target).closest(that._activeStateUnit);
                    if (!$target.length)
                        e.preventDefault()
                });
                this.callBase()
            },
            _makePlainItems: function() {
                return this._makePlainList(this.option("items"), null, true)
            },
            _makePlainNodes: function() {
                return this._makePlainList(this._nodes, null, true)
            },
            _updateSelectionItemsOption: function(items) {
                var that = this,
                    selectedItems = [];
                $.each(items, function(_, item) {
                    if (that._selectedGetter(item))
                        selectedItems.push(item)
                });
                return selectedItems
            },
            _renderContentImpl: function() {
                this._nodes = $.extend(true, [], this.option("items"));
                var items = this._nodes;
                if (items.length) {
                    if (this.option("dataStructure") === "plain") {
                        this._nodes = this._createHierarchicalStructure(this._nodes);
                        items = this._nodes
                    }
                    this._plainItems = this._makePlainItems();
                    this._plainNodes = this._makePlainNodes();
                    this._applyExpandedItemsFromOption();
                    this._applySelectedItemsFromOption(items);
                    var plainList = this._makePlainList(items, null);
                    if (this.option("selectNodesRecursive")) {
                        items = this._calculateChildrenSelectedState(items);
                        this._calculateParentSelectedState(plainList)
                    }
                    this._calculateParentExpandedState(plainList);
                    this._createParentFieldForEachItem(items);
                    var selectedItems = this._updateSelectionItemsOption(this._plainItems);
                    if (selectedItems.length)
                        this.option("selectedItems", selectedItems);
                    this._renderScrollableContainer();
                    var $nodeContainer = this._renderNodeContainer();
                    this._renderItems($nodeContainer, items, true);
                    this._scrollableContainer.content().append($nodeContainer);
                    if (this.option("selectAllEnabled"))
                        this._renderSelectAllItem($nodeContainer)
                }
            },
            _fireContentReadyAction: function() {
                this.callBase();
                if (this._scrollableContainer && this._scrollableContainer.content().height() > this.element().height()) {
                    this._scrollableContainer.update();
                    scrollableContainerUpdatedOnInit()
                }
            },
            _createHierarchicalStructure: function(items) {
                var result = [],
                    that = this;
                $.each(items, function(_, item) {
                    var currentParentId = that._parentIdGetter(item);
                    if (!item.items)
                        item.items = [];
                    if (!currentParentId) {
                        var rootNode = that._createNode(item);
                        result.push(rootNode)
                    }
                    else
                        that._makeChildren(result, currentParentId, item)
                });
                return result
            },
            _makeChildren: function(items, parentId, item) {
                for (var i = 0, len = items.length; i < len; i++)
                    if (this._keyGetter(items[i]) === parentId) {
                        var node = this._createNode(item);
                        items[i].items.push(node);
                        break
                    }
                    else
                        this._makeChildren(items[i].items, parentId, item)
            },
            _createNode: function(itemData) {
                var node = {};
                this._keySetter(node, this._keyGetter(itemData));
                this._displaySetter(node, this._displayGetter(itemData));
                this._itemsSetter(node, this._itemsGetter(itemData));
                this._expandedSetter(node, this._expandedGetter(itemData));
                return node
            },
            _createParentFieldForEachItem: function(items, parent) {
                var that = this,
                    parent = parent ? $.extend(true, {}, parent) : null;
                $.each(items, function(_, item) {
                    that._itemsCount++;
                    if (utils.isDefined(parent) && that._itemsGetter(parent))
                        that._itemsSetter(parent, null);
                    if (!$.isPlainObject(item))
                        item = that._makeObjectFromPrimitive(item);
                    item.parent = parent;
                    that._plainNodes[that._keyGetter(item)].parent = parent;
                    if (that._itemHasChildren(item))
                        that._createParentFieldForEachItem(that._itemsGetter(item), item)
                })
            },
            _makeObjectFromPrimitive: function(item) {
                var key = item;
                item = {};
                this._keySetter(item, key);
                return item
            },
            _itemHasChildren: function(item) {
                var items = this._itemsGetter(item);
                return items && items.length
            },
            _renderScrollableContainer: function() {
                var $scrollableContainer = $("<div />").dxScrollable({
                        direction: this.option("scrollDirection"),
                        useKeyboard: false
                    }).appendTo(this.element());
                this._scrollableContainer = $scrollableContainer.dxScrollable("instance")
            },
            _renderNodeContainer: function($parent) {
                var $container = $("<ul />").addClass(NODE_CONTAINER_CLASS);
                if ($parent) {
                    var itemData = this._getItemData($parent.find("> ." + ITEM_CLASS));
                    if (this._expandedGetter(itemData))
                        $container.addClass(OPENED_NODE_CONTAINER_CLASS);
                    $container.appendTo($parent)
                }
                return $container
            },
            _itemsCount: 0,
            _renderItems: function($nodeContainer, items) {
                var that = this,
                    showCheckBoxes = that.option("showCheckBoxes");
                $.each(items, function(i, item) {
                    var $node = $("<li />").addClass(NODE_CLASS).appendTo($nodeContainer).attr(DATA_ITEM_ID, that._keyGetter(item));
                    if (!$.isPlainObject(item))
                        item = that._makeObjectFromPrimitive(item);
                    var sourceItem = that._getSourceItemByKey(that._keyGetter(item));
                    that._renderItem.call(that, i, sourceItem, $node);
                    if (showCheckBoxes)
                        that._renderCheckBox($node, item);
                    var nestedItems = that._itemsGetter(item);
                    if ($.isArray(nestedItems) && nestedItems.length) {
                        that._renderToggleItemVisibilityIcon($node, item);
                        var $nestedNodeContainer = that._renderNodeContainer($node);
                        if (that._expandedGetter(item)) {
                            that._renderItems($nestedNodeContainer, nestedItems, false);
                            $nestedNodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS)
                        }
                    }
                    else
                        $node.addClass(IS_LEAF)
                });
                this._renderFocusTarget()
            },
            _getSourceItemByKey: function(key) {
                return this._plainItems[key]
            },
            _getNodeByKey: function(key) {
                return this._plainNodes[key]
            },
            _renderSelectAllItem: function($container) {
                $container = $container || this.element().find("." + NODE_CONTAINER_CLASS).first();
                this._$selectAllItem = $("<div />").dxCheckBox({
                    value: this._calculateSelectAllItemValue(),
                    text: this.option("selectAllText"),
                    onValueChanged: $.proxy(this._selectAllItemValueChanged, this)
                }).addClass(SELECT_ALL_ITEM_CLASS);
                $container.before(this._$selectAllItem)
            },
            _calculateSelectAllItemValue: function() {
                var result = false,
                    selectedItemsCount = this.option("selectedItems").length;
                if (selectedItemsCount)
                    result = this._itemsCount === selectedItemsCount ? true : undefined;
                return result
            },
            _selectAllItemValueChanged: function(args) {
                if (!this._suppressUpdateSelectAllItemValue) {
                    this._updateAllItems(this._nodes, args.value);
                    if (!args.value)
                        this.option("selectedItems", []);
                    else {
                        var selectedItems = this._updateSelectionItemsOption(this._plainItems);
                        this.option("selectedItems", selectedItems)
                    }
                    this._fireSelectionChanged()
                }
            },
            _updateAllItems: function(nodes, value) {
                var that = this;
                $.each(nodes, function(_, node) {
                    var $node = that.element().find("[" + DATA_ITEM_ID + "='" + that._keyGetter(node) + "']");
                    var itemData = that._getSourceItemByKey(that._keyGetter(node)),
                        currentState = that._selectedGetter(node);
                    if (currentState === value)
                        return true;
                    if ($node.length)
                        $node.find("> .dx-checkbox").dxCheckBox("instance").option("value", value);
                    that._selectedSetter(node, value);
                    that._selectedSetter(itemData, value);
                    $node = null;
                    if (that._itemHasChildren(node))
                        that._updateAllItems(that._itemsGetter(node), value)
                })
            },
            _applySelectedItemsFromOption: function(items) {
                var that = this;
                $.each(this.option("selectedItems"), function(_, item) {
                    var currentItem = that._getItemFromArray(item, items);
                    if (currentItem) {
                        var currentNode = that._getNodeByKey(that._keyGetter(currentItem));
                        that._selectedSetter(currentItem, true);
                        that._selectedSetter(currentNode, true)
                    }
                    var node = that._getNodeByKey(that._keyGetter(item));
                    that._selectedSetter(item, true);
                    that._selectedSetter(node, true)
                })
            },
            _applyExpandedItemsFromOption: function() {
                var that = this;
                $.each(this.option("expandedItems"), function(_, item) {
                    var node = that._getNodeByKey(that._keyGetter(item));
                    that._expandedSetter(item, true);
                    that._expandedSetter(node, true)
                })
            },
            _calculateChildrenSelectedState: function(items) {
                var that = this;
                $.each(items, function(_, item) {
                    if (that._selectedGetter(item))
                        if (that._itemHasChildren(item))
                            $.each(that._itemsGetter(item), function(_, child) {
                                var sourceItem = that._getSourceItemByKey(that._keyGetter(child));
                                that._selectedSetter(child, true);
                                that._selectedSetter(sourceItem, true)
                            });
                    if (that._itemHasChildren(item))
                        that._itemsSetter(item, that._calculateChildrenSelectedState(that._itemsGetter(item)))
                });
                return items
            },
            _makePlainList: function(items, plainList, makeHash) {
                var that = this,
                    dataStructure = makeHash ? {} : [];
                plainList = plainList || dataStructure;
                $.each(items, function(_, item) {
                    if (makeHash) {
                        if (!$.isPlainObject(item))
                            item = that._makeObjectFromPrimitive(item);
                        plainList[that._keyGetter(item)] = item
                    }
                    else
                        plainList.push(item);
                    if (that._itemHasChildren(item))
                        that._makePlainList(that._itemsGetter(item), plainList, makeHash)
                });
                return plainList
            },
            _calculateParentSelectedState: function(list) {
                var listSize = list.length - 1,
                    that = this;
                for (var i = listSize; i >= 0; i--) {
                    if (this._selectedGetter(list[i]))
                        continue;
                    var children = this._itemsGetter(list[i]),
                        childrenCount = 0;
                    if (children && children.length)
                        childrenCount = children.length;
                    if (childrenCount) {
                        var selectedChildren = $.grep(children, function(child) {
                                return that._selectedGetter(child) === true
                            });
                        var indeterminateChildren = $.grep(children, function(child) {
                                return child.hasOwnProperty(that.option("selectedExpr")) && typeof that._selectedGetter(child) === "undefined"
                            });
                        var sourceItem = this._getSourceItemByKey(this._keyGetter(list[i]));
                        if (selectedChildren.length) {
                            var selected = selectedChildren.length === childrenCount ? true : undefined;
                            this._selectedSetter(list[i], selected);
                            this._selectedSetter(sourceItem, selected)
                        }
                        else if (indeterminateChildren.length) {
                            this._selectedSetter(list[i], undefined);
                            this._selectedSetter(sourceItem, undefined)
                        }
                        else {
                            this._selectedSetter(list[i], false);
                            this._selectedSetter(sourceItem, false)
                        }
                    }
                }
                return list
            },
            _calculateParentExpandedState: function(list) {
                var listSize = list.length - 1,
                    that = this;
                for (var i = listSize; i >= 0; i--) {
                    if (this._expandedGetter(list[i]))
                        continue;
                    var children = this._itemsGetter(list[i]),
                        childrenCount = 0;
                    if (children && children.length)
                        childrenCount = children.length;
                    if (childrenCount) {
                        var expandedChildren = $.grep(children, function(child) {
                                return that._expandedGetter(child) === true
                            });
                        if (expandedChildren.length) {
                            var sourceItem = this._getSourceItemByKey(this._keyGetter(list[i]));
                            this._expandedSetter(list[i], true);
                            this._expandedSetter(sourceItem, true)
                        }
                    }
                }
            },
            _renderCheckBox: function($node, node) {
                var checkBoxValue = this._calculateCheckBoxValue(node);
                $node.addClass(ITEM_WITH_CHECKBOX_CLASS);
                var $checkbox = $("<div />").dxCheckBox({
                        value: checkBoxValue,
                        onValueChanged: $.proxy(this._changeCheckboxValue, this),
                        focusStateEnabled: false
                    }).appendTo($node);
                this._attachCheckboxClick($checkbox, node)
            },
            _attachCheckboxClick: function($checkbox, node) {
                var eventName = events.addNamespace("dxclick", this.NAME),
                    key = this._keyGetter(node);
                var handleItemSelected = function(e) {
                        this._itemJQueryEventHandler(e, "onItemSelected", {node: this._getNodeByKey(key)})
                    };
                $checkbox.off(eventName).on(eventName, $.proxy(handleItemSelected, this))
            },
            _renderToggleItemVisibilityIcon: function($node, itemData) {
                var $icon = $("<div />").addClass(TOGGLE_ITEM_VISIBILITY_CLASS).appendTo($node);
                if (this._expandedGetter(itemData)) {
                    $icon.addClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS);
                    $node.parent().addClass(OPENED_NODE_CONTAINER_CLASS)
                }
                this._renderToggleItemVisibilityIconClick($icon)
            },
            _renderToggleItemVisibilityIconClick: function($icon) {
                var eventName = events.addNamespace("dxclick", this.NAME),
                    that = this;
                var clickAction = this._createAction(function() {
                        $icon.toggleClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS);
                        var $node = $icon.parent(),
                            $nodeContainer = $node.find(" > ." + NODE_CONTAINER_CLASS);
                        that._renderNestedItems($nodeContainer);
                        $nodeContainer.toggleClass(OPENED_NODE_CONTAINER_CLASS);
                        that._scrollableContainer.update()
                    });
                var handleItemExpanded = function(e) {
                        that._itemJQueryEventHandler(e, "onItemExpanded")
                    };
                var handleItemCollapsed = function(e) {
                        that._itemJQueryEventHandler(e, "onItemCollapsed")
                    };
                $icon.off(eventName).on(eventName, function(e) {
                    clickAction({jQueryEvent: e});
                    if ($icon.hasClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS))
                        handleItemExpanded(e);
                    else
                        handleItemCollapsed(e)
                })
            },
            _renderNestedItems: function($container) {
                if (!$container.is(":empty"))
                    return;
                var itemData = this._getItemData($container.parent().find(">." + ITEM_CLASS)),
                    itemKey = this._keyGetter(itemData),
                    node = this._getNodeByKey(itemKey);
                this._renderItems($container, this._itemsGetter(node), false)
            },
            _calculateCheckBoxValue: function(itemData) {
                return itemData.hasOwnProperty(this.option("selectedExpr")) ? this._selectedGetter(itemData) : false
            },
            _changeCheckboxValue: function(e) {
                var $node = e.element.parent("." + NODE_CLASS),
                    itemData = this._getItemData($node.find("> ." + ITEM_CLASS)),
                    value = e.value,
                    key = this._keyGetter(itemData),
                    node = this._getNodeByKey(key);
                this._selectedSetter(itemData, value);
                this._selectedSetter(node, value);
                if (e.jQueryEvent && !this.option("selectNodesRecursive"))
                    this._fireSelectionChanged();
                if (!e.jQueryEvent || !this.option("selectNodesRecursive"))
                    return;
                this._updateParentsAndChildren(this._getNodeByKey(this._keyGetter(itemData)), value, false, $node)
            },
            _updateParentsAndChildren: function(node, childValue, suppressOnSelectionChanged, $node) {
                if (node.parent)
                    this._updateParentsState(node, $node);
                if (this._itemHasChildren(node))
                    this._updateChildrenState(this._itemsGetter(node), childValue, $node);
                var selectedItems = this._updateSelectionItemsOption(this._plainItems);
                this.option("selectedItems", selectedItems);
                if (!suppressOnSelectionChanged)
                    this._fireSelectionChanged()
            },
            _itemRenderDefault: function(item, index, $itemElement) {
                var $itemContent = $("<div />");
                $("<span>").text(this._displayGetter(item)).appendTo($itemContent);
                $itemContent.appendTo($itemElement)
            },
            _getItemFromArray: function(itemData, data) {
                var result = null,
                    that = this,
                    key = that._keyGetter(itemData);
                $.each(data, function(_, item) {
                    if (key === that._keyGetter(item)) {
                        result = item;
                        return false
                    }
                });
                return result
            },
            _calculateSelectedItemsOption: function(value, itemData) {
                var key = this._keyGetter(itemData),
                    node = this._getNodeByKey(key);
                this._selectedSetter(itemData, value);
                this._selectedSetter(node, value)
            },
            _reduceSelectedItemsOption: function(selectedItems, itemData) {
                var that = this,
                    itemDataKey = that._keyGetter(itemData);
                $.each(selectedItems, function(index, item) {
                    if (itemDataKey === that._keyGetter(item)) {
                        var unselectedItem = selectedItems.splice(index, 1)[0];
                        return false
                    }
                })
            },
            _updateParentsState: function(node, $node) {
                var currentItemData = this._getSourceItemByKey(this._keyGetter(node)),
                    parentNode = this._getNodeByKey(this._keyGetter(node.parent)),
                    that = this;
                $.each(this._itemsGetter(parentNode), function(_, item) {
                    if (that._keyGetter(node) === that._keyGetter(item))
                        that._selectedSetter(item, that._selectedGetter(node))
                });
                var nodesCount = this._itemsGetter(parentNode).length,
                    selectedNodesCount = this._getSelectedChildrenFromNode(parentNode),
                    intermediateNodesCount = this._getIntermediateChildrenFromNode(parentNode),
                    parentValue = undefined;
                if (selectedNodesCount === nodesCount)
                    parentValue = true;
                else if (!selectedNodesCount && !intermediateNodesCount)
                    parentValue = false;
                if ($node) {
                    var $parentNode = $($node.parents("." + NODE_CLASS)[0]);
                    $parentNode.find("> .dx-checkbox").dxCheckBox("instance").option("value", parentValue)
                }
                this._updateParentField(currentItemData, parentValue);
                if (node.parent.parent)
                    this._updateParentsState(node.parent, $parentNode);
                this._calculateSelectedItemsOption(parentValue, this._getSourceItemByKey(this._keyGetter(node.parent)))
            },
            _getSelectedChildrenFromNode: function(node) {
                var items = this._itemsGetter(node),
                    that = this;
                if (items && items.length)
                    return $.grep(items, function(item) {
                            return that._selectedGetter(item) === true
                        }).length;
                return 0
            },
            _getIntermediateChildrenFromNode: function(node) {
                var items = this._itemsGetter(node),
                    that = this;
                if (items && items.length)
                    return $.grep(items, function(item) {
                            return item.hasOwnProperty(that.option("selectedExpr")) && that._selectedGetter(item) === undefined
                        }).length;
                return 0
            },
            _updateChildrenState: function(childNodes, value, $node) {
                var that = this;
                $.each(childNodes, function(_, childNode) {
                    var itemData = that._getSourceItemByKey(that._keyGetter(childNode));
                    that._updateParentField(itemData, value);
                    that._calculateSelectedItemsOption(value, itemData);
                    if (that._itemHasChildren(childNode))
                        that._updateChildrenState(that._itemsGetter(childNode), value)
                });
                if ($node) {
                    var $childrenContainer = $node.find("> ." + NODE_CONTAINER_CLASS);
                    $childrenContainer.find(".dx-checkbox").each(function(_, checkbox) {
                        $(checkbox).dxCheckBox("instance").option("value", value)
                    })
                }
            },
            _updateParentField: function(itemData, value) {
                var node = this._getNodeByKey(this._keyGetter(itemData));
                if (node.parent !== null)
                    this._selectedSetter(node.parent, value)
            },
            _itemEventHandlerImpl: function(initiator, action, actionArgs) {
                var $itemElement = $(initiator).closest("." + NODE_CLASS).find("> ." + ITEM_CLASS);
                actionArgs = $.extend({
                    itemElement: $itemElement,
                    itemData: this._getItemData($itemElement)
                }, actionArgs);
                return action(actionArgs)
            },
            _itemClass: function() {
                return ITEM_CLASS
            },
            _itemDataKey: function() {
                return ITEM_DATA_KEY
            },
            _selectionEnabled: function() {
                return true
            },
            _focusElementClass: function() {
                return NODE_CLASS
            },
            _itemClickHandler: function(e) {
                this._itemJQueryEventHandler(e, "onItemClick");
                this._focusTarget().focus();
                this._focusTarget().focusin()
            },
            _updateItemSelection: function(value, itemElement, suppressOnSelectionChanged, $node) {
                var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement,
                    node = this._getNodeByKey(this._keyGetter(itemData));
                var currentState = this._selectedGetter(node);
                if (currentState === value)
                    return;
                if ($node)
                    $node.find("> .dx-checkbox").dxCheckBox("instance").option("value", value);
                this._selectedSetter(node, value);
                this._selectedSetter(itemData, value);
                this._calculateSelectedItemsOption(value, node);
                if (this.option("selectNodesRecursive"))
                    this._updateParentsAndChildren(node, value, suppressOnSelectionChanged, $node);
                else {
                    var selectedItems = this._updateSelectionItemsOption(this._plainItems);
                    this.option("selectedItems", selectedItems)
                }
                var handler = this.option("onItemSelected");
                if (handler)
                    handler.call(this, {
                        itemData: itemData,
                        node: node
                    })
            },
            _enlargeExpandedItemsOption: function(itemData, expandedItems) {
                if (!this._getItemFromArray(itemData, expandedItems))
                    expandedItems.push(itemData);
                if (itemData.parent)
                    this._enlargeExpandedItemsOption(itemData.parent, expandedItems);
                return expandedItems
            },
            _reduceExpandedItemsOption: function(node, expandedItems) {
                var that = this,
                    nodeKey = that._keyGetter(node);
                $.each(expandedItems, function(i, item) {
                    if (that._keyGetter(item) === nodeKey) {
                        var sourceItem = that._getSourceItemByKey(nodeKey);
                        that._expandedSetter(node, false);
                        that._expandedSetter(sourceItem, false);
                        expandedItems.splice(i, 1);
                        if (that._itemHasChildren(node))
                            $.each(that._itemsGetter(node), function(_, child) {
                                var sourceItemChild = that._getSourceItemByKey(that._keyGetter(child));
                                that._expandedSetter(child, false);
                                that._expandedSetter(sourceItemChild, false);
                                that._reduceExpandedItemsOption(child, expandedItems)
                            })
                    }
                });
                return expandedItems
            },
            _moveFocus: function(location) {
                var FOCUS_UP = "up",
                    FOCUS_DOWN = "down",
                    FOCUS_FIRST = "first",
                    FOCUS_LAST = "last",
                    FOCUS_ENTER = "enter",
                    FOCUS_LEFT = this.option("rtlEnabled") ? "right" : "left",
                    FOCUS_RIGHT = this.option("rtlEnabled") ? "left" : "right",
                    $items = this._nodeElements();
                switch (location) {
                    case FOCUS_UP:
                        this._resetFocusedItem(this._prevItem($items));
                        break;
                    case FOCUS_DOWN:
                        this._resetFocusedItem(this._nextItem($items));
                        break;
                    case FOCUS_FIRST:
                        this._resetFocusedItem($items.first());
                        break;
                    case FOCUS_LAST:
                        this._resetFocusedItem($items.last());
                        break;
                    case FOCUS_RIGHT:
                        this._expandFocusedContainer();
                        break;
                    case FOCUS_LEFT:
                        this._collapseFocusedContainer();
                        break;
                    default:
                        this.callBase.apply(this, arguments);
                        return
                }
            },
            _nodeElements: function() {
                return this.element().find("." + NODE_CLASS).not(":hidden")
            },
            _expandFocusedContainer: function() {
                if (this._$focusedItem.hasClass(IS_LEAF))
                    return;
                this._renderNestedItems(this._$focusedItem.find("> ." + NODE_CONTAINER_CLASS));
                this._$focusedItem.find("." + NODE_CONTAINER_CLASS).eq(0).toggleClass(OPENED_NODE_CONTAINER_CLASS, true);
                this._refreshActiveNode(this._$focusedItem, true)
            },
            _collapseFocusedContainer: function() {
                var collapsedNode,
                    nodeElement = this._$focusedItem.find("." + NODE_CONTAINER_CLASS).eq(0);
                if (!this._$focusedItem.hasClass(IS_LEAF) && nodeElement.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
                    nodeElement.toggleClass(OPENED_NODE_CONTAINER_CLASS, false);
                    collapsedNode = this._$focusedItem
                }
                else {
                    var parentElement = this._$focusedItem.parent("." + NODE_CONTAINER_CLASS);
                    parentElement.toggleClass(OPENED_NODE_CONTAINER_CLASS, false);
                    collapsedNode = parentElement.parent("." + NODE_CLASS).eq(0);
                    if (!collapsedNode.length)
                        collapsedNode = this._$focusedItem
                }
                this._refreshActiveNode(collapsedNode, false)
            },
            _refreshActiveNode: function($node, iconState) {
                this._scrollableContainer.update();
                this._resetFocusedItem($node);
                this._toggleFocusedNodeIcon(iconState)
            },
            _toggleFocusedNodeIcon: function(value) {
                this._$focusedItem.find("." + TOGGLE_ITEM_VISIBILITY_CLASS).eq(0).toggleClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS, value)
            },
            updateDimensions: function() {
                var that = this,
                    deferred = $.Deferred();
                if (that._scrollableContainer)
                    that._scrollableContainer.update().done(function() {
                        deferred.resolveWith(that)
                    });
                else
                    deferred.resolveWith(that);
                return deferred.promise()
            },
            selectItem: function(itemElement) {
                this._updateItemSelection(true, itemElement)
            },
            unselectItem: function(itemElement) {
                this._updateItemSelection(false, itemElement)
            },
            expandItem: function(itemElement) {
                this._renderNestedItems($(itemElement).parent().find("> ." + NODE_CONTAINER_CLASS));
                var itemData = this._getItemData(itemElement),
                    node = this._getNodeByKey(this._keyGetter(itemData)),
                    expandedItems = this._enlargeExpandedItemsOption(node, this.option("expandedItems"));
                var handler = this.option("onItemExpanded");
                if (handler)
                    handler.call(this, {
                        itemData: itemData,
                        node: node
                    });
                this.option("expandedItems", expandedItems)
            },
            collapseItem: function(itemElement) {
                var itemData = this._getItemData(itemElement),
                    node = this._getNodeByKey(this._keyGetter(itemData)),
                    expandedItems = this._reduceExpandedItemsOption(node, this.option("expandedItems"));
                var handler = this.option("onItemCollapsed");
                if (handler)
                    handler.call(this, {
                        itemData: itemData,
                        node: node
                    });
                this.option("expandedItems", expandedItems)
            },
            getNodes: function() {
                return this._nodes
            }
        }));
        ui.dxTreeView.__internals = {
            WIDGET_CLASS: WIDGET_CLASS,
            NODE_CONTAINER_CLASS: NODE_CONTAINER_CLASS,
            OPENED_NODE_CONTAINER_CLASS: OPENED_NODE_CONTAINER_CLASS,
            ITEM_CLASS: ITEM_CLASS,
            FOCUSED_ITEM_CLASS: FOCUSED_ITEM_CLASS,
            NODE_CLASS: NODE_CLASS,
            FOCUSED_NODE_CLASS: FOCUSED_NODE_CLASS,
            ITEM_WITH_CHECKBOX_CLASS: ITEM_WITH_CHECKBOX_CLASS,
            ITEM_DATA_KEY: ITEM_DATA_KEY,
            IS_LEAF: IS_LEAF,
            TOGGLE_ITEM_VISIBILITY_CLASS: TOGGLE_ITEM_VISIBILITY_CLASS,
            TOGGLE_ITEM_VISIBILITY_OPENED_CLASS: TOGGLE_ITEM_VISIBILITY_OPENED_CLASS,
            SELECT_ALL_ITEM_CLASS: SELECT_ALL_ITEM_CLASS,
            scrollableContainerUpdatedOnInitAccessor: function(value) {
                if (value)
                    scrollableContainerUpdatedOnInit = value;
                return scrollableContainerUpdatedOnInit
            }
        }
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils;
        var DATAGRID_ROW_SELECTOR = ".dx-row",
            DATAGRID_DEPRECATED_TEMPLATE_WARNING = "Specifying grid templates with the name of a jQuery selector is now deprecated. Instead, use the jQuery object that references this selector.";
        var ModuleItem = DX.Class.inherit({
                ctor: function(component) {
                    var that = this;
                    that.component = component;
                    that._actions = {};
                    that._actionConfigs = {};
                    $.each(this.callbackNames() || [], function(index, name) {
                        var flags = that.callbackFlags(name);
                        that[this] = $.Callbacks(flags)
                    })
                },
                callbackNames: function(){},
                callbackFlags: function(name){},
                publicMethods: function(){},
                init: function(){},
                option: function() {
                    return this.component.option.apply(this.component, arguments)
                },
                on: function() {
                    return this.component.on.apply(this.component, arguments)
                },
                off: function() {
                    return this.component.off.apply(this.component, arguments)
                },
                optionChanged: function(args) {
                    args.name in this._actions && this.createAction(args.name, this._actionConfigs[args.name])
                },
                getController: function(name) {
                    return this.component._controllers[name]
                },
                createAction: function(actionName, config) {
                    var action;
                    if (utils.isFunction(actionName)) {
                        action = this.component._createAction($.proxy(actionName, this), config);
                        return function(e) {
                                action({jQueryEvent: e})
                            }
                    }
                    else {
                        this._actions[actionName] = this.component._createActionByOption(actionName, config);
                        this._actionConfigs[actionName] = config
                    }
                },
                executeAction: function(actionName, options) {
                    var action = this._actions[actionName];
                    return action && action(options)
                },
                dispose: function() {
                    var that = this;
                    $.each(that.callbackNames() || [], function() {
                        that[this].empty()
                    })
                }
            });
        var Controller = ModuleItem;
        var ViewController = Controller.inherit({
                getView: function(name) {
                    return this.component._views[name]
                },
                getViews: function() {
                    return this.component._views
                }
            });
        var View = ModuleItem.inherit({
                element: function() {
                    return this._$element
                },
                _renderCore: function(options){},
                _resizeCore: function(){},
                _afterRender: function($root){},
                _parentElement: function() {
                    return this._$parent
                },
                ctor: function(component) {
                    this.callBase(component);
                    this.renderCompleted = $.Callbacks();
                    this.resizeCompleted = $.Callbacks()
                },
                isVisible: function() {
                    return true
                },
                getTemplate: function(name) {
                    return this.component._getTemplate(name)
                },
                render: function($parent, options) {
                    var $element = this._$element,
                        isVisible = this.isVisible();
                    this._$parent = $parent;
                    if (!$element)
                        $element = this._$element = $('<div />').appendTo($parent);
                    $element.toggle(isVisible);
                    if (isVisible) {
                        this._renderCore(options);
                        this._afterRender($parent);
                        this.renderCompleted.fire()
                    }
                },
                resize: function() {
                    this.isResizing = true;
                    this._resizeCore();
                    this.resizeCompleted.fire();
                    this.isResizing = false
                },
                focus: function() {
                    this.element().focus()
                }
            });
        var processModules = function(that, modules) {
                var controllerTypes = {},
                    viewTypes = {};
                $.each(modules, function() {
                    var controllers = this.controllers,
                        moduleName = this.name,
                        views = this.views;
                    controllers && $.each(controllers, function(name, type) {
                        if (controllerTypes[name])
                            throw DX.Error("E1001", moduleName, name);
                        else if (!(type && type.subclassOf && type.subclassOf(Controller))) {
                            type.subclassOf(Controller);
                            throw DX.Error("E1002", moduleName, name);
                        }
                        controllerTypes[name] = type
                    });
                    views && $.each(views, function(name, type) {
                        if (viewTypes[name])
                            throw DX.Error("E1003", moduleName, name);
                        else if (!(type && type.subclassOf && type.subclassOf(View)))
                            throw DX.Error("E1004", moduleName, name);
                        viewTypes[name] = type
                    })
                });
                $.each(modules, function() {
                    var extenders = this.extenders;
                    if (extenders) {
                        extenders.controllers && $.each(extenders.controllers, function(name, extender) {
                            if (controllerTypes[name])
                                controllerTypes[name] = controllerTypes[name].inherit(extender)
                        });
                        extenders.views && $.each(extenders.views, function(name, extender) {
                            if (viewTypes[name])
                                viewTypes[name] = viewTypes[name].inherit(extender)
                        })
                    }
                });
                var registerPublicMethods = function(that, name, moduleItem) {
                        var publicMethods = moduleItem.publicMethods();
                        if (publicMethods)
                            $.each(publicMethods, function(index, methodName) {
                                if (moduleItem[methodName])
                                    if (!that[methodName])
                                        that[methodName] = function() {
                                            return moduleItem[methodName].apply(moduleItem, arguments)
                                        };
                                    else
                                        throw DX.Error("E1005", methodName);
                                else
                                    throw DX.Error("E1006", name, methodName);
                            })
                    };
                var createModuleItems = function(moduleTypes) {
                        var moduleItems = {};
                        $.each(moduleTypes, function(name, moduleType) {
                            var moduleItem = new moduleType(that);
                            moduleItem.name = name;
                            registerPublicMethods(that, name, moduleItem);
                            moduleItems[name] = moduleItem
                        });
                        return moduleItems
                    };
                that._controllers = createModuleItems(controllerTypes);
                that._views = createModuleItems(viewTypes)
            };
        var callModuleItemsMethod = function(that, methodName, args) {
                args = args || [];
                if (that._controllers)
                    $.each(that._controllers, function() {
                        this[methodName] && this[methodName].apply(this, args)
                    });
                if (that._views)
                    $.each(that._views, function() {
                        this[methodName] && this[methodName].apply(this, args)
                    })
            };
        DX.registerComponent("dxDataGrid", ui, ui.Widget.inherit({
            _activeStateUnit: DATAGRID_ROW_SELECTOR,
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    rowClick: {
                        since: "14.2",
                        alias: "onRowClick"
                    },
                    cellClick: {
                        since: "14.2",
                        alias: "onCellClick"
                    },
                    cellHoverChanged: {
                        since: "14.2",
                        alias: "onCellHoverChanged"
                    },
                    cellPrepared: {
                        since: "14.2",
                        message: "The cellPrepared option is deprecated. Use the onCellPrepared option instead. For further information, see http://js.devexpress.com/Documentation/ApiReference/UI_Widgets/dxDataGrid/Configuration/?version=14_2#onCellPrepared"
                    },
                    rowPrepared: {
                        since: "14.2",
                        message: "The rowPrepared option is deprecated. Use the onRowPrepared option instead. For further information, see http://js.devexpress.com/Documentation/ApiReference/UI_Widgets/dxDataGrid/Configuration/?version=14_2#onRowPrepared"
                    },
                    selectionChanged: {
                        since: "14.2",
                        alias: "onSelectionChanged"
                    },
                    "editing.texts.recoverRow": {
                        since: "14.1",
                        alias: "editing.texts.undeleteRow"
                    },
                    dataErrorOccurred: {
                        since: "14.2",
                        alias: "onDataErrorOccurred"
                    },
                    initNewRow: {
                        since: "14.2",
                        alias: "onInitNewRow"
                    },
                    rowInserting: {
                        since: "14.2",
                        alias: "onRowInserting"
                    },
                    rowInserted: {
                        since: "14.2",
                        alias: "onRowInserted"
                    },
                    editingStart: {
                        since: "14.2",
                        alias: "onEditingStart"
                    },
                    rowUpdating: {
                        since: "14.2",
                        alias: "onRowUpdating"
                    },
                    rowUpdated: {
                        since: "14.2",
                        alias: "onRowUpdated"
                    },
                    rowRemoving: {
                        since: "14.2",
                        alias: "onRowRemoving"
                    },
                    rowRemoved: {
                        since: "14.2",
                        alias: "onRowRemoved"
                    },
                    editorPreparing: {
                        since: "14.2",
                        message: "The editorPreparing option is deprecated. Use the onEditorPreparing option instead. For further information, see http://js.devexpress.com/Documentation/ApiReference/UI_Widgets/dxDataGrid/Configuration/?version=14_2#onEditorPreparing"
                    },
                    editorPrepared: {
                        since: "14.2",
                        message: "The editorPrepared option is deprecated. Use the onEditorPrepared option instead. For further information, see http://js.devexpress.com/Documentation/ApiReference/UI_Widgets/dxDataGrid/Configuration/?version=14_2#onEditorPrepared"
                    },
                    contentReadyAction: {
                        since: "14.2",
                        alias: "onContentReady"
                    }
                })
            },
            _setDefaultOptions: function() {
                var that = this;
                that.callBase();
                $.each(ui.dxDataGrid.modules, function() {
                    if ($.isFunction(this.defaultOptions))
                        that.option(this.defaultOptions())
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "ios"},
                            options: {showRowLines: true}
                        }, {
                            device: function() {
                                return DevExpress.browser.webkit
                            },
                            options: {loadPanel: {animation: {show: {
                                            easing: 'cubic-bezier(1, 0, 1, 0)',
                                            duration: 500,
                                            from: {opacity: 0},
                                            to: {opacity: 1}
                                        }}}}
                        }, {
                            device: function() {
                                return DX.devices.real().ios
                            },
                            options: {loadingTimeout: 30}
                        }])
            },
            _init: function() {
                var that = this;
                that.callBase();
                processModules(that, ui.dxDataGrid.modules);
                callModuleItemsMethod(that, 'init')
            },
            _clean: $.noop,
            _optionChanged: function(args) {
                var that = this;
                that.callBase(args);
                callModuleItemsMethod(that, 'optionChanged', [args])
            },
            _dimensionChanged: function() {
                this.resize()
            },
            _visibilityChanged: function() {
                this.resize()
            },
            _renderContentImpl: function() {
                var that = this;
                that.getView('gridView').render(that.element())
            },
            _renderContent: function() {
                this._renderContentImpl()
            },
            _getTemplate: function(templateName) {
                var template = templateName;
                if (DX.utils.isString(template) && template[0] === '#') {
                    template = $(templateName);
                    DX.utils.logger.warn(DATAGRID_DEPRECATED_TEMPLATE_WARNING)
                }
                return this.callBase(template)
            },
            _dispose: function() {
                var that = this;
                that.callBase();
                callModuleItemsMethod(that, 'dispose')
            },
            beginUpdate: function() {
                var that = this;
                that.callBase();
                callModuleItemsMethod(that, 'beginUpdate')
            },
            endUpdate: function() {
                var that = this;
                callModuleItemsMethod(that, 'endUpdate');
                that.callBase()
            },
            getController: function(name) {
                return this._controllers[name]
            },
            getView: function(name) {
                return this._views[name]
            }
        }));
        var MAX_EQUAL_KEYS_LEVEL = 3;
        $.extend(ui.dxDataGrid, {
            __internals: {},
            modules: [],
            View: View,
            ViewController: ViewController,
            Controller: Controller,
            registerModule: function(name, module) {
                var modules = this.modules,
                    i;
                for (i = 0; i < modules.length; i++)
                    if (modules[i].name === name)
                        return;
                module.name = name;
                modules.push(module)
            },
            unregisterModule: function(name) {
                this.modules = $.grep(this.modules, function(module) {
                    return module.name !== name
                })
            },
            processModules: processModules,
            formatValue: function(value, options) {
                var valueText = DX.formatHelper.format(value, options.format, options.precision) || value && value.toString() || '',
                    formatObject = {
                        value: value,
                        valueText: options.getDisplayFormat ? options.getDisplayFormat(valueText) : valueText
                    };
                return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText
            },
            getSummaryText: function(summaryItem, summaryTexts) {
                var displayFormat = summaryItem.displayFormat || summaryTexts[summaryItem.summaryType + (summaryItem.columnCaption ? "OtherColumn" : "")];
                return this.formatValue(summaryItem.value, {
                        format: summaryItem.valueFormat,
                        precision: summaryItem.precision,
                        getDisplayFormat: function(valueText) {
                            return displayFormat ? utils.stringFormat(displayFormat, valueText, summaryItem.columnCaption) : valueText
                        },
                        customizeText: summaryItem.customizeText
                    })
            },
            equalKeys: function(key1, key2, level) {
                var propertyName,
                    i;
                level = level || 0;
                if (level < MAX_EQUAL_KEYS_LEVEL)
                    if (utils.isObject(key1) && utils.isObject(key2)) {
                        for (propertyName in key1)
                            if (key1.hasOwnProperty(propertyName) && !ui.dxDataGrid.equalKeys(key1[propertyName], key2[propertyName], level + 1))
                                return false;
                        for (propertyName in key2)
                            if (!(propertyName in key1))
                                return false;
                        return true
                    }
                    else if (utils.isArray(key1) && utils.isArray(key2)) {
                        if (key1.length !== key2.length)
                            return false;
                        for (i = 0; i < key1.length; i++)
                            if (!ui.dxDataGrid.equalKeys(key1[i], key2[i], level + 1))
                                return false;
                        return true
                    }
                    else if (utils.isDate(key1) && utils.isDate(key2))
                        return key1.getTime() === key2.getTime();
                    else
                        return key1 === key2;
                return true
            },
            getIndexByKey: function(key, items) {
                var index = -1;
                $.each(items, function(i, item) {
                    if (ui.dxDataGrid.equalKeys(key, item.key)) {
                        index = i;
                        return false
                    }
                });
                return index
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.stateStoring.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        dataGrid.StateStoringController = dataGrid.ViewController.inherit(function() {
            var getStorage = function(options) {
                    var storage = options.type === 'sessionStorage' ? sessionStorage : localStorage;
                    if (!storage)
                        throw new Error("E1007");
                    return storage
                };
            var getUniqueStorageKey = function(options) {
                    return 'dx_datagrid_' + (utils.isDefined(options.storageKey) ? options.storageKey : 'storage')
                };
            var dateReviver = function(key, value) {
                    var date;
                    if (typeof value === 'string') {
                        date = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                        if (date)
                            return new Date(Date.UTC(+date[1], +date[2] - 1, +date[3], +date[4], +date[5], +date[6]))
                    }
                    return value
                };
            var processLoadState = function(that) {
                    var columnsController = that.getController('columns'),
                        selectionController = that.getController('selection'),
                        dataController = that.getController('data'),
                        pagerView = that.getView('pagerView');
                    if (columnsController)
                        columnsController.columnsChanged.add(function() {
                            $.extend(that._state, {columns: columnsController.getUserState()});
                            that.isEnabled() && that.save()
                        });
                    if (selectionController)
                        selectionController.selectionChanged.add(function(keys) {
                            $.extend(that._state, {selectedRowKeys: keys});
                            that.isEnabled() && that.save()
                        });
                    if (dataController)
                        dataController.changed.add(function() {
                            $.extend(that._state, {
                                searchText: that.option("searchPanel.text"),
                                pageIndex: dataController.pageIndex(),
                                pageSize: dataController.pageSize(),
                                allowedPageSizes: pagerView ? pagerView.getPageSizes() : undefined
                            });
                            that.isEnabled() && that.save()
                        })
                };
            var applyState = function(that, state) {
                    var allowedPageSizes = state.allowedPageSizes,
                        searchText = state.searchText,
                        selectedRowKeys = state.selectedRowKeys,
                        columnsController = that.getController('columns'),
                        dataController = that.getController('data');
                    that.component.beginUpdate();
                    if (columnsController)
                        columnsController.setUserState(state.columns);
                    that.option('selectedRowKeys', selectedRowKeys || []);
                    if (allowedPageSizes && that.option('pager.allowedPageSizes') === 'auto')
                        that.option('pager').allowedPageSizes = allowedPageSizes;
                    that.option('searchPanel.text', searchText || '');
                    that.option('paging', {
                        enabled: that.option('paging.enabled'),
                        pageIndex: state.pageIndex,
                        pageSize: state.pageSize || 20
                    });
                    that.component.endUpdate()
                };
            return {
                    _loadState: function() {
                        var options = this.option('stateStoring');
                        if (options.type === 'custom')
                            return options.customLoad && options.customLoad();
                        try {
                            return JSON.parse(getStorage(options).getItem(getUniqueStorageKey(options)), dateReviver)
                        }
                        catch(e) {
                            DX.utils.logger.error(e.message)
                        }
                    },
                    _saveState: function(state) {
                        var options = this.option('stateStoring');
                        if (options.type === 'custom') {
                            options.customSave && options.customSave(state);
                            return
                        }
                        try {
                            getStorage(options).setItem(getUniqueStorageKey(options), JSON.stringify(state))
                        }
                        catch(e) {}
                    },
                    publicMethods: function() {
                        return ['state']
                    },
                    isEnabled: function() {
                        return this.option('stateStoring.enabled')
                    },
                    init: function() {
                        var that = this;
                        that._state = {};
                        that._isLoaded = false;
                        that._isLoading = false;
                        that._windowUnloadHandler = function() {
                            if (that._savingTimeoutID !== undefined)
                                that._saveState(that.state())
                        },
                        $(window).on('unload', that._windowUnloadHandler);
                        processLoadState(that)
                    },
                    isLoaded: function() {
                        return this._isLoaded
                    },
                    isLoading: function() {
                        return this._isLoading
                    },
                    load: function() {
                        var that = this,
                            loadResult;
                        that._isLoading = true;
                        loadResult = that._loadState();
                        if (!loadResult || !$.isFunction(loadResult.done))
                            loadResult = $.Deferred().resolve(loadResult);
                        loadResult.done(function(state) {
                            that._isLoaded = true;
                            that._isLoading = false;
                            that.state(state)
                        });
                        return loadResult
                    },
                    state: function(state) {
                        var that = this;
                        if (!state)
                            return $.extend(true, {}, that._state);
                        else {
                            $.extend(that._state, state);
                            applyState(that, $.extend({}, that._state))
                        }
                    },
                    save: function() {
                        var that = this;
                        clearTimeout(that._savingTimeoutID);
                        that._savingTimeoutID = setTimeout(function() {
                            that._saveState(that.state());
                            that._savingTimeoutID = undefined
                        }, that.option('stateStoring.savingTimeout'))
                    },
                    dispose: function() {
                        clearTimeout(this._savingTimeoutID);
                        $(window).off('unload', this._windowUnloadHandler)
                    }
                }
        }());
        dataGrid.registerModule('stateStoring', {
            defaultOptions: function() {
                return {stateStoring: {
                            enabled: false,
                            storageKey: null,
                            type: 'localStorage',
                            customLoad: null,
                            customSave: null,
                            savingTimeout: 2000
                        }}
            },
            controllers: {stateStoring: ui.dxDataGrid.StateStoringController},
            extenders: {controllers: {
                    columns: {getVisibleColumns: function() {
                            var visibleColumns = this.callBase();
                            return this.getController('stateStoring').isLoading() ? [] : visibleColumns
                        }},
                    data: {
                        _refreshDataSource: function() {
                            var that = this,
                                callBase = that.callBase,
                                stateStoringController = that.getController('stateStoring');
                            if (stateStoringController.isEnabled() && !stateStoringController.isLoaded())
                                stateStoringController.load().done(function() {
                                    callBase.call(that)
                                });
                            else
                                callBase.call(that)
                        },
                        isLoading: function() {
                            var that = this,
                                stateStoringController = that.getController('stateStoring');
                            return this.callBase() || stateStoringController.isLoading()
                        }
                    }
                }}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnsController.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            utils = DX.utils,
            dataUtils = DX.data.utils,
            normalizeSortingInfo = dataUtils.normalizeSortingInfo,
            isDefined = utils.isDefined;
        var USER_STATE_FIELD_NAMES = ['visibleIndex', 'dataField', 'dataType', 'width', 'visibleWidth', 'visible', 'sortOrder', 'sortIndex', 'groupIndex', 'filterValue', 'selectedFilterOperation'];
        dataGrid.checkChanges = function(changes, changeNames) {
            var changesWithChangeNamesCount = 0,
                i;
            for (i = 0; i < changeNames.length; i++)
                if (changes[changeNames[i]])
                    changesWithChangeNamesCount++;
            return changes.length && changes.length === changesWithChangeNamesCount
        };
        var ColumnsController = dataGrid.Controller.inherit(function() {
                var DEFAULT_COLUMN_OPTIONS = {
                        visible: true,
                        showInColumnChooser: true
                    },
                    DATATYPE_OPERATIONS = {
                        number: ['=', '<>', '<', '>', '<=', '>='],
                        string: ['contains', 'notcontains', 'startswith', 'endswith', '=', '<>'],
                        date: ['=', '<>', '<', '>', '<=', '>=']
                    },
                    GROUP_LOCATION = 'group',
                    COLUMN_CHOOSER_LOCATION = 'columnChooser';
                var convertNameToCaption = function(name) {
                        var captionList = [],
                            i,
                            char,
                            isPrevCharNewWord = false,
                            isNewWord = false;
                        for (i = 0; i < name.length; i++) {
                            char = name.charAt(i);
                            isNewWord = char === char.toUpperCase() || char in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
                            if (char === '_' || char === '.') {
                                char = ' ';
                                isNewWord = true
                            }
                            else if (i === 0) {
                                char = char.toUpperCase();
                                isNewWord = true
                            }
                            else if (!isPrevCharNewWord && isNewWord)
                                if (captionList.length > 0)
                                    captionList.push(' ');
                            captionList.push(char);
                            isPrevCharNewWord = isNewWord
                        }
                        return captionList.join('')
                    };
                var createColumn = function(that, columnOptions) {
                        var result,
                            commonColumnOptions,
                            calculatedColumnOptions;
                        if (columnOptions) {
                            if (utils.isString(columnOptions))
                                columnOptions = {dataField: columnOptions};
                            if (columnOptions.command)
                                return $.extend(true, {}, columnOptions);
                            else {
                                commonColumnOptions = that.getCommonSettings();
                                calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions);
                                return $.extend(true, {}, DEFAULT_COLUMN_OPTIONS, commonColumnOptions, calculatedColumnOptions, columnOptions)
                            }
                        }
                    };
                var createColumnsFromOptions = function(that, columnsOptions) {
                        var result = [];
                        if (columnsOptions)
                            $.each(columnsOptions, function(index, value) {
                                var column = createColumn(that, value);
                                if (column)
                                    result.push(column)
                            });
                        return result
                    };
                var getValueDataType = function(value) {
                        var dataType = $.type(value);
                        if (dataType !== 'string' && dataType !== 'boolean' && dataType !== 'number' && dataType !== 'date')
                            dataType = undefined;
                        return dataType
                    };
                var getSerializationFormat = function(dataType, value) {
                        switch (dataType) {
                            case'date':
                                if (utils.isNumber(value))
                                    return 'number';
                                else if (utils.isString(value))
                                    return 'yyyy/MM/dd';
                            case'number':
                                if (utils.isString(value))
                                    return 'string'
                        }
                    };
                var updateSerializers = function(options, dataType) {
                        if (!options.deserializeValue) {
                            if (dataType === 'date') {
                                options.deserializeValue = function(value) {
                                    var serializationFormat = this.serializationFormat,
                                        parsedValue;
                                    if (!serializationFormat || serializationFormat === 'number' || serializationFormat === 'yyyy/MM/dd') {
                                        parsedValue = !utils.isDate(value) && Date.parse(value);
                                        return parsedValue ? new Date(parsedValue) : value
                                    }
                                    else if (value !== undefined)
                                        return Globalize.parseDate(value, serializationFormat)
                                };
                                options.serializeValue = function(value) {
                                    var serializationFormat = this.serializationFormat;
                                    if (serializationFormat === 'number')
                                        return value && value.valueOf && value.valueOf();
                                    else if (serializationFormat)
                                        return Globalize.format(value, serializationFormat);
                                    else
                                        return value
                                }
                            }
                            if (dataType === 'number') {
                                options.deserializeValue = function(value) {
                                    return value ? Number(value) : value
                                };
                                options.serializeValue = function(value) {
                                    return value ? value.toString() : value
                                }
                            }
                        }
                    };
                var getAlignmentByDataType = function(dataType, isRTL) {
                        switch (dataType) {
                            case'number':
                                return 'right';
                            case'boolean':
                                return 'center';
                            case'date':
                                return 'left';
                            default:
                                return isRTL ? 'right' : 'left'
                        }
                    };
                var getFormatByDataType = function(dataType) {
                        switch (dataType) {
                            case"date":
                                return "shortDate"
                        }
                    };
                var getCustomizeTextByDataType = function(dataType) {
                        if (dataType === 'boolean')
                            return function(e) {
                                    if (e.value === true)
                                        return this.trueText || 'true';
                                    else if (e.value === false)
                                        return this.falseText || 'false';
                                    else
                                        return e.valueText || ''
                                }
                    };
                var createColumnsFromDataSource = function(that, dataSource) {
                        var firstItems = getFirstItems(dataSource),
                            fieldName,
                            processedFields = {},
                            i,
                            result = [];
                        for (i = 0; i < firstItems.length; i++)
                            firstItems[i] && $.each(firstItems[i], function(fieldName) {
                                processedFields[fieldName] = true
                            });
                        $.each(processedFields, function(fieldName) {
                            if (fieldName.indexOf('__') !== 0) {
                                var column = createColumn(that, fieldName);
                                result.push(column)
                            }
                        });
                        return result
                    };
                var equalSortParameters = function(sortParameters1, sortParameters2) {
                        var i;
                        if ($.isArray(sortParameters1) && $.isArray(sortParameters2)) {
                            if (sortParameters1.length !== sortParameters2.length)
                                return false;
                            else
                                for (i = 0; i < sortParameters1.length; i++)
                                    if (sortParameters1[i].selector !== sortParameters2[i].selector || sortParameters1[i].desc !== sortParameters2[i].desc || !sortParameters1[i].isExpanded !== !sortParameters2[i].isExpanded)
                                        return false;
                            return true
                        }
                        else
                            return (!sortParameters1 || !sortParameters1.length) === (!sortParameters2 || !sortParameters2.length)
                    };
                var getFirstItems = function(dataSource) {
                        var groupsCount,
                            item,
                            items = [];
                        var getFirstItemsCore = function(items, groupsCount) {
                                var i,
                                    childItems;
                                if (!items || !groupsCount)
                                    return items;
                                for (i = 0; i < items.length; i++) {
                                    childItems = getFirstItemsCore(items[i].items, groupsCount - 1);
                                    if (childItems && childItems.length)
                                        return childItems
                                }
                            };
                        if (dataSource && dataSource.items().length > 0) {
                            groupsCount = normalizeSortingInfo(dataSource.group() || []).length;
                            items = getFirstItemsCore(dataSource.items(), groupsCount) || []
                        }
                        return items
                    };
                var updateColumnIndexes = function(that) {
                        $.each(that._columns, function(index, column) {
                            column.index = index
                        });
                        $.each(that._commandColumns, function(index, column) {
                            column.index = -(index + 1)
                        })
                    };
                var updateColumnParameterIndexes = function(that, indexParameterName, currentColumn) {
                        var indexedColumns = {},
                            parameterIndex = 0;
                        $.each(that._columns, function(index, column) {
                            var index = column[indexParameterName];
                            if (isDefined(index)) {
                                indexedColumns[index] = indexedColumns[index] || [];
                                if (column === currentColumn)
                                    indexedColumns[index].unshift(column);
                                else
                                    indexedColumns[index].push(column);
                                delete column[indexParameterName]
                            }
                        });
                        $.each(indexedColumns, function(index, columns) {
                            $.each(columns, function() {
                                if (index >= 0)
                                    this[indexParameterName] = parameterIndex++
                            })
                        });
                        return parameterIndex
                    };
                var updateColumnGroupIndexes = function(that, currentColumn) {
                        var indexPropertyName = 'groupIndex',
                            groupIndex = updateColumnParameterIndexes(that, indexPropertyName, currentColumn);
                        $.each(that._columns, function(index, column) {
                            if (!isDefined(column[indexPropertyName]) && column.grouped)
                                column[indexPropertyName] = groupIndex++;
                            delete column.grouped
                        })
                    };
                var updateColumnSortIndexes = function(that, currentColumn) {
                        $.each(that._columns, function(index, column) {
                            if (isDefined(column.sortIndex) && !isSortOrderValid(column.sortOrder))
                                delete column.sortIndex
                        });
                        var sortIndex = updateColumnParameterIndexes(that, 'sortIndex', currentColumn);
                        $.each(that._columns, function(index, column) {
                            if (!isDefined(column.sortIndex) && !isDefined(column.groupIndex) && isSortOrderValid(column.sortOrder))
                                column.sortIndex = sortIndex++
                        })
                    };
                var updateColumnVisibleIndexes = function(that, currentColumn) {
                        var indexPropertyName = 'visibleIndex',
                            visibleIndex = updateColumnParameterIndexes(that, indexPropertyName, currentColumn);
                        $.each(that._columns, function(index, column) {
                            if (!isDefined(column[indexPropertyName]))
                                column[indexPropertyName] = visibleIndex++
                        })
                    };
                var getColumnIndexByVisibleIndex = function(that, visibleIndex, location) {
                        var columns = location === GROUP_LOCATION ? that.getGroupColumns() : location === COLUMN_CHOOSER_LOCATION ? that.getHiddenColumns() : that.getVisibleColumns(),
                            column = columns[visibleIndex];
                        return column && isDefined(column.index) ? column.index : -1
                    };
                var moveColumnToGroup = function(that, column, groupIndex) {
                        var groupColumns = that.getGroupColumns(),
                            i;
                        if (groupIndex >= 0) {
                            for (i = 0; i < groupColumns.length; i++)
                                if (groupColumns[i].groupIndex >= groupIndex)
                                    groupColumns[i].groupIndex++
                        }
                        else {
                            groupIndex = 0;
                            for (i = 0; i < groupColumns.length; i++)
                                groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1)
                        }
                        column.groupIndex = groupIndex
                    };
                var applyUserState = function(that) {
                        var columnsUserState = that._columnsUserState,
                            columns = that._columns,
                            resultColumns = [],
                            column,
                            i;
                        if (columnsUserState) {
                            if (columns.length !== columnsUserState.length)
                                return;
                            for (i = 0; i < columnsUserState.length; i++) {
                                column = isDefined(columnsUserState[i].initialIndex) ? columns[columnsUserState[i].initialIndex] : columns[i];
                                if (column && columnsUserState[i].dataField === column.dataField && columnsUserState[i].name === column.name) {
                                    column = $.extend({}, column);
                                    $.each(USER_STATE_FIELD_NAMES, function(index, fieldName) {
                                        if (fieldName === 'dataType')
                                            column[fieldName] = column[fieldName] || columnsUserState[i][fieldName];
                                        else
                                            column[fieldName] = columnsUserState[i][fieldName]
                                    });
                                    resultColumns.push(column)
                                }
                                else
                                    return
                            }
                            assignColumns(that, resultColumns)
                        }
                    };
                var updateIndexes = function(that, column) {
                        updateColumnIndexes(that);
                        updateColumnGroupIndexes(that, column);
                        updateColumnSortIndexes(that, column);
                        updateColumnVisibleIndexes(that, column)
                    };
                var isLocalDataSource = function(dataSource) {
                        return dataSource && dataSource.store && dataSource.store() instanceof DX.data.ArrayStore
                    };
                var assignColumns = function(that, columns) {
                        that._columns = columns;
                        that._visibleColumns = undefined;
                        that._updateColumnDataTypes()
                    };
                var updateColumnChanges = function(that, changeType, optionName, columnIndex) {
                        var columnChanges = that._columnChanges || {
                                optionNames: {length: 0},
                                changeTypes: {length: 0},
                                columnIndex: columnIndex
                            };
                        optionName = optionName || 'all';
                        var changeTypes = columnChanges.changeTypes;
                        if (changeType && !changeTypes[changeType]) {
                            changeTypes[changeType] = true;
                            changeTypes.length++
                        }
                        var optionNames = columnChanges.optionNames;
                        if (optionName && !optionNames[optionName]) {
                            optionNames[optionName] = true;
                            optionNames.length++
                        }
                        if (columnIndex === undefined || columnIndex !== columnChanges.columnIndex)
                            delete columnChanges.columnIndex;
                        that._columnChanges = columnChanges;
                        that._visibleColumns = undefined
                    };
                var fireColumnsChanged = function(that) {
                        var onColumnsChanging = that.option("onColumnsChanging"),
                            columnChanges = that._columnChanges;
                        if (that.isInitialized() && !that._updateLockCount && columnChanges) {
                            if (onColumnsChanging) {
                                that._updateLockCount++;
                                onColumnsChanging($.extend({component: that.component}, columnChanges));
                                that._updateLockCount--
                            }
                            that._columnChanges = undefined;
                            that.columnsChanged.fire(columnChanges)
                        }
                    };
                var columnOptionCore = function(that, column, optionName, value, notFireEvent) {
                        var optionGetter = dataUtils.compileGetter(optionName),
                            changeType;
                        if (arguments.length === 3)
                            return optionGetter(column, {functionsAsIs: true});
                        if (optionGetter(column, {functionsAsIs: true}) !== value) {
                            if (optionName === 'groupIndex')
                                changeType = 'grouping';
                            else if (optionName === 'sortIndex' || optionName === 'sortOrder')
                                changeType = 'sorting';
                            else
                                changeType = 'columns';
                            dataUtils.compileSetter(optionName)(column, value, {functionsAsIs: true});
                            if (!notFireEvent)
                                updateColumnChanges(that, changeType, optionName, column.index)
                        }
                    };
                var isSortOrderValid = function(sortOrder) {
                        return sortOrder === 'asc' || sortOrder === 'desc'
                    };
                var addExpandColumn = function(that) {
                        that.addCommandColumn({
                            command: 'expand',
                            width: 'auto',
                            cssClass: 'dx-command-expand',
                            allowEditing: false,
                            allowGrouping: false,
                            allowSorting: false,
                            allowResizing: false,
                            allowReordering: false,
                            allowHiding: false
                        })
                    };
                return {
                        init: function() {
                            var that = this,
                                columns = that.option('columns');
                            that._updateLockCount = that._updateLockCount || 0;
                            that._commandColumns = that._commandColumns || [];
                            addExpandColumn(that);
                            assignColumns(that, columns ? createColumnsFromOptions(that, columns) : []);
                            that._isColumnsFromOptions = !!columns;
                            if (that._isColumnsFromOptions)
                                applyUserState(that);
                            else
                                assignColumns(that, that._columnsUserState ? createColumnsFromOptions(that, that._columnsUserState) : that._columns);
                            if (that._dataSourceApplied)
                                that.applyDataSource(that._dataSource, true);
                            else
                                updateIndexes(that)
                        },
                        callbackNames: function() {
                            return ['columnsChanged']
                        },
                        optionChanged: function(args) {
                            switch (args.name) {
                                case'columns':
                                case'commonColumnSettings':
                                case'columnAutoWidth':
                                case'allowColumnResizing':
                                case'allowColumnReordering':
                                case'grouping':
                                case'groupPanel':
                                case'regenerateColumnsByVisibleItems':
                                case'customizeColumns':
                                case'editing':
                                case'rtlEnabled':
                                    this._columnsUserState = this.getUserState();
                                    this.init();
                                    break
                            }
                        },
                        publicMethods: function() {
                            return ['addColumn', 'columnOption', 'columnCount', 'clearSorting', 'clearGrouping']
                        },
                        applyDataSource: function(dataSource, forceApplying) {
                            var that = this,
                                isDataSourceLoaded = dataSource && dataSource.isLoaded(),
                                applyingComplete;
                            that._dataSource = dataSource;
                            if (!that._dataSourceApplied || that._dataSourceColumnsCount === 0 || forceApplying || that.option('regenerateColumnsByVisibleItems'))
                                if (isDataSourceLoaded) {
                                    if (!that._isColumnsFromOptions) {
                                        assignColumns(that, createColumnsFromDataSource(that, dataSource));
                                        that._dataSourceColumnsCount = that._columns.length;
                                        applyUserState(that)
                                    }
                                    return that.updateColumns(dataSource)
                                }
                        },
                        reset: function() {
                            this._dataSourceApplied = false;
                            this._dataSourceColumnsCount = undefined;
                            this._columnsUserState = this.getUserState();
                            this.init()
                        },
                        isInitialized: function() {
                            return !!this._columns.length
                        },
                        isDataSourceApplied: function() {
                            return this._dataSourceApplied
                        },
                        beginUpdate: function() {
                            this._updateLockCount++
                        },
                        endUpdate: function() {
                            var that = this,
                                lastChange = {},
                                change;
                            that._updateLockCount--;
                            if (!that._updateLockCount)
                                fireColumnsChanged(that)
                        },
                        getCommonSettings: function() {
                            var commonColumnSettings = this.option('commonColumnSettings') || {},
                                groupingOptions = this.option('grouping') || {},
                                groupPanelOptions = this.option('groupPanel') || {};
                            return $.extend({
                                    allowResizing: this.option('allowColumnResizing'),
                                    allowReordering: this.option('allowColumnReordering'),
                                    autoExpandGroup: groupingOptions.autoExpandAll,
                                    allowCollapsing: groupingOptions.allowCollapsing,
                                    allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible
                                }, commonColumnSettings)
                        },
                        isColumnOptionUsed: function(optionName) {
                            for (var i = 0; i < this._columns.length; i++)
                                if (this._columns[i][optionName])
                                    return true
                        },
                        isAllDataTypesDefined: function() {
                            var columns = this._columns,
                                i;
                            if (!columns.length)
                                return false;
                            for (i = 0; i < columns.length; i++)
                                if (!columns[i].dataType)
                                    return false;
                            return true
                        },
                        getColumns: function() {
                            return $.extend(true, [], this._columns)
                        },
                        getGroupColumns: function() {
                            var result = [];
                            $.each(this._columns, function() {
                                var column = this;
                                if (isDefined(column.groupIndex))
                                    result[column.groupIndex] = column
                            });
                            return result
                        },
                        getVisibleColumns: function() {
                            var that = this;
                            that._visibleColumns = that._visibleColumns || that._getVisibleColumnsCore();
                            return that._visibleColumns
                        },
                        _getExpandColumnsCore: function() {
                            return this.getGroupColumns()
                        },
                        getExpandColumns: function() {
                            var expandColumns = this._getExpandColumnsCore(),
                                expandColumn;
                            if (expandColumns.length)
                                expandColumn = this.columnOption("command:expand");
                            expandColumns = $.map(expandColumns, function(column) {
                                return $.extend({}, column, expandColumn, {index: column.index})
                            });
                            return expandColumns
                        },
                        _getVisibleColumnsCore: function() {
                            var visibleColumns = this.getExpandColumns(),
                                positiveIndexedColumns = {},
                                negativeIndexedColumns = {},
                                notGroupedColumnsCount = 0,
                                columns = this._columns.length ? this._commandColumns.concat(this._columns) : [];
                            $.each(columns, function() {
                                var column = this,
                                    visibleIndex = column.visibleIndex,
                                    indexedColumns;
                                if (column.visible && (!isDefined(column.groupIndex) || column.showWhenGrouped)) {
                                    column = $.extend(true, {}, column);
                                    if (visibleIndex < 0) {
                                        visibleIndex = -visibleIndex;
                                        indexedColumns = negativeIndexedColumns
                                    }
                                    else
                                        indexedColumns = positiveIndexedColumns;
                                    indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];
                                    indexedColumns[visibleIndex].push(column);
                                    notGroupedColumnsCount++
                                }
                            });
                            $.each(negativeIndexedColumns, function(visibleIndex, columns) {
                                visibleColumns.unshift.apply(visibleColumns, columns)
                            });
                            $.each(positiveIndexedColumns, function(visibleIndex, columns) {
                                visibleColumns.push.apply(visibleColumns, columns)
                            });
                            if (!notGroupedColumnsCount && this._columns.length)
                                visibleColumns.push({command: 'empty'});
                            return visibleColumns
                        },
                        getHiddenColumns: function() {
                            var result = [];
                            $.each(this._columns, function(_, column) {
                                if (!column.visible)
                                    result.push(column)
                            });
                            return result
                        },
                        allowMoveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
                            var that = this,
                                columnIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation),
                                sourceColumn = that._columns[columnIndex];
                            if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {
                                if (sourceLocation === targetLocation) {
                                    if (sourceLocation === COLUMN_CHOOSER_LOCATION)
                                        return false;
                                    return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex
                                }
                                else if (sourceLocation === GROUP_LOCATION && targetLocation !== COLUMN_CHOOSER_LOCATION || targetLocation === GROUP_LOCATION)
                                    return sourceColumn && sourceColumn.allowGrouping;
                                else if (sourceLocation === COLUMN_CHOOSER_LOCATION || targetLocation === COLUMN_CHOOSER_LOCATION)
                                    return sourceColumn && sourceColumn.allowHiding;
                                return true
                            }
                            return false
                        },
                        moveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
                            var that = this,
                                fromIndex,
                                toIndex,
                                targetGroupIndex,
                                isGroupMoving = sourceLocation === GROUP_LOCATION || targetLocation === GROUP_LOCATION,
                                column;
                            fromIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation);
                            toIndex = getColumnIndexByVisibleIndex(that, toVisibleIndex, targetLocation);
                            if (fromIndex >= 0) {
                                column = that._columns[fromIndex];
                                targetGroupIndex = toIndex >= 0 ? that._columns[toIndex].groupIndex : -1;
                                if (isDefined(column.groupIndex) && sourceLocation === GROUP_LOCATION) {
                                    if (targetGroupIndex > column.groupIndex)
                                        targetGroupIndex--;
                                    delete column.groupIndex;
                                    delete column.sortOrder;
                                    updateColumnGroupIndexes(that)
                                }
                                if (targetLocation === GROUP_LOCATION) {
                                    moveColumnToGroup(that, column, targetGroupIndex);
                                    updateColumnGroupIndexes(that)
                                }
                                else if (toVisibleIndex >= 0) {
                                    if (toIndex < 0)
                                        column.visibleIndex = undefined;
                                    else
                                        column.visibleIndex = that._columns[toIndex].visibleIndex;
                                    updateColumnVisibleIndexes(that, column)
                                }
                                column.visible = targetLocation !== COLUMN_CHOOSER_LOCATION;
                                updateColumnChanges(that, isGroupMoving ? 'grouping' : 'columns');
                                fireColumnsChanged(that)
                            }
                        },
                        changeSortOrder: function(columnIndex, sortOrder) {
                            var that = this,
                                commonColumnSettings = that.getCommonSettings(),
                                sortingOptions = that.option('sorting'),
                                sortingMode = sortingOptions && sortingOptions.mode,
                                needResetSorting = sortingMode === 'single' || !sortOrder,
                                allowSorting = sortingMode === 'single' || sortingMode === 'multiple',
                                column = that._columns[columnIndex],
                                nextSortOrder = function(column) {
                                    if (sortOrder === "ctrl") {
                                        delete column.sortOrder;
                                        delete column.sortIndex
                                    }
                                    else if (isDefined(column.groupIndex) || isDefined(column.sortIndex))
                                        column.sortOrder = column.sortOrder === 'desc' ? 'asc' : 'desc';
                                    else
                                        column.sortOrder = 'asc'
                                },
                                isSortingChanged = false;
                            if (allowSorting && column && column.allowSorting) {
                                if (needResetSorting && !isDefined(column.groupIndex))
                                    $.each(that._columns, function(index) {
                                        if (index !== columnIndex && this.sortOrder && !isDefined(this.groupIndex)) {
                                            delete this.sortOrder;
                                            delete this.sortIndex;
                                            isSortingChanged = true
                                        }
                                    });
                                if (isSortOrderValid(sortOrder)) {
                                    if (column.sortOrder !== sortOrder) {
                                        column.sortOrder = sortOrder;
                                        isSortingChanged = true
                                    }
                                }
                                else if (sortOrder === 'none') {
                                    if (column.sortOrder) {
                                        delete column.sortIndex;
                                        delete column.sortOrder;
                                        isSortingChanged = true
                                    }
                                }
                                else {
                                    nextSortOrder(column);
                                    isSortingChanged = true
                                }
                            }
                            if (isSortingChanged) {
                                updateColumnSortIndexes(that);
                                updateColumnChanges(that, 'sorting');
                                fireColumnsChanged(that, 'sorting')
                            }
                        },
                        getSortDataSourceParameters: function() {
                            var that = this,
                                sortColumns = [],
                                sort = [];
                            $.each(that._columns, function() {
                                if ((this.dataField || this.selector || this.calculateCellValue) && this.visible && isDefined(this.sortIndex) && !isDefined(this.groupIndex))
                                    sortColumns[this.sortIndex] = this
                            });
                            $.each(sortColumns, function() {
                                var sortOrder = this && this.sortOrder;
                                if (isSortOrderValid(sortOrder))
                                    sort.push({
                                        selector: this.selector || this.dataField || this.calculateCellValue,
                                        desc: this.sortOrder === 'desc'
                                    })
                            });
                            return sort.length > 0 ? sort : null
                        },
                        getGroupDataSourceParameters: function() {
                            var group = [];
                            $.each(this.getGroupColumns(), function() {
                                var selector = this.calculateGroupValue || this.selector || this.dataField || this.calculateCellValue;
                                if (selector)
                                    group.push({
                                        selector: selector,
                                        desc: this.sortOrder === 'desc',
                                        isExpanded: !!this.autoExpandGroup
                                    })
                            });
                            return group.length > 0 ? group : null
                        },
                        refresh: function(updateNewLookupsOnly) {
                            var deferreds = [];
                            $.each(this._columns, function() {
                                var lookup = this.lookup;
                                if (lookup) {
                                    if (updateNewLookupsOnly && lookup.valueMap)
                                        return;
                                    if (lookup.update)
                                        deferreds.push(lookup.update())
                                }
                            });
                            return $.when.apply($, deferreds)
                        },
                        _updateColumnDataTypes: function(dataSource) {
                            var firstItems = getFirstItems(dataSource),
                                isLocalData = isLocalDataSource(dataSource),
                                rtlEnabled = this.option("rtlEnabled");
                            $.each(this._columns, function(index, column) {
                                var i,
                                    value,
                                    dataType,
                                    lookupDataType,
                                    valueDataType,
                                    getter,
                                    lookup = column.lookup;
                                if (column.dataField && firstItems.length) {
                                    if (!column.dataType || lookup && !lookup.dataType) {
                                        for (i = 0; i < firstItems.length; i++) {
                                            value = column.calculateCellValue(firstItems[i]);
                                            valueDataType = column.dataType || getValueDataType(value);
                                            dataType = dataType || valueDataType;
                                            if (dataType && valueDataType && dataType !== valueDataType)
                                                dataType = "string";
                                            if (lookup) {
                                                valueDataType = lookup.dataType || getValueDataType(lookup.calculateCellValue(value));
                                                lookupDataType = lookupDataType || valueDataType;
                                                if (lookupDataType && valueDataType && lookupDataType !== valueDataType)
                                                    lookupDataType = "string"
                                            }
                                        }
                                        column.dataType = dataType;
                                        if (lookup)
                                            lookup.dataType = lookupDataType
                                    }
                                    if (!column.serializationFormat || lookup && !lookup.serializationFormat)
                                        for (i = 0; i < firstItems.length; i++) {
                                            value = column.calculateCellValue(firstItems[i], true);
                                            column.serializationFormat = column.serializationFormat || getSerializationFormat(column.dataType, value);
                                            if (lookup)
                                                lookup.serializationFormat = lookup.serializationFormat || getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value, true))
                                        }
                                }
                                if (isLocalData && column.serializationFormat || !column.dataField)
                                    column.selector = column.selector || $.proxy(column, 'calculateCellValue');
                                updateSerializers(column, column.dataType);
                                if (lookup)
                                    updateSerializers(lookup, lookup.dataType);
                                dataType = lookup ? lookup.dataType : column.dataType;
                                if (dataType) {
                                    column.alignment = column.alignment || getAlignmentByDataType(dataType, rtlEnabled);
                                    column.format = column.format || getFormatByDataType(dataType);
                                    column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);
                                    if (!isDefined(column.filterOperations))
                                        column.filterOperations = !lookup && DATATYPE_OPERATIONS[dataType] || [];
                                    column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || '=';
                                    column.defaultSelectedFilterOperation = column.selectedFilterOperation;
                                    column.showEditorAlways = isDefined(column.showEditorAlways) ? column.showEditorAlways : dataType === 'boolean'
                                }
                            })
                        },
                        _customizeColumns: function(columns) {
                            var that = this,
                                customizeColumns = that.option('customizeColumns');
                            if (customizeColumns) {
                                customizeColumns(columns);
                                assignColumns(that, createColumnsFromOptions(that, columns))
                            }
                        },
                        updateColumns: function(dataSource) {
                            var that = this,
                                sortParameters,
                                groupParameters;
                            that.updateSortingGrouping(dataSource);
                            if (!dataSource || dataSource.isLoaded()) {
                                sortParameters = dataSource ? dataSource.sort() || [] : that.getSortDataSourceParameters();
                                groupParameters = dataSource ? dataSource.group() || [] : that.getGroupDataSourceParameters();
                                that._customizeColumns(that._columns);
                                updateIndexes(that);
                                return $.when(that.refresh(true)).always(function() {
                                        if (dataSource) {
                                            that._updateColumnDataTypes(dataSource);
                                            that._dataSourceApplied = true
                                        }
                                        if (!equalSortParameters(sortParameters, that.getSortDataSourceParameters()))
                                            updateColumnChanges(that, 'sorting');
                                        if (!equalSortParameters(groupParameters, that.getGroupDataSourceParameters()))
                                            updateColumnChanges(that, 'grouping');
                                        updateColumnChanges(that, 'columns');
                                        fireColumnsChanged(that)
                                    })
                            }
                        },
                        updateSortingGrouping: function(dataSource) {
                            var that = this,
                                sortParameters,
                                groupParameters,
                                columnsGroupParameters,
                                columnsSortParameters,
                                updateSortGroupParameterIndexes = function(columns, sortParameters, indexParameterName) {
                                    var i;
                                    $.each(columns, function(index, column) {
                                        if (column.dataField) {
                                            delete column[indexParameterName];
                                            if (sortParameters && sortParameters.length)
                                                for (i = 0; i < sortParameters.length; i++)
                                                    if (sortParameters[i].selector === column.dataField) {
                                                        column.sortOrder = column.sortOrder || (sortParameters[i].desc ? 'desc' : 'asc');
                                                        column[indexParameterName] = i;
                                                        break
                                                    }
                                        }
                                    })
                                };
                            if (dataSource) {
                                sortParameters = normalizeSortingInfo(dataSource.sort() || []);
                                groupParameters = normalizeSortingInfo(dataSource.group() || []);
                                columnsGroupParameters = that.getGroupDataSourceParameters();
                                columnsSortParameters = that.getSortDataSourceParameters();
                                if (!that._columns.length) {
                                    $.each(groupParameters, function(index, group) {
                                        that._columns.push(group.selector)
                                    });
                                    $.each(sortParameters, function(index, sort) {
                                        that._columns.push(sort.selector)
                                    });
                                    assignColumns(that, createColumnsFromOptions(that, that._columns))
                                }
                                if (!columnsGroupParameters && !equalSortParameters(groupParameters, columnsGroupParameters)) {
                                    that.__groupingUpdated = true;
                                    updateSortGroupParameterIndexes(that._columns, groupParameters, 'groupIndex')
                                }
                                if (!columnsSortParameters && !equalSortParameters(sortParameters, columnsSortParameters)) {
                                    that.__sortingUpdated = true;
                                    updateSortGroupParameterIndexes(that._columns, sortParameters, 'sortIndex')
                                }
                            }
                        },
                        updateFilter: function(dataSource) {
                            var that = this,
                                isLocalData = isLocalDataSource(dataSource);
                            var updateFilterCore = function(filter) {
                                    if (!utils.isArray(filter))
                                        return;
                                    var calculateCellValue,
                                        column,
                                        i;
                                    if (utils.isString(filter[0])) {
                                        column = that.columnOption(filter[0]);
                                        if (column && column.calculateCellValue)
                                            filter[0] = $.proxy(column, 'calculateCellValue')
                                    }
                                    for (i = 0; i < filter.length; i++)
                                        updateFilterCore(filter[i])
                                };
                            if (isLocalData)
                                return updateFilterCore(dataSource.filter())
                        },
                        columnCount: function() {
                            return this._columns.length
                        },
                        columnOption: function(identificator, option, value, notFireEvent) {
                            var that = this,
                                i,
                                identificatorOptionName = utils.isString(identificator) && identificator.substr(0, identificator.indexOf(":")),
                                columns = identificator < 0 || identificatorOptionName === "command" ? that._commandColumns : that._columns,
                                column;
                            if (identificator === undefined)
                                return;
                            if (identificatorOptionName)
                                identificator = identificator.substr(identificatorOptionName.length + 1);
                            for (i = 0; i < columns.length; i++)
                                if (identificatorOptionName) {
                                    if ("" + columns[i][identificatorOptionName] === identificator) {
                                        column = columns[i];
                                        break
                                    }
                                }
                                else if (columns[i].index === identificator || columns[i].name === identificator || columns[i].dataField === identificator || columns[i].caption === identificator) {
                                    column = columns[i];
                                    break
                                }
                            if (column) {
                                if (arguments.length === 1)
                                    return $.extend({}, column);
                                if (utils.isString(option))
                                    if (arguments.length === 2)
                                        return columnOptionCore(that, column, option);
                                    else
                                        columnOptionCore(that, column, option, value, notFireEvent);
                                else if (utils.isObject(option))
                                    $.each(option, function(optionName, value) {
                                        columnOptionCore(that, column, optionName, value, notFireEvent)
                                    });
                                updateIndexes(that, column);
                                fireColumnsChanged(that)
                            }
                        },
                        clearSorting: function() {
                            var that = this,
                                columnCount = this.columnCount(),
                                i;
                            that.beginUpdate();
                            for (i = 0; i < columnCount; i++)
                                that.columnOption(i, "sortOrder", undefined);
                            that.endUpdate()
                        },
                        clearGrouping: function() {
                            var that = this,
                                columnCount = this.columnCount(),
                                i;
                            that.beginUpdate();
                            for (i = 0; i < columnCount; i++)
                                that.columnOption(i, "groupIndex", undefined);
                            that.endUpdate()
                        },
                        getVisibleIndex: function(index) {
                            var i,
                                visibleColumns = this.getVisibleColumns();
                            for (i = 0; i < visibleColumns.length; i++)
                                if (visibleColumns[i].index === index)
                                    return i;
                            return -1
                        },
                        addColumn: function(options) {
                            var that = this,
                                column = createColumn(that, options);
                            that._columns.push(column);
                            updateIndexes(that, column);
                            that.updateColumns(that._dataSource)
                        },
                        addCommandColumn: function(options) {
                            var commandColumns = this._commandColumns,
                                i;
                            for (i = 0; i < commandColumns.length; i++)
                                if (commandColumns[i].command === options.command)
                                    return;
                            commandColumns.push(options)
                        },
                        getUserState: function() {
                            var columns = this._columns,
                                result = [],
                                i;
                            for (i = 0; i < columns.length; i++) {
                                result[i] = {};
                                $.each(USER_STATE_FIELD_NAMES, function(index, value) {
                                    if (columns[i][value] !== undefined)
                                        result[i][value] = columns[i][value]
                                })
                            }
                            return result
                        },
                        setUserState: function(state) {
                            this._columnsUserState = state;
                            this.init()
                        },
                        _createCalculatedColumnOptions: function(columnOptions) {
                            var calculatedColumnOptions = {},
                                getter;
                            if (columnOptions.dataField) {
                                getter = dataUtils.compileGetter(columnOptions.dataField);
                                calculatedColumnOptions = {
                                    caption: convertNameToCaption(columnOptions.dataField),
                                    calculateCellValue: function(data, skipDeserialization) {
                                        var value = getter(data);
                                        return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value
                                    },
                                    parseValue: function(text) {
                                        var column = this,
                                            result,
                                            parsedValue;
                                        if (column.dataType === 'number') {
                                            if (utils.isString(text)) {
                                                parsedValue = Globalize.parseFloat(text);
                                                if (utils.isNumber(parsedValue))
                                                    result = parsedValue
                                            }
                                            else if (utils.isDefined(text))
                                                result = Number(text)
                                        }
                                        else if (column.dataType === 'boolean') {
                                            if (text === column.trueText)
                                                result = true;
                                            else if (text === column.falseText)
                                                result = false
                                        }
                                        else if (column.dataType === 'date') {
                                            parsedValue = Globalize.parseDate(text);
                                            if (parsedValue)
                                                result = parsedValue
                                        }
                                        else
                                            result = text;
                                        return result
                                    }
                                };
                                if (columnOptions.lookup)
                                    calculatedColumnOptions.lookup = {
                                        calculateCellValue: function(value, skipDeserialization) {
                                            var value = this.valueMap && this.valueMap[value];
                                            return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value
                                        },
                                        updateValueMap: function() {
                                            var calculateValue,
                                                calculateDisplayValue,
                                                item,
                                                i;
                                            this.valueMap = {};
                                            if (this.items) {
                                                calculateValue = dataUtils.compileGetter(this.valueExpr);
                                                calculateDisplayValue = dataUtils.compileGetter(this.displayExpr);
                                                for (i = 0; i < this.items.length; i++) {
                                                    item = this.items[i];
                                                    this.valueMap[calculateValue(item)] = calculateDisplayValue(item)
                                                }
                                            }
                                        },
                                        update: function() {
                                            var that = this,
                                                dataSource = that.dataSource;
                                            if (dataSource)
                                                if (utils.isObject(dataSource) || utils.isArray(dataSource)) {
                                                    dataSource = new DX.data.DataSource($.extend(true, {
                                                        paginate: false,
                                                        _preferSync: true
                                                    }, dataUtils.normalizeDataSourceOptions(dataSource)));
                                                    return dataSource.load().done(function(data) {
                                                            that.items = data;
                                                            that.updateValueMap && that.updateValueMap()
                                                        })
                                                }
                                                else
                                                    DX.log("E1016");
                                            else
                                                that.updateValueMap && that.updateValueMap()
                                        }
                                    }
                            }
                            else
                                $.extend(true, calculatedColumnOptions, {
                                    allowSorting: false,
                                    allowGrouping: false,
                                    calculateCellValue: function() {
                                        return null
                                    }
                                });
                            calculatedColumnOptions.resizedCallbacks = $.Callbacks();
                            if (columnOptions.resized)
                                calculatedColumnOptions.resizedCallbacks.add($.proxy(columnOptions.resized, columnOptions));
                            updateSerializers(calculatedColumnOptions, columnOptions.dataType);
                            return calculatedColumnOptions
                        }
                    }
            }());
        ui.dxDataGrid.ColumnsController = ColumnsController;
        dataGrid.registerModule('columns', {
            defaultOptions: function() {
                return {
                        commonColumnSettings: {
                            allowFiltering: true,
                            allowHiding: true,
                            allowSorting: true,
                            allowEditing: true,
                            encodeHtml: true,
                            trueText: Globalize.localize("dxDataGrid-trueText"),
                            falseText: Globalize.localize("dxDataGrid-falseText")
                        },
                        allowColumnReordering: false,
                        allowColumnResizing: false,
                        columns: undefined,
                        regenerateColumnsByVisibleItems: false,
                        sorting: {
                            mode: 'single',
                            ascendingText: Globalize.localize("dxDataGrid-sortingAscendingText"),
                            descendingText: Globalize.localize("dxDataGrid-sortingDescendingText"),
                            clearText: Globalize.localize("dxDataGrid-sortingClearText")
                        },
                        customizeColumns: null
                    }
            },
            controllers: {columns: ColumnsController}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.selection.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            events = DX.ui.events,
            utils = DX.utils;
        var DATAGRID_EDITOR_CELL_CLASS = "dx-editor-cell",
            DATAGRID_ROW_SELECTION_CLASS = "dx-selection",
            DATAGRID_SELECT_CHECKBOX_CLASS = "dx-select-checkbox",
            DATAGRID_CHECKBOXES_HIDDEN_CLASS = "dx-select-checkboxes-hidden",
            LONG_TAP_TIME = 500;
        $.extend(dataGrid.__internals, {DATAGRID_ROW_SELECTION_CLASS: DATAGRID_ROW_SELECTION_CLASS});
        var SHOW_CHECKBOXES_MODE = 'selection.showCheckBoxesInMultipleMode';
        dataGrid.SelectionController = dataGrid.Controller.inherit(function() {
            var SELECTION_MODE = 'selection.mode';
            var isSelectable = function(selectionMode) {
                    return selectionMode === 'single' || selectionMode === 'multiple'
                };
            var indexOfSelectedItemKey = function(that, key, isSelectAll) {
                    var index,
                        selectedItemKeys = isSelectAll ? that._unselectedItemKeys : that._selectedItemKeys;
                    if (utils.isObject(key)) {
                        for (index = 0; index < selectedItemKeys.length; index++)
                            if (equalKeys(selectedItemKeys[index], key))
                                return index;
                        return -1
                    }
                    else
                        return $.inArray(key, selectedItemKeys)
                };
            var getKeyIndex = function(key, keys) {
                    var index = -1;
                    $.each(keys, function(i, rowKey) {
                        if (dataGrid.equalKeys(key, rowKey)) {
                            index = i;
                            return false
                        }
                    });
                    return index
                };
            var addSelectedItem = function(that, itemData) {
                    var key = that.getController('data').keyOf(itemData),
                        keyIndex;
                    if (indexOfSelectedItemKey(that, key) === -1) {
                        that._selectedItemKeys.push(key);
                        that._addedItemKeys.push(key);
                        that._selectedItems.push(itemData)
                    }
                    if (that._isSelectAll) {
                        keyIndex = indexOfSelectedItemKey(that, key, true);
                        that._unselectedItemKeys.splice(keyIndex, 1)
                    }
                };
            var removeSelectedItem = function(that, key) {
                    var keyIndex = indexOfSelectedItemKey(that, key);
                    if (keyIndex >= 0) {
                        that._selectedItemKeys.splice(keyIndex, 1);
                        that._removedItemKeys.push(key);
                        that._selectedItems.splice(keyIndex, 1);
                        if (that._isSelectAll && indexOfSelectedItemKey(that, key, true) === -1)
                            that._unselectedItemKeys.push(key)
                    }
                };
            var clearSelectedItems = function(that) {
                    setSelectedItems(that, [], [])
                };
            var setSelectedItems = function(that, keys, items, isSelectAll) {
                    var i,
                        oldSelectedItemKeys = that._selectedItemKeys;
                    that._selectedItemKeys = keys;
                    that._selectedItems = items;
                    that._unselectedItemKeys = [];
                    that._isSelectAll = !!isSelectAll;
                    for (i = 0; i < oldSelectedItemKeys.length; i++)
                        if ($.inArray(oldSelectedItemKeys[i], keys) === -1)
                            that._removedItemKeys.push(oldSelectedItemKeys[i]);
                    for (i = 0; i < keys.length; i++)
                        if ($.inArray(keys[i], oldSelectedItemKeys) === -1)
                            that._addedItemKeys.push(keys[i])
                };
            var equalKeys = dataGrid.equalKeys;
            var resetItemSelectionWhenShiftKeyPressed = function(that) {
                    delete that._shiftFocusedItemIndex
                };
            var isDataItem = function(row) {
                    return row && row.rowType === "data"
                };
            var changeItemSelectionWhenShiftKeyPressed = function(that, itemIndex, items) {
                    var isSelectedItemsChanged = false,
                        itemIndexStep,
                        index,
                        dataController = that.getController('data'),
                        isFocusedItemSelected = items[that._focusedItemIndex] && that.isRowSelected(dataController.keyOf(items[that._focusedItemIndex].data));
                    var addRemoveSelectedItem = function(that, data, isRemove) {
                            if (isRemove)
                                removeSelectedItem(that, dataController.keyOf(data));
                            else
                                addSelectedItem(that, data)
                        };
                    if (!utils.isDefined(that._shiftFocusedItemIndex))
                        that._shiftFocusedItemIndex = that._focusedItemIndex;
                    if (that._shiftFocusedItemIndex !== that._focusedItemIndex) {
                        itemIndexStep = that._focusedItemIndex < that._shiftFocusedItemIndex ? 1 : -1;
                        for (index = that._focusedItemIndex; index !== that._shiftFocusedItemIndex; index += itemIndexStep)
                            if (isDataItem(items[index])) {
                                addRemoveSelectedItem(that, items[index].data, true);
                                isSelectedItemsChanged = true
                            }
                    }
                    if (itemIndex !== that._shiftFocusedItemIndex) {
                        itemIndexStep = itemIndex < that._shiftFocusedItemIndex ? 1 : -1;
                        for (index = itemIndex; index !== that._shiftFocusedItemIndex; index += itemIndexStep)
                            if (isDataItem(items[index])) {
                                addRemoveSelectedItem(that, items[index].data, false);
                                isSelectedItemsChanged = true
                            }
                    }
                    if (isDataItem(items[that._focusedItemIndex]) && !isFocusedItemSelected) {
                        addRemoveSelectedItem(that, items[that._focusedItemIndex].data, false);
                        isSelectedItemsChanged = true
                    }
                    return isSelectedItemsChanged
                };
            var createSelectedItemsFilterCriteria = function(dataSource, selectedItemKeys, isSelectAll) {
                    var keyCriteria,
                        i,
                        key = dataSource && dataSource.key(),
                        criteria = [];
                    if (dataSource)
                        if (key)
                            $.each(selectedItemKeys, function(index, keyValue) {
                                if (criteria.length > 0)
                                    criteria.push(isSelectAll ? 'and' : 'or');
                                if ($.isArray(key)) {
                                    keyCriteria = [];
                                    for (i = 0; i < key.length; i++) {
                                        if (i > 0)
                                            keyCriteria.push(isSelectAll ? 'or' : 'and');
                                        keyCriteria.push([key[i], isSelectAll ? '<>' : '=', keyValue[key[i]]])
                                    }
                                    criteria.push(keyCriteria)
                                }
                                else
                                    criteria.push([key, isSelectAll ? '<>' : '=', keyValue])
                            });
                        else
                            criteria = function(item) {
                                var i;
                                for (i = 0; i < selectedItemKeys.length; i++)
                                    if (equalKeys(selectedItemKeys[i], item))
                                        return !isSelectAll;
                                return isSelectAll
                            };
                    if (criteria.length > 0 || $.isFunction(criteria))
                        return criteria
                };
            var updateSelectedItems = function(that) {
                    var changedItemIndexes = [],
                        dataController = that.getController('data'),
                        addedItemKeys,
                        removedItemKeys;
                    if (dataController) {
                        $.each(dataController.items(), function(index, row) {
                            var key = dataController.keyOf(row.data);
                            if (isDataItem(row) && row.isSelected !== that.isRowSelected(key))
                                changedItemIndexes.push(index)
                        });
                        if (that.option(SHOW_CHECKBOXES_MODE) === 'onClick')
                            if (that._selectedItemKeys.length > 1)
                                that.startSelectionWithCheckboxes();
                            else if (that._selectedItemKeys.length === 0 && changedItemIndexes.length)
                                that.stopSelectionWithCheckboxes();
                        if (changedItemIndexes.length)
                            dataController.updateItems({
                                changeType: 'updateSelection',
                                itemIndexes: changedItemIndexes
                            });
                        addedItemKeys = that._addedItemKeys;
                        removedItemKeys = that._removedItemKeys;
                        if (addedItemKeys.length || removedItemKeys.length) {
                            that._selectedItemsInternalChange = true;
                            that.option("selectedRowKeys", that._selectedItemKeys.slice(0));
                            that._selectedItemsInternalChange = false;
                            that.selectionChanged.fire(that._selectedItemKeys);
                            that.executeAction("onSelectionChanged", {
                                selectedRowsData: that._selectedItems,
                                selectedRowKeys: that._selectedItemKeys,
                                currentSelectedRowKeys: addedItemKeys,
                                currentDeselectedRowKeys: removedItemKeys
                            })
                        }
                        that._addedItemKeys = [];
                        that._removedItemKeys = []
                    }
                };
            var updateSelectColumn = function(that) {
                    var columnsController = that.getController("columns"),
                        isSelectColumnVisible = that.isSelectColumnVisible();
                    columnsController.addCommandColumn({
                        command: 'select',
                        visible: isSelectColumnVisible,
                        visibleIndex: -1,
                        dataType: 'boolean',
                        alignment: 'center',
                        cssClass: "dx-command-select",
                        width: "auto"
                    });
                    columnsController.columnOption("command:select", "visible", isSelectColumnVisible)
                };
            return {
                    init: function() {
                        var that = this;
                        that._isSelectionWithCheckboxes = false;
                        that._focusedItemIndex = -1;
                        that._selectedItemKeys = [];
                        that._unselectedItemKeys = [];
                        that._selectedItems = [];
                        that._addedItemKeys = [];
                        that._removedItemKeys = [];
                        that._isSelectAll = false;
                        updateSelectColumn(that);
                        that.createAction("onSelectionChanged", {excludeValidators: ['disabled']})
                    },
                    callbackNames: function() {
                        return ['selectionChanged']
                    },
                    optionChanged: function(args) {
                        var that = this;
                        that.callBase(args);
                        switch (args.name) {
                            case"selection":
                                that.init();
                                that.getController('columns').updateColumns();
                                break;
                            case"selectedRowKeys":
                                if (utils.isArray(args.value) && !that._selectedItemsInternalChange)
                                    that.selectRows(args.value);
                                break
                        }
                    },
                    publicMethods: function() {
                        return ['selectRows', 'deselectRows', 'selectRowsByIndexes', 'getSelectedRowKeys', 'getSelectedRowsData', 'clearSelection', 'selectAll', 'startSelectionWithCheckboxes', 'stopSelectionWithCheckboxes', 'isRowSelected']
                    },
                    isRowSelected: function(key) {
                        var index = indexOfSelectedItemKey(this, key);
                        return index !== -1
                    },
                    isSelectColumnVisible: function() {
                        var showCheckboxesMode = this.option(SHOW_CHECKBOXES_MODE);
                        return this.option(SELECTION_MODE) === 'multiple' && (showCheckboxesMode === 'always' || showCheckboxesMode === 'onClick' || this._isSelectionWithCheckboxes)
                    },
                    isSelectAll: function() {
                        return this._isSelectAll && !this._unselectedItemKeys.length
                    },
                    selectAll: function() {
                        if (this.option(SHOW_CHECKBOXES_MODE) === 'onClick')
                            this.startSelectionWithCheckboxes();
                        return this.selectedItemKeys([], true)
                    },
                    clearSelection: function() {
                        this.selectedItemKeys([])
                    },
                    refresh: function() {
                        var that = this,
                            result;
                        if (that.isSelectAll())
                            result = that.selectAll();
                        else
                            result = that.selectedItemKeys(that.option("selectedRowKeys") || []);
                        return result.done(function(selectedRows) {
                                updateSelectedItems(that)
                            })
                    },
                    selectedItemKeys: function(value, isSelectAll) {
                        var that = this,
                            keys,
                            criteria,
                            isFunctionCriteria,
                            deferred,
                            dataController = that.getController('data'),
                            dataSource = dataController.dataSource(),
                            store = dataSource && dataSource.store(),
                            dataSourceFilter,
                            filter;
                        if (utils.isDefined(value)) {
                            if (store) {
                                keys = $.isArray(value) ? $.extend([], value) : [value];
                                that._isSelectAll = isSelectAll;
                                if (keys.length || isSelectAll) {
                                    criteria = createSelectedItemsFilterCriteria(dataSource, keys, isSelectAll);
                                    isFunctionCriteria = $.isFunction(criteria);
                                    if (criteria || isSelectAll) {
                                        dataSourceFilter = dataSource.filter();
                                        if (criteria && !isFunctionCriteria && dataSourceFilter) {
                                            filter = [];
                                            filter.push(criteria);
                                            filter.push(dataSourceFilter)
                                        }
                                        else if (dataSourceFilter)
                                            filter = dataSourceFilter;
                                        else if (criteria && !isFunctionCriteria)
                                            filter = criteria;
                                        deferred = $.Deferred();
                                        dataController.setSelectionLoading(true);
                                        store.load({filter: filter}).done(function(items) {
                                            new DX.data.ArrayStore(items).load({filter: criteria}).done(function(items) {
                                                deferred.resolve(items)
                                            })
                                        }).fail($.proxy(deferred.reject, deferred)).always(function() {
                                            dataController.setSelectionLoading(false)
                                        })
                                    }
                                }
                            }
                            deferred = deferred || $.Deferred().resolve([]);
                            deferred.done(function(items) {
                                var i,
                                    key,
                                    keys = [];
                                if (store && items.length > 0)
                                    for (i = 0; i < items.length; i++) {
                                        key = store.keyOf(items[i]);
                                        keys.push(key)
                                    }
                                setSelectedItems(that, keys, items, isSelectAll);
                                updateSelectedItems(that)
                            });
                            return deferred
                        }
                        else
                            return that._selectedItemKeys
                    },
                    getSelectedRowKeys: function() {
                        return this.selectedItemKeys()
                    },
                    selectRows: function(keys, preserve) {
                        keys = $.isArray(keys) ? keys : [keys];
                        var selectedRowKeys = keys;
                        if (preserve) {
                            selectedRowKeys = this.getSelectedRowKeys();
                            $.each(keys, function(_, key) {
                                if (getKeyIndex(key, selectedRowKeys) === -1)
                                    selectedRowKeys.push(key)
                            })
                        }
                        return this.selectedItemKeys(selectedRowKeys)
                    },
                    deselectRows: function(keys) {
                        var selectedRowKeys = this.getSelectedRowKeys(),
                            keys = $.isArray(keys) ? keys : [keys];
                        $.each(keys, function(_, key) {
                            var index = getKeyIndex(key, selectedRowKeys);
                            if (index >= 0)
                                selectedRowKeys.splice(index, 1)
                        });
                        return this.selectedItemKeys(selectedRowKeys)
                    },
                    selectRowsByIndexes: function(indexes) {
                        var items = this.getController('data').items(),
                            i,
                            keys = [];
                        if (!utils.isArray(indexes))
                            indexes = Array.prototype.slice.call(arguments, 0);
                        $.each(indexes, function() {
                            var item = items[this];
                            if (item && item.rowType === 'data')
                                keys.push(item.key)
                        });
                        return this.selectRows(keys)
                    },
                    getSelectedRowsData: function() {
                        return this._selectedItems
                    },
                    changeItemSelection: function(itemIndex, keys) {
                        var that = this,
                            dataController = that.getController('data'),
                            items = dataController.items(),
                            item = items[itemIndex],
                            itemData = item && item.data,
                            selectionMode = that.option(SELECTION_MODE),
                            isSelectedItemsChanged,
                            isSelected,
                            itemKey;
                        if (isSelectable(selectionMode) && isDataItem(item)) {
                            itemKey = dataController.keyOf(itemData);
                            keys = keys || {};
                            if (that.isSelectionWithCheckboxes())
                                keys.control = true;
                            if (keys.shift && selectionMode === 'multiple' && that._focusedItemIndex >= 0)
                                isSelectedItemsChanged = changeItemSelectionWhenShiftKeyPressed(that, itemIndex, items);
                            else if (keys.control) {
                                resetItemSelectionWhenShiftKeyPressed(that);
                                isSelected = that.isRowSelected(itemKey);
                                if (selectionMode === 'single')
                                    clearSelectedItems(that);
                                if (isSelected)
                                    removeSelectedItem(that, itemKey);
                                else
                                    addSelectedItem(that, itemData);
                                isSelectedItemsChanged = true
                            }
                            else {
                                resetItemSelectionWhenShiftKeyPressed(that);
                                if (that._selectedItemKeys.length !== 1 || !equalKeys(that._selectedItemKeys[0], itemKey)) {
                                    setSelectedItems(that, [itemKey], [itemData]);
                                    isSelectedItemsChanged = true
                                }
                            }
                            if (isSelectedItemsChanged) {
                                that._focusedItemIndex = itemIndex;
                                updateSelectedItems(that);
                                return true
                            }
                        }
                        return false
                    },
                    focusedItemIndex: function(itemIndex) {
                        var that = this;
                        if (utils.isDefined(itemIndex))
                            that._focusedItemIndex = itemIndex;
                        else
                            return that._focusedItemIndex
                    },
                    isSelectionWithCheckboxes: function() {
                        var selectionMode = this.option(SELECTION_MODE),
                            showCheckboxesMode = this.option(SHOW_CHECKBOXES_MODE);
                        return selectionMode === 'multiple' && (showCheckboxesMode === 'always' || this._isSelectionWithCheckboxes)
                    },
                    startSelectionWithCheckboxes: function() {
                        var that = this,
                            isSelectColumnVisible = that.isSelectColumnVisible();
                        if (that.option(SELECTION_MODE) === 'multiple' && !that.isSelectionWithCheckboxes()) {
                            that._isSelectionWithCheckboxes = true;
                            updateSelectColumn(that);
                            if (isSelectColumnVisible === that.isSelectColumnVisible() && that.option(SHOW_CHECKBOXES_MODE) === 'onClick')
                                updateSelectedItems(that);
                            return true
                        }
                        return false
                    },
                    stopSelectionWithCheckboxes: function() {
                        var that = this,
                            isSelectColumnVisible = that.isSelectColumnVisible();
                        if (that._isSelectionWithCheckboxes) {
                            that._isSelectionWithCheckboxes = false;
                            updateSelectColumn(that);
                            return true
                        }
                        return false
                    }
                }
        }());
        $.extend(dataGrid.__internals, {DATAGRID_CHECKBOXES_HIDDEN_CLASS: DATAGRID_CHECKBOXES_HIDDEN_CLASS});
        dataGrid.registerModule('selection', {
            defaultOptions: function() {
                return {
                        selection: {
                            mode: 'none',
                            showCheckBoxesInMultipleMode: 'onClick',
                            allowSelectAll: true
                        },
                        selectedRowKeys: []
                    }
            },
            controllers: {selection: dataGrid.SelectionController},
            extenders: {
                controllers: {data: {
                        setDataSource: function(dataSource) {
                            this.callBase(dataSource);
                            this.getController('selection').refresh()
                        },
                        setSelectionLoading: function(isLoading) {
                            this._isSelectionLoading = isLoading;
                            this._fireLoadingChanged()
                        },
                        isLoading: function() {
                            var isLoading = this.callBase();
                            return isLoading || !!this._isSelectionLoading
                        },
                        pageIndex: function(value) {
                            var that = this,
                                dataSource = that._dataSource;
                            if (dataSource && value && dataSource.pageIndex() !== value)
                                that.getController('selection').focusedItemIndex(-1);
                            return that.callBase(value)
                        },
                        _processDataItem: function() {
                            var that = this,
                                selectionController = that.getController('selection'),
                                hasSelectColumn = selectionController.isSelectColumnVisible(),
                                dataItem = this.callBase.apply(this, arguments);
                            dataItem.isSelected = selectionController.isRowSelected(dataItem.key);
                            if (hasSelectColumn && dataItem.values)
                                dataItem.values[0] = dataItem.isSelected;
                            return dataItem
                        },
                        refresh: function() {
                            var d = this.callBase.apply(this, arguments);
                            this.getController('selection').refresh();
                            return d
                        }
                    }},
                views: {
                    columnHeadersView: {
                        _renderCore: function(options) {
                            var that = this;
                            that.getController('selection').selectionChanged.remove(that._selectionChangedHandler);
                            that.callBase(options)
                        },
                        _renderHeaderContent: function(rootElement, column, columnIndex) {
                            var that = this,
                                groupElement,
                                selectionController = that.getController('selection');
                            var getSelectAllValue = function(selectionController) {
                                    if (selectionController.isSelectAll() || selectionController.getSelectedRowKeys().length === 0)
                                        return selectionController.isSelectAll()
                                };
                            if (column.command === 'select') {
                                rootElement.addClass(DATAGRID_EDITOR_CELL_CLASS);
                                groupElement = $('<div />').appendTo(rootElement).addClass(DATAGRID_SELECT_CHECKBOX_CLASS);
                                that.getController('editorFactory').createEditor(groupElement, $.extend({}, column, {
                                    parentType: "headerRow",
                                    value: getSelectAllValue(selectionController),
                                    setValue: function(value, e) {
                                        if (e.jQueryEvent && getSelectAllValue(selectionController) !== value) {
                                            if (e.previousValue === undefined || e.previousValue) {
                                                selectionController.clearSelection();
                                                e.component.option('value', false)
                                            }
                                            if (e.previousValue === false)
                                                if (that.option("selection.allowSelectAll"))
                                                    selectionController.selectAll();
                                                else
                                                    e.component.option('value', false);
                                            e.jQueryEvent.preventDefault()
                                        }
                                    }
                                }));
                                rootElement.on('dxclick', that.createAction(function(e) {
                                    var event = e.jQueryEvent;
                                    if (!$(event.target).closest('.' + DATAGRID_SELECT_CHECKBOX_CLASS).length)
                                        $(event.currentTarget).children().trigger('dxclick');
                                    event.preventDefault()
                                }));
                                that._selectionChangedHandler = function() {
                                    groupElement.dxCheckBox('instance').option('value', getSelectAllValue(selectionController))
                                };
                                selectionController.selectionChanged.add(that._selectionChangedHandler)
                            }
                            else
                                that.callBase(rootElement, column, columnIndex)
                        }
                    },
                    rowsView: {
                        _getDefaultTemplate: function(column) {
                            var that = this,
                                groupElement;
                            if (column.command === 'select')
                                return function(container, options) {
                                        if (options.rowType === 'data') {
                                            container.addClass(DATAGRID_EDITOR_CELL_CLASS);
                                            container.on('dxclick', that.createAction(function(e) {
                                                var selectionController = that.getController('selection'),
                                                    event = e.jQueryEvent,
                                                    rowIndex = that.getRowIndex($(event.currentTarget).closest('.dx-row'));
                                                if (rowIndex >= 0) {
                                                    selectionController.startSelectionWithCheckboxes();
                                                    selectionController.changeItemSelection(rowIndex, {shift: event.shiftKey})
                                                }
                                            }));
                                            groupElement = $('<div />').addClass(DATAGRID_SELECT_CHECKBOX_CLASS).appendTo(container);
                                            that.getController('editorFactory').createEditor(groupElement, $.extend({}, column, {
                                                parentType: "dataRow",
                                                value: options.value
                                            }))
                                        }
                                    };
                            else
                                return that.callBase(column)
                        },
                        _update: function(change) {
                            var that = this;
                            if (change.changeType === 'updateSelection') {
                                if (that._tableElement.length > 0)
                                    $.each(change.itemIndexes || [], function(_, index) {
                                        var $row,
                                            isSelected;
                                        if (change.items[index]) {
                                            $row = that._getRowElements().eq(index);
                                            isSelected = !!change.items[index].isSelected;
                                            $row.toggleClass(DATAGRID_ROW_SELECTION_CLASS, isSelected);
                                            $row.find('.' + DATAGRID_SELECT_CHECKBOX_CLASS).dxCheckBox('option', 'value', isSelected)
                                        }
                                    });
                                that._updateCheckboxesClass()
                            }
                            else
                                that.callBase(change)
                        },
                        _createTable: function() {
                            var that = this,
                                $table = that.callBase();
                            return $table.on(events.addNamespace('dxpointerdown', "dxDataGridRowsView"), that.createAction(function(e) {
                                    that._isTouchEvent = events.isTouchEvent(e.jQueryEvent)
                                })).on(events.addNamespace('dxhold', "dxDataGridRowsView"), {timeout: that.option("selection.longTapTime") || LONG_TAP_TIME}, that.createAction(function(e) {
                                    var selectionController = that.getController('selection'),
                                        event = e.jQueryEvent;
                                    if (that.option(SHOW_CHECKBOXES_MODE) === 'onLongTap')
                                        if (selectionController.isSelectionWithCheckboxes())
                                            selectionController.stopSelectionWithCheckboxes();
                                        else
                                            selectionController.startSelectionWithCheckboxes();
                                    if (that.option(SHOW_CHECKBOXES_MODE) === 'onClick')
                                        $(event.target).closest('.dx-row').find(DATAGRID_SELECT_CHECKBOX_CLASS).parent().trigger('dxclick')
                                })).on('mousedown selectstart', that.createAction(function(e) {
                                    var event = e.jQueryEvent;
                                    if (event.shiftKey)
                                        event.preventDefault()
                                }))
                        },
                        _createRow: function(rowOptions) {
                            var $row = this.callBase(rowOptions);
                            rowOptions && $row.toggleClass(DATAGRID_ROW_SELECTION_CLASS, !!rowOptions.isSelected);
                            return $row
                        },
                        _rowClick: function(rowIndex, event) {
                            var that = this,
                                isCommandSelect = $(event.target).closest('.dx-command-select').length;
                            if (!isCommandSelect) {
                                that.getController('selection').changeItemSelection(rowIndex, {
                                    control: event.ctrlKey,
                                    shift: event.shiftKey
                                });
                                that.callBase(rowIndex, event)
                            }
                        },
                        _renderCore: function(change) {
                            this.callBase(change);
                            this._updateCheckboxesClass()
                        },
                        _updateCheckboxesClass: function() {
                            var selectionController = this.getController('selection'),
                                isCheckBoxesHidden = selectionController.isSelectColumnVisible() && !selectionController.isSelectionWithCheckboxes();
                            this._tableElement && this._tableElement.toggleClass(DATAGRID_CHECKBOXES_HIDDEN_CLASS, isCheckBoxesHidden)
                        }
                    }
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.editorFactory.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            utils = DX.utils,
            addNamespace = DX.ui.events.addNamespace;
        var DATAGRID_CHECKBOX_SIZE_CLASS = "dx-datagrid-checkbox-size",
            DATAGRID_MODULE_NAMESPACE = 'dxDataGridEditorFactory',
            DATAGRID_UPDATE_FOCUS_EVENTS = addNamespace('focusin dxpointerdown dxclick', DATAGRID_MODULE_NAMESPACE),
            ENTER_KEY = 13,
            TAB_KEY = 9,
            DATAGRID_FOCUS_OVERLAY_CLASS = 'dx-datagrid-focus-overlay',
            DATAGRID_FOCUSED_ELEMENT_CLASS = 'dx-focused',
            DATAGRID_CONTENT_CLASS = 'dx-datagrid-content';
        dataGrid.EditorFactoryController = dataGrid.Controller.inherit(function() {
            var getResultConfig = function(config, options) {
                    return $.extend(config, {
                            readOnly: options.readOnly,
                            rtlEnabled: options.rtlEnabled,
                            disabled: options.disabled
                        })
                };
            var getTextEditorConfig = function($container, options) {
                    return getResultConfig({
                            placeholder: options.placeholder,
                            width: options.width,
                            value: options.value,
                            onValueChanged: function(e) {
                                var updateValue = function(e) {
                                        options && options.setValue(e.value)
                                    };
                                window.clearTimeout($container._valueChangeTimeoutID);
                                if (e.jQueryEvent && e.jQueryEvent.type === "keyup")
                                    $container._valueChangeTimeoutID = window.setTimeout(function() {
                                        updateValue(e)
                                    }, utils.isDefined(options.updateValueTimeout) ? options.updateValueTimeout : 0);
                                else if (e.jQueryEvent && e.jQueryEvent.type === 'keydown') {
                                    if (e.jQueryEvent.which === ENTER_KEY || e.jQueryEvent.which === TAB_KEY)
                                        updateValue(e)
                                }
                                else
                                    updateValue(e)
                            },
                            valueChangeEvent: 'change keydown' + (options.parentType === 'filterRow' ? ' keyup' : '')
                        }, options)
                };
            var createCalendarPicker = function($container, options) {
                    $container.dxDateBox(getResultConfig({
                        value: options.value,
                        useCalendar: true,
                        customOverlayCssClass: 'dx-datagrid',
                        formatString: DX.utils.isString(options.format) && DX.DateTimeFormat[options.format.toLowerCase()] || options.format,
                        formatWidthCalculator: null
                    }, options));
                    $container.dxDateBox('instance').on("optionChanged", function(args) {
                        var optionName = args.name,
                            value = args.value;
                        if (optionName === 'value')
                            options.setValue(value)
                    })
                };
            var createTextBox = function($container, options) {
                    var config = getTextEditorConfig($container, options),
                        isSearching = options.parentType === 'searchPanel',
                        toString = function(value) {
                            return DX.utils.isDefined(value) ? value.toString() : ''
                        };
                    config.value = toString(options.value);
                    config.valueChangeEvent += isSearching ? ' keyup search' : '';
                    config.mode = isSearching ? 'search' : 'text';
                    $container.dxTextBox(config)
                };
            var createNumberBox = function($container, options) {
                    var config = getTextEditorConfig($container, options);
                    config.showSpinButtons = true;
                    $container.dxNumberBox(config)
                };
            var createBooleanEditor = function($container, options) {
                    if (options.parentType === 'filterRow')
                        createSelectBox($container, $.extend({lookup: {
                                displayExpr: function(data) {
                                    if (data === true)
                                        return options.trueText || 'true';
                                    else if (data === false)
                                        return options.falseText || 'false'
                                },
                                items: [true, false],
                                rtlEnabled: options.rtlEnabled,
                                disabled: options.disabled
                            }}, options));
                    else
                        createCheckBox($container, options)
                };
            var createSelectBox = function($container, options) {
                    var lookup = options.lookup,
                        items,
                        displayGetter,
                        isFilterRow = options.parentType === "filterRow";
                    if (lookup) {
                        items = lookup.items;
                        displayGetter = DX.data.utils.compileGetter(lookup.displayExpr);
                        if (isFilterRow && items) {
                            items = items.slice(0);
                            items.unshift(null)
                        }
                        $container.dxSelectBox(getResultConfig({
                            searchEnabled: true,
                            value: options.value || null,
                            valueExpr: options.lookup.valueExpr,
                            showClearButton: lookup.allowClearing && !isFilterRow,
                            displayExpr: function(data) {
                                if (data === null)
                                    return options.showAllText;
                                return displayGetter(data)
                            },
                            items: items,
                            onValueChanged: function(e) {
                                options.setValue(e.value, e)
                            }
                        }, options))
                    }
                };
            var createCheckBox = function($container, options) {
                    $container.addClass(DATAGRID_CHECKBOX_SIZE_CLASS).dxCheckBox(getResultConfig({
                        value: options.value,
                        onValueChanged: function(e) {
                            options.setValue && options.setValue(e.value, e)
                        }
                    }, options))
                };
            return {
                    _getFocusedElement: function($dataGridElement) {
                        return $dataGridElement.find('[tabindex]:focus, input:focus')
                    },
                    _updateFocusCore: function() {
                        var $focus = this._$focusedElement,
                            $dataGridElement = this.component && this.component.element();
                        if ($dataGridElement) {
                            $focus = this._getFocusedElement($dataGridElement);
                            if ($focus.length) {
                                $focus = $focus.closest('.dx-editor-cell > *, .dx-row > td');
                                if ($focus.length) {
                                    this.focus($focus);
                                    return
                                }
                            }
                        }
                        this.loseFocus()
                    },
                    _updateFocus: function(e) {
                        var that = this,
                            isFocusOverlay = e.jQueryEvent && $(e.jQueryEvent.target).hasClass(DATAGRID_FOCUS_OVERLAY_CLASS);
                        that._isFocusOverlay = that._isFocusOverlay || isFocusOverlay;
                        clearTimeout(that._updateFocusTimeoutID);
                        that._updateFocusTimeoutID = setTimeout(function() {
                            delete that._updateFocusTimeoutID;
                            if (!that._isFocusOverlay)
                                that._updateFocusCore();
                            that._isFocusOverlay = false
                        })
                    },
                    callbackNames: function() {
                        return ["focused"]
                    },
                    focus: function($element) {
                        var that = this;
                        if ($element === undefined)
                            return that._$focusedElement;
                        else if ($element)
                            setTimeout(function() {
                                var $focusOverlay = that._$focusOverlay = that._$focusOverlay || $('<div>').addClass(DATAGRID_FOCUS_OVERLAY_CLASS);
                                var align = !parseInt($element.css('border-left-width')) && parseInt($element.css('border-right-width')) ? "right bottom" : "left top";
                                $focusOverlay.show().css('visibility', 'hidden').appendTo($element.closest('.' + DATAGRID_CONTENT_CLASS)).outerWidth($element.outerWidth() + 1).outerHeight($element.outerHeight() + 1);
                                DX.position($focusOverlay, {
                                    my: align,
                                    at: align,
                                    of: $element
                                });
                                $focusOverlay.css('visibility', 'visible');
                                that._$focusedElement && that._$focusedElement.removeClass(DATAGRID_FOCUSED_ELEMENT_CLASS);
                                $element.addClass(DATAGRID_FOCUSED_ELEMENT_CLASS);
                                that._$focusedElement = $element;
                                that.focused.fire($element)
                            })
                    },
                    loseFocus: function() {
                        this._$focusedElement && this._$focusedElement.removeClass(DATAGRID_FOCUSED_ELEMENT_CLASS);
                        this._$focusedElement = null;
                        this._$focusOverlay && this._$focusOverlay.hide()
                    },
                    init: function() {
                        var that = this,
                            $container = that.component && that.component.element();
                        that.createAction("onEditorPreparing", {excludeValidators: ['designMode', 'disabled']});
                        that.createAction("onEditorPrepared", {excludeValidators: ['designMode', 'disabled']});
                        that._updateFocusHandler = that._updateFocusHandler || that.createAction($.proxy(that._updateFocus, that));
                        $(document).on(DATAGRID_UPDATE_FOCUS_EVENTS, that._updateFocusHandler);
                        $container && $container.on('dxclick', '.' + DATAGRID_FOCUS_OVERLAY_CLASS, function(e) {
                            var $focusOverlay = $(e.target),
                                element;
                            $focusOverlay.hide();
                            element = document.elementFromPoint(e.pageX, e.pageY);
                            $focusOverlay.show();
                            $(element).trigger('dxclick');
                            that._$focusedElement && that._$focusedElement.find('input').focus()
                        })
                    },
                    dispose: function() {
                        $(document).off(DATAGRID_UPDATE_FOCUS_EVENTS, this._updateFocusHandler)
                    },
                    createEditor: function($container, options) {
                        this.component._suppressDeprecatedWarnings();
                        var editorPreparing = this.option("editorPreparing"),
                            editorPrepared = this.option("editorPrepared");
                        this.component._resumeDeprecatedWarnings();
                        options.rtlEnabled = this.option('rtlEnabled');
                        options.disabled = options.disabled || this.option("disabled");
                        options.cancel = false;
                        options.editorElement = $container;
                        editorPreparing && editorPreparing($container, options);
                        this.executeAction("onEditorPreparing", options);
                        if (options.cancel)
                            return;
                        if (options.lookup)
                            createSelectBox($container, options);
                        else
                            switch (options.dataType) {
                                case'date':
                                    createCalendarPicker($container, options);
                                    break;
                                case'boolean':
                                    createBooleanEditor($container, options);
                                    break;
                                case'number':
                                    createNumberBox($container, options);
                                    break;
                                default:
                                    createTextBox($container, options);
                                    break
                            }
                        editorPrepared && editorPrepared($container, options);
                        this.executeAction("onEditorPrepared", options)
                    }
                }
        }());
        $.extend(dataGrid.__internals, {DATAGRID_FOCUSED_ELEMENT_CLASS: DATAGRID_FOCUSED_ELEMENT_CLASS});
        dataGrid.registerModule('editorFactory', {
            defaultOptions: function() {
                return {}
            },
            controllers: {editorFactory: dataGrid.EditorFactoryController}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnsView.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_SORT_CLASS = "dx-sort",
            DATAGRID_SORTUP_CLASS = "dx-sort-up",
            DATAGRID_SORTDOWN_CLASS = "dx-sort-down",
            DATAGRID_SORT_ALIGNMENT_CLASS = "dx-sort-alignment-",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_SCROLL_CONTAINER_CLASS = "dx-datagrid-scroll-container",
            DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
            DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_TABLE_FIXED_CLASS = "dx-datagrid-table-fixed";
        dataGrid.createColGroup = function(columns) {
            var colgroupElement = $('<colgroup />'),
                columnsLength = columns.length,
                i;
            for (i = 0; i < columnsLength; i++)
                $('<col />').width(columns[i].visibleWidth || columns[i].width).appendTo(colgroupElement);
            return colgroupElement
        };
        dataGrid.ColumnsView = dataGrid.View.inherit({
            _applySorting: function(rootElement, column, showColumnLines) {
                var $span,
                    columnAlignment;
                function getAlignment(columnAlignment) {
                    return columnAlignment === 'right' ? 'left' : 'right'
                }
                rootElement.find('.' + DATAGRID_SORT_CLASS).remove();
                if (utils.isDefined(column.sortOrder)) {
                    if (column.alignment === 'center') {
                        var align = this.option('rtlEnabled') ? 'right' : 'left';
                        $('<span />').addClass(DATAGRID_SORT_CLASS).css('float', align).prependTo(rootElement)
                    }
                    columnAlignment = column.alignment || 'left';
                    $span = $('<span />').addClass(DATAGRID_SORT_CLASS).css('float', showColumnLines ? getAlignment(column.alignment) : columnAlignment).toggleClass(DATAGRID_SORTUP_CLASS, column.sortOrder === 'asc').toggleClass(DATAGRID_SORTDOWN_CLASS, column.sortOrder === 'desc');
                    if (this.option("showColumnLines"))
                        $span.prependTo(rootElement);
                    else
                        $span.addClass(DATAGRID_SORT_ALIGNMENT_CLASS + columnAlignment).appendTo(rootElement)
                }
            },
            _updateSortIndicatorPositions: function(rootElement) {
                if (!rootElement)
                    return;
                var sortIndicators = rootElement.find('.' + DATAGRID_SORT_CLASS);
                $.each(sortIndicators, function() {
                    var $sortIndicator = $(this),
                        $sortIndicatorContainer = $sortIndicator.parent(),
                        $textContent = $sortIndicatorContainer.find('.' + DATAGRID_CELL_CONTENT_CLASS);
                    $sortIndicator.height($textContent.height() || $sortIndicatorContainer.height())
                })
            },
            _createRow: function() {
                return $("<tr />").addClass(DATAGRID_ROW_CLASS)
            },
            _createTable: function() {
                var that = this,
                    $table = $('<table />').addClass(DATAGRID_TABLE_CLASS).addClass(DATAGRID_TABLE_CLASS + '-fixed');
                if (that.option("cellHintEnabled"))
                    $table.on("mousemove", ".dx-row .dx-datagrid-text-content, .dx-row > td", this.createAction(function(args) {
                        var e = args.jQueryEvent,
                            element = $(e.currentTarget);
                        element.removeAttr("title");
                        if (element[0].scrollWidth > element[0].clientWidth)
                            element.attr("title", element.text())
                    }));
                return $table
            },
            _columnOptionChanged: function(e) {
                var optionNames = e.optionNames;
                if (dataGrid.checkChanges(optionNames, ['width', 'visibleWidth'])) {
                    var visibleColumns = this._columnsController.getVisibleColumns();
                    var widths = $.map(visibleColumns, function(column) {
                            return column.visibleWidth || column.width || 'auto'
                        });
                    this.setColumnWidths(widths);
                    return
                }
                this.render()
            },
            _getTableElements: function() {
                return this._tableElement || []
            },
            optionChanged: function(args) {
                this.callBase(args);
                if (args.name === 'cellHintEnabled')
                    this.render()
            },
            init: function() {
                var that = this;
                that._columnsController = that.getController('columns');
                that._dataController = that.getController('data');
                that._columnsController.columnsChanged.add(function(e) {
                    var dataControllerChangedHandler = function() {
                            that._dataController.changed.remove(dataControllerChangedHandler);
                            that._columnOptionChanged(e)
                        };
                    if (e.changeTypes.grouping)
                        that._dataController.changed.add(dataControllerChangedHandler);
                    else
                        that._columnOptionChanged(e)
                })
            },
            scrollOffset: function(pos) {
                var that = this,
                    $element = that.element(),
                    $scrollContainer = $element && $element.find('.' + DATAGRID_SCROLL_CONTAINER_CLASS);
                if (pos === undefined)
                    return $scrollContainer && $scrollContainer.scrollLeft();
                else if (that._scrollLeft !== pos) {
                    that._scrollLeft = pos;
                    $scrollContainer && $scrollContainer.scrollLeft(pos)
                }
            },
            wrapTableInScrollContainer: function($table) {
                return $('<div/>').addClass(DATAGRID_SCROLL_CONTAINER_CLASS).append($table)
            },
            getColumnWidths: function() {
                var that = this,
                    cells,
                    result = [],
                    width,
                    clientRect;
                if (that._tableElement) {
                    cells = that._tableElement.find('tr').filter(':not(.' + DATAGRID_GROUP_ROW_CLASS + ')').first().find('td');
                    $.each(cells, function(index, item) {
                        if (item.getBoundingClientRect) {
                            clientRect = item.getBoundingClientRect();
                            width = Math.floor(clientRect.right - clientRect.left)
                        }
                        else
                            width = $(item).outerWidth(true);
                        result.push(width)
                    })
                }
                return result
            },
            setColumnWidths: function(widths) {
                var $cols,
                    i,
                    columnIndex,
                    tableElements = this._getTableElements();
                if (widths)
                    for (i = 0; i < tableElements.length; i++) {
                        $cols = tableElements.eq(i).find('col');
                        for (columnIndex = 0; columnIndex < widths.length; columnIndex++)
                            $cols.eq(columnIndex).width(widths[columnIndex] || 'auto')
                    }
            },
            getColumnElements: function(){},
            getColumns: function(){},
            getCell: function(columnIndex, rowIndex) {
                var row;
                if (this._tableElement && this._tableElement.length === 1) {
                    row = this._tableElement[0].rows[rowIndex];
                    return row ? $(row.cells[columnIndex]) : null
                }
            },
            getRowsCount: function() {
                if (this._tableElement && this._tableElement.length === 1)
                    return this._tableElement[0].rows.length;
                return 0
            },
            getBoundingRect: function(){},
            getName: function(){},
            tableElement: function() {
                return this._tableElement
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_SORT_CLASS: DATAGRID_SORT_CLASS,
            DATAGRID_SORTUP_CLASS: DATAGRID_SORTUP_CLASS,
            DATAGRID_SORTDOWN_CLASS: DATAGRID_SORTDOWN_CLASS,
            DATAGRID_SORT_ALIGNMENT_CLASS: DATAGRID_SORT_ALIGNMENT_CLASS,
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_ROW_CLASS: DATAGRID_ROW_CLASS,
            DATAGRID_GROUP_ROW_CLASS: DATAGRID_GROUP_ROW_CLASS,
            DATAGRID_TABLE_CLASS: DATAGRID_TABLE_CLASS,
            DATAGRID_TABLE_FIXED_CLASS: DATAGRID_TABLE_FIXED_CLASS,
            DATAGRID_SCROLL_CONTAINER_CLASS: DATAGRID_SCROLL_CONTAINER_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnChooserModule.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_COLUMN_CHOOSER_CLASS = 'dx-datagrid-column-chooser',
            DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS = 'dx-datagrid-column-chooser-button',
            DATAGRID_COLUMN_CHOOSER_ICON_NAME = 'column-chooser',
            DATAGRID_COLUMN_CHOOSER_ITEM_CLASS = "dx-column-chooser-item",
            DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS = "dx-column-chooser-message",
            DATAGRID_HEADERS_DRAG_ACTION_CLASS = "dx-datagrid-drag-action";
        dataGrid.ColumnChooserController = dataGrid.ViewController.inherit({renderShowColumnChooserButton: function($element) {
                var that = this,
                    columnChooserEnabled = that.option("columnChooser.enabled"),
                    $showColumnChooserButton = $element.find("." + DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS);
                if (columnChooserEnabled)
                    if (!$showColumnChooserButton.length)
                        $('<div />').addClass(DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS).appendTo($element).dxButton({
                            icon: DATAGRID_COLUMN_CHOOSER_ICON_NAME,
                            onClick: function(e) {
                                that.getView("columnChooserView").showColumnChooser()
                            },
                            hint: that.option("columnChooser.title")
                        });
                    else
                        $showColumnChooserButton.show();
                else
                    $showColumnChooserButton.hide()
            }});
        dataGrid.ColumnChooserView = dataGrid.ColumnsView.inherit({
            _updateItems: function() {
                var hiddenColumns = this._columnsController.getHiddenColumns(),
                    columnChooserOptions = this.option("columnChooser"),
                    $content = this._popupContainer.content();
                $content.dxScrollable(dataGrid.createScrollableOptions(this));
                this._renderColumnChooserItems($content, hiddenColumns);
                if (!hiddenColumns.length)
                    $('<span />').addClass(DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS).text(columnChooserOptions ? columnChooserOptions.emptyPanelText : "").appendTo($content.dxScrollable("instance").content())
            },
            _initializePopupContainer: function() {
                var that = this,
                    $element = this.element().addClass(DATAGRID_COLUMN_CHOOSER_CLASS),
                    columnChooserOptions = this.option("columnChooser"),
                    theme = DevExpress.ui.themes.current(),
                    isGenericTheme = theme && theme.indexOf("generic") > -1;
                if (!utils.isDefined(this._popupContainer)) {
                    this._popupContainer = $element.dxPopup({
                        visible: false,
                        shading: false,
                        buttons: [{
                                text: columnChooserOptions.title,
                                toolbar: "top",
                                location: isGenericTheme ? "before" : "center"
                            }, {shortcut: isGenericTheme ? "close" : "cancel"}],
                        width: columnChooserOptions.width,
                        height: columnChooserOptions.height,
                        container: this.element().parent(),
                        rtlEnabled: this.option('rtlEnabled')
                    }).data('dxPopup');
                    this._popupContainer.on("optionChanged", function(args) {
                        if (args.name === "visible")
                            that.renderCompleted.fire()
                    })
                }
            },
            _renderCore: function() {
                if (this.option("columnChooser.enabled"))
                    this._initializePopupContainer();
                if (this._popupContainer)
                    this._updateItems()
            },
            _renderColumnChooserItems: function($container, hiddenColumns) {
                var dxScrollable = $container.dxScrollable("instance"),
                    $scrollableContainer = dxScrollable.content(),
                    $item;
                $scrollableContainer.empty();
                $.each(hiddenColumns, function(index, hiddenColumn) {
                    if (hiddenColumn.showInColumnChooser)
                        $item = $('<div />').addClass(hiddenColumn.cssClass).addClass(DATAGRID_COLUMN_CHOOSER_ITEM_CLASS).toggleClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS, hiddenColumn.allowHiding).text(hiddenColumn.caption).appendTo($scrollableContainer)
                });
                dxScrollable.update()
            },
            getColumnElements: function() {
                var $content = this._popupContainer && this._popupContainer.content();
                return $content && $content.find('.' + DATAGRID_COLUMN_CHOOSER_ITEM_CLASS)
            },
            getName: function() {
                return 'columnChooser'
            },
            getColumns: function() {
                return this._columnsController.getHiddenColumns()
            },
            allowDragging: function(column) {
                return this.isColumnChooserVisible() && column && column.allowHiding
            },
            getBoundingRect: function() {
                var that = this,
                    container = that._popupContainer && that._popupContainer._container(),
                    offset;
                if (container && container.is(':visible')) {
                    offset = container.offset();
                    return {
                            left: offset.left,
                            top: offset.top,
                            right: offset.left + container.outerWidth(),
                            bottom: offset.top + container.outerHeight()
                        }
                }
                return null
            },
            showColumnChooser: function() {
                this._isPopupContainerShown = true;
                if (!this._popupContainer) {
                    this._initializePopupContainer();
                    this.render()
                }
                this._popupContainer.show()
            },
            hideColumnChooser: function() {
                if (this._popupContainer) {
                    this._popupContainer.hide();
                    this._isPopupContainerShown = false
                }
            },
            isColumnChooserVisible: function() {
                var popupContainer = this._popupContainer;
                return popupContainer && popupContainer.option("visible")
            },
            publicMethods: function() {
                return ['showColumnChooser', 'hideColumnChooser']
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_COLUMN_CHOOSER_CLASS: DATAGRID_COLUMN_CHOOSER_CLASS,
            DATAGRID_COLUMN_CHOOSER_ITEM_CLASS: DATAGRID_COLUMN_CHOOSER_ITEM_CLASS,
            DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS: DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS,
            DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS: DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS
        });
        dataGrid.registerModule('columnChooser', {
            defaultOptions: function() {
                return {columnChooser: {
                            enabled: false,
                            width: 250,
                            height: 260,
                            title: Globalize.localize("dxDataGrid-columnChooserTitle"),
                            emptyPanelText: Globalize.localize("dxDataGrid-columnChooserEmptyText")
                        }}
            },
            controllers: {columnChooser: dataGrid.ColumnChooserController},
            views: {columnChooserView: dataGrid.ColumnChooserView},
            extenders: {views: {headerPanel: {
                        _renderShowColumnChooserButton: function() {
                            this.getController("columnChooser").renderShowColumnChooserButton(this.element())
                        },
                        _renderCore: function() {
                            this.callBase();
                            this._renderShowColumnChooserButton()
                        },
                        optionChanged: function(args) {
                            this.callBase(args);
                            switch (args.name) {
                                case'columnChooser':
                                    this._renderShowColumnChooserButton();
                                    break
                            }
                        },
                        isVisible: function() {
                            var that = this,
                                columnChooserEnabled = that.option('columnChooser.enabled');
                            return that.callBase() || columnChooserEnabled
                        }
                    }}}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.editing.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            events = DX.ui.events,
            addNamespace = events.addNamespace,
            utils = DX.utils,
            getIndexByKey = dataGrid.getIndexByKey;
        var DATAGRID_LINK_CLASS = "dx-link",
            DATAGRID_EDITOR_CELL_CLASS = "dx-editor-cell",
            DATAGRID_ROW_SELECTED = "dx-selection",
            DATAGRID_EDIT_ROW = "dx-edit-row",
            DATAGRID_EDIT_BUTTON_CLASS = "dx-edit-button",
            DATAGRID_INSERT_INDEX = "__DX_INSERT_INDEX__",
            DATAGRID_ROW_REMOVED = "dx-row-removed",
            DATAGRID_ROW_INSERTED = "dx-row-inserted",
            DATAGRID_ROW_MODIFIED = "dx-row-modified",
            DATAGRID_CELL_MODIFIED = "dx-cell-modified",
            DATAGRID_CELL_HIGHLIGHT_OUTLINE = "dx-highlight-outline",
            DATAGRID_EDITING_NAMESPACE = "dxDataGridEditing",
            DATAGRID_FOCUS_OVERLAY_CLASS = "dx-datagrid-focus-overlay",
            DATAGRID_READONLY_CLASS = "dx-datagrid-readonly",
            CHECKBOX_CLASS = "dx-checkbox",
            WIDGET_CLASS = "dx-widget",
            DATAGRID_EDIT_MODE_BATCH = "batch",
            DATAGRID_EDIT_MODE_ROW = "row",
            DATAGRID_EDIT_MODE_CELL = "cell",
            DATA_EDIT_DATA_INSERT_TYPE = "insert",
            DATA_EDIT_DATA_UPDATE_TYPE = "update",
            DATA_EDIT_DATA_REMOVE_TYPE = "remove";
        var getEditMode = function(that) {
                var editMode = that.option('editing.editMode');
                if (editMode === DATAGRID_EDIT_MODE_BATCH || editMode === DATAGRID_EDIT_MODE_CELL)
                    return editMode;
                return DATAGRID_EDIT_MODE_ROW
            };
        dataGrid.EditingController = dataGrid.ViewController.inherit(function() {
            var getDefaultEditorTemplate = function(that) {
                    return function(container, options) {
                            var $editor = $('<div/>').appendTo(container);
                            that.getController('editorFactory').createEditor($editor, $.extend({}, options.column, {
                                value: options.value,
                                setValue: options.setValue,
                                parentType: 'dataRow',
                                width: null,
                                readOnly: options.setValue === undefined
                            }))
                        }
                };
            var getDataController = function(that) {
                    return that.getController('data')
                };
            return {
                    init: function() {
                        var that = this;
                        that._insertIndex = 1;
                        that._editRowIndex = -1;
                        that._editData = [];
                        that._editColumnIndex = -1;
                        that._columnsController = that.getController("columns");
                        that.createAction("onInitNewRow", {excludeValidators: ['disabled']});
                        that.createAction("onRowInserting", {excludeValidators: ['disabled']});
                        that.createAction("onRowInserted", {excludeValidators: ['disabled']});
                        that.createAction("onEditingStart", {excludeValidators: ['disabled']});
                        that.createAction("onRowUpdating", {excludeValidators: ['disabled']});
                        that.createAction("onRowUpdated", {excludeValidators: ['disabled']});
                        that.createAction("onRowRemoving", {excludeValidators: ['disabled']});
                        that.createAction("onRowRemoved", {excludeValidators: ['disabled']});
                        if (!that._saveEditorHandler) {
                            that._saveEditorHandler = that.createAction(function(e) {
                                var event = e.jQueryEvent,
                                    visibleColumns,
                                    isEditorPopup,
                                    isFocusOverlay,
                                    $targetCell,
                                    allowEditing,
                                    cellIndex,
                                    isDataRow;
                                if (getEditMode(that) !== DATAGRID_EDIT_MODE_ROW && that.isEditing() && !that._editCellInProgress) {
                                    isEditorPopup = $(event.target).closest('.dx-overlay-wrapper').length;
                                    isFocusOverlay = $(event.target).hasClass(DATAGRID_FOCUS_OVERLAY_CLASS);
                                    isDataRow = $(event.target).closest('.dx-data-row').length;
                                    visibleColumns = that._columnsController.getVisibleColumns();
                                    $targetCell = $(event.target).closest('td');
                                    cellIndex = $targetCell[0] && $targetCell[0].cellIndex;
                                    allowEditing = visibleColumns[cellIndex] && visibleColumns[cellIndex].allowEditing;
                                    if ((!isDataRow || isDataRow && !allowEditing) && !isEditorPopup && !isFocusOverlay)
                                        that.closeEditCell()
                                }
                            });
                            $(document).on('dxclick', that._saveEditorHandler)
                        }
                        that._updateEditColumn();
                        that._updateEditButtons()
                    },
                    getEditMode: function() {
                        return getEditMode(this)
                    },
                    getIndexByKey: function(key, items) {
                        return getIndexByKey(key, items)
                    },
                    hasChanges: function() {
                        var that = this,
                            result = false;
                        $.each(that._editData, function(_, editData) {
                            result = result || !!editData.type
                        });
                        return result
                    },
                    dispose: function() {
                        this.callBase();
                        $(document).off('dxclick', this._saveEditorHandler)
                    },
                    optionChanged: function(args) {
                        if (args.name === "editing")
                            this.init();
                        this.callBase(args)
                    },
                    publicMethods: function() {
                        return ['insertRow', 'editRow', 'editCell', 'closeEditCell', 'removeRow', 'saveEditData', 'recoverRow', 'undeleteRow', 'cancelEditData']
                    },
                    refresh: function() {
                        var editRowIndex = this._editRowIndex,
                            editData = this._editData;
                        if (getEditMode(this) === DATAGRID_EDIT_MODE_ROW || getEditMode(this) === DATAGRID_EDIT_MODE_CELL)
                            this.init();
                        else {
                            this._editRowIndex = -1;
                            this._editColumnIndex = -1
                        }
                    },
                    isEditing: function() {
                        return this._editRowIndex > -1
                    },
                    isEditRow: function(rowIndex) {
                        return getEditMode(this) === DATAGRID_EDIT_MODE_ROW && this._editRowIndex === rowIndex
                    },
                    isEditCell: function(rowIndex, columnIndex) {
                        return this._editRowIndex === rowIndex && this._editColumnIndex === columnIndex
                    },
                    processItems: function(items, changeType) {
                        var that = this,
                            editData = that._editData,
                            i,
                            key,
                            data;
                        that.update();
                        for (i = 0; i < editData.length; i++) {
                            key = editData[i].key;
                            data = {key: key};
                            if (editData[i].type === DATA_EDIT_DATA_INSERT_TYPE && key.pageIndex === that._pageIndex) {
                                data[DATAGRID_INSERT_INDEX] = key[DATAGRID_INSERT_INDEX];
                                items.splice(key.rowIndex, 0, data)
                            }
                        }
                        return items
                    },
                    processDataItem: function(item, columns, generateDataValues) {
                        var that = this,
                            editIndex,
                            editData,
                            data,
                            key = item.data[DATAGRID_INSERT_INDEX] ? item.data.key : item.key,
                            editMode = getEditMode(that);
                        editIndex = getIndexByKey(key, that._editData);
                        if (editIndex >= 0) {
                            editData = that._editData[editIndex];
                            data = editData.data;
                            switch (editData.type) {
                                case DATA_EDIT_DATA_INSERT_TYPE:
                                    item.inserted = true;
                                    item.key = key;
                                    item.data = data;
                                    break;
                                case DATA_EDIT_DATA_UPDATE_TYPE:
                                    item.modified = true;
                                    item.data = $.extend(true, {}, item.data, data);
                                    item.modifiedValues = generateDataValues(data, columns);
                                    break;
                                case DATA_EDIT_DATA_REMOVE_TYPE:
                                    if (editMode === DATAGRID_EDIT_MODE_BATCH)
                                        item.data = $.extend(true, {}, item.data, data);
                                    item.removed = true;
                                    break
                            }
                        }
                    },
                    insertRow: function() {
                        var that = this,
                            dataController = getDataController(that),
                            rowsView = that.getView('rowsView'),
                            param = {data: {}},
                            insertKey = {
                                pageIndex: dataController.pageIndex(),
                                rowIndex: rowsView ? rowsView.getTopVisibleItemIndex() : 0
                            },
                            oldEditRowIndex = that._editRowIndex,
                            editMode = getEditMode(that);
                        that.refresh();
                        if (editMode !== DATAGRID_EDIT_MODE_BATCH) {
                            if (that._insertIndex > 1)
                                return;
                            that._editRowIndex = insertKey.rowIndex
                        }
                        that.executeAction("onInitNewRow", param);
                        insertKey[DATAGRID_INSERT_INDEX] = that._insertIndex++;
                        that._addEditData({
                            key: insertKey,
                            data: param.data,
                            type: DATA_EDIT_DATA_INSERT_TYPE
                        });
                        dataController.updateItems({
                            changeType: 'update',
                            rowIndices: [oldEditRowIndex, insertKey.rowIndex]
                        });
                        that._afterInsertRow({
                            key: insertKey,
                            data: param.data
                        })
                    },
                    _isEditingStart: function(options) {
                        this.executeAction("onEditingStart", options);
                        return options.cancel
                    },
                    editRow: function(rowIndex) {
                        var that = this,
                            dataController = getDataController(that),
                            items = dataController.items(),
                            item = items[rowIndex],
                            params = {
                                data: item.data,
                                key: item.key,
                                cancel: false
                            },
                            oldEditRowIndex = that._editRowIndex;
                        if (rowIndex === oldEditRowIndex)
                            return true;
                        if (!item.inserted)
                            params.key = item.key;
                        if (that._isEditingStart(params))
                            return;
                        that.init();
                        that._pageIndex = dataController.pageIndex();
                        if (!items[0].inserted) {
                            that._editRowIndex = rowIndex;
                            that._addEditData({
                                data: {},
                                key: item.key,
                                oldData: item.data
                            });
                            dataController.updateItems({
                                changeType: 'update',
                                rowIndices: [oldEditRowIndex, that._editRowIndex]
                            })
                        }
                    },
                    editCell: function(rowIndex, columnIndex) {
                        var that = this,
                            dataController = getDataController(that),
                            items = dataController.items(),
                            item = items[rowIndex],
                            params = {
                                data: item && item.data,
                                cancel: false,
                                column: that._columnsController.getVisibleColumns()[columnIndex]
                            },
                            editMode = getEditMode(that),
                            oldEditRowIndex = that._editRowIndex,
                            oldEditColumnIndex = that._editColumnIndex,
                            isCellEditingAllowed = params.column && params.column.allowEditing,
                            showEditorAlways = params.column && params.column.showEditorAlways;
                        if (isCellEditingAllowed && item && item.rowType === 'data' && !item.removed && editMode !== DATAGRID_EDIT_MODE_ROW) {
                            if (editMode === DATAGRID_EDIT_MODE_CELL && !item.inserted && that.hasChanges()) {
                                that.saveEditData();
                                if (that.hasChanges())
                                    return true
                            }
                            if (that.isEditCell(rowIndex, columnIndex))
                                return true;
                            if (!item.inserted)
                                params.key = item.key;
                            if (that._isEditingStart(params))
                                return true;
                            that._editRowIndex = rowIndex;
                            that._editColumnIndex = columnIndex;
                            that._pageIndex = dataController.pageIndex();
                            that._addEditData({
                                data: {},
                                key: item.key,
                                oldData: item.data
                            });
                            if (!showEditorAlways || oldEditColumnIndex >= 0 && oldEditColumnIndex !== columnIndex) {
                                that._editCellInProgress = true;
                                dataController.updateItems({
                                    changeType: 'update',
                                    rowIndices: [oldEditRowIndex, that._editRowIndex]
                                })
                            }
                            setTimeout(function() {
                                var rowsView = that.getView("rowsView"),
                                    $editCell = rowsView.getCellElement(that._editRowIndex, that._editColumnIndex);
                                $editCell && $editCell.find('input').focus();
                                that._editCellInProgress = false
                            });
                            return true
                        }
                        return false
                    },
                    removeRow: function(rowIndex) {
                        var that = this,
                            editingOptions = that.option("editing"),
                            editingTexts = editingOptions && editingOptions.texts,
                            confirmDeleteTitle = editingTexts && editingTexts.confirmDeleteTitle,
                            isBatchMode = editingOptions && editingOptions.editMode === DATAGRID_EDIT_MODE_BATCH,
                            confirmDeleteMessage = editingTexts && editingTexts.confirmDeleteMessage,
                            dataController = getDataController(that),
                            removeByKey,
                            oldEditRowIndex = that._editRowIndex,
                            item = dataController.items()[rowIndex],
                            key = item && item.key;
                        if (item) {
                            removeByKey = function(key) {
                                that.refresh();
                                var editIndex = getIndexByKey(key, that._editData);
                                if (editIndex >= 0)
                                    if (that._editData[editIndex].type === DATA_EDIT_DATA_INSERT_TYPE)
                                        that._editData.splice(editIndex, 1);
                                    else
                                        that._editData[editIndex].type = DATA_EDIT_DATA_REMOVE_TYPE;
                                else
                                    that._addEditData({
                                        key: key,
                                        oldData: item.data,
                                        type: DATA_EDIT_DATA_REMOVE_TYPE
                                    });
                                if (isBatchMode)
                                    dataController.updateItems({
                                        changeType: 'update',
                                        rowIndices: [oldEditRowIndex, rowIndex]
                                    });
                                else
                                    that.saveEditData()
                            };
                            if (isBatchMode || !confirmDeleteMessage)
                                removeByKey(key);
                            else
                                DX.ui.dialog.confirm(confirmDeleteMessage, confirmDeleteTitle).done(function(confirmResult) {
                                    if (confirmResult)
                                        removeByKey(key)
                                })
                        }
                    },
                    recoverRow: function(rowIndex) {
                        DX.log("W1002", "recoverRow", "14.1", "Use the 'undeleteRow' method instead");
                        return this.undeleteRow(rowIndex)
                    },
                    undeleteRow: function(rowIndex) {
                        var that = this,
                            dataController = getDataController(that),
                            item = dataController.items()[rowIndex],
                            oldEditRowIndex = that._editRowIndex,
                            key = item && item.key;
                        if (item) {
                            var editIndex = getIndexByKey(key, that._editData),
                                editData;
                            if (editIndex >= 0) {
                                editData = that._editData[editIndex];
                                if ($.isEmptyObject(editData.data))
                                    that._editData.splice(editIndex, 1);
                                else
                                    editData.type = DATA_EDIT_DATA_UPDATE_TYPE;
                                dataController.updateItems({
                                    changeType: 'update',
                                    rowIndices: [oldEditRowIndex, rowIndex]
                                })
                            }
                        }
                    },
                    saveEditData: function() {
                        var that = this,
                            dataController = getDataController(that),
                            store = dataController.store(),
                            item,
                            key,
                            processedKeys = [],
                            deferreds = [],
                            rowIndex = that._editRowIndex,
                            editData = $.extend({}, that._editData),
                            editMode = getEditMode(that);
                        var removeEditData = function(that, keys) {
                                $.each(keys, function(index, key) {
                                    var editIndex = getIndexByKey(key, that._editData);
                                    if (editIndex >= 0)
                                        that._editData.splice(editIndex, 1)
                                })
                            };
                        var resetEditIndeces = function(that) {
                                that._editColumnIndex = -1;
                                that._editRowIndex = -1
                            };
                        if (that._beforeSaveEditData())
                            return;
                        $.each(that._editData, function(index, editData) {
                            var data = editData.data,
                                oldData = editData.oldData,
                                key = editData.key,
                                type = editData.type,
                                deferred,
                                params;
                            if (that._beforeSaveEditData(editData, index))
                                return;
                            switch (type) {
                                case DATA_EDIT_DATA_REMOVE_TYPE:
                                    params = {
                                        data: oldData,
                                        key: key,
                                        cancel: false
                                    };
                                    that.executeAction("onRowRemoving", params);
                                    if (params.cancel)
                                        return;
                                    deferred = store.remove(key);
                                    break;
                                case DATA_EDIT_DATA_INSERT_TYPE:
                                    params = {
                                        data: data,
                                        cancel: false
                                    };
                                    that.executeAction("onRowInserting", params);
                                    if (params.cancel)
                                        return;
                                    deferred = store.insert(data);
                                    break;
                                case DATA_EDIT_DATA_UPDATE_TYPE:
                                    params = {
                                        newData: data,
                                        oldData: oldData,
                                        key: key,
                                        cancel: false
                                    };
                                    that.executeAction("onRowUpdating", params);
                                    if (params.cancel)
                                        return;
                                    deferred = store.update(key, data);
                                    break
                            }
                            if (deferred) {
                                deferred.done($.proxy(processedKeys.push, processedKeys, key));
                                deferreds.push(deferred)
                            }
                        });
                        if (deferreds.length) {
                            $.when.apply($, deferreds).always(function(e) {
                                var isError = e && e.name === "Error";
                                if (isError) {
                                    dataController.dataErrorOccurred.fire(e);
                                    if (editMode !== DATAGRID_EDIT_MODE_BATCH)
                                        return
                                }
                                removeEditData(that, processedKeys);
                                resetEditIndeces(that);
                                $.when(dataController.refresh()).always(function() {
                                    $.each(editData, function(_, itemData) {
                                        var data = itemData.data,
                                            key = itemData.key,
                                            type = itemData.type,
                                            params = {
                                                key: key,
                                                data: data
                                            };
                                        if (isError)
                                            params.error = e;
                                        switch (type) {
                                            case DATA_EDIT_DATA_REMOVE_TYPE:
                                                that.executeAction("onRowRemoved", $.extend({}, params, {data: itemData.oldData}));
                                                break;
                                            case DATA_EDIT_DATA_INSERT_TYPE:
                                                that.executeAction("onRowInserted", params);
                                                break;
                                            case DATA_EDIT_DATA_UPDATE_TYPE:
                                                that.executeAction("onRowUpdated", params);
                                                break
                                        }
                                    });
                                    that._afterSaveEditData()
                                })
                            });
                            return
                        }
                        if (editMode === DATAGRID_EDIT_MODE_ROW) {
                            if (!that.hasChanges())
                                that.cancelEditData()
                        }
                        else {
                            resetEditIndeces(that);
                            dataController.updateItems(rowIndex >= 0 && {
                                changeType: 'update',
                                rowIndices: [rowIndex]
                            })
                        }
                        that._afterSaveEditData()
                    },
                    _updateEditColumn: function() {
                        var that = this,
                            editing = that.option('editing'),
                            isEditColumnVisible = editing && ((editing.editEnabled || editing.insertEnabled) && getEditMode(that) === DATAGRID_EDIT_MODE_ROW || editing.removeEnabled);
                        that._columnsController.addCommandColumn({
                            command: 'edit',
                            visible: isEditColumnVisible,
                            cssClass: "dx-command-edit",
                            width: "auto"
                        });
                        that._columnsController.columnOption("command:edit", "visible", isEditColumnVisible)
                    },
                    _updateEditButtons: function() {
                        var that = this,
                            saveChangesButton = that._saveChangesButton,
                            cancelChangesButton = that._cancelChangesButton,
                            hasChanges = that.hasChanges();
                        if (saveChangesButton)
                            saveChangesButton.option('disabled', !hasChanges);
                        if (cancelChangesButton)
                            cancelChangesButton.option('disabled', !hasChanges)
                    },
                    cancelEditData: function() {
                        var that = this,
                            dataController = getDataController(that);
                        that._beforeCancelEditData();
                        that.init();
                        dataController.updateItems()
                    },
                    closeEditCell: function() {
                        var that = this,
                            oldEditRowIndex = that._editRowIndex,
                            dataController = getDataController(that);
                        setTimeout(function() {
                            if (getEditMode(that) === DATAGRID_EDIT_MODE_CELL && that.hasChanges())
                                that.saveEditData();
                            else if (oldEditRowIndex >= 0) {
                                that._editRowIndex = -1;
                                that._editColumnIndex = -1;
                                dataController.updateItems({
                                    changeType: 'update',
                                    rowIndices: [oldEditRowIndex]
                                });
                                that._afterCloseEditCell()
                            }
                        })
                    },
                    update: function() {
                        var that = this,
                            dataController = getDataController(that);
                        if (that._pageIndex !== dataController.pageIndex()) {
                            that.refresh();
                            that._pageIndex = dataController.pageIndex()
                        }
                        that._updateEditButtons()
                    },
                    updateFieldValue: function(options, value) {
                        var that = this,
                            data = {},
                            rowKey = options.key,
                            dataField = options.column.dataField,
                            serializedValue = options.column.serializeValue ? options.column.serializeValue(value) : value,
                            params;
                        options.value = value;
                        if (rowKey !== undefined) {
                            data[dataField] = serializedValue;
                            params = {
                                data: data,
                                key: rowKey,
                                type: DATA_EDIT_DATA_UPDATE_TYPE
                            };
                            that._addEditData(params);
                            that._updateEditButtons()
                        }
                    },
                    _addEditData: function(options) {
                        var that = this,
                            editDataIndex = getIndexByKey(options.key, that._editData);
                        if (editDataIndex < 0) {
                            editDataIndex = that._editData.length;
                            that._editData.push(options)
                        }
                        if (that._editData[editDataIndex]) {
                            options.type = that._editData[editDataIndex].type || options.type;
                            $.extend(true, that._editData[editDataIndex], {
                                data: options.data,
                                type: options.type
                            })
                        }
                        return editDataIndex
                    },
                    getColumnTemplate: function(options) {
                        var that = this,
                            column = options.column,
                            rowIndex = options.row && options.row.rowIndex,
                            template,
                            editingOptions,
                            editingTexts,
                            editEnabled = that.option("editing.editEnabled"),
                            isRowMode = getEditMode(that) === DATAGRID_EDIT_MODE_ROW,
                            isRowEditing = that.isEditRow(rowIndex),
                            isCellEditing = that.isEditCell(rowIndex, options.columnIndex);
                        if (column.showEditorAlways || column.allowEditing && column.dataField && (isRowEditing || isCellEditing) && options.rowType === 'data') {
                            if ((editEnabled || isRowEditing || isCellEditing) && (isRowMode && isRowEditing || !isRowMode))
                                options.setValue = function(value) {
                                    that.updateFieldValue(options, value)
                                };
                            template = column.editCellTemplate || getDefaultEditorTemplate(that)
                        }
                        else if (column.command === 'edit')
                            template = function(container, options) {
                                var createLink = function(container, text, methodName, options) {
                                        var $link = $('<a />').addClass(DATAGRID_LINK_CLASS).text(text).on(addNamespace('dxclick', DATAGRID_EDITING_NAMESPACE), that.createAction(function(params) {
                                                var e = params.jQueryEvent;
                                                e.stopPropagation();
                                                setTimeout(function() {
                                                    options.row && that[methodName](options.row.rowIndex)
                                                })
                                            }));
                                        options.rtlEnabled ? container.prepend($link, "&nbsp;") : container.append($link, "&nbsp;")
                                    };
                                container.css('text-align', 'center');
                                options.rtlEnabled = that.option('rtlEnabled');
                                editingOptions = that.option("editing") || {};
                                editingTexts = editingOptions.texts || {};
                                if (options.row && options.row.rowIndex === that._editRowIndex && isRowMode) {
                                    createLink(container, editingTexts.saveRowChanges, 'saveEditData', options);
                                    createLink(container, editingTexts.cancelRowChanges, 'cancelEditData', options)
                                }
                                else {
                                    if (editingOptions.editEnabled && isRowMode)
                                        createLink(container, editingTexts.editRow, 'editRow', options);
                                    if (editingOptions.removeEnabled)
                                        if (options.row.removed)
                                            createLink(container, editingTexts.undeleteRow, 'undeleteRow', options);
                                        else
                                            createLink(container, editingTexts.deleteRow, 'removeRow', options)
                                }
                            };
                        return template
                    },
                    renderEditButtons: function(rootElement) {
                        var that = this,
                            insertButton = rootElement.find('.' + DATAGRID_EDIT_BUTTON_CLASS),
                            editingOptions = that.option("editing") || {},
                            editingTexts = that.option("editing.texts") || {},
                            titleButtonTextByClassNames = {
                                cancel: editingTexts.cancelAllChanges,
                                save: editingTexts.saveAllChanges,
                                addrow: editingTexts.addRow
                            };
                        var createEditButton = function(rootElement, className, methodName) {
                                return $('<div />').addClass(DATAGRID_EDIT_BUTTON_CLASS).addClass("dx-datagrid-" + className + "-button").appendTo(rootElement).dxButton({
                                        icon: "edit-button-" + className,
                                        onClick: function(options) {
                                            var e = options.jQueryEvent;
                                            e.stopPropagation();
                                            that[methodName]()
                                        },
                                        hint: titleButtonTextByClassNames && titleButtonTextByClassNames[className]
                                    }).dxButton('instance')
                            };
                        if (insertButton.length)
                            insertButton.remove();
                        if ((editingOptions.editEnabled || editingOptions.insertEnabled || editingOptions.removeEnabled) && getEditMode(that) === DATAGRID_EDIT_MODE_BATCH) {
                            that._cancelChangesButton = createEditButton(rootElement, "cancel", 'cancelEditData');
                            that._saveChangesButton = createEditButton(rootElement, "save", 'saveEditData');
                            that._updateEditButtons()
                        }
                        if (editingOptions.insertEnabled)
                            createEditButton(rootElement, "addrow", 'insertRow')
                    },
                    createHighlightCell: function($cell, column) {
                        var $highlight = $cell.find("." + DATAGRID_CELL_HIGHLIGHT_OUTLINE),
                            $contents;
                        if (!$highlight.length) {
                            $cell.addClass(DATAGRID_CELL_MODIFIED);
                            $contents = $cell.contents();
                            if (column.showEditorAlways || $cell.find('.' + WIDGET_CLASS).length)
                                $highlight = $cell.find('.' + CHECKBOX_CLASS).length ? $('<div>').wrapInner($contents) : $cell.find('.' + WIDGET_CLASS).first();
                            else
                                $highlight = $('<div>').append(!$contents.length || $contents.length === 1 && !$contents.eq(0).text().length ? "&nbsp;" : $contents);
                            $highlight.appendTo($cell).addClass(DATAGRID_CELL_HIGHLIGHT_OUTLINE)
                        }
                        return $highlight
                    },
                    removeHighlightCell: function($cell) {
                        var $highlight = $cell.find("." + DATAGRID_CELL_HIGHLIGHT_OUTLINE),
                            $widget = $cell.find('.' + WIDGET_CLASS);
                        if ($widget.length && !$cell.find('.' + CHECKBOX_CLASS).length)
                            $widget.removeClass(DATAGRID_CELL_HIGHLIGHT_OUTLINE);
                        else
                            $highlight.children().unwrap()
                    },
                    _afterInsertRow: function(options){},
                    _beforeEditCell: function(){},
                    _beforeSaveEditData: function(editData, editIndex){},
                    _afterSaveEditData: function(){},
                    _beforeCancelEditData: function(){},
                    _afterCloseEditCell: function(){}
                }
        }());
        dataGrid.registerModule('editing', {
            defaultOptions: function() {
                return {editing: {
                            editMode: 'row',
                            insertEnabled: false,
                            editEnabled: false,
                            removeEnabled: false,
                            texts: {
                                editRow: Globalize.localize("dxDataGrid-editingEditRow"),
                                saveAllChanges: Globalize.localize("dxDataGrid-editingSaveAllChanges"),
                                saveRowChanges: Globalize.localize("dxDataGrid-editingSaveRowChanges"),
                                cancelAllChanges: Globalize.localize("dxDataGrid-editingCancelAllChanges"),
                                cancelRowChanges: Globalize.localize("dxDataGrid-editingCancelRowChanges"),
                                addRow: Globalize.localize("dxDataGrid-editingAddRow"),
                                deleteRow: Globalize.localize("dxDataGrid-editingDeleteRow"),
                                recoverRow: Globalize.localize("dxDataGrid-editingUndeleteRow"),
                                undeleteRow: Globalize.localize("dxDataGrid-editingUndeleteRow"),
                                confirmDeleteMessage: Globalize.localize("dxDataGrid-editingConfirmDeleteMessage"),
                                confirmDeleteTitle: Globalize.localize("dxDataGrid-editingConfirmDeleteTitle")
                            }
                        }}
            },
            controllers: {editing: dataGrid.EditingController},
            extenders: {
                controllers: {data: {
                        init: function() {
                            this._editingController = this.getController('editing');
                            this.callBase()
                        },
                        reload: function() {
                            this._editingController.refresh();
                            return this.callBase()
                        },
                        _processItems: function(items, changeType) {
                            items = this._editingController.processItems(items, changeType);
                            return this.callBase(items, changeType)
                        },
                        _processDataItem: function(dataItem, options) {
                            this._editingController.processDataItem(dataItem, options.visibleColumns, this._generateDataValues);
                            return this.callBase(dataItem, options)
                        }
                    }},
                views: {
                    rowsView: {
                        _getColumnTemplate: function(options) {
                            var that = this,
                                template = that.getController('editing').getColumnTemplate(options);
                            return template || that.callBase(options)
                        },
                        _createRow: function(options) {
                            var $row = this.callBase(options),
                                editingController,
                                isEditRow,
                                isRowRemoved,
                                isRowInserted,
                                isRowModified;
                            if (options) {
                                editingController = this.getController('editing');
                                isEditRow = editingController.isEditRow(options.rowIndex);
                                isRowRemoved = !!options.removed;
                                isRowInserted = !!options.inserted;
                                isRowModified = !!options.modified;
                                if (getEditMode(this) === DATAGRID_EDIT_MODE_BATCH)
                                    $row.toggleClass(DATAGRID_ROW_REMOVED, isRowRemoved);
                                else
                                    $row.toggleClass(DATAGRID_EDIT_ROW, isEditRow);
                                $row.toggleClass(DATAGRID_ROW_INSERTED, isRowInserted);
                                $row.toggleClass(DATAGRID_ROW_MODIFIED, isRowModified);
                                if (isEditRow || isRowInserted || isRowRemoved || isRowModified)
                                    $row.removeClass(DATAGRID_ROW_SELECTED)
                            }
                            return $row
                        },
                        _rowClick: function(rowIndex, event) {
                            var that = this,
                                editingController = that.getController('editing'),
                                $targetCell = $(event.target).closest('td'),
                                columnIndex = $targetCell.length ? $targetCell[0].cellIndex : -1,
                                editEnabled = that.option("editing.editEnabled");
                            if (!(editEnabled && editingController.editCell(rowIndex, columnIndex)) && !editingController.isEditRow(rowIndex))
                                that.callBase(rowIndex, event)
                        },
                        _cellPrepared: function($cell, parameters) {
                            var modifiedValues = parameters.row && (parameters.row.inserted ? parameters.row.values : parameters.row.modifiedValues),
                                columnIndex = parameters.columnIndex,
                                alignment = parameters.column.alignment,
                                editingController = this.getController('editing');
                            parameters.isEditing = editingController.isEditCell(parameters.rowIndex, parameters.columnIndex) || editingController.isEditRow(parameters.rowIndex) && parameters.column.allowEditing;
                            if (parameters.isEditing || parameters.column.showEditorAlways) {
                                $cell.addClass(DATAGRID_EDITOR_CELL_CLASS).toggleClass(DATAGRID_READONLY_CLASS, !parameters.setValue);
                                if (alignment)
                                    $cell.find('input').first().css('text-align', alignment)
                            }
                            if (modifiedValues && parameters.column && parameters.column.allowEditing && modifiedValues[columnIndex] !== undefined && !parameters.isEditing)
                                editingController.createHighlightCell($cell, parameters.column);
                            this.callBase.apply(this, arguments)
                        },
                        _update: function(change) {
                            this.callBase(change);
                            if (change.changeType === 'updateSelection')
                                this._tableElement.children('tbody').children('.' + DATAGRID_EDIT_ROW).removeClass(DATAGRID_ROW_SELECTED)
                        }
                    },
                    headerPanel: {
                        _renderCore: function() {
                            this.callBase();
                            this.getController('editing').renderEditButtons(this.element())
                        },
                        isVisible: function() {
                            var that = this,
                                editingOptions = that.getController('editing').option('editing');
                            return that.callBase() || editingOptions && (editingOptions.insertEnabled || (editingOptions.editEnabled || editingOptions.removeEnabled) && editingOptions.editMode === DATAGRID_EDIT_MODE_BATCH)
                        }
                    }
                }
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_LINK_CLASS: DATAGRID_LINK_CLASS,
            DATAGRID_EDITOR_CELL_CLASS: DATAGRID_EDITOR_CELL_CLASS,
            DATAGRID_EDIT_ROW: DATAGRID_EDIT_ROW,
            DATAGRID_EDIT_BUTTON_CLASS: DATAGRID_EDIT_BUTTON_CLASS,
            DATAGRID_CELL_MODIFIED: DATAGRID_CELL_MODIFIED,
            DATAGRID_ROW_REMOVED: DATAGRID_ROW_REMOVED,
            DATAGRID_ROW_INSERTED: DATAGRID_ROW_INSERTED,
            DATAGRID_ROW_MODIFIED: DATAGRID_ROW_MODIFIED,
            DATAGRID_CELL_HIGHLIGHT_OUTLINE: DATAGRID_CELL_HIGHLIGHT_OUTLINE,
            DATAGRID_FOCUS_OVERLAY_CLASS: DATAGRID_FOCUS_OVERLAY_CLASS,
            DATAGRID_READONLY_CLASS: DATAGRID_READONLY_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.validationModule.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            utils = DX.utils;
        var DATAGRID_INVALIDATE_CLASS = "dx-datagrid-invalid",
            DATAGRID_CELL_HIGHLIGHT_OUTLINE = "dx-highlight-outline",
            DATAGRID_INVALID_MESSAGE_CLASS = "dx-invalid-message",
            DATAGRID_INVALID_MESSAGE_ALWAYS_CLASS = "dx-invalid-message-always",
            DATAGRID_INSERT_INDEX = "__DX_INSERT_INDEX__",
            DATAGRID_EDIT_MODE_ROW = "row",
            DATAGRID_EDIT_MODE_BATCH = "batch",
            DATAGRID_EDIT_MODE_CELL = "cell";
        dataGrid.ValidatingController = dataGrid.Controller.inherit(function() {
            return {
                    init: function() {
                        this._editingController = this.getController("editing");
                        this.createAction("onRowValidating")
                    },
                    _rowValidating: function(editData, validate) {
                        var that = this,
                            brokenRules = validate.brokenRules || validate.brokenRule && [validate.brokenRule],
                            items = that.getController("data").items(),
                            parameters = {
                                brokenRules: brokenRules,
                                isValid: validate.isValid,
                                key: editData.key,
                                newData: editData.data,
                                oldData: editData.oldData,
                                errorText: null
                            };
                        that.executeAction("onRowValidating", parameters);
                        return {
                                isValid: parameters.isValid,
                                errorText: parameters.errorText,
                                rowIndex: that._editingController.getIndexByKey(editData.key, items)
                            }
                    },
                    validate: function(isFull) {
                        var that = this,
                            isValid = true,
                            editingController = that._editingController,
                            isFull = isFull || editingController.getEditMode() === DATAGRID_EDIT_MODE_ROW;
                        if (isFull)
                            $.each(editingController._editData, function(index, editData) {
                                var validationResult;
                                if (editData.type) {
                                    validationResult = that.validateGroup(editData);
                                    isValid = isValid && validationResult.isValid
                                }
                            });
                        else if (that._currentCellValidator) {
                            var group = that._currentCellValidator._findGroup(),
                                validate = that._currentCellValidator.validate();
                            isValid = that._rowValidating(group, validate).isValid
                        }
                        return isValid
                    },
                    validateGroup: function(editData) {
                        var that = this,
                            isHasValidateGroup = DX.validationEngine.getGroupConfig(editData),
                            validationResults,
                            result = {isValid: true};
                        if (isHasValidateGroup) {
                            validationResults = DX.validationEngine.validateGroup(editData);
                            $.extend(true, result, that._rowValidating(editData, validationResults))
                        }
                        return result
                    },
                    setValidator: function(validator) {
                        this._currentCellValidator = validator
                    },
                    removeValidators: function(editIndex) {
                        var that = this,
                            editingController = that._editingController;
                        $.each(editingController._editData, function(index, editData) {
                            var validateGroup = DX.validationEngine.getGroupConfig(editData),
                                validationResults;
                            if (!utils.isDefined(editIndex) || editIndex === index)
                                if (validateGroup)
                                    for (var i = 0; i < validateGroup.validators.length; i++) {
                                        validateGroup.validators[i]._dispose();
                                        i--
                                    }
                        })
                    },
                    createValidator: function(parameters, $container) {
                        var that = this,
                            editingController = that._editingController,
                            column = parameters.column,
                            editData,
                            editIndex = editingController.getIndexByKey(parameters.key, editingController._editData),
                            defaultValidationResult = function(options) {
                                if (options.brokenRule)
                                    options.brokenRule.columnIndex = column.index;
                                if ($container) {
                                    $container.removeClass(DATAGRID_INVALIDATE_CLASS);
                                    if (!options.isValid) {
                                        $container.addClass(DATAGRID_INVALIDATE_CLASS);
                                        editingController.createHighlightCell($container, column, true)
                                    }
                                    else
                                        editingController.removeHighlightCell($container)
                                }
                            };
                        if (editIndex < 0)
                            editIndex = editingController._addEditData({key: parameters.key});
                        if (editIndex >= 0) {
                            editData = editingController._editData[editIndex];
                            return new DX.ui.dxValidator($container || {}, {
                                    name: column.caption,
                                    validationRules: $.extend(true, [], column.validationRules),
                                    validationGroup: editData,
                                    adapter: {
                                        getValue: function() {
                                            return parameters.value
                                        },
                                        applyValidationResults: defaultValidationResult
                                    }
                                })
                        }
                    }
                }
        }());
        dataGrid.registerModule('validating', {
            defaultOptions: function() {
                return {}
            },
            controllers: {validating: dataGrid.ValidatingController},
            extenders: {
                controllers: {
                    data: {reload: function() {
                            var d = this.callBase(),
                                editingController = this.getController("editing");
                            return d.done(function() {
                                    editingController.resetRowAndPageIndeces(true)
                                })
                        }},
                    editing: {
                        _addEditData: function(options) {
                            var that = this,
                                editDataIndex = that.getIndexByKey(options.key, that._editData);
                            if (editDataIndex >= 0) {
                                var editData = that._editData[editDataIndex];
                                editData.isValid = DX.validationEngine.getGroupConfig(editData) ? DX.validationEngine.validateGroup(editData).isValid : true
                            }
                            return that.callBase(options)
                        },
                        _updateRowAndPageIndeces: function() {
                            var that = this,
                                startInsertIndex = that.getView('rowsView').getTopVisibleItemIndex(),
                                rowIndex = startInsertIndex;
                            $.each(that._editData, function(_, editData) {
                                if (!editData.isValid && editData.pageIndex !== that._pageIndex) {
                                    editData.pageIndex = that._pageIndex;
                                    if (editData.type === "insert")
                                        editData.rowIndex = startInsertIndex;
                                    else
                                        editData.rowIndex = rowIndex;
                                    rowIndex++
                                }
                            })
                        },
                        resetRowAndPageIndeces: function(alwaysRest) {
                            var that = this;
                            $.each(that._editData, function(_, editData) {
                                if (editData.pageIndex !== that._pageIndex || alwaysRest) {
                                    delete editData.pageIndex;
                                    delete editData.rowIndex
                                }
                            })
                        },
                        init: function() {
                            var that = this;
                            that.callBase();
                            that.getController("data").changed.add(function(change) {
                                if (that.option("scrolling.mode") === "standard")
                                    that.resetRowAndPageIndeces();
                                $.each(that._editData, function(_, editData) {
                                    if (change && change.changeType === 'prepend')
                                        editData.rowIndex += change.items.length
                                })
                            })
                        },
                        processItems: function(items, changeType) {
                            var that = this,
                                dataController = that.getController("data"),
                                i,
                                editData = that._editData,
                                itemsCount = items.length,
                                insertCount = 0,
                                getIndexByEditData = function(editData, items) {
                                    var index = -1,
                                        isInsert = editData.type === "insert",
                                        key = editData.key;
                                    $.each(items, function(i, item) {
                                        if (dataGrid.equalKeys(key, isInsert ? item : dataController.keyOf(item))) {
                                            index = i;
                                            return false
                                        }
                                    });
                                    return index
                                },
                                addInValidItem = function(editData) {
                                    var data = {key: editData.key},
                                        index = getIndexByEditData(editData, items),
                                        rowIndex;
                                    if (index >= 0 && that.option("scrolling.mode") === "standard")
                                        return;
                                    editData.rowIndex = editData.rowIndex > itemsCount ? editData.rowIndex % itemsCount : editData.rowIndex;
                                    rowIndex = editData.rowIndex;
                                    data[DATAGRID_INSERT_INDEX] = 1;
                                    if (index >= 0) {
                                        items.splice(index, 1);
                                        rowIndex -= insertCount
                                    }
                                    items.splice(rowIndex, 0, data);
                                    insertCount++
                                };
                            that.update();
                            if (that.getEditMode() === DATAGRID_EDIT_MODE_BATCH && changeType !== "prepend" && changeType !== "append")
                                for (i = 0; i < editData.length; i++)
                                    if (editData[i].type && editData[i].pageIndex === that._pageIndex && editData[i].key.pageIndex !== that._pageIndex)
                                        addInValidItem(editData[i]);
                            return that.callBase(items, changeType)
                        },
                        processDataItem: function(item, columns, generateDataValues) {
                            var that = this,
                                editIndex,
                                editData,
                                isInserted = item.data[DATAGRID_INSERT_INDEX],
                                key = isInserted ? item.data.key : item.key,
                                editMode = that.getEditMode();
                            if (editMode === DATAGRID_EDIT_MODE_BATCH && isInserted && key) {
                                editIndex = dataGrid.getIndexByKey(key, that._editData);
                                if (editIndex >= 0) {
                                    editData = that._editData[editIndex];
                                    if (editData.type !== "insert") {
                                        item.data = $.extend(true, {}, editData.oldData, editData.data);
                                        item.key = key
                                    }
                                }
                            }
                            that.callBase.apply(that, arguments)
                        },
                        saveEditData: function() {
                            this._updateRowAndPageIndeces();
                            this.callBase()
                        },
                        _afterInsertRow: function(options) {
                            var validatingController = this.getController("validating"),
                                hiddenColumns = this.getController("columns").getHiddenColumns();
                            $.each(hiddenColumns, function(_, column) {
                                if (utils.isArray(column.validationRules))
                                    validatingController.createValidator({
                                        column: column,
                                        key: options.key,
                                        value: options.data[column.dataField]
                                    })
                            });
                            this.callBase(options)
                        },
                        _beforeSaveEditData: function(editData, editIndex) {
                            var that = this,
                                validatingController,
                                isValid,
                                result = that.callBase.apply(that, arguments);
                            if (editData) {
                                isValid = editData.type === "remove" || editData.isValid;
                                if (isValid) {
                                    validatingController = that.getController("validating");
                                    validatingController.removeValidators(editIndex)
                                }
                                else if (utils.isDefined(that._hasInvalidRules))
                                    that._hasInvalidRules = true;
                                result = result || !isValid
                            }
                            else if (that.getEditMode() === DATAGRID_EDIT_MODE_CELL) {
                                isValid = that.getController("validating").validate();
                                if (isValid && that._hasInvalidRules) {
                                    that.cancelEditData();
                                    that._hasInvalidRules = false;
                                    result = true
                                }
                                else if (!that._isValid) {
                                    that._hasInvalidRules = true;
                                    result = true
                                }
                            }
                            return result
                        },
                        _afterSaveEditData: function() {
                            var validatingController = this.getController("validating"),
                                isValid = validatingController.validate(true);
                            isValid && validatingController.removeValidators()
                        },
                        _beforeCancelEditData: function() {
                            var validatingController = this.getController("validating");
                            validatingController.removeValidators();
                            this.callBase()
                        },
                        _afterCloseEditCell: function() {
                            var validatingController = this.getController("validating");
                            validatingController.validate(true);
                            this.callBase()
                        },
                        createHighlightCell: function($cell, options, skipValidation) {
                            var isValid = true,
                                validator;
                            if (!skipValidation) {
                                validator = $cell.data("dxValidator");
                                if (validator)
                                    isValid = validator.validate().isValid
                            }
                            if (isValid)
                                this.callBase($cell, options)
                        },
                        updateFieldValue: function(options, value) {
                            var that = this,
                                editMode = that.getEditMode();
                            that.callBase.apply(that, arguments);
                            that._hasInvalidRules = false;
                            that._isValid = that.getController('validating').validate()
                        }
                    },
                    editorFactory: {
                        loseFocus: function(skipValidator) {
                            if (!skipValidator)
                                this.getController('validating').setValidator(null);
                            this.callBase()
                        },
                        focus: function($element) {
                            var that = this,
                                tdElement = $element && $element.closest("td"),
                                validator = tdElement && tdElement.data("dxValidator"),
                                $tooltip = tdElement && tdElement.closest(".dx-datagrid-rowsview").find(".dx-tooltip"),
                                column = tdElement && that.getController("columns").getVisibleColumns()[tdElement.index()];
                            $tooltip && $tooltip.remove();
                            if (validator) {
                                that.getController('validating').setValidator(validator);
                                var validationResult = validator.validate();
                                if (!validationResult.isValid) {
                                    var alignment = column.alignment;
                                    that.loseFocus(true);
                                    return $("<div/>").addClass(DATAGRID_INVALID_MESSAGE_CLASS).addClass(DATAGRID_INVALID_MESSAGE_ALWAYS_CLASS).text(validationResult.brokenRule.message).appendTo(tdElement).dxTooltip({
                                            target: tdElement,
                                            container: tdElement,
                                            visible: true,
                                            closeOnOutsideClick: false,
                                            closeOnTargetScroll: false,
                                            arrowPosition: {
                                                offset: alignment === "left" ? "5 0" : "-5 0",
                                                my: "bottom " + alignment,
                                                at: "top " + alignment
                                            },
                                            position: {
                                                offset: "0 -9",
                                                my: "top " + alignment,
                                                at: "bottom " + alignment
                                            }
                                        })
                                }
                            }
                            return that.callBase($element)
                        }
                    }
                },
                views: {rowsView: {_cellPrepared: function($cell, parameters) {
                            var validatingController = this.getController("validating"),
                                column = parameters.column;
                            if (utils.isArray(column.validationRules))
                                validatingController.createValidator(parameters, $cell);
                            this.callBase.apply(this, arguments)
                        }}}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.dataController.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            utils = DX.utils;
        dataGrid.proxyMethod = function(instance, methodName, defaultResult) {
            if (!instance[methodName])
                instance[methodName] = function() {
                    var dataSource = this._dataSource;
                    return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult
                }
        };
        dataGrid.DataController = dataGrid.Controller.inherit({}).include(ui.DataHelperMixin).inherit(function() {
            var members = {
                    init: function() {
                        var that = this;
                        that._items = [];
                        that._columnsController = that.getController('columns');
                        that._columnsChangedHandler = $.proxy(that._handleColumnsChanged, that);
                        that._dataChangedHandler = $.proxy(that._handleDataChanged, that);
                        that._loadingChangedHandler = $.proxy(that._handleLoadingChanged, that);
                        that._loadErrorHandler = $.proxy(that._handleLoadError, that);
                        that._columnsController.columnsChanged.add(that._columnsChangedHandler);
                        that._isLoading = false;
                        that._isCustomLoading = false;
                        that._refreshDataSource();
                        that.createAction('onDataErrorOccurred');
                        that.dataErrorOccurred.add(function(error) {
                            return that.executeAction('onDataErrorOccurred', {error: error})
                        })
                    },
                    callbackNames: function() {
                        return ['changed', 'loadingChanged', 'dataErrorOccurred', 'pageIndexChanged', 'pageSizeChanged', 'filterChanged', 'dataSourceChanged']
                    },
                    callbackFlags: function(name) {
                        if (name === 'dataErrorOccurred')
                            return 'stopOnFalse'
                    },
                    publicMethods: function() {
                        return ['beginCustomLoading', 'endCustomLoading', 'refresh', 'filter', 'clearFilter', 'keyOf', 'byKey', 'getDataByKeys', 'pageIndex', 'pageSize', 'pageCount', 'totalCount', '_disposeDataSource', 'getKeyByRowIndex', 'getRowIndexByKey']
                    },
                    optionChanged: function(args) {
                        var that = this;
                        switch (args.name) {
                            case'dataSource':
                            case'scrolling':
                            case'rtlEnabled':
                            case'paging':
                            case'columns':
                                that._columnsController.reset();
                                that._refreshDataSource();
                                break;
                            case'onDataErrorOccurred':
                                that.createAction('onDataErrorOccurred');
                                break
                        }
                    },
                    _handleColumnsChanged: function(e) {
                        var that = this,
                            changeTypes = e.changeTypes,
                            optionNames = e.optionNames,
                            filterValue;
                        var updateItemsHandler = function() {
                                that._columnsController.columnsChanged.remove(updateItemsHandler);
                                that.updateItems()
                            };
                        if (changeTypes.sorting || changeTypes.grouping) {
                            if (that._dataSource) {
                                that._dataSource.group(that._columnsController.getGroupDataSourceParameters());
                                that._dataSource.sort(that._columnsController.getSortDataSourceParameters());
                                that.reload()
                            }
                        }
                        else if (changeTypes.columns) {
                            if (optionNames.filterValue || optionNames.selectedFilterOperation)
                                if (this.option("filterRow.applyFilter") !== "onClick") {
                                    filterValue = that._columnsController.columnOption(e.columnIndex, 'filterValue');
                                    if (e.columnIndex === undefined || utils.isDefined(filterValue) || !optionNames.selectedFilterOperation || optionNames.filterValue)
                                        that._applyFilter()
                                }
                            if (!that._needApplyFilter && !dataGrid.checkChanges(optionNames, ['width', 'visibleWidth', 'filterValue', 'selectedFilterOperation']))
                                that._columnsController.columnsChanged.add(updateItemsHandler)
                        }
                    },
                    _handleDataChanged: function(e) {
                        var that = this,
                            dataSource = that._dataSource,
                            columnsController = that._columnsController,
                            isAllDataTypesDefined = columnsController.isAllDataTypesDefined();
                        if (dataSource && !that._isDataSourceApplying) {
                            that._isDataSourceApplying = true;
                            $.when(that._columnsController.applyDataSource(dataSource)).done(function() {
                                that._isDataSourceApplying = false;
                                var additionalFilter = that._calculateAdditionalFilter(),
                                    needApplyFilter = that._needApplyFilter;
                                that._needApplyFilter = false;
                                if (needApplyFilter && additionalFilter && additionalFilter.length && !isAllDataTypesDefined) {
                                    DX.log("W1005", that.component.NAME);
                                    that._applyFilter()
                                }
                                else
                                    that.updateItems(e)
                            });
                            that._needApplyFilter = !that._columnsController.isDataSourceApplied()
                        }
                    },
                    _handleLoadingChanged: function(isLoading) {
                        this._isLoading = isLoading;
                        this._fireLoadingChanged()
                    },
                    _handleLoadError: function(e) {
                        this.dataErrorOccurred.fire(e)
                    },
                    _dataSourceOptions: function() {
                        var that = this,
                            paging = that.option('paging'),
                            scrolling = that.option('scrolling'),
                            virtualMode = !!(scrolling && scrolling.mode === 'virtual'),
                            appendMode = !!(scrolling && scrolling.mode === 'infinite');
                        return {
                                _preferSync: true,
                                paginate: paging && paging.enabled || virtualMode || appendMode,
                                pageIndex: paging && paging.pageIndex,
                                pageSize: paging && paging.pageSize,
                                requireTotalCount: !appendMode,
                                scrolling: scrolling
                            }
                    },
                    _initDataSource: function() {
                        var that = this,
                            columnsController = that._columnsController,
                            sort,
                            group,
                            dataSource = this.option("dataSource"),
                            oldDataSource = this._dataSource;
                        that.callBase();
                        dataSource = that._dataSource;
                        that._dataSource = oldDataSource;
                        if (dataSource) {
                            columnsController.updateSortingGrouping(dataSource);
                            sort = columnsController.getSortDataSourceParameters();
                            if (sort)
                                dataSource.sort(sort);
                            group = columnsController.getGroupDataSourceParameters();
                            if (group)
                                dataSource.group(group);
                            that.setDataSource(dataSource)
                        }
                    },
                    _processItems: function(items, changeType) {
                        var that = this,
                            visibleColumns = that._columnsController.getVisibleColumns(),
                            options = {
                                visibleColumns: visibleColumns,
                                dataIndex: 0
                            },
                            result = [];
                        $.each(items, function(index, item) {
                            if (utils.isDefined(item)) {
                                item = that._processItem(item, options);
                                result.push(item)
                            }
                        });
                        return result
                    },
                    _processItem: function(item, options) {
                        item = this._generateDataItem(item);
                        item = this._processDataItem(item, options);
                        item.dataIndex = options.dataIndex++;
                        return item
                    },
                    _generateDataItem: function(data) {
                        return {
                                rowType: 'data',
                                data: data,
                                key: this.keyOf(data)
                            }
                    },
                    _processDataItem: function(dataItem, options) {
                        dataItem.values = this._generateDataValues(dataItem.data, options.visibleColumns);
                        return dataItem
                    },
                    _generateDataValues: function(data, columns) {
                        var values = [];
                        $.each(columns, function() {
                            var value = null;
                            if (this.command)
                                value = null;
                            else if (this.calculateCellValue)
                                value = this.calculateCellValue(data);
                            else if (this.dataField)
                                value = data[this.dataField];
                            values.push(value)
                        });
                        return values
                    },
                    _updateItemsCore: function(change) {
                        var that = this,
                            items,
                            dataSource = that._dataSource,
                            changes = [],
                            changeType = change.changeType;
                        if (dataSource) {
                            items = change.items || dataSource.items();
                            items = that._processItems(items.slice(0), changeType);
                            change.items = items;
                            change.changeType = changeType || 'refresh';
                            switch (changeType) {
                                case'prepend':
                                    that._items.unshift.apply(that._items, items);
                                    break;
                                case'append':
                                    that._items.push.apply(that._items, items);
                                    break;
                                case'update':
                                    var rowIndices = change.rowIndices;
                                    rowIndices.sort(function(a, b) {
                                        return a - b
                                    });
                                    var rowIndexCorrection = 0;
                                    change.items = [];
                                    change.rowIndices = [];
                                    change.changeTypes = [];
                                    var equalItems = function(item1, item2) {
                                            return dataGrid.equalKeys(item1.key, item2.key) && item1.rowType === item2.rowType
                                        };
                                    $.each(rowIndices, function(index, rowIndex) {
                                        var oldItem,
                                            newItem,
                                            oldNextItem,
                                            newNextItem;
                                        rowIndex += rowIndexCorrection;
                                        if (rowIndex >= 0 && $.inArray(rowIndex, change.rowIndices) < 0) {
                                            change.rowIndices.push(rowIndex);
                                            oldItem = that._items[rowIndex];
                                            oldNextItem = that._items[rowIndex + 1];
                                            newItem = items[rowIndex];
                                            newNextItem = items[rowIndex + 1];
                                            if (newItem)
                                                change.items.push(newItem);
                                            if (oldItem && newItem && equalItems(oldItem, newItem)) {
                                                changeType = 'update';
                                                that._items[rowIndex] = newItem
                                            }
                                            else if (newItem && !oldItem || newNextItem && equalItems(oldItem, newNextItem)) {
                                                changeType = 'insert';
                                                that._items.splice(rowIndex, 0, newItem);
                                                rowIndexCorrection++
                                            }
                                            else if (oldItem && !newItem || oldNextItem && equalItems(newItem, oldNextItem)) {
                                                changeType = 'remove';
                                                that._items.splice(rowIndex, 1);
                                                rowIndexCorrection--
                                            }
                                            change.changeTypes.push(changeType)
                                        }
                                    });
                                    break;
                                default:
                                    that._items = items.slice(0);
                                    break
                            }
                            $.each(that._items, function(index, item) {
                                item.rowIndex = index
                            })
                        }
                    },
                    updateItems: function(change) {
                        var that = this;
                        change = change || {};
                        if (that._dataSource && that._columnsController.isDataSourceApplied()) {
                            that._updateItemsCore(change);
                            that.changed.fire(change)
                        }
                    },
                    isLoading: function() {
                        return this._isLoading || this._isCustomLoading
                    },
                    _fireLoadingChanged: function(messageText) {
                        this.loadingChanged.fire(this.isLoading(), messageText)
                    },
                    _calculateAdditionalFilter: function() {
                        return null
                    },
                    _applyFilter: function(isInit) {
                        var that = this,
                            dataSource = that._dataSource,
                            columnsController = that._columnsController,
                            isAllDataTypesDefined = columnsController.isAllDataTypesDefined(),
                            filter = that._filter,
                            additionalFilter,
                            pageIndex;
                        if (dataSource) {
                            additionalFilter = that._calculateAdditionalFilter();
                            if (additionalFilter)
                                if (!isInit || isAllDataTypesDefined)
                                    if (filter)
                                        filter = [additionalFilter, 'and', filter];
                                    else
                                        filter = additionalFilter;
                            pageIndex = dataSource.pageIndex();
                            dataSource.filter(filter && filter.length ? filter : null);
                            dataSource.pageIndex(pageIndex);
                            columnsController.updateFilter(dataSource);
                            if (!isInit) {
                                dataSource.pageIndex(0);
                                return that.reload().done($.proxy(that.filterChanged, 'fire'))
                            }
                        }
                    },
                    filter: function(filterExpr) {
                        this._filter = arguments.length > 1 ? Array.prototype.slice.call(arguments, 0) : filterExpr;
                        this._applyFilter()
                    },
                    clearFilter: function() {
                        this._filter = null;
                        this._applyFilter()
                    },
                    _fireDataSourceChanged: function() {
                        var that = this;
                        var changedHandler = function() {
                                that.changed.remove(changedHandler);
                                that.dataSourceChanged.fire()
                            };
                        that.changed.add(changedHandler)
                    },
                    _getDataSourceAdapterType: function(remoteOperations) {
                        return remoteOperations && remoteOperations.filtering && remoteOperations.sorting && remoteOperations.paging ? dataGrid.DataSourceAdapterServer : dataGrid.DataSourceAdapterClient
                    },
                    _createDataSourceAdapterCore: function(dataSource, remoteOperations) {
                        var dataSourceAdapterType,
                            dataSourceAdapter;
                        if (remoteOperations === 'auto')
                            remoteOperations = !(dataSource.store() instanceof DX.data.ArrayStore);
                        if (remoteOperations === true)
                            remoteOperations = {
                                filtering: true,
                                sorting: true,
                                paging: true
                            };
                        dataSourceAdapterType = this._getDataSourceAdapterType(remoteOperations);
                        dataSourceAdapter = new dataSourceAdapterType(this.component);
                        dataSourceAdapter.init(dataSource, remoteOperations);
                        return dataSourceAdapter
                    },
                    _createDataSourceAdapter: function(dataSource) {
                        var remoteOperations = this.option("remoteOperations");
                        return this._createDataSourceAdapterCore(dataSource, remoteOperations)
                    },
                    setDataSource: function(dataSource) {
                        var that = this;
                        if (that._dataSource) {
                            that._dataSource.changed.remove(that._dataChangedHandler);
                            that._dataSource.loadingChanged.remove(that._loadingChangedHandler);
                            that._dataSource.loadError.remove(that._loadErrorHandler);
                            that._dataSource.dispose()
                        }
                        if (dataSource)
                            dataSource = that._createDataSourceAdapter(dataSource);
                        that._dataSource = dataSource;
                        if (dataSource) {
                            that._fireDataSourceChanged();
                            that._isLoading = !dataSource.isLoaded();
                            that._filter = dataSource.filter();
                            that._needApplyFilter = true;
                            that._applyFilter(true);
                            dataSource.changed.add(that._dataChangedHandler);
                            dataSource.loadingChanged.add(that._loadingChangedHandler);
                            dataSource.loadError.add(that._loadErrorHandler);
                            if (dataSource.isLoaded())
                                that._handleDataChanged()
                        }
                    },
                    items: function() {
                        return this._items
                    },
                    pageCount: function() {
                        return this._dataSource ? this._dataSource.pageCount() : 1
                    },
                    dataSource: function() {
                        return this._dataSource
                    },
                    store: function() {
                        var dataSource = this._dataSource;
                        return dataSource && dataSource.store()
                    },
                    getKeyByRowIndex: function(rowIndex) {
                        var item = this.items()[rowIndex];
                        if (item)
                            return item.key
                    },
                    getRowIndexByKey: function(key) {
                        return dataGrid.getIndexByKey(key, this.items())
                    },
                    keyOf: function(data) {
                        var store = this.store();
                        if (store)
                            return store.keyOf(data)
                    },
                    byKey: function(key) {
                        var store = this.store(),
                            rowIndex = this.getRowIndexByKey(key),
                            result;
                        if (!store)
                            return;
                        if (rowIndex >= 0)
                            result = $.Deferred().resolve(this.items()[rowIndex].data);
                        return result || store.byKey(key)
                    },
                    getDataByKeys: function(rowKeys) {
                        var that = this,
                            result = $.Deferred(),
                            deferreds = [],
                            data = [];
                        $.each(rowKeys, function(index, key) {
                            deferreds.push(that.byKey(key).done(function(keyData) {
                                data[index] = keyData
                            }))
                        });
                        $.when.apply($, deferreds).always(function() {
                            result.resolve(data)
                        });
                        return result
                    },
                    pageIndex: function(value) {
                        var that = this,
                            dataSource = that._dataSource;
                        if (dataSource) {
                            if (value !== undefined)
                                if (dataSource.pageIndex() !== value) {
                                    dataSource.pageIndex(value);
                                    return dataSource.load().done($.proxy(that.pageIndexChanged, 'fire'))
                                }
                            return dataSource.pageIndex()
                        }
                        return 0
                    },
                    pageSize: function(value) {
                        var that = this,
                            pagingOptions = that.option("paging"),
                            dataSource = that._dataSource;
                        if (value === undefined)
                            return dataSource ? dataSource.pageSize() : 0;
                        if (dataSource) {
                            dataSource.pageIndex(0);
                            dataSource.pageSize(value);
                            if (pagingOptions)
                                pagingOptions.pageSize = value;
                            return dataSource.reload().done($.proxy(that.pageSizeChanged, 'fire'))
                        }
                    },
                    beginCustomLoading: function(messageText) {
                        this._isCustomLoading = true;
                        this._fireLoadingChanged(messageText)
                    },
                    endCustomLoading: function() {
                        this._isCustomLoading = false;
                        this._fireLoadingChanged()
                    },
                    refresh: function() {
                        var that = this,
                            d = $.Deferred();
                        $.when(this._columnsController.refresh()).always(function() {
                            $.when(that.reload()).done(d.resolve).fail(d.reject)
                        });
                        return d
                    },
                    dispose: function() {
                        var that = this,
                            dataSource = that._dataSource;
                        that.callBase();
                        if (dataSource) {
                            dataSource.changed.remove(that._dataChangedHandler);
                            dataSource.loadingChanged.remove(that._loadingChangedHandler)
                        }
                    }
                };
            dataGrid.proxyMethod(members, 'load');
            dataGrid.proxyMethod(members, 'reload');
            dataGrid.proxyMethod(members, 'itemsCount', 0);
            dataGrid.proxyMethod(members, 'totalItemsCount', 0);
            dataGrid.proxyMethod(members, 'hasKnownLastPage', true);
            dataGrid.proxyMethod(members, 'isLoaded', false);
            dataGrid.proxyMethod(members, 'totalCount', 0);
            return members
        }());
        dataGrid.registerModule('data', {
            defaultOptions: function() {
                return {
                        loadingTimeout: 0,
                        dataSource: null,
                        onDataErrorOccurred: null,
                        remoteOperations: 'auto'
                    }
            },
            controllers: {data: ui.dxDataGrid.DataController}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.dataSourceAdapter.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            utils = DX.utils;
        dataGrid.DataSourceAdapterServer = dataGrid.Controller.inherit(function() {
            return {
                    init: function(dataSource, remoteOperations) {
                        var that = this;
                        that._dataSource = dataSource;
                        that._remoteOperations = remoteOperations;
                        that._isLastPage = !dataSource.isLastPage();
                        that._hasLastPage = false;
                        that._currentTotalCount = 0;
                        that.changed = $.Callbacks();
                        that.loadingChanged = $.Callbacks();
                        that.loadError = $.Callbacks();
                        that._dataChangedHandler = $.proxy(that._handleDataChanged, that);
                        that._dataLoadingHandler = $.proxy(that._handleDataLoading, that);
                        that._dataLoadedHandler = $.proxy(that._handleDataLoaded, that);
                        that._loadingChangedHandler = $.proxy(that._handleLoadingChanged, that);
                        that._loadErrorHandler = $.proxy(that._handleLoadError, that);
                        dataSource.on("changed", that._dataChangedHandler);
                        dataSource.on("customizeStoreLoadOptions", that._dataLoadingHandler);
                        dataSource.on("customizeLoadResult", that._dataLoadedHandler);
                        dataSource.on("loadingChanged", that._loadingChangedHandler);
                        dataSource.on("loadError", that._loadErrorHandler);
                        $.each(dataSource, function(memberName, member) {
                            if (!that[memberName] && $.isFunction(member))
                                that[memberName] = function() {
                                    return this._dataSource[memberName].apply(this._dataSource, arguments)
                                }
                        })
                    },
                    dispose: function() {
                        var that = this,
                            dataSource = that._dataSource;
                        dataSource.off("changed", that._dataChangedHandler);
                        dataSource.off("customizeStoreLoadOptions", that._dataLoadingHandler);
                        dataSource.off("customizeLoadResult", that._dataLoadedHandler);
                        dataSource.off("loadingChanged", that._loadingChangedHandler);
                        dataSource.off("loadError", that._loadErrorHandler)
                    },
                    _handleDataLoading: function(options) {
                        options.delay = this.option("loadingTimeout");
                        options.originalStoreLoadOptions = options.storeLoadOptions;
                        this._dataSource.cancel(this._lastOperationId);
                        this._lastOperationId = options.operationId
                    },
                    _handleDataLoaded: function(options) {
                        options.storeLoadOptions = options.originalStoreLoadOptions
                    },
                    _handleLoadingChanged: function(isLoading) {
                        this.loadingChanged.fire(isLoading)
                    },
                    _handleLoadError: function(error) {
                        this.changed.fire({
                            changeType: 'loadError',
                            error: error
                        });
                        this.loadError.fire(error)
                    },
                    _handleDataChanged: function(args) {
                        var that = this,
                            currentTotalCount,
                            dataSource = that._dataSource,
                            itemsCount = that.itemsCount();
                        that._isLastPage = !itemsCount || !that.pageSize() || itemsCount < that.pageSize();
                        if (that._isLastPage)
                            that._hasLastPage = true;
                        if (dataSource.totalCount() >= 0) {
                            if (dataSource.pageIndex() >= that.pageCount()) {
                                dataSource.pageIndex(that.pageCount() - 1);
                                dataSource.load()
                            }
                        }
                        else {
                            currentTotalCount = dataSource.pageIndex() * that.pageSize() + itemsCount;
                            that._currentTotalCount = Math.max(that._currentTotalCount, currentTotalCount);
                            if (itemsCount === 0 && dataSource.pageIndex() >= that.pageCount()) {
                                dataSource.pageIndex(that.pageCount() - 1);
                                dataSource.load()
                            }
                        }
                        if (!dataSource.isLoading())
                            this.changed.fire(args)
                    },
                    isLastPage: function() {
                        return this._isLastPage
                    },
                    totalCount: function() {
                        return parseInt(this._currentTotalCount || this._dataSource.totalCount())
                    },
                    itemsCount: function() {
                        return this._dataSource.items().length
                    },
                    totalItemsCount: function() {
                        return this.totalCount()
                    },
                    pageSize: function() {
                        var dataSource = this._dataSource;
                        if (!arguments.length && !dataSource.paginate())
                            return 0;
                        return dataSource.pageSize.apply(dataSource, arguments)
                    },
                    pageCount: function() {
                        var that = this,
                            count = that.totalItemsCount(),
                            pageSize = that.pageSize();
                        if (pageSize && count > 0)
                            return Math.max(1, Math.ceil(count / pageSize));
                        return 1
                    },
                    _reloadCore: function() {
                        var that = this,
                            dataSource = that._dataSource;
                        that._currentTotalCount = 0;
                        that._isLastPage = !dataSource.paginate();
                        that._hasLastPage = that._isLastPage;
                        return dataSource.reload()
                    },
                    reload: function() {
                        var that = this,
                            dataSource = this._dataSource,
                            d = $.Deferred();
                        if (dataSource.isLoading()) {
                            var loadingChangedHandler = function() {
                                    dataSource.loadingChanged.remove(loadingChangedHandler);
                                    setTimeout(function() {
                                        that.reload().done(d.resolve).fail(d.reject)
                                    })
                                };
                            dataSource.loadingChanged.add(loadingChangedHandler)
                        }
                        else
                            $.when(that.refresh(dataSource._createStoreLoadOptions())).always(function() {
                                that._reloadCore().done(d.resolve).fail(d.reject)
                            });
                        return d
                    },
                    hasKnownLastPage: function() {
                        return this._hasLastPage || this._dataSource.totalCount() >= 0
                    }
                }
        }());
        dataGrid.DataSourceAdapterClient = dataGrid.DataSourceAdapterServer.inherit({
            _handleDataLoading: function(options) {
                var remoteOperations = this._remoteOperations || {},
                    loadOptions = options.loadOptions = options.storeLoadOptions;
                this.callBase(options);
                options.storeLoadOptions = {userData: loadOptions.userData};
                if (remoteOperations.filtering) {
                    options.storeLoadOptions.filter = loadOptions.filter;
                    delete loadOptions.filter
                }
                if (remoteOperations.sorting) {
                    options.storeLoadOptions.sort = loadOptions.sort;
                    delete loadOptions.sort
                }
                this._handleDataLoadingCore(options)
            },
            _handleDataLoadingCore: function(){},
            _handleDataLoaded: function(options) {
                var callBase = this.callBase,
                    loadOptions = options.loadOptions;
                options.skip = loadOptions.skip;
                options.take = loadOptions.take;
                delete loadOptions.skip;
                delete loadOptions.take;
                new DX.data.ArrayStore(options.data).load(loadOptions).done(function(data) {
                    options.data = data;
                    if (loadOptions.requireTotalCount)
                        options.extra = options.extra || {totalCount: data.length}
                });
                this._handleDataLoadedCore(options);
                callBase.apply(this, arguments)
            },
            _handleDataLoadedCore: function(options) {
                if (options.skip !== undefined)
                    options.data = options.data.slice(options.skip);
                if (options.take !== undefined)
                    options.data = options.data.slice(0, options.take)
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.groupingModule.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            events = ui.events,
            utils = DX.utils,
            normalizeSortingInfo = DX.data.utils.normalizeSortingInfo;
        var DATAGRID_GROUP_PANEL_CLASS = "dx-datagrid-group-panel",
            DATAGRID_GROUP_PANEL_MESSAGE_CLASS = "dx-group-panel-message",
            DATAGRID_GROUP_PANEL_ITEM_CLASS = "dx-group-panel-item",
            DATAGRID_HEADERS_ACTION_CLASS = "dx-datagrid-action";
        var GroupingDataSourceAdapterExtender = function() {
                var findGroupInfoByKey = function(groupsInfo, key) {
                        var i;
                        for (i = 0; i < groupsInfo.length; i++)
                            if (DX.data.utils.keysEqual(null, groupsInfo[i].key, key))
                                return groupsInfo[i]
                    };
                var getGroupInfoIndexByOffset = function(groupsInfo, offset) {
                        var index;
                        for (index = 0; index < groupsInfo.length; index++)
                            if (groupsInfo[index].offset > offset)
                                break;
                        return index
                    };
                var updateGroupInfoOffsets = function(groupsInfo) {
                        var groupInfo,
                            index,
                            newIndex;
                        for (index = 0; index < groupsInfo.length; index++) {
                            groupInfo = groupsInfo[index];
                            if (groupInfo.data && groupInfo.data.offset !== groupInfo.offset) {
                                groupsInfo.splice(index, 1);
                                groupInfo.offset = groupInfo.data.offset;
                                newIndex = getGroupInfoIndexByOffset(groupsInfo, groupInfo.offset);
                                groupsInfo.splice(newIndex, 0, groupInfo);
                                if (newIndex > index)
                                    index--
                            }
                        }
                    };
                var cleanGroupsInfo = function(groupsInfo, groupIndex, groupsCount) {
                        var i;
                        for (i = 0; i < groupsInfo.length; i++)
                            if (groupIndex + 1 >= groupsCount)
                                groupsInfo[i].children = [];
                            else
                                cleanGroupsInfo(groupsInfo[i].children, groupIndex + 1, groupsCount)
                    };
                return {
                        init: function() {
                            this.callBase.apply(this, arguments);
                            this.reset()
                        },
                        reset: function() {
                            this._groupsInfo = [];
                            this._totalCountCorrection = 0
                        },
                        totalItemsCount: function() {
                            var that = this,
                                totalCount = that.callBase();
                            return totalCount > 0 && that._dataSource.group() && that._dataSource._createStoreLoadOptions().requireTotalCount ? totalCount + that._totalCountCorrection : totalCount
                        },
                        itemsCount: function() {
                            return this._dataSource.group() ? this._itemsCount || 0 : this.callBase()
                        },
                        updateTotalItemsCount: function(totalCountCorrection) {
                            this._totalCountCorrection = totalCountCorrection || 0
                        },
                        _isGroupItemCountable: function(item) {
                            return !this._isVirtualPaging() || !item.isContinuation
                        },
                        _isVirtualPaging: function() {
                            var scrollingMode = this.option("scrolling.mode");
                            return scrollingMode === 'virtual' || scrollingMode === 'infinite'
                        },
                        updateItemsCount: function(data, groupsCount) {
                            function calculateItemsCount(that, items, groupsCount) {
                                var i,
                                    result = 0;
                                if (items)
                                    if (!groupsCount)
                                        result = items.length;
                                    else
                                        for (i = 0; i < items.length; i++) {
                                            if (that._isGroupItemCountable(items[i]))
                                                result++;
                                            result += calculateItemsCount(that, items[i].items, groupsCount - 1)
                                        }
                                return result
                            }
                            this._itemsCount = calculateItemsCount(this, data, groupsCount)
                        },
                        foreachGroups: function(callback, childrenAtFirst) {
                            var that = this;
                            function foreachGroupsCore(groupsInfo, callback, childrenAtFirst, parents) {
                                var i,
                                    callbackResult,
                                    callbackResults = [];
                                function executeCallback(callback, data, parents, callbackResults) {
                                    var callbackResult = data && callback(data, parents);
                                    callbackResults.push(callbackResult);
                                    return callbackResult
                                }
                                for (i = 0; i < groupsInfo.length; i++) {
                                    parents.push(groupsInfo[i].data);
                                    if (!childrenAtFirst && executeCallback(callback, groupsInfo[i].data, parents, callbackResults) === false)
                                        return false;
                                    if (!groupsInfo[i].data || groupsInfo[i].data.isExpanded) {
                                        callbackResult = foreachGroupsCore(groupsInfo[i].children, callback, childrenAtFirst, parents);
                                        callbackResults.push(callbackResult);
                                        if (callbackResult === false)
                                            return false
                                    }
                                    if (childrenAtFirst && executeCallback(callback, groupsInfo[i].data, parents, callbackResults) === false)
                                        return false;
                                    parents.pop()
                                }
                                return $.when.apply($, callbackResults).always(function() {
                                        updateGroupInfoOffsets(groupsInfo)
                                    })
                            }
                            return foreachGroupsCore(that._groupsInfo, callback, childrenAtFirst, [])
                        },
                        findGroupInfo: function(path) {
                            var that = this,
                                i,
                                pathIndex,
                                groupInfo,
                                groupsInfo = that._groupsInfo;
                            for (pathIndex = 0; groupsInfo && pathIndex < path.length; pathIndex++) {
                                groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
                                groupsInfo = groupInfo && groupInfo.children
                            }
                            return groupInfo && groupInfo.data
                        },
                        addGroupInfo: function(groupInfoData) {
                            var that = this,
                                index,
                                groupInfo,
                                path = groupInfoData.path,
                                pathIndex,
                                groupsInfo = that._groupsInfo;
                            for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                                groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
                                if (!groupInfo) {
                                    groupInfo = {
                                        key: path[pathIndex],
                                        offset: groupInfoData.offset,
                                        children: []
                                    };
                                    index = getGroupInfoIndexByOffset(groupsInfo, groupInfoData.offset);
                                    groupsInfo.splice(index, 0, groupInfo)
                                }
                                if (pathIndex === path.length - 1) {
                                    groupInfo.data = groupInfoData;
                                    updateGroupInfoOffsets(groupsInfo)
                                }
                                groupsInfo = groupInfo.children
                            }
                        },
                        allowCollapseAll: function() {
                            return true
                        },
                        isRowExpanded: function(key) {
                            var groupInfo = this.findGroupInfo(key);
                            return groupInfo ? groupInfo.isExpanded : false
                        },
                        collapseAll: function(groupIndex) {
                            if (!this.allowCollapseAll()) {
                                DX.log("E1018");
                                return false
                            }
                            return this._collapseExpandAll(groupIndex, false)
                        },
                        expandAll: function(groupIndex) {
                            return this._collapseExpandAll(groupIndex, true)
                        },
                        _collapseExpandAll: function(groupIndex, isExpand) {
                            var that = this,
                                dataSource = that._dataSource,
                                group = dataSource.group(),
                                groups = normalizeSortingInfo(group || []),
                                i;
                            if (groups.length) {
                                for (i = 0; i < groups.length; i++)
                                    if (groupIndex === undefined || groupIndex === i)
                                        groups[i].isExpanded = isExpand;
                                    else if (group && group[i])
                                        groups[i].isExpanded = group[i].isExpanded;
                                dataSource.group(groups);
                                that.foreachGroups(function(groupInfo, parents) {
                                    if (groupIndex === undefined || groupIndex === parents.length - 1)
                                        groupInfo.isExpanded = isExpand
                                })
                            }
                            return true
                        },
                        _handleDataLoading: function(options) {
                            this._group = options.storeLoadOptions.group;
                            this.callBase(options)
                        },
                        refresh: function(storeLoadOptions) {
                            var that = this,
                                groupIndex,
                                oldGroups = normalizeSortingInfo(that._group || []),
                                groups = normalizeSortingInfo(storeLoadOptions.group || []),
                                groupsCount = Math.min(oldGroups.length, groups.length);
                            that._group = storeLoadOptions.group;
                            for (groupIndex = 0; groupIndex < groupsCount; groupIndex++)
                                if (oldGroups[groupIndex].selector !== groups[groupIndex].selector) {
                                    groupsCount = groupIndex;
                                    break
                                }
                            if (!groupsCount)
                                that.reset();
                            else
                                cleanGroupsInfo(that._groupsInfo, 0, groupsCount)
                        },
                        changeRowExpand: function(path) {
                            var that = this,
                                dataSource = that._dataSource;
                            if (dataSource.group()) {
                                dataSource._changeLoadingCount(1);
                                return that._changeRowExpandCore(path).always(function() {
                                        dataSource._changeLoadingCount(-1)
                                    })
                            }
                        }
                    }
            }();
        dataGrid.DataSourceAdapterClient = dataGrid.DataSourceAdapterClient.inherit(GroupingDataSourceAdapterExtender);
        dataGrid.DataSourceAdapterServer = dataGrid.DataSourceAdapterServer.inherit(GroupingDataSourceAdapterExtender);
        var GroupingDataControllerExtender = function() {
                return {
                        _processItems: function(items) {
                            var groupColumns = this._columnsController.getGroupColumns();
                            if (items.length && groupColumns.length)
                                items = this._processGroupItems(items, groupColumns.length);
                            return this.callBase(items)
                        },
                        _processItem: function(item, options) {
                            if (utils.isDefined(item.groupIndex) && utils.isString(item.rowType) && item.rowType.indexOf("group") === 0) {
                                item = this._processGroupItem(item, options);
                                options.dataIndex = 0
                            }
                            else
                                item = this.callBase.apply(this, arguments);
                            return item
                        },
                        _processGroupItem: function(item, options) {
                            return item
                        },
                        _processGroupItems: function(items, groupsCount, options) {
                            var that = this,
                                scrollingMode,
                                i,
                                item,
                                resultItems,
                                path;
                            if (!options) {
                                scrollingMode = that.option('scrolling.mode');
                                options = {
                                    collectContinuationItems: scrollingMode !== 'virtual' && scrollingMode !== 'infinite',
                                    resultItems: [],
                                    path: []
                                }
                            }
                            resultItems = options.resultItems;
                            path = options.path;
                            if (options.data)
                                if (options.collectContinuationItems || !options.data.isContinuation)
                                    resultItems.push({
                                        rowType: 'group',
                                        data: options.data,
                                        groupIndex: path.length - 1,
                                        isExpanded: !!options.data.items,
                                        key: path,
                                        values: path
                                    });
                            if (items)
                                if (groupsCount === 0)
                                    resultItems.push.apply(resultItems, items);
                                else
                                    for (i = 0; i < items.length; i++) {
                                        item = items[i];
                                        if (item) {
                                            options.data = item;
                                            options.path = path.concat(item.key);
                                            that._processGroupItems(item.items, groupsCount - 1, options);
                                            options.data = undefined;
                                            options.path = path
                                        }
                                    }
                            return resultItems
                        },
                        publicMethods: function() {
                            return this.callBase().concat(['collapseAll', 'expandAll', 'isRowExpanded', 'expandRow', 'collapseRow'])
                        },
                        collapseAll: function(groupIndex) {
                            var dataSource = this._dataSource;
                            if (dataSource && dataSource.collapseAll(groupIndex)) {
                                dataSource.pageIndex(0);
                                dataSource.reload()
                            }
                        },
                        expandAll: function(groupIndex) {
                            var dataSource = this._dataSource;
                            if (dataSource && dataSource.expandAll(groupIndex)) {
                                dataSource.pageIndex(0);
                                dataSource.reload()
                            }
                        },
                        changeRowExpand: function(path) {
                            var that = this,
                                dataSource = this._dataSource;
                            if (!dataSource)
                                return;
                            $.when(dataSource.changeRowExpand(path)).done(function() {
                                that.load()
                            })
                        },
                        isRowExpanded: function(key) {
                            var dataSource = this._dataSource;
                            return dataSource && dataSource.isRowExpanded(key)
                        },
                        expandRow: function(key) {
                            if (!this.isRowExpanded(key))
                                this.changeRowExpand(key)
                        },
                        collapseRow: function(key) {
                            if (this.isRowExpanded(key))
                                this.changeRowExpand(key)
                        },
                        optionChanged: function(args) {
                            if (args.name === "grouping")
                                args.name = "dataSource";
                            this.callBase(args)
                        }
                    }
            }();
        var GroupingHeaderPanelExtender = function() {
                return {
                        _renderGroupPanel: function() {
                            var that = this,
                                $element = that.element(),
                                groupPanelOptions = that.option("groupPanel"),
                                $groupPanel,
                                groupColumns = that.getController('columns').getGroupColumns();
                            $groupPanel = $element.find('.' + DATAGRID_GROUP_PANEL_CLASS);
                            if (groupPanelOptions && groupPanelOptions.visible) {
                                if (!$groupPanel.length)
                                    $groupPanel = $('<div />').addClass(DATAGRID_GROUP_PANEL_CLASS).prependTo($element);
                                else
                                    $groupPanel.show();
                                that._renderGroupPanelItems($groupPanel, groupColumns);
                                if (groupPanelOptions.allowColumnDragging && !groupColumns.length)
                                    $('<div />').addClass(DATAGRID_GROUP_PANEL_MESSAGE_CLASS).text(groupPanelOptions.emptyPanelText).appendTo($groupPanel)
                            }
                            else
                                $groupPanel.hide()
                        },
                        _renderGroupPanelItems: function($groupPanel, groupColumns) {
                            var that = this,
                                $item;
                            $groupPanel.empty();
                            $.each(groupColumns, function(index, groupColumn) {
                                $item = $('<div />').addClass(groupColumn.cssClass).addClass(DATAGRID_GROUP_PANEL_ITEM_CLASS).toggleClass(DATAGRID_HEADERS_ACTION_CLASS, groupColumn.allowSorting).appendTo($groupPanel).text(groupColumn.caption).on(events.addNamespace("dxclick", "dxDataGridHeaderPanel"), that.createAction(function(e) {
                                    setTimeout(function() {
                                        that.getController('columns').changeSortOrder(groupColumn.index)
                                    })
                                }));
                                that._applySorting($item, {
                                    alignment: 'left',
                                    sortOrder: groupColumn.sortOrder === 'desc' ? 'desc' : 'asc'
                                }, true)
                            });
                            that._updateSortIndicatorPositions($groupPanel)
                        },
                        _renderCore: function() {
                            this.callBase.apply(this, arguments);
                            this._renderGroupPanel()
                        },
                        _resizeCore: function() {
                            var that = this,
                                $element = that.element(),
                                $groupPanel = $element && $element.find('.' + DATAGRID_GROUP_PANEL_CLASS),
                                groupPanelOptions = that.option('groupPanel');
                            that.callBase();
                            that._updateSortIndicatorPositions($groupPanel)
                        },
                        allowDragging: function(column) {
                            var groupPanelOptions = this.option("groupPanel");
                            return groupPanelOptions && groupPanelOptions.visible && groupPanelOptions.allowColumnDragging && column && column.allowGrouping
                        },
                        getColumnElements: function() {
                            var $element = this.element();
                            return $element && $element.find('.' + DATAGRID_GROUP_PANEL_ITEM_CLASS)
                        },
                        getColumns: function() {
                            return this.getController('columns').getGroupColumns()
                        },
                        getBoundingRect: function() {
                            var that = this,
                                $element = that.element(),
                                offset;
                            if ($element && $element.find('.' + DATAGRID_GROUP_PANEL_CLASS).length) {
                                offset = $element.offset();
                                return {
                                        top: offset.top,
                                        bottom: offset.top + $element.height()
                                    }
                            }
                            return null
                        },
                        getName: function() {
                            return 'group'
                        },
                        isVisible: function() {
                            return this.callBase() || this.option('groupPanel.visible')
                        },
                        optionChanged: function(args) {
                            if (args.name === "groupPanel")
                                this._renderGroupPanel();
                            else
                                this.callBase(args)
                        }
                    }
            }();
        dataGrid.GroupingHeaderPanelExtender = GroupingHeaderPanelExtender;
        $.extend(dataGrid.__internals, {
            DATAGRID_GROUP_PANEL_CLASS: DATAGRID_GROUP_PANEL_CLASS,
            DATAGRID_GROUP_PANEL_MESSAGE_CLASS: DATAGRID_GROUP_PANEL_MESSAGE_CLASS,
            DATAGRID_GROUP_PANEL_ITEM_CLASS: DATAGRID_GROUP_PANEL_ITEM_CLASS
        });
        dataGrid.registerModule('grouping', {
            defaultOptions: function() {
                return {
                        grouping: {
                            autoExpandAll: true,
                            allowCollapsing: true,
                            groupContinuesMessage: Globalize.localize("dxDataGrid-groupContinuesMessage"),
                            groupContinuedMessage: Globalize.localize("dxDataGrid-groupContinuedMessage")
                        },
                        groupPanel: {
                            visible: false,
                            emptyPanelText: Globalize.localize("dxDataGrid-groupPanelEmptyText"),
                            allowColumnDragging: true
                        }
                    }
            },
            extenders: {
                controllers: {data: GroupingDataControllerExtender},
                views: {headerPanel: GroupingHeaderPanelExtender}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.grouping.server.js */
    (function($, DX) {
        var utils = DX.utils,
            dataUtils = DX.data.utils,
            dataGrid = DX.ui.dxDataGrid,
            normalizeSortingInfo = dataUtils.normalizeSortingInfo,
            keysEqual = dataUtils.keysEqual;
        var loadTotalCount = function(store, options) {
                var d = $.Deferred(),
                    loadOptions = $.extend({
                        skip: 0,
                        take: 0,
                        requireTotalCount: true
                    }, options);
                store.load(loadOptions).done(function(data, extra) {
                    if (extra && isFinite(extra.totalCount))
                        d.resolve(extra.totalCount);
                    else
                        store.totalCount(options).done($.proxy(d.resolve, d)).fail($.proxy(d.reject, d))
                }).fail($.proxy(d.reject, d));
                return d
            };
        dataGrid.DataSourceAdapterServer = dataGrid.DataSourceAdapterServer.inherit(function() {
            var foreachCollapsedGroups = function(that, callback) {
                    return that.foreachGroups(function(groupInfo) {
                            if (!groupInfo.isExpanded)
                                return callback(groupInfo)
                        })
                };
            var correctSkipLoadOption = function(that, skip) {
                    var skipCorrection = 0,
                        resultSkip = skip || 0;
                    if (skip) {
                        foreachCollapsedGroups(that, function(groupInfo) {
                            if (groupInfo.offset - skipCorrection >= skip)
                                return false;
                            skipCorrection += groupInfo.count - 1
                        });
                        resultSkip += skipCorrection
                    }
                    return resultSkip
                };
            var processGroupItems = function(that, items, path, offset, skipFirstItem, take) {
                    var i,
                        item,
                        offsetInfo,
                        removeLastItemsCount = 0,
                        needRemoveFirstItem = false;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if (item.items !== undefined) {
                            path.push(item.key);
                            var groupInfo = that.findGroupInfo(path);
                            if (groupInfo && !groupInfo.isExpanded) {
                                item.items = null;
                                offset += groupInfo.count;
                                take--;
                                if (take < 0)
                                    removeLastItemsCount++;
                                if (skipFirstItem)
                                    needRemoveFirstItem = true
                            }
                            else if (item.items) {
                                offsetInfo = processGroupItems(that, item.items, path, offset, skipFirstItem, take);
                                if (skipFirstItem)
                                    if (offsetInfo.offset - offset > 1)
                                        item.isContinuation = true;
                                    else
                                        needRemoveFirstItem = true;
                                offset = offsetInfo.offset;
                                take = offsetInfo.take;
                                if (take < 0)
                                    if (item.items.length)
                                        item.isContinuationOnNextPage = true;
                                    else
                                        removeLastItemsCount++
                            }
                            path.pop()
                        }
                        else {
                            if (skipFirstItem)
                                needRemoveFirstItem = true;
                            offset++;
                            take--;
                            if (take < 0)
                                removeLastItemsCount++
                        }
                        skipFirstItem = false
                    }
                    if (needRemoveFirstItem)
                        items.splice(0, 1);
                    if (removeLastItemsCount)
                        items.splice(-removeLastItemsCount, removeLastItemsCount);
                    return {
                            offset: offset,
                            take: take
                        }
                };
            var pathEquals = function(path1, path2) {
                    var i;
                    if (path1.length !== path2.length)
                        return false;
                    for (i = 0; i < path1.length; i++)
                        if (!keysEqual(null, path1[i], path2[i]))
                            return false;
                    return true
                };
            var updateGroupOffsets = function(that, items, path, offset, additionalGroupInfo) {
                    var i,
                        item,
                        groupsInfo = that._groupsInfo;
                    if (!items)
                        return;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if ('key' in item && item.items !== undefined) {
                            path.push(item.key);
                            if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation)
                                additionalGroupInfo.offset = offset;
                            var groupInfo = that.findGroupInfo(path);
                            if (groupInfo && !groupInfo.isExpanded) {
                                if (!item.isContinuation) {
                                    groupInfo.offset = offset;
                                    offset += groupInfo.count
                                }
                            }
                            else
                                offset = updateGroupOffsets(that, item.items, path, offset, additionalGroupInfo);
                            path.pop()
                        }
                        else
                            offset++
                    }
                    return offset
                };
            var removeGroupLoadOption = function(storeLoadOptions) {
                    var groups,
                        sorts;
                    if (storeLoadOptions.group) {
                        groups = normalizeSortingInfo(storeLoadOptions.group || []);
                        sorts = normalizeSortingInfo(storeLoadOptions.sort || []);
                        storeLoadOptions.sort = dataUtils.arrangeSortingInfo(groups, sorts);
                        delete storeLoadOptions.group
                    }
                };
            var createGroupFilter = function(path, storeLoadOptions) {
                    var groups = normalizeSortingInfo(storeLoadOptions.group || []),
                        i,
                        filter = [];
                    for (i = 0; i < path.length; i++)
                        filter.push([groups[i].selector, '=', path[i]]);
                    if (storeLoadOptions.filter)
                        filter.push(storeLoadOptions.filter);
                    return filter
                };
            var createNotGroupFilter = function(path, storeLoadOptions, group) {
                    var groups = normalizeSortingInfo(group || storeLoadOptions.group || []),
                        i,
                        j,
                        filterElement,
                        filter = [];
                    for (i = 0; i < path.length; i++) {
                        filterElement = [];
                        for (j = 0; j <= i; j++)
                            filterElement.push([groups[j].selector, i === j ? '<>' : '=', path[j]]);
                        if (filter.length)
                            filter.push('or');
                        filter.push(filterElement)
                    }
                    if (path.length > 1)
                        filter = [filter];
                    if (storeLoadOptions.filter)
                        filter.push(storeLoadOptions.filter);
                    return filter
                };
            var createOffsetFilter = function(path, storeLoadOptions) {
                    var groups = normalizeSortingInfo(storeLoadOptions.group || []),
                        i,
                        j,
                        filterElement,
                        filter = [];
                    for (i = 0; i < path.length; i++) {
                        filterElement = [];
                        for (j = 0; j <= i; j++)
                            filterElement.push([groups[j].selector, i === j ? groups[j].desc ? '>' : '<' : '=', path[j]]);
                        if (filter.length)
                            filter.push('or');
                        filter.push(filterElement)
                    }
                    if (storeLoadOptions.filter)
                        filter.push(storeLoadOptions.filter);
                    return filter
                };
            return {
                    _handleDataLoading: function(options) {
                        var that = this,
                            storeLoadOptions = options.storeLoadOptions,
                            currentTake,
                            loadOptions,
                            collapsedPaths = [],
                            collapsedPathsByLoads = [],
                            skipFirstItem = false,
                            take,
                            group = storeLoadOptions.group,
                            skipCorrection = 0;
                        that.callBase(options);
                        removeGroupLoadOption(storeLoadOptions);
                        loadOptions = $.extend({}, storeLoadOptions);
                        loadOptions.skip = correctSkipLoadOption(that, storeLoadOptions.skip);
                        if (loadOptions.skip && loadOptions.take && group) {
                            loadOptions.skip--;
                            loadOptions.take++;
                            skipFirstItem = true
                        }
                        if (loadOptions.take && group) {
                            take = loadOptions.take;
                            loadOptions.take++
                        }
                        foreachCollapsedGroups(that, function(groupInfo) {
                            if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection)
                                return false;
                            else if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {
                                skipCorrection += groupInfo.count - 1;
                                collapsedPaths.push(groupInfo.path)
                            }
                        });
                        $.each(collapsedPaths, function() {
                            loadOptions.filter = createNotGroupFilter(this, loadOptions, group)
                        });
                        options.storeLoadOptions = loadOptions;
                        options.collapsedPaths = collapsedPaths;
                        options.skip = loadOptions.skip || 0;
                        options.skipFirstItem = skipFirstItem;
                        options.take = take;
                        options.group = group
                    },
                    _handleDataLoaded: function(options) {
                        var that = this,
                            data = options.data,
                            i,
                            pathIndex,
                            query,
                            collapsedPaths = options.collapsedPaths,
                            groups = normalizeSortingInfo(options.group || []),
                            groupCount = groups.length;
                        function appendCollapsedPath(data, path, groups) {
                            if (!data || !path.length || !groups.length)
                                return;
                            var i,
                                items,
                                keyValue,
                                pathValue = dataUtils.toComparable(path[0], true);
                            for (i = 0; i < data.length; i++) {
                                keyValue = dataUtils.toComparable(data[i].key, true);
                                if (groups[0].desc ? pathValue >= keyValue : pathValue <= keyValue)
                                    break
                            }
                            if (!data.length || pathValue !== keyValue)
                                data.splice(i, 0, {
                                    key: path[0],
                                    items: []
                                });
                            appendCollapsedPath(data[i].items, path.slice(1), groups.slice(1))
                        }
                        this.callBase(options);
                        if (groupCount) {
                            query = DX.data.query(data);
                            DX.data.utils.multiLevelGroup(query, groups).enumerate().done(function(groupedData) {
                                data = groupedData
                            });
                            if (collapsedPaths)
                                for (pathIndex = 0; pathIndex < collapsedPaths.length; pathIndex++)
                                    appendCollapsedPath(data, collapsedPaths[pathIndex], groups);
                            processGroupItems(that, data, [], options.skip, options.skipFirstItem, options.take);
                            that.updateItemsCount(data, groupCount);
                            options.data = data
                        }
                    },
                    updateTotalItemsCount: function() {
                        var itemsCountCorrection = 0;
                        foreachCollapsedGroups(this, function(groupInfo) {
                            if (groupInfo.count)
                                itemsCountCorrection -= groupInfo.count - 1
                        });
                        this.callBase(itemsCountCorrection)
                    },
                    _changeRowExpandCore: function(path) {
                        var that = this,
                            dataSource = that._dataSource,
                            basePageIndex = that.basePageIndex && that.basePageIndex() || that.pageIndex(),
                            dataSourceItems = that.items(),
                            offset = correctSkipLoadOption(that, basePageIndex * that.pageSize()),
                            groupCountQuery;
                        groupCountQuery = loadTotalCount(dataSource.store(), {filter: createGroupFilter(path, {
                                filter: dataSource.filter(),
                                group: dataSource.group()
                            })});
                        return $.when(groupCountQuery).done(function(count) {
                                var groupInfo;
                                count = parseInt(count.length ? count[0] : count);
                                groupInfo = that.findGroupInfo(path);
                                if (groupInfo) {
                                    updateGroupOffsets(that, dataSourceItems, [], offset);
                                    groupInfo.isExpanded = !groupInfo.isExpanded;
                                    groupInfo.count = count
                                }
                                else {
                                    groupInfo = {
                                        offset: -1,
                                        count: count,
                                        path: path,
                                        isExpanded: false
                                    };
                                    updateGroupOffsets(that, dataSourceItems, [], offset, groupInfo);
                                    if (groupInfo.offset >= 0)
                                        that.addGroupInfo(groupInfo)
                                }
                                that.updateTotalItemsCount()
                            }).fail($.proxy(dataSource.loadError.fire, dataSource.loadError))
                    },
                    allowCollapseAll: function() {
                        return false
                    },
                    refresh: function(storeLoadOptions) {
                        var that = this,
                            store = that._dataSource.store();
                        that.callBase(storeLoadOptions);
                        return foreachCollapsedGroups(that, function(groupInfo) {
                                var groupCountQuery = loadTotalCount(store, {filter: createGroupFilter(groupInfo.path, storeLoadOptions)}),
                                    groupOffsetQuery = loadTotalCount(store, {filter: createOffsetFilter(groupInfo.path, storeLoadOptions)});
                                return $.when(groupOffsetQuery, groupCountQuery).done(function(offset, count) {
                                        offset = parseInt(offset.length ? offset[0] : offset);
                                        count = parseInt(count.length ? count[0] : count);
                                        groupInfo.offset = offset;
                                        if (groupInfo.count !== count) {
                                            groupInfo.count = count;
                                            that.updateTotalItemsCount()
                                        }
                                    }).fail($.proxy(that._dataSource.loadError.fire, that._dataSource.loadError))
                            })
                    }
                }
        }());
        $.extend(DX.ui.dxDataGrid.__internals, {loadTotalCount: loadTotalCount})
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.grouping.client.js */
    (function($, DX) {
        var utils = DX.utils,
            dataUtils = DX.data.utils,
            dataGrid = DX.ui.dxDataGrid,
            normalizeSortingInfo = dataUtils.normalizeSortingInfo,
            keysEqual = dataUtils.keysEqual;
        dataGrid.DataSourceAdapterClient = dataGrid.DataSourceAdapterClient.inherit(function() {
            var foreachExpandedGroups = function(that, callback) {
                    return that.foreachGroups(function(groupInfo, parents) {
                            if (groupInfo.isExpanded)
                                return callback(groupInfo, parents)
                        }, true)
                };
            var processGroupItems = function(that, items, path, groupsCount) {
                    var i,
                        item;
                    if (!groupsCount)
                        return;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if (item.items !== undefined) {
                            path.push(item.key);
                            var groupInfo = that.findGroupInfo(path);
                            if (!groupInfo || !groupInfo.isExpanded)
                                item.items = null;
                            else
                                processGroupItems(that, item.items, path, groupsCount - 1);
                            path.pop()
                        }
                    }
                };
            var hasExpandedGroup = function(that, group) {
                    var hasExpandedGroup = false,
                        i,
                        groupsCount = normalizeSortingInfo(group || []).length;
                    for (i = 0; i < groupsCount; i++)
                        if (that._isGroupExpanded(i))
                            hasExpandedGroup = true;
                    return hasExpandedGroup
                };
            var updateGroupInfos = function(that, items, groupsCount, offset) {
                    updateGroupInfosCore(that, items, 0, groupsCount, [], offset)
                };
            var updateGroupInfosCore = function(that, items, groupIndex, groupsCount, path, offset) {
                    var item,
                        i,
                        groupInfo;
                    if (groupIndex >= groupsCount)
                        return;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if (item) {
                            path.push(item.key);
                            groupInfo = that.findGroupInfo(path);
                            if (!groupInfo)
                                that.addGroupInfo({
                                    isExpanded: that._isGroupExpanded(groupIndex),
                                    path: path.slice(0),
                                    offset: offset + i,
                                    count: item.items.length
                                });
                            else {
                                groupInfo.count = item.items.length;
                                groupInfo.offset = offset + i
                            }
                            updateGroupInfosCore(that, item.items, groupIndex + 1, groupsCount, path, 0);
                            path.pop()
                        }
                    }
                };
            var isGroupExpanded = function(groups, groupIndex) {
                    return groups && groups.length && groups[groupIndex] && !!groups[groupIndex].isExpanded
                };
            var getTotalOffset = function(groupInfos, pageSize, offset) {
                    var groupIndex,
                        prevOffset = 0,
                        groupSize,
                        totalOffset = offset;
                    for (groupIndex = 0; groupIndex < groupInfos.length; groupIndex++) {
                        groupSize = groupInfos[groupIndex].offset + 1;
                        if (groupIndex > 0) {
                            groupSize += groupInfos[groupIndex - 1].childrenTotalCount;
                            if (pageSize)
                                groupSize += getContinuationGroupCount(totalOffset, pageSize, groupSize, groupIndex - 1) * groupIndex
                        }
                        totalOffset += groupSize
                    }
                    return totalOffset
                };
            var getContinuationGroupCount = function(groupOffset, pageSize, groupSize, groupIndex) {
                    groupIndex = groupIndex || 0;
                    if (pageSize > 1 && groupSize > 0) {
                        var pageOffset = groupOffset - Math.floor(groupOffset / pageSize) * pageSize || pageSize;
                        pageOffset += groupSize - groupIndex - 2;
                        if (pageOffset < 0)
                            pageOffset += pageSize;
                        return Math.floor(pageOffset / (pageSize - groupIndex - 1))
                    }
                    return 0
                };
            DX.ui.dxDataGrid.getContinuationGroupCount = getContinuationGroupCount;
            return {
                    updateTotalItemsCount: function() {
                        var totalItemsCount = 0,
                            pageSize = this.pageSize(),
                            isVirtualPaging = this._isVirtualPaging();
                        foreachExpandedGroups(this, function(groupInfo, parents) {
                            groupInfo.childrenTotalCount = 0
                        });
                        foreachExpandedGroups(this, function(groupInfo, parents) {
                            var totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, totalItemsCount),
                                count = groupInfo.count + groupInfo.childrenTotalCount,
                                i;
                            if (!isVirtualPaging)
                                count += getContinuationGroupCount(totalOffset, pageSize, count, parents.length - 1);
                            if (parents[parents.length - 2])
                                parents[parents.length - 2].childrenTotalCount += count;
                            else
                                totalItemsCount += count
                        });
                        this.callBase(totalItemsCount)
                    },
                    _isGroupExpanded: function(groupIndex) {
                        var groups = this._dataSource.group();
                        return isGroupExpanded(groups, groupIndex)
                    },
                    _updatePagingOptions: function(options) {
                        var that = this,
                            storeLoadOptions = options.loadOptions,
                            dataSource = this._dataSource,
                            isVirtualPaging = that._isVirtualPaging(),
                            pageSize = that.pageSize(),
                            groups = normalizeSortingInfo(storeLoadOptions.group || []),
                            sorts = normalizeSortingInfo(storeLoadOptions.sort || []),
                            skips = [],
                            takes = [],
                            skipChildrenTotalCount = 0,
                            childrenTotalCount = 0;
                        if (options.take) {
                            foreachExpandedGroups(this, function(groupInfo) {
                                groupInfo.childrenTotalCount = 0;
                                groupInfo.skipChildrenTotalCount = 0
                            });
                            foreachExpandedGroups(that, function(groupInfo, parents) {
                                var skip,
                                    take,
                                    takeCorrection = 0,
                                    parentTakeCorrection = 0,
                                    totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, childrenTotalCount),
                                    continuationGroupCount = 0,
                                    skipContinuationGroupCount = 0,
                                    groupInfoCount = groupInfo.count + groupInfo.childrenTotalCount,
                                    childrenGroupInfoCount = groupInfoCount;
                                if (totalOffset <= options.skip + options.take && groupInfoCount) {
                                    skip = options.skip - totalOffset;
                                    take = options.take;
                                    if (!isVirtualPaging) {
                                        continuationGroupCount = getContinuationGroupCount(totalOffset, pageSize, groupInfoCount, parents.length - 1);
                                        groupInfoCount += continuationGroupCount * parents.length;
                                        childrenGroupInfoCount += continuationGroupCount;
                                        if (pageSize && skip >= 0) {
                                            takeCorrection = parents.length;
                                            parentTakeCorrection = parents.length - 1;
                                            skipContinuationGroupCount = Math.floor(skip / pageSize)
                                        }
                                    }
                                    if (skip >= 0) {
                                        if (totalOffset + groupInfoCount > options.skip)
                                            skips.unshift(skip - skipContinuationGroupCount * takeCorrection - groupInfo.skipChildrenTotalCount);
                                        if (totalOffset + groupInfoCount >= options.skip + take)
                                            takes.unshift(take - takeCorrection - groupInfo.childrenTotalCount + groupInfo.skipChildrenTotalCount)
                                    }
                                    else if (totalOffset + groupInfoCount >= options.skip + take)
                                        takes.unshift(take + skip - groupInfo.childrenTotalCount)
                                }
                                if (totalOffset <= options.skip)
                                    if (parents[parents.length - 2])
                                        parents[parents.length - 2].skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1 - skipContinuationGroupCount * parentTakeCorrection);
                                    else
                                        skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1);
                                if (totalOffset <= options.skip + take) {
                                    groupInfoCount = Math.min(childrenGroupInfoCount, skip + take - (skipContinuationGroupCount + 1) * parentTakeCorrection);
                                    if (parents[parents.length - 2])
                                        parents[parents.length - 2].childrenTotalCount += groupInfoCount;
                                    else
                                        childrenTotalCount += groupInfoCount
                                }
                            });
                            options.skip -= skipChildrenTotalCount;
                            options.take -= childrenTotalCount - skipChildrenTotalCount
                        }
                        options.skips = skips;
                        options.takes = takes
                    },
                    _changeRowExpandCore: function(path) {
                        var that = this,
                            groupInfo = that.findGroupInfo(path);
                        if (groupInfo) {
                            groupInfo.isExpanded = !groupInfo.isExpanded;
                            that.updateTotalItemsCount();
                            return $.Deferred().resolve()
                        }
                        return $.Deferred().reject()
                    },
                    _handleDataLoadedCore: function(options) {
                        var that = this,
                            callBase = that.callBase,
                            data = options.data,
                            groupCount = normalizeSortingInfo(options.loadOptions.group || []).length,
                            summary = that.summary(),
                            skips,
                            takes,
                            i,
                            item,
                            items;
                        updateGroupInfos(that, options.data, groupCount, 0);
                        that.updateTotalItemsCount();
                        that._updatePagingOptions(options);
                        callBase.call(that, options);
                        skips = options.skips;
                        takes = options.takes;
                        items = options.data;
                        for (i = 0; items && i < groupCount; i++) {
                            item = items[0];
                            items = item && item.items;
                            if (items && skips[i] !== undefined) {
                                item.isContinuation = true;
                                items = items.slice(skips[i]);
                                item.items = items
                            }
                        }
                        items = options.data;
                        for (i = 0; items && i < groupCount; i++) {
                            item = items[items.length - 1];
                            items = item && item.items;
                            if (items && takes[i] !== undefined && items.length > takes[i]) {
                                item.isContinuationOnNextPage = true;
                                items = items.slice(0, takes[i]);
                                item.items = items
                            }
                        }
                        processGroupItems(that, options.data, [], groupCount);
                        that.updateItemsCount(options.data, groupCount)
                    },
                    refresh: function(storeLoadOptions) {
                        var that = this,
                            oldGroups = normalizeSortingInfo(that._group || []),
                            groups = normalizeSortingInfo(storeLoadOptions.group || []),
                            groupIndex;
                        for (groupIndex = 0; groupIndex < oldGroups.length; groupIndex++)
                            if (isGroupExpanded(that._group, groupIndex) !== isGroupExpanded(storeLoadOptions.group, groupIndex)) {
                                that.reset();
                                return
                            }
                        that.callBase(storeLoadOptions);
                        that.foreachGroups(function(groupInfo) {
                            groupInfo.count = 0
                        });
                        if (groups.length)
                            return that._dataSource.store().load(storeLoadOptions).done(function(data) {
                                    updateGroupInfos(that, data, groups.length, 0)
                                }).fail($.proxy(that._dataSource.loadError.fire, that._dataSource.loadError))
                    }
                }
        }())
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.virtualScrollingModule.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            utils = DX.utils;
        var DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_FREESPACE_CLASS = "dx-freespace-row",
            DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
            DATAGRID_BOTTOM_LOAD_PANEL_CLASS = "dx-datagrid-bottom-load-panel",
            DATAGRID_TABLE_CONTENT_CLASS = "dx-datagrid-table-content",
            DATAGRID_GROUP_SPACE_CLASS = "dx-datagrid-group-space",
            SCROLLING_MODE_INFINITE = 'infinite',
            SCROLLING_MODE_VIRTUAL = 'virtual',
            PIXELS_LIMIT = 250000;
        var VirtualScrollingDataSourceAdapterExtender = function() {
                var getPreloadPageCount = function(that) {
                        return that.option('scrolling.preloadEnabled') ? 2 : 1
                    };
                var isVirtualMode = function(that) {
                        return that.option('scrolling.mode') === SCROLLING_MODE_VIRTUAL
                    };
                var isAppendMode = function(that) {
                        return that.option('scrolling.mode') === SCROLLING_MODE_INFINITE
                    };
                var getBasePageIndex = function(that) {
                        return that._cache[0] ? that._cache[0].pageIndex : -1
                    };
                var updateLoading = function(that) {
                        var basePageIndex = getBasePageIndex(that),
                            pageCount = that._cache.length;
                        if (isVirtualMode(that))
                            if (basePageIndex < 0 || that._viewportItemIndex >= 0 && (basePageIndex * that.pageSize() > that._viewportItemIndex || basePageIndex * that.pageSize() + that.itemsCount() < that._viewportItemIndex + that._viewportSize) && that._dataSource.isLoading()) {
                                if (!that._isLoading) {
                                    that._isLoading = true;
                                    that.loadingChanged.fire(true)
                                }
                            }
                            else if (that._isLoading) {
                                that._isLoading = false;
                                that.loadingChanged.fire(false)
                            }
                    };
                var processDelayChanged = function(that, changed) {
                        if (that._isDelayChanged) {
                            that._isDelayChanged = false;
                            changed.call(that)
                        }
                    };
                var processChanged = function(that, changed, changeType, isDelayChanged) {
                        var dataSource = that._dataSource,
                            items = dataSource.items();
                        if (changeType === 'append')
                            that._items.push.apply(that._items, items);
                        else if (changeType === 'prepend')
                            that._items.unshift.apply(that._items, items);
                        else
                            that._items = items;
                        updateLoading(that);
                        that._lastPageIndex = that.pageIndex();
                        that._isDelayChanged = isDelayChanged;
                        if (!isDelayChanged)
                            changed.call(that, changeType && {
                                changeType: changeType,
                                items: items
                            })
                    };
                return {
                        init: function(dataSource) {
                            var that = this;
                            that.callBase.apply(that, arguments);
                            that._isLoading = true;
                            that._pageIndex = dataSource.pageIndex();
                            that._lastPageIndex = that._pageIndex;
                            that._viewportSize = 0;
                            that._viewportItemIndex = -1;
                            that._userPageSize = that.option("paging.pageSize");
                            that._items = [];
                            that._isLoaded = true;
                            that._cache = [];
                            if (dataSource.isLoaded())
                                that._handleDataChanged()
                        },
                        _handleLoadingChanged: function(isLoading) {
                            var that = this;
                            if (!isVirtualMode(that)) {
                                that._isLoading = isLoading;
                                that.callBase.apply(that, arguments)
                            }
                        },
                        _handleLoadError: function() {
                            var that = this;
                            that._isLoading = false;
                            that.loadingChanged.fire(false);
                            that.callBase.apply(that, arguments)
                        },
                        _handleDataChanged: function() {
                            var that = this,
                                basePageIndex,
                                callBase = that.callBase,
                                dataSource = that._dataSource,
                                lastCacheLength = that._cache.length,
                                changeType,
                                cacheItem;
                            if (isVirtualMode(that)) {
                                basePageIndex = getBasePageIndex(that);
                                if (basePageIndex >= 0)
                                    if (basePageIndex + that._cache.length === dataSource.pageIndex());
                                    else if (basePageIndex - 1 === dataSource.pageIndex());
                                    else
                                        that._cache = [];
                                cacheItem = {
                                    pageIndex: dataSource.pageIndex(),
                                    itemsCount: that.itemsCount(true)
                                };
                                processDelayChanged(that, callBase);
                                if (basePageIndex === dataSource.pageIndex() + 1) {
                                    changeType = 'prepend';
                                    that._cache.unshift(cacheItem)
                                }
                                else {
                                    changeType = 'append';
                                    that._cache.push(cacheItem)
                                }
                                processChanged(that, callBase, that._cache.length > 1 ? changeType : undefined, lastCacheLength === 0);
                                that.load().done(function() {
                                    processDelayChanged(that, callBase)
                                })
                            }
                            else
                                processChanged(that, callBase, isAppendMode(that) && dataSource.pageIndex() !== 0 ? 'append' : undefined)
                        },
                        items: function() {
                            return this._items
                        },
                        itemsCount: function(isBase) {
                            var itemsCount = 0;
                            if (!isBase && isVirtualMode(this))
                                $.each(this._cache, function() {
                                    itemsCount += this.itemsCount
                                });
                            else
                                itemsCount = this.callBase();
                            return itemsCount
                        },
                        virtualItemsCount: function() {
                            var that = this,
                                pageIndex,
                                itemsCount = 0,
                                i,
                                beginItemsCount,
                                endItemsCount;
                            if (isVirtualMode(that)) {
                                pageIndex = getBasePageIndex(that);
                                if (pageIndex < 0)
                                    pageIndex = 0;
                                beginItemsCount = pageIndex * that.pageSize();
                                itemsCount = that._cache.length * that.pageSize();
                                endItemsCount = Math.max(0, that.totalItemsCount() - itemsCount - beginItemsCount);
                                return {
                                        begin: beginItemsCount,
                                        end: endItemsCount
                                    }
                            }
                        },
                        setViewportItemIndex: function(itemIndex) {
                            var that = this,
                                pageSize = that.pageSize(),
                                dataSource = that._dataSource,
                                pageCount = that.pageCount(),
                                virtualMode = isVirtualMode(that),
                                appendMode = isAppendMode(that),
                                totalItemsCount = that.totalItemsCount(),
                                lastPageSize,
                                needLoad = that._viewportItemIndex < 0,
                                maxPageIndex,
                                newPageIndex;
                            that._viewportItemIndex = itemIndex;
                            if (pageSize && (virtualMode || appendMode)) {
                                if (that._viewportSize && itemIndex + that._viewportSize >= totalItemsCount) {
                                    if (that.hasKnownLastPage()) {
                                        newPageIndex = pageCount - 1;
                                        lastPageSize = totalItemsCount % pageSize;
                                        if (newPageIndex > 0 && lastPageSize > 0 && lastPageSize < pageSize / 2)
                                            newPageIndex--
                                    }
                                    else if (that.pageIndex() < pageCount)
                                        newPageIndex = pageCount
                                }
                                else {
                                    newPageIndex = Math.floor(itemIndex / pageSize);
                                    maxPageIndex = pageCount - 1;
                                    newPageIndex = Math.max(newPageIndex, 0);
                                    newPageIndex = Math.min(newPageIndex, maxPageIndex)
                                }
                                if (that.pageIndex() !== newPageIndex || needLoad) {
                                    that.pageIndex(newPageIndex);
                                    that.load()
                                }
                            }
                        },
                        setViewportSize: function(size) {
                            var that = this,
                                pageSize;
                            if (that._viewportSize !== size) {
                                that._viewportSize = size;
                                if ((isVirtualMode(that) || isAppendMode(that)) && !that._userPageSize) {
                                    pageSize = Math.ceil(size / 5) * 10;
                                    if (pageSize !== that.pageSize()) {
                                        that.pageSize(pageSize);
                                        that.reload()
                                    }
                                }
                            }
                        },
                        getViewportSize: function() {
                            return this._viewportSize
                        },
                        pageIndex: function(pageIndex) {
                            if (isVirtualMode(this) || isAppendMode(this)) {
                                if (pageIndex !== undefined)
                                    this._pageIndex = pageIndex;
                                return this._pageIndex
                            }
                            else
                                return this._dataSource.pageIndex(pageIndex)
                        },
                        basePageIndex: function() {
                            var basePageIndex = getBasePageIndex(this);
                            return basePageIndex > 0 ? basePageIndex : 0
                        },
                        load: function() {
                            var basePageIndex = getBasePageIndex(this),
                                pageIndexForLoad = -1,
                                dataSource = this._dataSource,
                                result;
                            var loadCore = function(that, pageIndex) {
                                    var dataSource = that._dataSource;
                                    if (pageIndex === that.pageIndex() || !dataSource.isLoading() && pageIndex < that.pageCount() || !that.hasKnownLastPage() && pageIndex === that.pageCount()) {
                                        dataSource.pageIndex(pageIndex);
                                        return dataSource.load()
                                    }
                                };
                            if (isVirtualMode(this)) {
                                if (basePageIndex < 0 || !this._cache[this._pageIndex - basePageIndex])
                                    pageIndexForLoad = this._pageIndex;
                                if (basePageIndex >= 0 && pageIndexForLoad < 0 && this._viewportItemIndex >= 0 && basePageIndex + this._cache.length <= this._pageIndex + getPreloadPageCount(this))
                                    pageIndexForLoad = basePageIndex + this._cache.length;
                                if (pageIndexForLoad >= 0)
                                    result = loadCore(this, pageIndexForLoad);
                                updateLoading(this)
                            }
                            else if (isAppendMode(this)) {
                                if (!dataSource.isLoaded() || this.pageIndex() === this.pageCount()) {
                                    dataSource.pageIndex(this.pageIndex());
                                    result = dataSource.load()
                                }
                            }
                            else
                                result = dataSource.load();
                            if (!result && this._lastPageIndex !== this.pageIndex())
                                this.changed.fire({changeType: 'pageIndex'});
                            return result || $.Deferred().resolve()
                        },
                        isLoading: function() {
                            return this._isLoading
                        },
                        isLoaded: function() {
                            return this._dataSource.isLoaded() && this._isLoaded
                        },
                        changeRowExpand: function() {
                            this._cache = [];
                            updateLoading(this);
                            return this.callBase.apply(this, arguments)
                        },
                        reload: function() {
                            var that = this,
                                dataSource = that._dataSource;
                            that._cache = [];
                            that._isLoaded = false;
                            updateLoading(that);
                            that._isLoaded = true;
                            if (isAppendMode(that)) {
                                that.pageIndex(0);
                                dataSource.pageIndex(0)
                            }
                            else
                                dataSource.pageIndex(that.pageIndex());
                            return that.callBase()
                        }
                    }
            }();
        dataGrid.DataSourceAdapterServer = dataGrid.DataSourceAdapterServer.inherit(VirtualScrollingDataSourceAdapterExtender);
        dataGrid.DataSourceAdapterClient = dataGrid.DataSourceAdapterClient.inherit(VirtualScrollingDataSourceAdapterExtender);
        var VirtualScrollingRowsViewExtender = function() {
                return {
                        _renderCore: function() {
                            var that = this;
                            that.callBase.apply(that, arguments);
                            that._updateContentPosition()
                        },
                        _renderContent: function(contentElement, tableElement) {
                            var that = this,
                                virtualItemsCount = that._dataController.virtualItemsCount(),
                                contentChildrenCount = contentElement.children().length;
                            if (virtualItemsCount) {
                                tableElement.addClass(DATAGRID_TABLE_CONTENT_CLASS);
                                if (!contentElement.children().length)
                                    contentElement.append(tableElement);
                                else
                                    contentElement.children().first().replaceWith(tableElement);
                                if (contentElement.children().length === 1) {
                                    contentElement.append(that._createTable());
                                    that._contentHeight = 0
                                }
                            }
                            else
                                return that.callBase.apply(that, arguments)
                        },
                        _updateContent: function(contentElement, change, tableElement) {
                            var that = this,
                                rowHeight = that._rowHeight || 20,
                                contentTable,
                                changeType = change && change.changeType,
                                virtualItemsCount = that._dataController.virtualItemsCount();
                            if (changeType === 'append' || changeType === 'prepend') {
                                contentTable = contentElement.children().first();
                                tableElement.children('tbody').children('tr')[changeType === 'append' ? 'appendTo' : 'prependTo'](contentTable)
                            }
                            else
                                that.callBase.apply(that, arguments);
                            that._updateBottomLoading()
                        },
                        _updateContentPosition: function() {
                            var that = this,
                                contentElement,
                                contentHeight,
                                rowHeight = that._rowHeight || 20,
                                virtualItemsCount = that._dataController.virtualItemsCount();
                            if (virtualItemsCount) {
                                contentElement = that._findContentElement();
                                DX.translator.move(contentElement.children().first(), {top: Math.floor(virtualItemsCount.begin * rowHeight)});
                                contentHeight = (virtualItemsCount.begin + virtualItemsCount.end) * rowHeight + contentElement.children().first().outerHeight();
                                if (that._contentHeight !== contentHeight || contentHeight === 0) {
                                    that._contentHeight = contentHeight;
                                    that._updateContainerHeight(contentElement.children().eq(1), contentHeight)
                                }
                            }
                        },
                        _updateContainerHeight: function(container, height) {
                            var that = this,
                                columns = that._columnsController.getVisibleColumns(),
                                html = dataGrid.createColGroup(columns).prop('outerHTML'),
                                freeSpaceCellsHtml = '',
                                i,
                                columnLinesClass = that.option('showColumnLines') ? DATAGRID_COLUMN_LINES_CLASS : '',
                                createFreeSpaceRowHtml = function(height) {
                                    return '<tr style="height:' + height + 'px;" class="' + DATAGRID_FREESPACE_CLASS + ' ' + DATAGRID_ROW_CLASS + ' ' + columnLinesClass + '" >' + freeSpaceCellsHtml + '</tr>'
                                };
                            for (i = 0; i < columns.length; i++)
                                freeSpaceCellsHtml += columns[i].command === "expand" ? '<td class="' + DATAGRID_GROUP_SPACE_CLASS + '"/>' : '<td />';
                            while (height > PIXELS_LIMIT) {
                                html += createFreeSpaceRowHtml(PIXELS_LIMIT);
                                height -= PIXELS_LIMIT
                            }
                            html += createFreeSpaceRowHtml(height);
                            container.addClass(DATAGRID_TABLE_CLASS);
                            container.html(html)
                        },
                        _findBottomLoadPanel: function() {
                            var $bottomLoadPanel = this.element().find('.' + DATAGRID_BOTTOM_LOAD_PANEL_CLASS);
                            if ($bottomLoadPanel.length)
                                return $bottomLoadPanel
                        },
                        _updateBottomLoading: function() {
                            var that = this,
                                scrollingMode = that.option("scrolling.mode"),
                                virtualMode = scrollingMode === SCROLLING_MODE_VIRTUAL,
                                appendMode = scrollingMode === SCROLLING_MODE_INFINITE,
                                showBottomLoading = !that._dataController.hasKnownLastPage() && that._dataController.isLoaded() && (virtualMode || appendMode),
                                bottomLoadPanelElement = that._findBottomLoadPanel();
                            if (showBottomLoading) {
                                bottomLoadPanelElement = bottomLoadPanelElement || $('<div />').addClass(DATAGRID_BOTTOM_LOAD_PANEL_CLASS).append($('<div />').dxLoadIndicator());
                                bottomLoadPanelElement.appendTo(that._findContentElement());
                                bottomLoadPanelElement.show()
                            }
                            else if (bottomLoadPanelElement)
                                bottomLoadPanelElement.hide()
                        },
                        _handleScroll: function(e) {
                            var that = this;
                            if (that._hasHeight && that._rowHeight)
                                that._dataController.setViewportItemIndex(e.scrollOffset.top / that._rowHeight);
                            that.callBase.apply(that, arguments)
                        },
                        _renderScrollableCore: function($element) {
                            var that = this;
                            that.callBase.apply(that, arguments);
                            that._subscribeToWindowScrollEvents($element)
                        },
                        _subscribeToWindowScrollEvents: function($element) {
                            var that = this,
                                disposing = that.disposing,
                                $componentContainer = that.component.element(),
                                $scrollElement;
                            if (!$componentContainer)
                                return;
                            if (!that._windowScrollEvents) {
                                that._windowScrollEvents = true;
                                var createWindowScrollHandler = function($scrollElement, oldHandler) {
                                        var handler = function(e) {
                                                var contentOffset,
                                                    scrollTop = $scrollElement.scrollTop();
                                                if (!that._hasHeight && that._rowHeight) {
                                                    scrollTop -= $element.offset().top;
                                                    scrollTop = scrollTop > 0 ? scrollTop : 0;
                                                    that._scrollTop = scrollTop;
                                                    that._dataController.setViewportItemIndex(scrollTop / that._rowHeight)
                                                }
                                            };
                                        if (oldHandler)
                                            return function(e) {
                                                    handler(e);
                                                    oldHandler(e)
                                                };
                                        return handler
                                    };
                                var subscribeToScrollEvents = function($scrollElement) {
                                        var dxScrollable = $scrollElement.data("dxScrollable"),
                                            scrollHandler,
                                            oldScrollHandler;
                                        if (dxScrollable) {
                                            oldScrollHandler = dxScrollable.option('onScroll');
                                            scrollHandler = createWindowScrollHandler($scrollElement, oldScrollHandler);
                                            dxScrollable.option('onScroll', scrollHandler);
                                            that.on("disposing", function() {
                                                if (dxScrollable.option('onScroll') === scrollHandler)
                                                    dxScrollable.option('onScroll', oldScrollHandler)
                                            })
                                        }
                                        else if ($scrollElement.is(document) || $scrollElement.css("overflow-y") === "auto") {
                                            if ($scrollElement.is(document))
                                                $scrollElement = $(window);
                                            scrollHandler = createWindowScrollHandler($scrollElement);
                                            $scrollElement.on('scroll', scrollHandler);
                                            that.on("disposing", function() {
                                                $scrollElement.off('scroll', scrollHandler)
                                            })
                                        }
                                    };
                                for ($scrollElement = that.component.element().parent(); $scrollElement.length; $scrollElement = $scrollElement.parent())
                                    subscribeToScrollEvents($scrollElement)
                            }
                        },
                        _needUpdateRowHeight: function(itemsCount) {
                            var that = this;
                            return that.callBase.apply(that, arguments) || itemsCount > 0 && that.option('scrolling.mode') === SCROLLING_MODE_INFINITE
                        },
                        _updateRowHeight: function() {
                            var that = this,
                                lastRowHeight = that._rowHeight,
                                viewportHeight;
                            that.callBase.apply(that, arguments);
                            if (!lastRowHeight && that._rowHeight) {
                                that._updateContentPosition();
                                viewportHeight = that._hasHeight ? that.element().outerHeight() : $(window).outerHeight();
                                that._dataController.setViewportSize(Math.round(viewportHeight / that._rowHeight))
                            }
                        },
                        setLoading: function(isLoading, messageText) {
                            var that = this,
                                callBase = that.callBase,
                                hasBottomLoadPanel = !!that._findBottomLoadPanel() && that._dataController.isLoaded();
                            if (hasBottomLoadPanel)
                                isLoading = false;
                            callBase.call(that, isLoading, messageText)
                        }
                    }
            }();
        $.extend(dataGrid.__internals, {
            DATAGRID_BOTTOM_LOAD_PANEL_CLASS: DATAGRID_BOTTOM_LOAD_PANEL_CLASS,
            DATAGRID_TABLE_CONTENT_CLASS: DATAGRID_TABLE_CONTENT_CLASS
        });
        dataGrid.registerModule('virtualScrolling', {
            defaultOptions: function() {
                return {scrolling: {
                            mode: 'standard',
                            preloadEnabled: false,
                            useNativeScrolling: 'auto'
                        }}
            },
            extenders: {
                controllers: {data: function() {
                        var members = {};
                        dataGrid.proxyMethod(members, "virtualItemsCount");
                        dataGrid.proxyMethod(members, "setViewportSize");
                        dataGrid.proxyMethod(members, "setViewportItemIndex");
                        return members
                    }()},
                views: {rowsView: VirtualScrollingRowsViewExtender}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnHeadersView.js */
    (function($, DX) {
        var ui = DX.ui,
            events = ui.events,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_HEADERS_ACTION_CLASS = "dx-datagrid-action",
            DATAGRID_HEADERS_CLASS = "dx-datagrid-headers",
            DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
            DATAGRID_NOWRAP_CLASS = "dx-datagrid-nowrap",
            DATAGRID_GROUP_SPACE_CLASS = "dx-datagrid-group-space",
            DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
            DATAGRID_CONTEXT_MENU_SORT_ASC_ICON = "context-menu-sort-asc",
            DATAGRID_CONTEXT_MENU_SORT_DESC_ICON = "context-menu-sort-desc",
            DATAGRID_CONTEXT_MENU_SORT_NONE_ICON = "context-menu-sort-none",
            DATAGRID_SORT_CLASS = "dx-sort",
            COLUMN_HEADERS_VIEW_NAMESPACE = 'dxDataGridColumnHeadersView',
            DATAGRID_BORDER_COLLAPSE_CORRECTION = 1;
        dataGrid.ColumnHeadersView = dataGrid.ColumnsView.inherit({
            _renderHeaderContent: function($cell, column, columnIndex) {
                var that = this,
                    $group = $('<div />'),
                    headerCellTemplate = column.headerCellTemplate;
                if (column.command) {
                    $cell.html('&nbsp;');
                    if (column.command === "expand")
                        $cell.addClass(DATAGRID_GROUP_SPACE_CLASS)
                }
                else {
                    that._applySorting($cell, column, that.option('showColumnLines'));
                    var $content = $('<div />').addClass(DATAGRID_CELL_CONTENT_CLASS);
                    if (that.option("showColumnLines"))
                        $content.appendTo($cell);
                    else
                        $content.css("float", column.alignment || 'left').prependTo($cell);
                    var templateOptions = {
                            column: column,
                            columnIndex: columnIndex
                        };
                    if ($.isFunction(headerCellTemplate))
                        headerCellTemplate($content, templateOptions);
                    else if (utils.isString(headerCellTemplate)) {
                        headerCellTemplate = that.getTemplate(headerCellTemplate);
                        if (headerCellTemplate)
                            headerCellTemplate.render(templateOptions, $content)
                    }
                    else
                        $content.text(column.caption)
                }
            },
            _renderHeader: function(rootElement, column, columnIndex) {
                var that = this,
                    sortingMode = that.option('sorting.mode'),
                    cellElement;
                cellElement = $('<td />').css('text-align', column.alignment || 'left').toggleClass(column.cssClass, !utils.isDefined(column.groupIndex));
                that._renderHeaderContent(cellElement, column, columnIndex);
                if ((sortingMode === 'single' || sortingMode === 'multiple') && column.allowSorting)
                    cellElement.addClass(DATAGRID_HEADERS_ACTION_CLASS);
                cellElement.appendTo(rootElement)
            },
            _renderCore: function() {
                var that = this,
                    $container = that.element(),
                    columns = that._columnsController.getVisibleColumns(),
                    scrollLeft = that._scrollLeft;
                that._tableElement = that._createTable().attr('style', '-webkit-user-select: none').append(dataGrid.createColGroup(columns));
                $container.addClass(DATAGRID_HEADERS_CLASS).addClass(DATAGRID_CONTENT_CLASS).toggleClass(DATAGRID_NOWRAP_CLASS, !!that.option("columnAutoWidth") || !that.option("wordWrapEnabled")).empty();
                that._renderContent(that._tableElement);
                that.wrapTableInScrollContainer(that._tableElement).appendTo($container);
                that._scrollLeft = 0;
                that.scrollOffset(scrollLeft)
            },
            _renderContent: function($table) {
                var that = this,
                    columns = that._columnsController.getVisibleColumns(),
                    $row,
                    i;
                if (that.option('showColumnHeaders')) {
                    $row = that._createRow().addClass(DATAGRID_HEADER_ROW_CLASS).toggleClass(DATAGRID_COLUMN_LINES_CLASS, that.option('showColumnLines'));
                    $row.on(events.addNamespace("dxclick", COLUMN_HEADERS_VIEW_NAMESPACE), 'td', that.createAction(function(e) {
                        var keyName = null,
                            event = e.jQueryEvent;
                        event.stopPropagation();
                        setTimeout(function() {
                            var column = columns[event.currentTarget.cellIndex];
                            if (event.shiftKey)
                                keyName = "shift";
                            else if (event.ctrlKey)
                                keyName = "ctrl";
                            if (column && !utils.isDefined(column.groupIndex))
                                that._columnsController.changeSortOrder(column.index, keyName)
                        })
                    }));
                    for (i = 0; i < columns.length; i++)
                        that._renderHeader($row, columns[i], i);
                    $table.append($row)
                }
            },
            _afterRender: function($root) {
                var that = this;
                that._updateSortIndicatorPositions(that.element());
                that.processSizeChanged()
            },
            _updateSortIndicatorPositions: function(element) {
                var that = this,
                    columnElements = that.getColumnElements(),
                    $cell,
                    i;
                that.callBase(element);
                if (!that.option('showColumnLines') && columnElements)
                    for (i = 0; i < columnElements.length; i++) {
                        $cell = columnElements.eq(i);
                        that._setColumnTextWidth($cell, $cell.outerWidth())
                    }
            },
            _updateSortIndicators: function() {
                var that = this,
                    columns = that._columnsController.getVisibleColumns(),
                    $element = that.element(),
                    $cells = $element.find('.' + DATAGRID_HEADER_ROW_CLASS + ' > td'),
                    i;
                for (i = 0; i < columns.length; i++)
                    if (!utils.isDefined(columns[i].groupIndex))
                        that._applySorting($cells.eq(i), columns[i], that.option('showColumnLines'));
                that._updateSortIndicatorPositions($element)
            },
            _columnOptionChanged: function(e) {
                var changeTypes = e.changeTypes,
                    optionNames = e.optionNames;
                if (changeTypes.length && changeTypes.length == !!changeTypes.sorting) {
                    this._updateSortIndicators();
                    return
                }
                this.callBase(e);
                if (optionNames.width || optionNames.visibleWidth) {
                    this._updateSortIndicatorPositions(this.element());
                    this.resizeCompleted.fire()
                }
            },
            _setColumnTextWidth: function($column, columnWidth) {
                var $sortElement = $column.find("." + DATAGRID_SORT_CLASS),
                    indicatorOuterWidth = $sortElement.outerWidth(),
                    columnPaddings = $column.outerWidth() - $column.width(),
                    columnContentIndent = indicatorOuterWidth + columnPaddings;
                $column.find("." + DATAGRID_CELL_CONTENT_CLASS).css("max-width", columnWidth - columnContentIndent - DATAGRID_BORDER_COLLAPSE_CORRECTION)
            },
            _isElementVisible: function(elementOptions) {
                return elementOptions && elementOptions.visible
            },
            _resizeCore: function() {
                this.callBase();
                this._updateSortIndicatorPositions(this.element())
            },
            getHeadersRowHeight: function() {
                if (this._tableElement) {
                    var $headerRow = this._tableElement.find('.' + DATAGRID_HEADER_ROW_CLASS).first();
                    return $headerRow && $headerRow.height()
                }
                return 0
            },
            setColumnWidths: function(widths) {
                var that = this,
                    scrollLeft = that._scrollLeft;
                that.callBase(widths);
                that._scrollLeft = 0;
                that.scrollOffset(scrollLeft)
            },
            processSizeChanged: function() {
                var that = this,
                    $element = that.element();
                if (!utils.isDefined(that._headersHeight) || that._headersHeight !== $element.height()) {
                    that._headersHeight = $element.height();
                    that.sizeChanged.fire()
                }
            },
            getHeaderElement: function(index) {
                var columnElements = this.getColumnElements();
                return columnElements && columnElements.eq(index)
            },
            getColumnElements: function() {
                var that = this,
                    columnElements;
                if (that._tableElement) {
                    columnElements = that._tableElement.find('.' + DATAGRID_HEADER_ROW_CLASS).find('td');
                    if (columnElements.length)
                        return columnElements
                }
                return null
            },
            allowDragging: function(column, draggingPanels) {
                var i,
                    result = false,
                    columns = this.getColumns(),
                    draggableColumnCount = 0,
                    draggingPanel,
                    allowDrag = function(column) {
                        return column.allowReordering || column.allowGrouping || column.allowHiding
                    };
                for (i = 0; i < columns.length; i++)
                    if (allowDrag(columns[i]))
                        draggableColumnCount++;
                if (draggableColumnCount <= 1)
                    return false;
                else if (!draggingPanels)
                    return (this.option("allowColumnReordering") || this._columnsController.isColumnOptionUsed("allowReordering")) && column && column.allowReordering;
                for (i = 0; i < draggingPanels.length; i++) {
                    draggingPanel = draggingPanels[i];
                    if (draggingPanel && draggingPanel.allowDragging(column))
                        return true
                }
                return false
            },
            getColumns: function() {
                return this._columnsController.getVisibleColumns()
            },
            getBoundingRect: function() {
                var that = this,
                    offset;
                if (that._tableElement.length > 0 && that._tableElement[0].rows.length > 0 && that._tableElement[0].rows[0].cells.length > 0) {
                    offset = that._tableElement.offset();
                    return {top: offset.top}
                }
                return null
            },
            getName: function() {
                return 'headers'
            },
            getHeadersLength: function() {
                var that = this;
                if (that._tableElement.length > 0 && that._tableElement[0].rows.length > 0)
                    return that._tableElement[0].rows[0].cells.length;
                return 0
            },
            init: function() {
                var that = this;
                that.callBase();
                that._scrollerWidth = 0;
                that.sizeChanged = $.Callbacks()
            },
            isVisible: function() {
                return this.option('showColumnHeaders')
            },
            setScrollerSpacing: function(width) {
                var that = this,
                    $element = that.element(),
                    rtlEnabled = that.option("rtlEnabled");
                that._scrollerWidth = width;
                $element && $element.css(rtlEnabled ? {paddingLeft: width} : {paddingRight: width})
            },
            optionChanged: function(args) {
                var that = this;
                that.callBase(args);
                switch (args.name) {
                    case'showColumnHeaders':
                    case'wordWrapEnabled':
                    case'showColumnLines':
                        that.render();
                        break
                }
            },
            getHeight: function() {
                var that = this,
                    $element = that.element();
                return $element ? $element.height() : 0
            },
            getContextMenuItems: function($targetElement) {
                var that = this,
                    $cell,
                    column,
                    onItemClick,
                    sortingOptions;
                if ($targetElement.closest("." + DATAGRID_HEADER_ROW_CLASS).length) {
                    $cell = $targetElement.closest("td");
                    column = $cell.length && that.getColumns()[$cell[0].cellIndex];
                    sortingOptions = that.option("sorting");
                    if (sortingOptions && sortingOptions.mode !== "none" && column && column.allowSorting) {
                        onItemClick = function(params) {
                            setTimeout(function() {
                                that._columnsController.changeSortOrder(column.index, params.itemData.value)
                            })
                        };
                        return [{
                                    text: sortingOptions.ascendingText,
                                    value: "asc",
                                    icon: DATAGRID_CONTEXT_MENU_SORT_ASC_ICON,
                                    onItemClick: onItemClick
                                }, {
                                    text: sortingOptions.descendingText,
                                    value: "desc",
                                    icon: DATAGRID_CONTEXT_MENU_SORT_DESC_ICON,
                                    onItemClick: onItemClick
                                }, {
                                    text: sortingOptions.clearText,
                                    value: "none",
                                    icon: DATAGRID_CONTEXT_MENU_SORT_NONE_ICON,
                                    onItemClick: onItemClick
                                }]
                    }
                    return []
                }
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_HEADERS_ACTION_CLASS: DATAGRID_HEADERS_ACTION_CLASS,
            DATAGRID_HEADERS_CLASS: DATAGRID_HEADERS_CLASS,
            DATAGRID_HEADER_ROW_CLASS: DATAGRID_HEADER_ROW_CLASS,
            DATAGRID_NOWRAP_CLASS: DATAGRID_NOWRAP_CLASS,
            DATAGRID_BORDER_COLLAPSE_CORRECTION: DATAGRID_BORDER_COLLAPSE_CORRECTION
        });
        dataGrid.registerModule('columnHeaders', {
            defaultOptions: function() {
                return {
                        showColumnHeaders: true,
                        cellHintEnabled: true
                    }
            },
            views: {columnHeadersView: dataGrid.ColumnHeadersView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.filterRow.js */
    (function($, DX) {
        var ui = DX.ui,
            events = ui.events,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var OPERATION_ICONS = {
                '=': 'filter-operation-equals',
                '<>': 'filter-operation-not-equals',
                '<': 'filter-operation-less',
                '<=': 'filter-operation-less-equal',
                '>': 'filter-operation-greater',
                '>=': 'filter-operation-greater-equal',
                'default': 'filter-operation-default',
                notcontains: 'filter-operation-not-contains',
                contains: 'filter-operation-contains',
                startswith: 'filter-operation-starts-with',
                endswith: 'filter-operation-ends-with'
            };
        var FILTERING_TIMEOUT = 700,
            DATAGRID_FILTER_ROW_CLASS = "dx-datagrid-filter-row",
            DATAGRID_MENU_CLASS = "dx-menu",
            DATAGRID_MENU_IMAGE_CLASS = 'dx-menu-image',
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_GROUP_SPACE_CLASS = "dx-datagrid-group-space",
            DATAGRID_EDITOR_WITH_MENU_CLASS = "dx-editor-with-menu",
            DATAGRID_EDITOR_CONTAINER_CLASS = "dx-editor-container",
            DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
            DATAGRID_EDITOR_CELL_CLASS = "dx-editor-cell",
            DATAGRID_APPLY_BUTTON_CLASS = "dx-apply-button",
            DATAGRID_HIGHLIGHT_OUTLINE_CLASS = "dx-highlight-outline";
        var ColumnHeadersViewFilterRowExtender = {
                _columnOptionChanged: function(e) {
                    var that = this,
                        optionNames = e.optionNames,
                        visibleIndex,
                        column,
                        $cell,
                        $editor,
                        componentNames,
                        editor,
                        $menu;
                    if (dataGrid.checkChanges(optionNames, ['filterValue', 'selectedFilterOperation']) && e.columnIndex !== undefined) {
                        visibleIndex = that.getController('columns').getVisibleIndex(e.columnIndex);
                        column = that.getController('columns').columnOption(e.columnIndex);
                        $cell = that.element().find('.' + DATAGRID_FILTER_ROW_CLASS).children().eq(visibleIndex);
                        $editor = $cell.find(".dx-texteditor");
                        if (optionNames.filterValue)
                            if ($editor.length) {
                                componentNames = $editor.data("dxComponents");
                                editor = componentNames.length && $editor.data(componentNames[0]);
                                if (editor instanceof ui.Editor)
                                    editor && editor.option("value", column.filterValue)
                            }
                        if (optionNames.selectedFilterOperation)
                            if (visibleIndex >= 0 && column) {
                                $menu = $cell.find('.' + DATAGRID_MENU_CLASS);
                                if ($menu.length)
                                    that._updateFilterOperationChooser($menu, column, $editor.parent())
                            }
                        return
                    }
                    that.callBase(e)
                },
                isFilterRowVisible: function() {
                    return this._isElementVisible(this.option('filterRow'))
                },
                isVisible: function() {
                    return this.callBase() || this.isFilterRowVisible()
                },
                init: function() {
                    this.callBase();
                    this._applyFilterViewController = this.getController("applyFilter")
                },
                _renderContent: function($table) {
                    this.callBase($table);
                    var that = this,
                        columns = that._columnsController.getVisibleColumns(),
                        i,
                        rowElement;
                    if (that.isFilterRowVisible()) {
                        rowElement = that._createRow().appendTo($table);
                        rowElement.addClass(DATAGRID_FILTER_ROW_CLASS).toggleClass(DATAGRID_COLUMN_LINES_CLASS, that.option('showColumnLines'));
                        for (i = 0; i < columns.length; i++)
                            that._renderFilterRowCell(rowElement, columns[i])
                    }
                },
                _updateFilterOperationChooser: function($menu, column, $editorContainer) {
                    var that = this;
                    $menu.dxMenu({
                        selectionMode: "single",
                        cssClass: 'dx-datagrid dx-widget',
                        showFirstSubmenuMode: 'onHover',
                        items: [{
                                disabled: column.filterOperations && column.filterOperations.length ? false : true,
                                icon: OPERATION_ICONS[column.selectedFilterOperation || "default"],
                                items: that._getFilterOperationMenuItems(column)
                            }],
                        onItemClick: function(properties) {
                            var selectedFilterOperation = properties.itemData.name;
                            if (properties.itemData.items)
                                return;
                            if (selectedFilterOperation)
                                that._columnsController.columnOption(column.index, 'selectedFilterOperation', selectedFilterOperation);
                            else
                                that._columnsController.columnOption(column.index, {
                                    selectedFilterOperation: column.defaultSelectedFilterOperation,
                                    filterValue: undefined
                                });
                            that._applyFilterViewController.setHighLight($editorContainer, true)
                        },
                        rtlEnabled: that.option('rtlEnabled')
                    })
                },
                _renderFilterOperationChooser: function($container, column, $editorContainer) {
                    var that = this,
                        $menu;
                    if (that.option("filterRow.showOperationChooser")) {
                        $container.addClass(DATAGRID_EDITOR_WITH_MENU_CLASS);
                        $menu = $('<div />').appendTo($container);
                        that._updateFilterOperationChooser($menu, column, $editorContainer)
                    }
                },
                _getFilterOperationMenuItems: function(column) {
                    var that = this,
                        result = [{}],
                        filterRowOptions = that.option("filterRow"),
                        operationDescriptions = filterRowOptions && filterRowOptions.operationDescriptions || {};
                    if (column.filterOperations && column.filterOperations.length) {
                        result = $.map(column.filterOperations, function(value) {
                            return {
                                    name: value,
                                    selectable: true,
                                    selected: (column.selectedFilterOperation || column.defaultFilterOperation) === value,
                                    text: operationDescriptions[value],
                                    icon: OPERATION_ICONS[value]
                                }
                        });
                        result.push({
                            name: null,
                            text: filterRowOptions && filterRowOptions.resetOperationText,
                            icon: OPERATION_ICONS['default']
                        })
                    }
                    return result
                },
                _renderFilterRowCell: function(rootElement, column) {
                    var that = this,
                        $cell = $('<td />').toggleClass(column.cssClass, !utils.isDefined(column.groupIndex)).appendTo(rootElement),
                        columnsController = that._columnsController,
                        $container,
                        $editorContainer,
                        $editor;
                    var updateFilterValue = function(that, column, value) {
                            if (value === '')
                                value = undefined;
                            if (!utils.isDefined(column.filterValue) && !utils.isDefined(value))
                                return;
                            that._applyFilterViewController.setHighLight($editorContainer, column.filterValue !== value);
                            column.filterValue = value;
                            columnsController.columnOption(column.index, 'filterValue', value)
                        };
                    if (column.command) {
                        $cell.html('&nbsp;');
                        if (column.command === "expand")
                            $cell.addClass(DATAGRID_GROUP_SPACE_CLASS)
                    }
                    else if (column.allowFiltering) {
                        $cell.addClass(DATAGRID_EDITOR_CELL_CLASS);
                        $container = $('<div />').appendTo($cell),
                        $editorContainer = $('<div />').addClass(DATAGRID_EDITOR_CONTAINER_CLASS).appendTo($container),
                        $editor = $('<div />').appendTo($editorContainer);
                        that.getController('editorFactory').createEditor($editor, $.extend({}, column, {
                            value: columnsController.isDataSourceApplied() ? column.filterValue : undefined,
                            setValue: function(value) {
                                updateFilterValue(that, column, value)
                            },
                            parentType: "filterRow",
                            showAllText: that.option('filterRow.showAllText'),
                            updateValueTimeout: that.option("filterRow.applyFilter") === "onClick" ? 0 : FILTERING_TIMEOUT,
                            width: null
                        }));
                        if (column.alignment)
                            $cell.find('input').first().css('text-align', column.alignment);
                        if (column.filterOperations && column.filterOperations.length)
                            that._renderFilterOperationChooser($container, column, $editorContainer)
                    }
                },
                optionChanged: function(args) {
                    var that = this;
                    switch (args.name) {
                        case'filterRow':
                        case'showColumnLines':
                        case'disabled':
                            that.render();
                            break;
                        default:
                            that.callBase(args);
                            break
                    }
                }
            };
        var DataControllerFilterRowExtender = {_calculateAdditionalFilter: function() {
                    var that = this,
                        filter = that.callBase(),
                        i,
                        filters = [],
                        resultFilter = [],
                        columns = that._columnsController.getVisibleColumns();
                    $.each(columns, function() {
                        var filterOptions,
                            filter;
                        if (this.allowFiltering && this.calculateFilterExpression && utils.isDefined(this.filterValue)) {
                            filter = this.calculateFilterExpression(this.filterValue, this.selectedFilterOperation || this.defaultFilterOperation);
                            if (filter)
                                filters.push(filter)
                        }
                    });
                    if (filters.length) {
                        if (filter && filter.length)
                            filters.unshift(filter);
                        for (i = 0; i < filters.length; i++) {
                            if (i > 0)
                                resultFilter.push('and');
                            resultFilter.push(filters[i])
                        }
                    }
                    else
                        resultFilter = filter;
                    return resultFilter && resultFilter.length ? resultFilter : null
                }};
        var ColumnsControllerFilterRowExtender = {_createCalculatedColumnOptions: function(columnOptions) {
                    var calculatedColumnOptions = this.callBase(columnOptions);
                    if (columnOptions.dataField)
                        $.extend(calculatedColumnOptions, {
                            calculateFilterExpression: function(value, selectedFilterOperation) {
                                var column = this,
                                    dataField = column.dataField,
                                    filter = null;
                                if (utils.isDefined(value))
                                    if (column.dataType === 'string' && !column.lookup)
                                        filter = [dataField, selectedFilterOperation || 'contains', value];
                                    else if (column.dataType === 'date') {
                                        if (utils.isDate(value)) {
                                            var dateStart = new Date(value.getFullYear(), value.getMonth(), value.getDate()),
                                                dateEnd = new Date(value.getFullYear(), value.getMonth(), value.getDate() + 1);
                                            switch (selectedFilterOperation) {
                                                case'<':
                                                    return [dataField, '<', dateStart];
                                                case'<=':
                                                    return [dataField, '<', dateEnd];
                                                case'>':
                                                    return [dataField, '>=', dateEnd];
                                                case'>=':
                                                    return [dataField, '>=', dateStart];
                                                case'<>':
                                                    return [[dataField, '<', dateStart], 'or', [dataField, '>=', dateEnd]];
                                                default:
                                                    return [[dataField, '>=', dateStart], 'and', [dataField, '<', dateEnd]]
                                            }
                                        }
                                    }
                                    else
                                        filter = [dataField, selectedFilterOperation || '=', value];
                                return filter
                            },
                            allowFiltering: true
                        });
                    else
                        $.extend(calculatedColumnOptions, {allowFiltering: !!columnOptions.calculateFilterExpression});
                    return calculatedColumnOptions
                }};
        dataGrid.ApplyFilterViewController = dataGrid.ViewController.inherit({
            _isOnClick: function() {
                return this.option("filterRow.applyFilter") === "onClick"
            },
            _getHeaderPanel: function() {
                if (!this._headerPanel)
                    this._headerPanel = this.getView("headerPanel");
                return this._headerPanel
            },
            setHighLight: function($element, value) {
                if (this._isOnClick()) {
                    $element && $element.toggleClass(DATAGRID_HIGHLIGHT_OUTLINE_CLASS, value);
                    this._getHeaderPanel().enableApplyButton(value)
                }
            },
            removeHighLights: function() {
                if (this._isOnClick()) {
                    var columnHeadersView = this.getView("columnHeadersView");
                    columnHeadersView.element().find("." + DATAGRID_FILTER_ROW_CLASS + " ." + DATAGRID_HIGHLIGHT_OUTLINE_CLASS).removeClass(DATAGRID_HIGHLIGHT_OUTLINE_CLASS);
                    this._getHeaderPanel().enableApplyButton(false)
                }
            }
        });
        dataGrid.registerModule('filterRow', {
            defaultOptions: function() {
                return {filterRow: {
                            visible: false,
                            showOperationChooser: true,
                            showAllText: Globalize.localize("dxDataGrid-filterRowShowAllText"),
                            resetOperationText: Globalize.localize("dxDataGrid-filterRowResetOperationText"),
                            applyFilter: "auto",
                            applyFilterText: Globalize.localize("dxDataGrid-applyFilterText"),
                            operationDescriptions: {
                                '=': Globalize.localize("dxDataGrid-filterRowOperationEquals"),
                                '<>': Globalize.localize("dxDataGrid-filterRowOperationNotEquals"),
                                '<': Globalize.localize("dxDataGrid-filterRowOperationLess"),
                                '<=': Globalize.localize("dxDataGrid-filterRowOperationLessOrEquals"),
                                '>': Globalize.localize("dxDataGrid-filterRowOperationGreater"),
                                '>=': Globalize.localize("dxDataGrid-filterRowOperationGreaterOrEquals"),
                                startswith: Globalize.localize("dxDataGrid-filterRowOperationStartsWith"),
                                contains: Globalize.localize("dxDataGrid-filterRowOperationContains"),
                                notcontains: Globalize.localize("dxDataGrid-filterRowOperationNotContains"),
                                endswith: Globalize.localize("dxDataGrid-filterRowOperationEndsWith")
                            }
                        }}
            },
            controllers: {applyFilter: dataGrid.ApplyFilterViewController},
            extenders: {
                controllers: {
                    data: DataControllerFilterRowExtender,
                    columns: ColumnsControllerFilterRowExtender
                },
                views: {
                    columnHeadersView: ColumnHeadersViewFilterRowExtender,
                    headerPanel: {
                        _isShowApplyFilterButton: function() {
                            var filterRowOptions = this.option("filterRow");
                            return filterRowOptions && filterRowOptions.visible && filterRowOptions.applyFilter === "onClick"
                        },
                        _renderCore: function() {
                            var that = this,
                                disabled = that._applyButton ? that._applyButton.option("disabled") : true;
                            that.callBase();
                            that._$applyButton && that._$applyButton.remove();
                            if (this._isShowApplyFilterButton()) {
                                that._$applyButton = $("<div>").addClass(DATAGRID_APPLY_BUTTON_CLASS).dxButton({
                                    disabled: disabled,
                                    hint: that.option("filterRow.applyFilterText"),
                                    icon: "apply-filter",
                                    onClick: function() {
                                        that._dataController._applyFilter();
                                        that._applyFilterViewController.removeHighLights()
                                    }
                                }).appendTo(that.element());
                                that._applyButton = that._$applyButton.dxButton("instance")
                            }
                        },
                        init: function() {
                            this.callBase();
                            this._dataController = this.getController("data");
                            this._applyFilterViewController = this.getController("applyFilter")
                        },
                        enableApplyButton: function(value) {
                            this._applyButton && this._applyButton.option("disabled", !value)
                        },
                        isVisible: function() {
                            return this.callBase() || this._isShowApplyFilterButton()
                        },
                        optionChanged: function(args) {
                            if (args.name === "filterRow")
                                this.render();
                            else
                                this.callBase(args.name)
                        }
                    }
                }
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_FILTER_ROW_CLASS: DATAGRID_FILTER_ROW_CLASS,
            DATAGRID_MENU_CLASS: DATAGRID_MENU_CLASS,
            DATAGRID_MENU_IMAGE_CLASS: DATAGRID_MENU_IMAGE_CLASS,
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_EDITOR_WITH_MENU_CLASS: DATAGRID_EDITOR_WITH_MENU_CLASS,
            DATAGRID_EDITOR_CONTAINER_CLASS: DATAGRID_EDITOR_CONTAINER_CLASS,
            DATAGRID_HIGHLIGHT_OUTLINE_CLASS: DATAGRID_HIGHLIGHT_OUTLINE_CLASS,
            DATAGRID_APPLY_BUTTON_CLASS: DATAGRID_APPLY_BUTTON_CLASS
        });
        dataGrid.ColumnHeadersViewFilterRowExtender = ColumnHeadersViewFilterRowExtender;
        dataGrid.DataControllerFilterRowExtender = DataControllerFilterRowExtender
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.headerPanel.js */
    (function($, DX) {
        var ui = DX.ui,
            events = ui.events,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_HEADER_PANEL_CLASS = "dx-datagrid-header-panel";
        dataGrid.HeaderPanel = dataGrid.ColumnsView.inherit({
            _renderCore: function() {
                this.element().addClass(DATAGRID_HEADER_PANEL_CLASS)
            },
            getHeaderPanel: function() {
                return this.element()
            },
            getHeight: function() {
                var $element = this.element();
                return $element ? $element.outerHeight(true) : 0
            },
            isVisible: function() {
                return false
            },
            optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case'disabled':
                        that.render();
                        break
                }
            }
        });
        $.extend(dataGrid.__internals, {DATAGRID_HEADER_PANEL_CLASS: DATAGRID_HEADER_PANEL_CLASS});
        dataGrid.registerModule('headerPanel', {
            defaultOptions: function() {
                return {}
            },
            views: {headerPanel: dataGrid.HeaderPanel}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.search.js */
    (function($, DX) {
        var ui = DX.ui,
            events = ui.events,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_SEARCH_PANEL_CLASS = "dx-datagrid-search-panel",
            FILTERING_TIMEOUT = 700,
            MARGIN_RIGHT = 10;
        dataGrid.registerModule('search', {
            defaultOptions: function() {
                return {searchPanel: {
                            visible: false,
                            width: 160,
                            placeholder: Globalize.localize("dxDataGrid-searchPanelPlaceholder"),
                            highlightSearchText: true,
                            text: ""
                        }}
            },
            extenders: {
                controllers: {data: function() {
                        var calculateSearchFilter = function(that, text) {
                                var i,
                                    column,
                                    columns = that._columnsController.getColumns(),
                                    filter,
                                    filterValue,
                                    lookup,
                                    searchFilter = [];
                                if (!text)
                                    return null;
                                for (i = 0; i < columns.length; i++) {
                                    filter = null;
                                    column = columns[i];
                                    if (column.allowFiltering && column.calculateFilterExpression) {
                                        lookup = column.lookup;
                                        if (lookup && lookup.items) {
                                            filterValue = column.parseValue.call(lookup, text);
                                            DX.data.query(lookup.items).filter(column.calculateFilterExpression.call({
                                                dataField: lookup.displayExpr,
                                                dataType: lookup.dataType
                                            }, filterValue)).enumerate().done(function(items) {
                                                var i,
                                                    valueGetter = DX.data.utils.compileGetter(lookup.valueExpr),
                                                    value;
                                                for (i = 0; i < items.length; i++) {
                                                    if (searchFilter.length > 0)
                                                        searchFilter.push('or');
                                                    value = valueGetter(items[i]);
                                                    searchFilter.push(column.calculateFilterExpression(value))
                                                }
                                            })
                                        }
                                        else {
                                            filterValue = column.parseValue ? column.parseValue(text) : text;
                                            if (filterValue !== undefined) {
                                                filter = column.calculateFilterExpression(filterValue);
                                                if (filter) {
                                                    if (searchFilter.length > 0)
                                                        searchFilter.push('or');
                                                    searchFilter.push(filter)
                                                }
                                            }
                                        }
                                    }
                                }
                                return searchFilter
                            };
                        return {
                                publicMethods: function() {
                                    return this.callBase().concat(['searchByText'])
                                },
                                _calculateAdditionalFilter: function() {
                                    var that = this,
                                        filter = that.callBase(),
                                        searchFilter = calculateSearchFilter(that, that.option("searchPanel.text"));
                                    if (searchFilter)
                                        if (filter)
                                            filter = [filter, 'and', searchFilter];
                                        else
                                            filter = searchFilter;
                                    return filter
                                },
                                searchByText: function(text) {
                                    this.option("searchPanel.text", text)
                                },
                                optionChanged: function(args) {
                                    var that = this;
                                    that.callBase(args);
                                    switch (args.fullName) {
                                        case"searchPanel.text":
                                        case"searchPanel":
                                            that._applyFilter();
                                            break
                                    }
                                }
                            }
                    }()},
                views: {headerPanel: function() {
                        var getSearchPanelOptions = function(that) {
                                return that.option('searchPanel')
                            };
                        return {
                                _renderSearchPanel: function() {
                                    var that = this,
                                        $element = that.element(),
                                        dataController = that.getController('data'),
                                        searchPanelOptions = getSearchPanelOptions(that);
                                    if (searchPanelOptions && searchPanelOptions.visible) {
                                        if (!that._$searchPanel)
                                            that._$searchPanel = $('<div/>').addClass(DATAGRID_SEARCH_PANEL_CLASS).prependTo($element);
                                        else
                                            that._$searchPanel.show();
                                        that.getController('editorFactory').createEditor(that._$searchPanel, {
                                            width: searchPanelOptions.width,
                                            placeholder: searchPanelOptions.placeholder,
                                            parentType: "searchPanel",
                                            value: that.option("searchPanel.text"),
                                            updateValueTimeout: FILTERING_TIMEOUT,
                                            setValue: function(value) {
                                                dataController.searchByText(value)
                                            }
                                        });
                                        that.resize()
                                    }
                                    else
                                        that._$searchPanel && that._$searchPanel.hide()
                                },
                                _renderCore: function() {
                                    this.callBase();
                                    this._renderSearchPanel()
                                },
                                focus: function() {
                                    var textBox = this._$searchPanel.dxTextBox("instance");
                                    if (textBox)
                                        textBox.focus()
                                },
                                isVisible: function() {
                                    var searchPanelOptions = getSearchPanelOptions(this);
                                    return this.callBase() || searchPanelOptions && searchPanelOptions.visible
                                },
                                optionChanged: function(args) {
                                    if (args.name === "searchPanel")
                                        this._renderSearchPanel();
                                    else
                                        this.callBase(args)
                                }
                            }
                    }()}
            }
        });
        dataGrid.__internals = $.extend({}, dataGrid.__internals, {DATAGRID_SEARCH_PANEL_CLASS: DATAGRID_SEARCH_PANEL_CLASS})
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.rowsView.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
            DATAGRID_SEARCH_TEXT_CLASS = "dx-datagrid-search-text",
            DATAGRID_ROWS_VIEW_CLASS = "dx-datagrid-rowsview",
            DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_DATA_ROW_CLASS = "dx-data-row",
            DATAGRID_FREESPACE_CLASS = "dx-freespace-row",
            DATAGRID_NODATA_TEXT_CLASS = "dx-datagrid-nodata",
            DATAGRID_GROUP_SPACE_CLASS = "dx-datagrid-group-space",
            DATAGRID_GROUP_OPENED_CLASS = "dx-datagrid-group-opened",
            DATAGRID_GROUP_CLOSED_CLASS = "dx-datagrid-group-closed",
            DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            DATAGRID_NOWRAP_CLASS = "dx-datagrid-nowrap",
            DATAGRID_ROW_LINES_CLASS = "dx-row-lines",
            DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
            DATAGRID_ROW_ALTERNATION_CLASS = "dx-row-alt",
            DATAGRID_SCROLLABLE_CONTAINER = "dx-scrollable-container",
            DATAGRID_SCROLLABLE_CONTENT = "dx-scrollable-content",
            DATAGRID_LOADPANEL_HIDE_TIMEOUT = 200;
        var appendElementTemplate = {render: function(element, container) {
                    container.append(element)
                }};
        var createScrollableOptions = function(that) {
                var useNativeScrolling = that.option("scrolling.useNativeScrolling");
                var options = {
                        direction: "both",
                        rtlEnabled: that.option("rtlEnabled") || DX.rtlEnabled,
                        disabled: that.option("disabled"),
                        bounceEnabled: false,
                        useKeyboard: false
                    };
                if (useNativeScrolling === undefined)
                    useNativeScrolling = true;
                if (useNativeScrolling !== 'auto') {
                    options.useNative = !!useNativeScrolling;
                    options.useSimulatedScrollbar = !useNativeScrolling
                }
                return options
            };
        dataGrid.createScrollableOptions = createScrollableOptions;
        dataGrid.RowsView = dataGrid.ColumnsView.inherit({
            _getDefaultTemplate: function(column) {
                var that = this;
                switch (column.command) {
                    case"expand":
                        return function(container, options) {
                                if (!utils.isDefined(options.value) || options.data && options.data.isContinuation)
                                    container.addClass(DATAGRID_GROUP_SPACE_CLASS);
                                else
                                    container.addClass(DATAGRID_GROUP_SPACE_CLASS).addClass(options.value ? DATAGRID_GROUP_OPENED_CLASS : DATAGRID_GROUP_CLOSED_CLASS).on('dxclick', that.createAction(function(e) {
                                        that._dataController.changeRowExpand(options.key);
                                        e.jQueryEvent.stopPropagation()
                                    }))
                            };
                    case"empty":
                        return function(container) {
                                container.html('&nbsp;')
                            };
                    default:
                        return function(container, options) {
                                var isDataTextEmpty = !options.text && options.rowType === "data",
                                    text = isDataTextEmpty ? "&nbsp;" : options.text;
                                if (column.encodeHtml && !isDataTextEmpty)
                                    container.text(text);
                                else
                                    container.html(text)
                            }
                }
            },
            _getDefaultGroupTemplate: function() {
                var that = this,
                    summaryTexts = that.option("summary.texts");
                return function(container, options) {
                        var data = options.data,
                            i,
                            summaryItem,
                            text = options.column.caption + ": " + options.text;
                        if (options.summaryItems && options.summaryItems.length) {
                            text += " (";
                            for (i = 0; i < options.summaryItems.length; i++) {
                                summaryItem = options.summaryItems[i];
                                text += (i > 0 ? ", " : "") + dataGrid.getSummaryText(summaryItem, summaryTexts)
                            }
                            text += ")"
                        }
                        if (data)
                            if (options.groupContinuedMessage && options.groupContinuesMessage)
                                text += ' (' + options.groupContinuedMessage + '. ' + options.groupContinuesMessage + ')';
                            else if (options.groupContinuesMessage)
                                text += ' (' + options.groupContinuesMessage + ')';
                            else if (options.groupContinuedMessage)
                                text += ' (' + options.groupContinuedMessage + ')';
                        container.css('text-align', that.option('rtlEnabled') ? 'right' : 'left').text(text)
                    }
            },
            _update: function(change){},
            _createRow: function(rowOptions) {
                var $row = this.callBase(),
                    isGroup,
                    isDataRow;
                if (rowOptions) {
                    isGroup = rowOptions.rowType === 'group';
                    isDataRow = rowOptions.rowType === 'data';
                    $row.toggleClass(DATAGRID_DATA_ROW_CLASS, isDataRow).toggleClass(DATAGRID_ROW_ALTERNATION_CLASS, isDataRow && rowOptions.dataIndex % 2 === 1 && this.option('rowAlternationEnabled')).toggleClass(DATAGRID_ROW_LINES_CLASS, isDataRow && this.option('showRowLines')).toggleClass(DATAGRID_COLUMN_LINES_CLASS, this.option('showColumnLines')).toggleClass(DATAGRID_GROUP_ROW_CLASS, isGroup)
                }
                return $row
            },
            _highlightSearchText: function(cellElement, isEquals) {
                var that = this,
                    $parent,
                    searchHTML,
                    searchText = that.option("searchPanel.text");
                if (searchText && that.option("searchPanel.highlightSearchText")) {
                    searchHTML = $('<div>').text(searchText).html();
                    $parent = cellElement.parent();
                    if (!$parent.length)
                        $parent = $('<div>').append(cellElement);
                    $.each($parent.find(":dxicontains('" + searchText + "')"), function(index, element) {
                        $.each($(element).contents(), function(index, content) {
                            if (content.nodeType !== 3)
                                return;
                            var highlightSearchTextInTextNode = function($content, searchText) {
                                    var $searchTextSpan = $('<span />').addClass(DATAGRID_SEARCH_TEXT_CLASS),
                                        text = $content.text(),
                                        index = text.toLowerCase().indexOf(searchText.toLowerCase());
                                    if (index >= 0) {
                                        if ($content[0].textContent)
                                            $content[0].textContent = text.substr(0, index);
                                        else
                                            $content[0].nodeValue = text.substr(0, index);
                                        $content.after($searchTextSpan.text(text.substr(index, searchText.length)));
                                        $content = $(document.createTextNode(text.substr(index + searchText.length))).insertAfter($searchTextSpan);
                                        return highlightSearchTextInTextNode($content, searchText)
                                    }
                                };
                            if (isEquals) {
                                if ($(content).text().toLowerCase() === searchText.toLowerCase())
                                    $(this).replaceWith($('<span />').addClass(DATAGRID_SEARCH_TEXT_CLASS).text($(content).text()))
                            }
                            else
                                highlightSearchTextInTextNode($(content), searchText)
                        })
                    })
                }
            },
            _renderTemplate: function(container, template, options) {
                var that = this,
                    renderingTemplate;
                if ($.isFunction(template))
                    renderingTemplate = {render: function(options, container) {
                            template(container, options)
                        }};
                else {
                    if (!that._templatesCache[template])
                        that._templatesCache[template] = that.getTemplate(template);
                    renderingTemplate = that._templatesCache[template]
                }
                if (renderingTemplate)
                    if (options.denyRenderToDetachedContainer || renderingTemplate.denyRenderToDetachedContainer)
                        that._delayedTemplates.push({
                            template: renderingTemplate,
                            container: container,
                            options: options
                        });
                    else {
                        renderingTemplate.render(options, container);
                        return true
                    }
                return false
            },
            _getColumnTemplate: function(options) {
                var that = this,
                    column = options.column,
                    template;
                if (options.rowType === 'group' && column.groupIndex !== undefined)
                    template = column.groupCellTemplate || that._getDefaultGroupTemplate();
                else
                    template = column.cellTemplate || that._getDefaultTemplate(column);
                return template
            },
            _updateCell: function($cell, parameters) {
                var that = this,
                    column = parameters.column,
                    isEquals = column.dataType !== "string";
                if (column.allowFiltering)
                    that._highlightSearchText($cell, isEquals);
                if (parameters.rowType === "data")
                    that._cellPrepared($cell, parameters)
            },
            _createCell: function(value, item, rowIndex, column, columnIndex) {
                var that = this,
                    template,
                    groupingOptions = that.option('grouping'),
                    scrollingMode = that.option('scrolling.mode'),
                    data = item && item.data,
                    summaryCells = item && item.summaryCells,
                    displayValue = column.lookup ? column.lookup.calculateCellValue(value) : value,
                    $cell = $('<td />').addClass(column.cssClass),
                    parameters = {
                        value: value,
                        displayValue: displayValue,
                        row: item,
                        key: item && item.key,
                        data: data,
                        rowType: item && item.rowType,
                        values: item && item.values,
                        text: dataGrid.formatValue(displayValue, column),
                        rowIndex: rowIndex,
                        columnIndex: columnIndex,
                        column: column,
                        summaryItems: summaryCells && summaryCells[columnIndex],
                        resized: column.resizedCallbacks
                    };
                if (utils.isDefined(column.groupIndex) && scrollingMode !== 'virtual' && scrollingMode !== 'infinite') {
                    parameters.groupContinuesMessage = data && data.isContinuationOnNextPage && groupingOptions && groupingOptions.groupContinuesMessage;
                    parameters.groupContinuedMessage = data && data.isContinuation && groupingOptions && groupingOptions.groupContinuedMessage
                }
                template = that._getColumnTemplate(parameters);
                if (that._renderTemplate($cell, template, parameters))
                    that._updateCell($cell, parameters);
                return $cell
            },
            _cellPrepared: function($cell, options) {
                var that = this,
                    cellPrepared,
                    alignment = options.column.alignment,
                    extendOptions = function(event) {
                        return {
                                cellElement: $(event.target).closest('td'),
                                jQueryEvent: event,
                                eventType: event.type
                            }
                    };
                if (alignment)
                    $cell[0].style.textAlign = alignment;
                if (that.option("onCellClick"))
                    $cell.on("dxclick", function(e) {
                        that.executeAction("onCellClick", $.extend({}, options, extendOptions(e)))
                    });
                if (that.option("onCellHoverChanged")) {
                    $cell.on("mouseover", function(e) {
                        that.executeAction("onCellHoverChanged", $.extend({}, options, extendOptions(e)))
                    });
                    $cell.on("mouseout", function(e) {
                        that.executeAction("onCellHoverChanged", $.extend({}, options, extendOptions(e)))
                    })
                }
                this.component._suppressDeprecatedWarnings();
                cellPrepared = that.option("cellPrepared");
                this.component._resumeDeprecatedWarnings();
                cellPrepared && cellPrepared($cell, options);
                options.cellElement = $cell;
                that.executeAction("onCellPrepared", options)
            },
            _rowPrepared: function($row, options) {
                var that = this,
                    rowPrepared;
                this.component._suppressDeprecatedWarnings();
                rowPrepared = that.option("rowPrepared");
                this.component._resumeDeprecatedWarnings();
                rowPrepared && rowPrepared($row, options);
                options.rowElement = $row;
                this.executeAction("onRowPrepared", options)
            },
            _renderScrollable: function($table) {
                var that = this,
                    $element = that.element();
                if (!utils.isDefined(that._tableElement)) {
                    that._tableElement = $table;
                    if (!$element.children().length)
                        $element.append('<div />');
                    that._renderLoadPanel($element);
                    that._renderScrollableCore($element)
                }
            },
            _handleScroll: function(e) {
                var that = this;
                that._scrollTop = e.scrollOffset.top;
                that.scrollOffsetChanged.fire(e.scrollOffset)
            },
            _renderScrollableCore: function($element) {
                var that = this,
                    dxScrollableOptions = createScrollableOptions(that),
                    scrollHandler = $.proxy(that._handleScroll, that);
                dxScrollableOptions.onScroll = scrollHandler;
                dxScrollableOptions.onStop = scrollHandler;
                $element.dxScrollable(dxScrollableOptions);
                that._scrollable = $element.data('dxScrollable');
                that._scrollableContainer = that._scrollable._$container
            },
            _renderLoadPanel: function($element) {
                var that = this,
                    loadPanelOptions;
                if ($element.dxLoadPanel) {
                    loadPanelOptions = that.option("loadPanel");
                    if (loadPanelOptions && loadPanelOptions.enabled) {
                        loadPanelOptions = $.extend({
                            shading: false,
                            message: loadPanelOptions.text,
                            position: {of: $element},
                            container: $element
                        }, loadPanelOptions);
                        if (that._loadPanel)
                            that._loadPanel.option(loadPanelOptions);
                        else
                            that._loadPanel = $('<div />').appendTo($element.parent()).dxLoadPanel(loadPanelOptions).dxLoadPanel('instance')
                    }
                    else {
                        that._loadPanel && that._loadPanel.element().remove();
                        that._loadPanel = null
                    }
                }
            },
            _renderContent: function(contentElement, tableElement) {
                return contentElement.replaceWith($('<div>').addClass(DATAGRID_CONTENT_CLASS).append(tableElement))
            },
            _updateContent: function(contentElement, change, tableElement) {
                var that = this,
                    changeType = change && change.changeType,
                    executors = [];
                switch (changeType) {
                    case'update':
                        $.each(change.rowIndices, function(index, rowIndex) {
                            var $newRowElement = that._getRowElements(tableElement).eq(index),
                                changeType = change.changeTypes[index];
                            executors.push(function() {
                                var $rowsElement = that._getRowElements(),
                                    $rowElement = $rowsElement.eq(rowIndex);
                                switch (changeType) {
                                    case'update':
                                        $rowElement.replaceWith($newRowElement);
                                        break;
                                    case'insert':
                                        if (!$rowsElement.length)
                                            $newRowElement.prependTo(that._tableElement);
                                        else if ($rowElement.length)
                                            $newRowElement.insertBefore($rowElement);
                                        else
                                            $newRowElement.insertAfter($rowsElement.last());
                                        break;
                                    case'remove':
                                        $rowElement.remove();
                                        break
                                }
                            })
                        });
                        $.each(executors, function() {
                            this()
                        });
                        break;
                    default:
                        that._tableElement = tableElement;
                        contentElement.addClass(DATAGRID_CONTENT_CLASS);
                        that._renderContent(contentElement, tableElement);
                        break
                }
            },
            _renderFreeSpaceRow: function(tableElement, columns) {
                var that = this,
                    i,
                    freeSpaceRowElement = that._createRow().hide(),
                    column;
                freeSpaceRowElement.addClass(DATAGRID_FREESPACE_CLASS).toggleClass(DATAGRID_COLUMN_LINES_CLASS, that.option('showColumnLines'));
                for (i = 0; i < columns.length; i++) {
                    column = {
                        command: columns[i].command === 'expand' ? columns[i].command : '',
                        cssClass: utils.isDefined(columns[i].cssClass) ? columns[i].cssClass : ''
                    };
                    freeSpaceRowElement.append(that._createCell(null, null, null, column))
                }
                that._appendRow(tableElement, freeSpaceRowElement)
            },
            _needUpdateRowHeight: function(itemsCount) {
                return itemsCount > 0 && !this._rowHeight
            },
            _updateRowHeight: function() {
                var that = this,
                    tableElement = that._tableElement,
                    tableHeight,
                    itemsCount = that._dataController.items().length,
                    freeSpaceRowElement;
                if (tableElement && that._needUpdateRowHeight(itemsCount)) {
                    tableHeight = tableElement.outerHeight();
                    freeSpaceRowElement = that._getFreeSpaceRowElement();
                    if (freeSpaceRowElement && freeSpaceRowElement.is(':visible'))
                        tableHeight -= freeSpaceRowElement.outerHeight();
                    that._rowHeight = tableHeight / itemsCount
                }
            },
            _findContentElement: function() {
                var $element = this.element(),
                    $scrollableContent;
                if ($element) {
                    $scrollableContent = $element.find('.dx-scrollable-content');
                    if (!$scrollableContent)
                        $scrollableContent = $element;
                    return $scrollableContent.children().first()
                }
            },
            _getRowElements: function(tableElement) {
                tableElement = tableElement || this._tableElement;
                return tableElement.children('tbody').children('.dx-row').not('.' + DATAGRID_FREESPACE_CLASS)
            },
            _getFreeSpaceRowElement: function() {
                var tableElement = this._tableElement;
                return tableElement && tableElement.children('tbody').children('.' + DATAGRID_FREESPACE_CLASS)
            },
            _appendRow: function($table, $row) {
                var that = this;
                if (that.option("rowTemplate") && that._delayedTemplates.length && $row)
                    that._delayedTemplates.push({
                        container: $table,
                        template: appendElementTemplate,
                        options: $row
                    });
                else
                    $table.append($row)
            },
            _updateNoDataText: function() {
                var noDataElement = this.element().find('.' + DATAGRID_NODATA_TEXT_CLASS),
                    isVisible = !this._dataController.items().length,
                    isLoading = this._dataController.isLoading(),
                    rtlEnabled = this.option("rtlEnabled"),
                    noDataElementCSSConfig = {};
                if (!noDataElement.length)
                    noDataElement = $('<span>').addClass(DATAGRID_NODATA_TEXT_CLASS).hide().appendTo(this.element());
                noDataElement.text(this.option("noDataText"));
                noDataElementCSSConfig = {
                    marginTop: -Math.floor(noDataElement.height() / 2),
                    marginRight: rtlEnabled ? -Math.floor(noDataElement.width() / 2) : 0,
                    marginLeft: rtlEnabled ? 0 : -Math.floor(noDataElement.width() / 2)
                };
                noDataElement.css(noDataElementCSSConfig);
                if (isVisible && !isLoading)
                    noDataElement.show();
                else
                    noDataElement.hide()
            },
            _createTable: function() {
                var that = this;
                return that.callBase().on("dxclick", '.dx-row', that.createAction(function(args) {
                        var e = args.jQueryEvent;
                        if (!$(e.target).closest('a').length) {
                            that._rowClick(that.getRowIndex(e.currentTarget), e);
                            e.preventDefault()
                        }
                    }))
            },
            _rowClick: function(rowIndex, event) {
                var item = this._dataController.items()[rowIndex] || {};
                this.executeAction("onRowClick", $.extend({
                    rowIndex: rowIndex,
                    columns: this._columnsController.getVisibleColumns(),
                    jQueryEvent: event,
                    rowElement: $(event.target).closest(".dx-row"),
                    evaluate: function(expr) {
                        var getter = DX.data.utils.compileGetter(expr);
                        return getter(item.data)
                    }
                }, item))
            },
            _renderCells: function(item, options) {
                var $groupCell,
                    $cells = [],
                    i,
                    columns = options.columns,
                    rowIndex = item.rowIndex,
                    isExpanded,
                    groupEmptyCellsCount,
                    groupColumn;
                if (item.rowType === 'group') {
                    groupEmptyCellsCount = (item.groupIndex || 0) + options.columnsCountBeforeGroups;
                    for (i = 0; i <= groupEmptyCellsCount; i++) {
                        if (i === groupEmptyCellsCount && columns[i].allowCollapsing && options.scrollingMode !== "infinite")
                            isExpanded = !!item.isExpanded;
                        else
                            isExpanded = null;
                        $cells.push(this._createCell(isExpanded, item, rowIndex, {
                            command: "expand",
                            cssClass: columns[i].cssClass
                        }))
                    }
                    groupColumn = $.extend({}, columns[groupEmptyCellsCount], {
                        command: null,
                        cssClass: null
                    });
                    $groupCell = this._createCell(item.values[item.groupIndex], item, rowIndex, groupColumn, groupEmptyCellsCount);
                    $groupCell.attr('colspan', columns.length - groupEmptyCellsCount - 1);
                    $cells.push($groupCell)
                }
                else
                    for (i = 0; i < columns.length; i++)
                        $cells.push(this._createCell(item.values[i], item, rowIndex, columns[i], i));
                return $cells
            },
            _renderTable: function(items) {
                var itemsLength = items.length,
                    item,
                    $row,
                    i,
                    $cells,
                    columnsCountBeforeGroups = 0,
                    columns = this._columnsController.getVisibleColumns(),
                    groupColumns = this._columnsController.getGroupColumns(),
                    rowTemplate = this.option("rowTemplate"),
                    scrollingMode = this.option("scrolling.mode"),
                    $table = this._createTable();
                $table.append(dataGrid.createColGroup(columns));
                for (i = 0; i < columns.length; i++)
                    if (columns[i].command === 'expand') {
                        columnsCountBeforeGroups = i;
                        break
                    }
                for (i = 0; i < itemsLength; i++) {
                    item = items[i];
                    if (!utils.isDefined(item.groupIndex) && rowTemplate)
                        this._renderTemplate($table, rowTemplate, $.extend({columns: columns}, item));
                    else {
                        $cells = this._renderCells(item, {
                            columns: columns,
                            scrollingMode: scrollingMode,
                            columnsCountBeforeGroups: columnsCountBeforeGroups,
                            groupColumns: groupColumns
                        });
                        if ($cells.length) {
                            $row = this._createRow(item);
                            $row.append($cells);
                            this._rowPrepared($row, $.extend({columns: columns}, item));
                            this._appendRow($table, $row)
                        }
                    }
                }
                if (rowTemplate)
                    this._highlightSearchText($table);
                this._renderFreeSpaceRow($table, columns);
                return $table
            },
            _renderCore: function(change) {
                var that = this,
                    items = change && change.items || that._dataController.items(),
                    $table,
                    $content,
                    $element = that.element(),
                    $root = $element.parent();
                change = change || {};
                $element.addClass(DATAGRID_ROWS_VIEW_CLASS).toggleClass(DATAGRID_NOWRAP_CLASS, !that.option("wordWrapEnabled"));
                $table = that._renderTable(items);
                that._renderScrollable($table);
                $content = that._findContentElement();
                that._updateContent($content, change, $table);
                if (!$root || $root.parent().length)
                    that.renderDelayedTemplates();
                that._lastColumnWidths = null
            },
            _getTableElements: function() {
                return this.element().find("> ." + DATAGRID_SCROLLABLE_CONTAINER + " > ." + DATAGRID_SCROLLABLE_CONTENT + "> ." + DATAGRID_CONTENT_CLASS + "> ." + DATAGRID_TABLE_CLASS)
            },
            getRowIndex: function($row) {
                return this._getRowElements().index($row)
            },
            getRow: function(index) {
                var rows = this._getRowElements();
                if (rows.length > index)
                    return $(rows[index])
            },
            getCell: function(columnIndex, rowIndex) {
                var rows = this._getRowElements(),
                    cells;
                if (rows.length > 0 && rowIndex >= 0) {
                    rowIndex = rowIndex < rows.length ? rowIndex : rows.length - 1;
                    cells = rows[rowIndex].cells;
                    if (cells && cells.length > 0)
                        return $(cells[cells.length > columnIndex ? columnIndex : cells.length - 1])
                }
            },
            updateFreeSpaceRowHeight: function() {
                var that = this,
                    elementHeight,
                    contentElement = that._findContentElement(),
                    freeSpaceRowElement = that._getFreeSpaceRowElement(),
                    contentHeight = 0,
                    freespaceRowCount,
                    scrollingMode,
                    resultHeight;
                if (freeSpaceRowElement && contentElement) {
                    freeSpaceRowElement.hide();
                    elementHeight = that.element().height();
                    contentHeight = contentElement.outerHeight();
                    resultHeight = elementHeight - contentHeight - that.getScrollbarWidth(true);
                    if (that._dataController.items().length > 0)
                        if (resultHeight > 0) {
                            freeSpaceRowElement.height(resultHeight);
                            freeSpaceRowElement.show()
                        }
                        else if (!that._hasHeight) {
                            freespaceRowCount = that._dataController.pageSize() - that._dataController.items().length;
                            scrollingMode = that.option('scrolling.mode');
                            if (freespaceRowCount > 0 && that._dataController.pageCount() > 1 && scrollingMode !== 'virtual' && scrollingMode !== 'infinite') {
                                freeSpaceRowElement.height(freespaceRowCount * that._rowHeight);
                                freeSpaceRowElement.show()
                            }
                        }
                }
            },
            _columnOptionChanged: function(e) {
                var optionNames = e.optionNames;
                if (optionNames.width || optionNames.visibleWidth) {
                    this.callBase(e);
                    this._fireColumnResizedCallbacks()
                }
            },
            callbackNames: function() {
                return ['scrollOffsetChanged']
            },
            init: function() {
                var that = this,
                    visibleColumnIndex,
                    dataController = that.getController('data');
                that.callBase();
                that._editorFactoryController = that.getController("editorFactory");
                that._editorFactoryController && that._editorFactoryController.focused.add(function($element) {
                    that._scrollable && that._scrollable.scrollToElement($element)
                });
                that._rowHeight = 0;
                that._scrollTop = 0;
                that._hasHeight = false;
                dataController.changed.add(function(change) {
                    switch (change.changeType) {
                        case'refresh':
                        case'prepend':
                        case'append':
                        case'update':
                            that.render(null, change);
                            break;
                        default:
                            that._update(change);
                            break
                    }
                });
                dataController.loadingChanged.add(function(isLoading, messageText) {
                    that.setLoading(isLoading, messageText)
                });
                that._delayedTemplates = [];
                that._templatesCache = {};
                that.createAction("onRowClick");
                that.createAction("onCellClick");
                that.createAction("onCellHoverChanged", {excludeValidators: ['disabled']});
                that.createAction("onCellPrepared", {excludeValidators: ['designMode', 'disabled']});
                that.createAction("onRowPrepared", {excludeValidators: ['designMode', 'disabled']});
                var scrollToCurrentPageHandler = function() {
                        that.scrollToPage(dataController.pageIndex())
                    };
                dataController.pageIndexChanged.add(scrollToCurrentPageHandler);
                dataController.pageSizeChanged.add(scrollToCurrentPageHandler);
                dataController.filterChanged.add(scrollToCurrentPageHandler);
                dataController.dataSourceChanged.add(scrollToCurrentPageHandler)
            },
            publicMethods: function() {
                return ['isScrollbarVisible', 'getTopVisibleRowData', 'getScrollbarWidth', 'getCellElement']
            },
            renderDelayedTemplates: function() {
                var templateParameters,
                    delayedTemplates = this._delayedTemplates;
                while (delayedTemplates.length) {
                    templateParameters = delayedTemplates.shift();
                    templateParameters.template.render(templateParameters.options, templateParameters.container);
                    if (templateParameters.options.column)
                        this._updateCell(templateParameters.container, templateParameters.options)
                }
            },
            getScrollbarWidth: function(isHorizontal) {
                var scrollableContainer = this._scrollableContainer && this._scrollableContainer.get(0),
                    scrollbarWidth = 0;
                if (scrollableContainer)
                    if (!isHorizontal)
                        scrollbarWidth = scrollableContainer.offsetWidth - scrollableContainer.clientWidth;
                    else
                        scrollbarWidth = scrollableContainer.offsetHeight - scrollableContainer.clientHeight;
                return scrollbarWidth
            },
            _fireColumnResizedCallbacks: function() {
                var that = this,
                    lastColumnWidths = that._lastColumnWidths || [],
                    columnWidths = that.getColumnWidths(),
                    columns = that._columnsController.getVisibleColumns(),
                    i;
                for (i = 0; i < columns.length; i++)
                    if (columns[i].resizedCallbacks && !utils.isDefined(columns[i].groupIndex) && lastColumnWidths[i] !== columnWidths[i])
                        columns[i].resizedCallbacks.fire(columnWidths[i]);
                that._lastColumnWidths = columnWidths
            },
            _resizeCore: function() {
                var that = this,
                    dxScrollable;
                that.callBase();
                that._fireColumnResizedCallbacks();
                that._updateRowHeight();
                that._updateNoDataText();
                that.updateFreeSpaceRowHeight();
                dxScrollable = that.element().data('dxScrollable');
                if (dxScrollable)
                    dxScrollable.update();
                that.setLoading(that._dataController.isLoading())
            },
            scrollToPage: function(pageIndex) {
                var that = this,
                    scrollingMode = that.option('scrolling.mode'),
                    dataController = that._dataController,
                    pageSize = dataController ? dataController.pageSize() : 0,
                    scrollPosition;
                if (scrollingMode === 'virtual' || scrollingMode === 'infinite')
                    scrollPosition = pageIndex * that._rowHeight * pageSize;
                else
                    scrollPosition = 0;
                that.scrollTo({
                    y: scrollPosition,
                    x: 0
                })
            },
            scrollTo: function(location) {
                var $element = this.element(),
                    dxScrollable = $element && $element.data('dxScrollable');
                if (dxScrollable)
                    dxScrollable.scrollTo(location)
            },
            height: function(height) {
                var that = this,
                    $element = this.element(),
                    freeSpaceRowElement;
                if (utils.isDefined(height)) {
                    that._hasHeight = height !== 'auto';
                    if ($element)
                        $element.height(height);
                    freeSpaceRowElement = this._getFreeSpaceRowElement();
                    freeSpaceRowElement && freeSpaceRowElement.hide()
                }
                else
                    return $element ? $element.height() : 0
            },
            setLoading: function(isLoading, messageText) {
                var that = this,
                    loadPanel = that._loadPanel,
                    dataController = that._dataController,
                    loadPanelOptions = that.option("loadPanel") || {},
                    animation = dataController.isLoaded() ? loadPanelOptions.animation : null,
                    visibilityOptions;
                if (loadPanel) {
                    visibilityOptions = {
                        message: messageText || loadPanelOptions.text,
                        animation: animation,
                        visible: isLoading
                    };
                    clearTimeout(that._hideLoadingTimeoutID);
                    if (loadPanel.option('visible') && !isLoading)
                        that._hideLoadingTimeoutID = setTimeout(function() {
                            loadPanel.option(visibilityOptions)
                        }, DATAGRID_LOADPANEL_HIDE_TIMEOUT);
                    else
                        loadPanel.option(visibilityOptions);
                    that._updateNoDataText()
                }
            },
            isScrollbarVisible: function() {
                var $element = this.element();
                return $element ? this._findContentElement().outerHeight() - $element.height() > 0 : false
            },
            setRowsOpacity: function(columnIndex, value) {
                var that = this,
                    $rows = that._getRowElements().not('.' + DATAGRID_GROUP_ROW_CLASS) || [];
                $.each($rows, function(_, row) {
                    $(row).children().eq(columnIndex).css({opacity: value})
                })
            },
            getTopVisibleItemIndex: function() {
                var that = this,
                    itemIndex = 0,
                    prevOffsetTop = 0,
                    offsetTop = 0,
                    rowElements,
                    scrollPosition = that._scrollTop,
                    contentElementOffsetTop = that._findContentElement().offset().top,
                    items = that._dataController.items();
                if (items.length && that._tableElement) {
                    rowElements = that._tableElement.children('tbody').children('.dx-row, .dx-error-row').not('.' + DATAGRID_FREESPACE_CLASS);
                    for (itemIndex = 0; itemIndex < items.length; itemIndex++) {
                        prevOffsetTop = offsetTop;
                        offsetTop = rowElements.eq(itemIndex).offset().top - contentElementOffsetTop;
                        if (offsetTop > scrollPosition) {
                            if (scrollPosition * 2 < offsetTop + prevOffsetTop && itemIndex)
                                itemIndex--;
                            break
                        }
                    }
                    if (itemIndex && itemIndex === items.length)
                        itemIndex--
                }
                return itemIndex
            },
            getTopVisibleRowData: function() {
                var itemIndex = this.getTopVisibleItemIndex(),
                    items = this._dataController.items();
                if (items[itemIndex])
                    return items[itemIndex].data
            },
            getCellElement: function(rowIndex, columnIdentificator) {
                var that = this,
                    $row = that._getRowElements().eq(rowIndex),
                    $cell,
                    columnsController = that._columnsController,
                    columnIndex,
                    columnVisibleIndex = columnIdentificator;
                if (utils.isString(columnIdentificator)) {
                    columnIndex = columnsController.columnOption(columnIdentificator, 'index');
                    columnVisibleIndex = columnsController.getVisibleIndex(columnIndex)
                }
                if ($row.length && columnVisibleIndex >= 0)
                    $cell = $row.children().eq(columnVisibleIndex);
                if ($cell && $cell.length)
                    return $cell
            },
            optionChanged: function(args) {
                var that = this;
                that.callBase(args);
                switch (args.name) {
                    case'wordWrapEnabled':
                    case'hoverStateEnabled':
                    case'showColumnLines':
                    case'showRowLines':
                    case'rowAlternationEnabled':
                    case'rowTemplate':
                    case'onCellPrepared':
                    case'onRowPrepared':
                        that.render();
                        that.component.resize();
                        break;
                    case'scrolling':
                    case'rtlEnabled':
                        that._rowHeight = null;
                        that._tableElement = null;
                        break;
                    case"disabled":
                    case'loadPanel':
                        that._tableElement = null;
                        that.render();
                        that.component.resize();
                        break;
                    case'noDataText':
                        that._updateNoDataText();
                        break;
                    case'onCellHoverChanged':
                        that.render();
                        that.component.resize();
                        break
                }
            },
            dispose: function() {
                clearTimeout(this._hideLoadingTimeoutID)
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_GROUP_ROW_CLASS: DATAGRID_GROUP_ROW_CLASS,
            DATAGRID_SEARCH_TEXT_CLASS: DATAGRID_SEARCH_TEXT_CLASS,
            DATAGRID_ROWS_VIEW_CLASS: DATAGRID_ROWS_VIEW_CLASS,
            DATAGRID_TABLE_CLASS: DATAGRID_TABLE_CLASS,
            DATAGRID_FREESPACE_CLASS: DATAGRID_FREESPACE_CLASS,
            DATAGRID_NODATA_TEXT_CLASS: DATAGRID_NODATA_TEXT_CLASS,
            DATAGRID_GROUP_SPACE_CLASS: DATAGRID_GROUP_SPACE_CLASS,
            DATAGRID_GROUP_OPENED_CLASS: DATAGRID_GROUP_OPENED_CLASS,
            DATAGRID_GROUP_CLOSED_CLASS: DATAGRID_GROUP_CLOSED_CLASS,
            DATAGRID_NOWRAP_CLASS: DATAGRID_NOWRAP_CLASS,
            DATAGRID_ROW_LINES_CLASS: DATAGRID_ROW_LINES_CLASS,
            DATAGRID_COLUMN_LINES_CLASS: DATAGRID_COLUMN_LINES_CLASS,
            DATAGRID_ROW_ALTERNATION_CLASS: DATAGRID_ROW_ALTERNATION_CLASS
        });
        dataGrid.registerModule('rows', {
            defaultOptions: function() {
                return {
                        hoverStateEnabled: false,
                        loadPanel: {
                            enabled: true,
                            text: Globalize.localize("Loading"),
                            width: 200,
                            height: 70,
                            showIndicator: true,
                            indicatorSrc: "",
                            showPane: true
                        },
                        rowTemplate: null,
                        columnAutoWidth: false,
                        noDataText: Globalize.localize("dxDataGrid-noDataText"),
                        wordWrapEnabled: false,
                        showColumnLines: true,
                        showRowLines: false,
                        rowAlternationEnabled: false,
                        activeStateEnabled: false
                    }
            },
            views: {rowsView: dataGrid.RowsView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.pager.js */
    (function($, DX) {
        var ui = DX.ui,
            events = ui.events,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_PAGER_CLASS = "dx-datagrid-pager";
        var MAX_PAGES_COUNT = 10;
        dataGrid.PagerView = dataGrid.View.inherit({
            init: function() {
                var that = this,
                    dataController = that.getController('data');
                that._isVisible = false;
                dataController.changed.add(function() {
                    that.render()
                })
            },
            _getPager: function() {
                var $element = this.element();
                return $element && $element.data('dxPager')
            },
            _renderCore: function() {
                var that = this,
                    $element = that.element().addClass(DATAGRID_PAGER_CLASS),
                    pagerOptions = that.option('pager') || {},
                    dataController = that.getController('data'),
                    rtlEnabled = that.option('rtlEnabled'),
                    options = {
                        maxPagesCount: MAX_PAGES_COUNT,
                        pageIndex: dataController.pageIndex() + 1,
                        pageCount: dataController.pageCount(),
                        pageSize: dataController.pageSize(),
                        showPageSizes: pagerOptions.showPageSizeSelector,
                        showInfo: pagerOptions.showInfo,
                        showNavigationButtons: pagerOptions.showNavigationButtons,
                        pageSizes: that.getPageSizes(),
                        rtlEnabled: rtlEnabled,
                        hasKnownLastPage: dataController.hasKnownLastPage(),
                        pageIndexChanged: function(pageIndex) {
                            setTimeout(function() {
                                dataController.pageIndex(pageIndex - 1)
                            })
                        },
                        pageSizeChanged: function(pageSize) {
                            setTimeout(function() {
                                dataController.pageSize(pageSize)
                            })
                        }
                    };
                if (utils.isDefined(pagerOptions.infoText))
                    options.infoText = pagerOptions.infoText;
                $element.dxPager(options)
            },
            getPageSizes: function() {
                var that = this,
                    dataController = that.getController('data'),
                    pagerOptions = that.option('pager'),
                    allowedPageSizes = pagerOptions && pagerOptions.allowedPageSizes,
                    pageSize = dataController.pageSize();
                if (!utils.isDefined(that._pageSizes) || $.inArray(pageSize, that._pageSizes) === -1) {
                    that._pageSizes = [];
                    if (pagerOptions)
                        if ($.isArray(allowedPageSizes))
                            that._pageSizes = allowedPageSizes;
                        else if (allowedPageSizes && pageSize > 1)
                            that._pageSizes = [Math.floor(pageSize / 2), pageSize, pageSize * 2]
                }
                return that._pageSizes
            },
            isVisible: function() {
                var that = this,
                    dataController = that.getController('data'),
                    pagerOptions = that.option('pager'),
                    pagerVisible = pagerOptions && pagerOptions.visible,
                    scrolling = that.option('scrolling');
                if (that._isVisible)
                    return true;
                if (pagerVisible === 'auto')
                    if (scrolling && (scrolling.mode === 'virtual' || scrolling.mode === 'infinite'))
                        pagerVisible = false;
                    else
                        pagerVisible = dataController.pageCount() > 1 || dataController.isLoaded() && !dataController.hasKnownLastPage();
                that._isVisible = pagerVisible;
                return pagerVisible
            },
            getHeight: function() {
                var pager = this._getPager();
                return pager && this.isVisible() ? pager.getHeight() : 0
            },
            optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case'paging':
                    case'pager':
                        that._pageSizes = null;
                    case'scrolling':
                        that._isVisible = false;
                        that.render();
                        if (args.name === 'pager')
                            that.component && that.component.resize();
                        break
                }
            }
        });
        dataGrid.registerModule('pager', {
            defaultOptions: function() {
                return {
                        paging: {
                            enabled: true,
                            pageSize: undefined,
                            pageIndex: undefined
                        },
                        pager: {
                            visible: 'auto',
                            showPageSizeSelector: false,
                            allowedPageSizes: 'auto'
                        }
                    }
            },
            views: {pagerView: dataGrid.PagerView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.gridView.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            utils = DX.utils;
        var DATAGRID_CLASS = "dx-datagrid",
            DATAGRID_HIDDEN_CLASS = "dx-hidden",
            DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_TABLE_FIXED_CLASS = "dx-datagrid-table-fixed",
            DATAGRID_BORDERS_CLASS = "dx-datagrid-borders",
            DATAGRID_COLUMN_HEADERS_HIDDEN = "dx-datagrid-headers-hidden",
            EMPTY_GRID_ROWS_HEIGHT = 100,
            LOADPANEL_MARGIN = 50,
            VIEW_NAMES = ['columnsSeparatorView', 'blockSeparatorView', 'trackerView', 'headerPanel', 'columnHeadersView', 'rowsView', 'footerView', 'columnChooserView', 'pagerView', 'draggingHeaderView', 'contextMenuView', 'errorView'];
        var mergeArraysByMaxValue = function(values1, values2) {
                var result = [],
                    i;
                if (values1 && values2 && values1.length && values1.length === values2.length)
                    for (i = 0; i < values1.length; i++)
                        result.push(values1[i] > values2[i] ? values1[i] : values2[i]);
                else if (values1)
                    result = values1;
                return result
            };
        var isPercentWidth = function(width) {
                return utils.isString(width) && width.slice(-1) === '%'
            };
        dataGrid.ResizingController = dataGrid.ViewController.inherit({
            _initPostRenderHandlers: function() {
                var that = this;
                if (!that._refreshSizesHandler) {
                    that._refreshSizesHandler = function(e) {
                        that._dataController.changed.remove(that._refreshSizesHandler);
                        if (!e || e.changeType === 'refresh' || e.changeType === 'append' || e.changeType === 'update')
                            that.resize()
                    };
                    that._dataController.changed.add(function() {
                        that._dataController.changed.add(that._refreshSizesHandler)
                    });
                    that._dataController.changed.add(function() {
                        that.component._fireContentReadyAction()
                    });
                    that._columnHeadersView.sizeChanged.add(that._refreshSizesHandler)
                }
            },
            _getBestFitWidths: function() {
                var that = this,
                    rowsColumnWidths = that._rowsView.getColumnWidths(),
                    headerColumnWidths = that._columnHeadersView && that._columnHeadersView.getColumnWidths(),
                    footerColumnWidths = that._footerView && that._footerView.getColumnWidths(),
                    resultWidths;
                resultWidths = mergeArraysByMaxValue(rowsColumnWidths, headerColumnWidths);
                resultWidths = mergeArraysByMaxValue(resultWidths, footerColumnWidths);
                return resultWidths
            },
            _setVisibleWidths: function(visibleColumns, widths) {
                var columnsController = this._columnsController;
                columnsController.beginUpdate();
                $.each(visibleColumns, function(index, column) {
                    columnsController.columnOption(column.index, 'visibleWidth', widths[index])
                });
                columnsController.endUpdate()
            },
            _toggleBestFitMode: function(isBestFit) {
                var $element = this.component.element();
                $element.find('.' + DATAGRID_TABLE_CLASS).toggleClass(DATAGRID_TABLE_FIXED_CLASS, !isBestFit);
                $element.find('input').toggleClass(DATAGRID_HIDDEN_CLASS, isBestFit)
            },
            _synchronizeColumns: function() {
                var that = this,
                    $gridViewElement = that.getView("gridView").element(),
                    columnsController = that._columnsController,
                    visibleColumns = columnsController.getVisibleColumns(),
                    contentWidth = $gridViewElement.width() - that._rowsView.getScrollbarWidth(),
                    columnAutoWidth = that.option("columnAutoWidth"),
                    needBestFit = columnAutoWidth,
                    lastWidthReseted = false,
                    resultWidths = [];
                that._setVisibleWidths(visibleColumns, []);
                $.each(visibleColumns, function(index, column) {
                    if (column.width === "auto") {
                        needBestFit = true;
                        return false
                    }
                });
                if (needBestFit) {
                    that._toggleBestFitMode(true);
                    resultWidths = that._getBestFitWidths();
                    $.each(visibleColumns, function(index, column) {
                        columnsController.columnOption(column.index, 'bestFitWidth', resultWidths[index], true)
                    })
                }
                $.each(visibleColumns, function(index) {
                    if (this.width !== 'auto')
                        if (this.width)
                            resultWidths[index] = this.width;
                        else if (!columnAutoWidth)
                            resultWidths[index] = undefined
                });
                lastWidthReseted = that._correctColumnWidths(resultWidths, visibleColumns, contentWidth);
                if (columnAutoWidth)
                    that._processStretch(resultWidths, visibleColumns, contentWidth);
                if (needBestFit)
                    that._toggleBestFitMode(false);
                if (needBestFit || lastWidthReseted)
                    that._setVisibleWidths(visibleColumns, resultWidths)
            },
            _correctColumnWidths: function(resultWidths, visibleColumns, contentWidth) {
                var that = this,
                    hasPercentWidth = false,
                    hasAutoWidth = false,
                    lastWidthReseted = false,
                    $element = that.component.element(),
                    width = that.option('width');
                $.each(visibleColumns, function(index) {
                    if (this.width !== 'auto')
                        if (this.width)
                            resultWidths[index] = this.width;
                        else
                            hasAutoWidth = true;
                    if (isPercentWidth(this.width))
                        hasPercentWidth = true
                });
                if ($element && that._maxWidth) {
                    delete that._maxWidth;
                    $element.css('max-width', '')
                }
                if (!hasAutoWidth && resultWidths.length) {
                    var totalWidth = that._getTotalWidth(resultWidths, contentWidth);
                    if (totalWidth <= contentWidth) {
                        resultWidths[resultWidths.length - 1] = 'auto';
                        lastWidthReseted = true;
                        if ((!width || width === 'auto') && !hasPercentWidth) {
                            that._maxWidth = totalWidth;
                            $element.css('max-width', that._maxWidth)
                        }
                    }
                }
                return lastWidthReseted
            },
            _processStretch: function(resultSizes, visibleColumns, groupSize) {
                var tableSize = this._getTotalWidth(resultSizes, groupSize),
                    unusedIndexes = {length: 0},
                    diff,
                    diffElement,
                    onePixelElementsCount,
                    i;
                if (!resultSizes.length)
                    return;
                $.each(visibleColumns, function(index) {
                    if (this.width) {
                        unusedIndexes[index] = true;
                        unusedIndexes.length++
                    }
                });
                diff = groupSize - tableSize;
                diffElement = Math.floor(diff / (resultSizes.length - unusedIndexes.length));
                onePixelElementsCount = diff - diffElement * (resultSizes.length - unusedIndexes.length);
                if (diff >= 0)
                    for (i = 0; i < resultSizes.length; i++) {
                        if (unusedIndexes[i])
                            continue;
                        resultSizes[i] += diffElement;
                        if (i < onePixelElementsCount)
                            resultSizes[i]++
                    }
            },
            _getTotalWidth: function(widths, groupWidth) {
                var result = 0,
                    width,
                    i;
                for (i = 0; i < widths.length; i++) {
                    width = widths[i];
                    if (width)
                        result += isPercentWidth(width) ? parseInt(width) * groupWidth / 100 : parseInt(width)
                }
                return Math.round(result)
            },
            updateHeight: function($rootElement) {
                var that = this;
                if (that._hasHeight === undefined && $rootElement)
                    that._hasHeight = !!$rootElement.height()
            },
            publicMethods: function() {
                return ["resize"]
            },
            resize: function() {
                var that = this,
                    dataController = that._dataController,
                    $rootElement = that.component.element(),
                    rootElementHeight = $rootElement && $rootElement.height(),
                    loadPanelOptions = that.option('loadPanel'),
                    height = that.option('height'),
                    rowsViewHeight,
                    $testDiv;
                that._initPostRenderHandlers();
                if (height && that._hasHeight ^ height !== 'auto') {
                    $testDiv = $('<div>').height(height).appendTo($rootElement);
                    that._hasHeight = !!$testDiv.height();
                    $testDiv.remove()
                }
                if (that._hasHeight && rootElementHeight > 0 && that.option('scrolling')) {
                    rowsViewHeight = rootElementHeight;
                    $.each(that.getViews(), function() {
                        if (this.isVisible() && this.getHeight)
                            rowsViewHeight -= this.getHeight()
                    })
                }
                else if (!that._hasHeight && dataController.items().length === 0)
                    rowsViewHeight = loadPanelOptions && loadPanelOptions.visible ? loadPanelOptions.height + LOADPANEL_MARGIN : EMPTY_GRID_ROWS_HEIGHT;
                else
                    rowsViewHeight = 'auto';
                that._rowsView.height(rowsViewHeight);
                that._columnHeadersView.setScrollerSpacing(that._rowsView.getScrollbarWidth());
                that._synchronizeColumns();
                $.each(VIEW_NAMES, function(index, viewName) {
                    var view = that.getView(viewName);
                    if (view)
                        view.resize()
                })
            },
            optionChanged: function(args) {
                switch (args.name) {
                    case"width":
                    case"height":
                        this.resize()
                }
            },
            init: function() {
                var that = this;
                that._dataController = that.getController('data');
                that._columnsController = that.getController('columns');
                that._columnHeadersView = that.getView('columnHeadersView');
                that._footerView = that.getView("footerView");
                that._rowsView = that.getView('rowsView');
                that._footerView = that.getView('footerView');
                that._rowsView.scrollOffsetChanged.add(function(e) {
                    that._columnHeadersView.scrollOffset(e.left);
                    that._footerView.scrollOffset(e.left)
                })
            }
        });
        dataGrid.GridView = dataGrid.View.inherit({
            init: function() {
                var that = this;
                that._dataController = that.getController('data');
                that._rowsView = that.getView('rowsView')
            },
            getView: function(name) {
                return this.component._views[name]
            },
            element: function() {
                return this._groupElement
            },
            optionChanged: function(args) {
                var that = this;
                that.callBase(args);
                if (utils.isDefined(that._groupElement) && args.name === "showBorders")
                    that._groupElement.toggleClass(DATAGRID_BORDERS_CLASS, !!args.value)
            },
            render: function($rootElement) {
                var that = this,
                    isFirstRender,
                    resizingController = that.getController('resizing'),
                    groupElement = that._groupElement || $('<div />').addClass(DATAGRID_CLASS).toggleClass(DATAGRID_BORDERS_CLASS, !!that.option("showBorders"));
                isFirstRender = !that._groupElement;
                that._groupElement = groupElement;
                $.each(VIEW_NAMES, function(index, viewName) {
                    var view = that.getView(viewName);
                    if (view)
                        view.render(groupElement)
                });
                if (isFirstRender) {
                    resizingController.updateHeight($rootElement);
                    groupElement.appendTo($rootElement);
                    that._rowsView.renderDelayedTemplates()
                }
                resizingController.resize();
                if (that._dataController.isLoaded())
                    that.component._fireContentReadyAction()
            }
        });
        dataGrid.registerModule("gridView", {
            defaultOptions: function() {
                showBorders:false
            },
            controllers: {resizing: dataGrid.ResizingController},
            views: {gridView: dataGrid.GridView}
        });
        $.extend(dataGrid.__internals, {
            viewNames: VIEW_NAMES,
            DATAGRID_CLASS: DATAGRID_CLASS,
            DATAGRID_COLUMN_HEADERS_HIDDEN: DATAGRID_COLUMN_HEADERS_HIDDEN,
            DATAGRID_BORDERS_CLASS: DATAGRID_BORDERS_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnsResizingReorderingModule.js */
    (function($, DX) {
        var ui = DX.ui,
            events = ui.events,
            addNamespace = events.addNamespace,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid,
            fx = DX.fx;
        var DATAGRID_COLUMNS_SEPARATOR_CLASS = "dx-datagrid-columns-separator",
            DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT = "dx-datagrid-columns-separator-transparent",
            DATAGRID_DRAGGING_HEADER_CLASS = "dx-datagrid-drag-header",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_HEADERS_DRAG_ACTION_CLASS = "dx-datagrid-drag-action",
            DATAGRID_TRACKER_CLASS = "dx-datagrid-tracker",
            DATAGRID_BLOCK_SEPARATOR_CLASS = "dx-block-separator",
            DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS = 'dx-datagrid-drop-highlight',
            DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
            DATAGRID_COLUMNS_SEPARATOR_TRACKER_CLASS = "dx-separator-tracker",
            WIDGET_CLASS = "dx-widget",
            DATAGRID_MODULE_NAMESPACE = "dxDataGridResizingReordering",
            COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH = 10,
            DRAGGING_DELTA = 5;
        var allowResizing = function(that) {
                return that.option("allowColumnResizing") || that.getController("columns").isColumnOptionUsed("allowResizing")
            };
        var allowReordering = function(that) {
                return that.option("allowColumnReordering") || that.getController("columns").isColumnOptionUsed("allowReordering")
            };
        dataGrid.getPointsByColumns = function(items, pointCreated, isVertical) {
            var cellsLength = items.length,
                cancel = false,
                i,
                point,
                item,
                offset,
                result = [],
                rtlEnabled,
                columnIndex = 0;
            for (i = 0; i <= cellsLength; i++) {
                if (i < cellsLength) {
                    item = items.eq(columnIndex);
                    offset = item.offset();
                    rtlEnabled = item.css('direction') === 'rtl'
                }
                point = {
                    index: i,
                    x: offset ? offset.left + (!isVertical && rtlEnabled ^ i === cellsLength ? item.outerWidth() : 0) : 0,
                    y: offset ? offset.top + (isVertical && i === cellsLength ? item.outerHeight() : 0) : 0,
                    columnIndex: columnIndex
                };
                if (pointCreated)
                    cancel = pointCreated(point);
                if (!cancel)
                    result.push(point);
                columnIndex++
            }
            return result
        };
        dataGrid.TrackerView = dataGrid.View.inherit({
            _renderCore: function(options) {
                this.callBase();
                this.element().addClass(DATAGRID_TRACKER_CLASS);
                this.hide()
            },
            init: function() {
                var that = this,
                    $element;
                that.callBase();
                that.getController("tablePosition").positionChanged.add(function(position) {
                    $element = that.element();
                    if ($element && $element.hasClass(DATAGRID_TRACKER_CLASS)) {
                        $element.css({top: position.top});
                        $element.height(position.height)
                    }
                })
            },
            isVisible: function() {
                return allowResizing(this)
            },
            show: function() {
                this.element().show()
            },
            hide: function() {
                this.element().hide()
            },
            setHeight: function(value) {
                this.element().height(value)
            }
        });
        dataGrid.SeparatorView = dataGrid.View.inherit({
            _renderSeparator: function(){},
            _renderCore: function(options) {
                this.callBase(options);
                this._isShown = true;
                this._renderSeparator();
                this.hide()
            },
            show: function() {
                this._isShown = true
            },
            hide: function() {
                this._isShown = false
            },
            height: function(value) {
                var $element = this.element();
                if ($element)
                    if (utils.isDefined(value))
                        $element.height(value);
                    else
                        return $element.height()
            },
            width: function(value) {
                var $element = this.element();
                if ($element)
                    if (utils.isDefined(value))
                        $element.width(value);
                    else
                        return $element.width()
            }
        });
        dataGrid.ColumnsSeparatorView = dataGrid.SeparatorView.inherit({
            _renderSeparator: function() {
                this.callBase();
                var $element = this.element();
                $element.addClass(DATAGRID_COLUMNS_SEPARATOR_CLASS);
                if (!utils.isDefined(this._tracker))
                    this._tracker = $("<div>").addClass(DATAGRID_COLUMNS_SEPARATOR_TRACKER_CLASS).appendTo($element)
            },
            _subscribeToEvent: function() {
                var that = this,
                    $element;
                that.getController("tablePosition").positionChanged.add(function(position) {
                    $element = that.element();
                    if ($element) {
                        $element.css({top: position.top});
                        $element.height(position.height)
                    }
                    that._tracker && that._tracker.height(position.headersRowHeight)
                })
            },
            isVisible: function() {
                return this.option('showColumnHeaders') && (allowReordering(this) || allowResizing(this))
            },
            init: function() {
                this.callBase();
                this._isTransparent = allowResizing(this);
                if (this.isVisible())
                    this._subscribeToEvent()
            },
            show: function() {
                var that = this,
                    $element = this.element();
                if ($element && !that._isShown)
                    if (that._isTransparent)
                        $element.removeClass(DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT);
                    else
                        $element.show();
                this.callBase()
            },
            hide: function() {
                var $element = this.element();
                if ($element && this._isShown)
                    if (this._isTransparent)
                        $element.addClass(DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT);
                    else
                        $element.hide();
                this.callBase()
            },
            tracker: function() {
                return this._tracker
            },
            moveByX: function(outerX) {
                var $element = this.element();
                if ($element) {
                    $element.css("left", outerX - this._parentElement().offset().left);
                    this._testPosx = outerX
                }
            },
            changeCursor: function(cursorName) {
                cursorName = utils.isDefined(cursorName) ? cursorName : "";
                if (this._tracker) {
                    this._tracker.css('cursor', cursorName);
                    this._testCursorName = cursorName
                }
            }
        });
        dataGrid.BlockSeparatorView = dataGrid.SeparatorView.inherit({
            _renderSeparator: function() {
                this.callBase();
                this.element().addClass(DATAGRID_BLOCK_SEPARATOR_CLASS).html('&nbsp;')
            },
            hide: function() {
                var that = this,
                    $parent = this._parentElement(),
                    $element = this.element();
                if ($element && this._isShown)
                    $element.hide();
                if ($parent && !$parent.children('.' + DATAGRID_BLOCK_SEPARATOR_CLASS).length)
                    $parent.prepend(that.element());
                that.callBase()
            },
            isVisible: function() {
                var groupPanelOptions = this.option("groupPanel"),
                    columnChooserOptions = this.option('columnChooser');
                return groupPanelOptions && groupPanelOptions.visible || columnChooserOptions && columnChooserOptions.enabled
            },
            show: function(targetLocation) {
                var that = this,
                    $element = this.element(),
                    startAnimate = function(toOptions) {
                        fx.stop($element, true);
                        fx.animate($element, {
                            type: "slide",
                            from: {
                                width: 0,
                                display: toOptions.display
                            },
                            to: toOptions,
                            duration: 300,
                            easing: "swing"
                        })
                    };
                if ($element && !that._isShown)
                    switch (targetLocation) {
                        case"group":
                            startAnimate({
                                width: "50px",
                                display: "inline-block"
                            });
                            break;
                        case"columnChooser":
                            startAnimate({
                                width: "100%",
                                display: "block"
                            });
                            break;
                        default:
                            $element.show()
                    }
                that.callBase()
            }
        });
        dataGrid.DraggingHeaderView = dataGrid.View.inherit({
            _isDragging: false,
            _getDropOptions: function() {
                var that = this;
                if (that._dragOptions)
                    return {
                            sourceColumnIndex: that._dragOptions.columnIndex,
                            sourceColumnElement: that._dragOptions.columnElement,
                            sourceLocation: that._dragOptions.sourceLocation,
                            targetColumnIndex: that._dropColumnIndex,
                            targetLocation: that._dropLocation
                        }
            },
            _dropHeader: function(args) {
                var e = args.jQueryEvent,
                    that = e.data.that,
                    controller = that._controller;
                that.element().hide();
                if (controller && that._isDragging)
                    controller.drop(that._getDropOptions());
                that.element().appendTo(that._parentElement());
                that._dragOptions = null;
                that._isDragging = false;
                document.onselectstart = that._onSelectStart || null
            },
            _getDraggingPanelByPos: function(pos) {
                var that = this,
                    result;
                $.each(that._dragOptions.draggingPanels, function(index, draggingPanel) {
                    if (draggingPanel) {
                        var boundingRect = draggingPanel.getBoundingRect();
                        if (boundingRect && (boundingRect.bottom === undefined || pos.y < boundingRect.bottom) && (boundingRect.top === undefined || pos.y > boundingRect.top) && (boundingRect.left === undefined || pos.x > boundingRect.left) && (boundingRect.right === undefined || pos.x < boundingRect.right)) {
                            result = draggingPanel;
                            return false
                        }
                    }
                });
                return result
            },
            _pointCreated: function(point, columns, location, sourceColumn) {
                var targetColumn = columns[point.columnIndex],
                    prevColumn = columns[point.columnIndex - 1];
                switch (location) {
                    case"columnChooser":
                        return true;
                    case"headers":
                        return sourceColumn && !sourceColumn.allowReordering || (!targetColumn || !targetColumn.allowReordering) && (!prevColumn || !prevColumn.allowReordering);
                    default:
                        return columns.length === 0
                }
            },
            _moveHeader: function(args) {
                var e = args.jQueryEvent,
                    that = e.data.that,
                    columnElements,
                    pointsByColumns,
                    newLeft,
                    newTop,
                    moveDeltaX,
                    moveDeltaY,
                    eventData = events.eventData(e),
                    targetDraggingPanel,
                    controller = that._controller,
                    i,
                    params,
                    dragOptions = that._dragOptions,
                    isVerticalOrientation,
                    centerPosition,
                    axisName,
                    rtlEnabled;
                if (that._isDragging) {
                    moveDeltaX = Math.abs(eventData.x - dragOptions.columnElement.offset().left - dragOptions.deltaX);
                    moveDeltaY = Math.abs(eventData.y - dragOptions.columnElement.offset().top - dragOptions.deltaY);
                    if (that.element().is(':visible') || moveDeltaX > DRAGGING_DELTA || moveDeltaY > DRAGGING_DELTA) {
                        that.element().show();
                        newLeft = eventData.x - dragOptions.deltaX;
                        newTop = eventData.y - dragOptions.deltaY;
                        that.element().offset({
                            left: newLeft,
                            top: newTop
                        });
                        targetDraggingPanel = that._getDraggingPanelByPos(eventData);
                        if (targetDraggingPanel) {
                            rtlEnabled = that.option('rtlEnabled');
                            isVerticalOrientation = targetDraggingPanel.getName() === 'columnChooser';
                            axisName = isVerticalOrientation ? 'y' : 'x';
                            columnElements = targetDraggingPanel.getColumnElements() || [];
                            pointsByColumns = dataGrid.getPointsByColumns(columnElements, function(point) {
                                return that._pointCreated(point, targetDraggingPanel.getColumns(), targetDraggingPanel.getName(), dragOptions.sourceColumn)
                            }, axisName === 'y');
                            that._dropLocation = targetDraggingPanel.getName();
                            if (pointsByColumns.length > 0)
                                for (i = 0; i < pointsByColumns.length; i++) {
                                    centerPosition = pointsByColumns[i + 1] && (pointsByColumns[i][axisName] + pointsByColumns[i + 1][axisName]) / 2;
                                    if (centerPosition === undefined || (rtlEnabled && axisName === 'x' ? eventData[axisName] > centerPosition : eventData[axisName] < centerPosition)) {
                                        that._dropColumnIndex = pointsByColumns[i].columnIndex;
                                        params = that._getDropOptions();
                                        if (columnElements[i])
                                            params.targetColumnElement = columnElements.eq(i);
                                        else {
                                            params.targetColumnElement = columnElements.last();
                                            params.isLast = true
                                        }
                                        params.posX = pointsByColumns[i].x;
                                        controller.dock(params);
                                        break
                                    }
                                }
                            else {
                                that._dropColumnIndex = -1;
                                params = that._getDropOptions();
                                controller.dock(params)
                            }
                        }
                    }
                    e.preventDefault()
                }
            },
            _subscribeToEvents: function(rootElement) {
                var that = this;
                that._moveHeaderAction = this.createAction(this._moveHeader);
                that._dropHeaderAction = this.createAction(this._dropHeader);
                $(document).on(addNamespace('dxpointermove', DATAGRID_MODULE_NAMESPACE), {
                    that: that,
                    rootElement: rootElement
                }, that._moveHeaderAction);
                that.element().on(addNamespace('dxpointerup', DATAGRID_MODULE_NAMESPACE), {that: that}, that._dropHeaderAction);
                $(document).on(addNamespace('dxpointerup', DATAGRID_MODULE_NAMESPACE), {that: that}, that._dropHeaderAction)
            },
            _renderCore: function() {
                this.element().addClass(DATAGRID_DRAGGING_HEADER_CLASS + ' ' + DATAGRID_CELL_CONTENT_CLASS + ' ' + WIDGET_CLASS).css('display', 'none')
            },
            _afterRender: function($parent) {
                this._unsubscribeFromEvents();
                this._subscribeToEvents($parent)
            },
            _unsubscribeFromEvents: function() {
                if (this._dropHeaderAction) {
                    this.element().off(addNamespace('dxpointerup', DATAGRID_MODULE_NAMESPACE), this._dropHeaderAction);
                    $(document).off(addNamespace('dxpointerup', DATAGRID_MODULE_NAMESPACE), this._dropHeaderAction)
                }
                if (this._moveHeaderAction)
                    $(document).off(addNamespace('dxpointermove', DATAGRID_MODULE_NAMESPACE), this._moveHeaderAction)
            },
            dispose: function() {
                this._dragOptions = null;
                this._unsubscribeFromEvents();
                this.element().parent().find('.' + DATAGRID_DRAGGING_HEADER_CLASS).remove()
            },
            isVisible: function() {
                var columnsController = this.getController("columns"),
                    commonColumnSettings = columnsController.getCommonSettings();
                return this.option('showColumnHeaders') && (allowReordering(this) || commonColumnSettings.allowGrouping || commonColumnSettings.allowHiding)
            },
            init: function() {
                this.callBase();
                this._controller = this.getController("draggingHeader")
            },
            drag: function(options) {
                var that = this,
                    columnElement = options.columnElement;
                that._dragOptions = options;
                that._isDragging = true;
                that._dropColumnIndex = options.columnIndex;
                that._dropLocation = options.sourceLocation;
                that._onSelectStart = document.onselectstart;
                document.onselectstart = function() {
                    return false
                };
                that.element().css({
                    textAlign: columnElement && columnElement.css('text-align'),
                    height: columnElement && columnElement.height(),
                    width: columnElement && columnElement.width(),
                    whiteSpace: columnElement && columnElement.css('white-space')
                }).addClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS).text(options.sourceColumn.caption);
                that.element().appendTo($(document.body))
            }
        });
        dataGrid.ColumnsResizerViewController = dataGrid.ViewController.inherit({
            _pointCreated: function(point, cellsLength, columns) {
                var currentColumn,
                    nextColumn;
                if (point.index > 0 && point.index < cellsLength) {
                    point.columnIndex -= 1;
                    currentColumn = columns[point.columnIndex] || {};
                    nextColumn = columns[point.columnIndex + 1] || {};
                    return !(currentColumn.allowResizing && nextColumn.allowResizing)
                }
                return true
            },
            _getTargetPoint: function(pointsByColumns, currentX, deltaX) {
                if (pointsByColumns)
                    for (var i = 0; i < pointsByColumns.length; i++)
                        if (pointsByColumns[i].x - deltaX <= currentX && currentX <= pointsByColumns[i].x + deltaX)
                            return pointsByColumns[i];
                return null
            },
            _moveSeparator: function(args) {
                var e = args.jQueryEvent,
                    that = e.data,
                    pointsByColumns = that._pointsByColumns,
                    columnsSeparatorWidth = that._columnsSeparatorView.width(),
                    columnsSeparatorOffset = that._columnsSeparatorView.element().offset(),
                    deltaX = columnsSeparatorWidth / 2,
                    parentOffsetLeft = that._$parentContainer.offset().left,
                    eventData = events.eventData(e);
                if (that._isResizing) {
                    if (parentOffsetLeft <= eventData.x && eventData.x <= parentOffsetLeft + that._$parentContainer.width())
                        if (that._updateColumnsWidthIfNeeded(that._targetPoint.columnIndex, eventData.x)) {
                            that._columnsSeparatorView.moveByX(that._targetPoint.x + (eventData.x - that._resizingInfo.startPosX));
                            that._tablePositionController.update();
                            e.preventDefault()
                        }
                }
                else {
                    that._targetPoint = that._getTargetPoint(pointsByColumns, eventData.x, columnsSeparatorWidth);
                    that._isReadyResizing = false;
                    that._columnsSeparatorView.changeCursor();
                    if (that._targetPoint && columnsSeparatorOffset.top <= eventData.y && columnsSeparatorOffset.top + that._columnsSeparatorView.height() >= eventData.y) {
                        that._columnsSeparatorView.changeCursor('col-resize');
                        that._columnsSeparatorView.moveByX(that._targetPoint.x - deltaX);
                        that._isReadyResizing = true;
                        e.preventDefault()
                    }
                }
            },
            _endResizing: function(args) {
                var e = args.jQueryEvent,
                    that = e.data;
                if (that._isResizing) {
                    that._updatePointsByColumns();
                    that._resizingInfo = null;
                    that._columnsSeparatorView.hide();
                    that._columnsSeparatorView.changeCursor();
                    that._trackerView.hide();
                    that._isReadyResizing = false;
                    that._isResizing = false
                }
            },
            _setupResizingInfo: function(posX) {
                var that = this,
                    currentHeader = that._columnHeadersView.getHeaderElement(that._targetPoint.columnIndex),
                    nextHeader = that._columnHeadersView.getHeaderElement(that._targetPoint.columnIndex + 1);
                that._resizingInfo = {
                    startPosX: posX,
                    currentColumnWidth: currentHeader && currentHeader.length > 0 ? currentHeader.outerWidth() : 0,
                    nextColumnWidth: nextHeader && nextHeader.length > 0 ? nextHeader.outerWidth() : 0
                }
            },
            _startResizing: function(args) {
                var e = args.jQueryEvent,
                    that = e.data,
                    eventData = events.eventData(e);
                if (events.isTouchEvent(e)) {
                    that._targetPoint = that._getTargetPoint(that._pointsByColumns, eventData.x, COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH);
                    if (that._targetPoint) {
                        that._columnsSeparatorView.moveByX(that._targetPoint.x - that._columnsSeparatorView.width() / 2);
                        that._isReadyResizing = true
                    }
                }
                if (that._isReadyResizing) {
                    if (that._targetPoint)
                        that._testColumnIndex = that._targetPoint.columnIndex;
                    that._setupResizingInfo(eventData.x);
                    that._columnsSeparatorView.show();
                    that._trackerView.show();
                    that._isResizing = true;
                    e.preventDefault()
                }
            },
            _generatePointsByColumns: function() {
                var that = this,
                    columns = that._columnsController ? that._columnsController.getVisibleColumns() : [],
                    cells = that._columnHeadersView.getColumnElements(),
                    pointsByColumns = [];
                if (cells && cells.length > 0)
                    pointsByColumns = dataGrid.getPointsByColumns(cells, function(point) {
                        return that._pointCreated(point, cells.length, columns)
                    });
                that._pointsByColumns = pointsByColumns
            },
            _unsubscribeFromEvents: function() {
                this._moveSeparatorHandler && this._$parentContainer.off(addNamespace('dxpointermove', DATAGRID_MODULE_NAMESPACE), this._moveSeparatorHandler);
                this._startResizingHandler && this._columnsSeparatorView.tracker().off(addNamespace('dxpointerdown', DATAGRID_MODULE_NAMESPACE), this._startResizingHandler);
                if (this._endResizingHandler) {
                    this._columnsSeparatorView.element().off(addNamespace('dxpointerup', DATAGRID_MODULE_NAMESPACE), this._endResizingHandler);
                    $(document).off(addNamespace('dxpointerup', DATAGRID_MODULE_NAMESPACE), this._endResizingHandler)
                }
            },
            _subscribeToEvents: function() {
                this._moveSeparatorHandler = this.createAction(this._moveSeparator);
                this._startResizingHandler = this.createAction(this._startResizing);
                this._endResizingHandler = this.createAction(this._endResizing);
                this._$parentContainer.on(addNamespace('dxpointermove', DATAGRID_MODULE_NAMESPACE), this, this._moveSeparatorHandler);
                this._columnsSeparatorView.tracker().on(addNamespace('dxpointerdown', DATAGRID_MODULE_NAMESPACE), this, this._startResizingHandler);
                this._columnsSeparatorView.element().on(addNamespace('dxpointerup', DATAGRID_MODULE_NAMESPACE), this, this._endResizingHandler);
                $(document).on(addNamespace('dxpointerup', DATAGRID_MODULE_NAMESPACE), this, this._endResizingHandler)
            },
            _updateColumnsWidthIfNeeded: function(columnIndex, posX) {
                var deltaX,
                    isUpdated = false,
                    nextCellWidth,
                    columnsController = this._columnsController,
                    visibleColumns = columnsController.getVisibleColumns(),
                    columnsSeparatorWidth = this._columnsSeparatorView.width(),
                    column,
                    nextColumn,
                    cellWidth;
                deltaX = posX - this._resizingInfo.startPosX;
                if (this.option("rtlEnabled"))
                    deltaX = -deltaX;
                cellWidth = this._resizingInfo.currentColumnWidth + deltaX;
                nextCellWidth = this._resizingInfo.nextColumnWidth - deltaX;
                isUpdated = !(cellWidth <= columnsSeparatorWidth || nextCellWidth <= columnsSeparatorWidth);
                if (isUpdated) {
                    column = visibleColumns[columnIndex];
                    nextColumn = visibleColumns[columnIndex + 1];
                    columnsController.beginUpdate();
                    column && columnsController.columnOption(column.index, 'visibleWidth', undefined);
                    nextColumn && columnsController.columnOption(nextColumn.index, 'visibleWidth', undefined);
                    column && columnsController.columnOption(column.index, 'width', Math.floor(cellWidth));
                    nextColumn && columnsController.columnOption(nextColumn.index, 'width', Math.floor(nextCellWidth));
                    columnsController.endUpdate()
                }
                return isUpdated
            },
            _updatePointsByColumns: function() {
                var i,
                    point,
                    rtlEnabled = this.option("rtlEnabled"),
                    headerElement;
                for (i = 0; i < this._pointsByColumns.length; i++) {
                    point = this._pointsByColumns[i];
                    headerElement = this._columnHeadersView.getHeaderElement(point.columnIndex + 1);
                    if (headerElement && headerElement.length > 0)
                        point.x = headerElement.offset().left + (rtlEnabled ? headerElement.outerWidth() : 0)
                }
            },
            init: function() {
                var that = this,
                    gridView,
                    previousScrollbarVisibility,
                    generatePointsByColumnsScrollHandler = function(offset) {
                        if (that._scrollLeft !== offset.left) {
                            that._scrollLeft = offset.left;
                            that._generatePointsByColumns()
                        }
                    },
                    generatePointsByColumnsHandler = function() {
                        that._generatePointsByColumns()
                    };
                that.callBase();
                if (allowResizing(that)) {
                    that._columnsSeparatorView = that.getView("columnsSeparatorView");
                    that._columnHeadersView = that.getView("columnHeadersView");
                    that._trackerView = that.getView("trackerView");
                    that._rowsView = that.getView("rowsView");
                    that._columnsController = that.getController("columns");
                    that._tablePositionController = that.getController("tablePosition");
                    that._$parentContainer = that._columnsSeparatorView.component.element();
                    that._columnHeadersView.renderCompleted.add(generatePointsByColumnsHandler);
                    that._columnHeadersView.resizeCompleted.add(generatePointsByColumnsHandler);
                    that._columnsSeparatorView.renderCompleted.add(function() {
                        that._unsubscribeFromEvents();
                        that._subscribeToEvents()
                    });
                    that._rowsView.renderCompleted.add(function() {
                        that._rowsView.scrollOffsetChanged.remove(generatePointsByColumnsScrollHandler);
                        that._rowsView.scrollOffsetChanged.add(generatePointsByColumnsScrollHandler)
                    });
                    gridView = that.getView("gridView");
                    previousScrollbarVisibility = that._rowsView.getScrollbarWidth() !== 0;
                    that.getController("tablePosition").positionChanged.add(function() {
                        if (that._isResizing && !that._rowsView.isResizing) {
                            var scrollbarVisibility = that._rowsView.getScrollbarWidth() !== 0;
                            if (previousScrollbarVisibility !== scrollbarVisibility) {
                                previousScrollbarVisibility = scrollbarVisibility;
                                gridView.resize()
                            }
                            else {
                                that._rowsView.updateFreeSpaceRowHeight();
                                that._columnHeadersView.processSizeChanged()
                            }
                        }
                    })
                }
            },
            dispose: function() {
                this._unsubscribeFromEvents()
            }
        });
        dataGrid.TablePositionViewController = dataGrid.ViewController.inherit({
            update: function() {
                var $element = this._columnHeadersView.element(),
                    columnsHeadersHeight = this._columnHeadersView ? this._columnHeadersView.getHeight() : 0,
                    rowsHeight = this._rowsView ? this._rowsView.height() - this._rowsView.getScrollbarWidth(true) : 0;
                this.positionChanged.fire({
                    height: columnsHeadersHeight + rowsHeight,
                    headersRowHeight: this._columnHeadersView ? this._columnHeadersView.getHeadersRowHeight() : 0,
                    top: $element && $element.length > 0 ? Math.floor($element[0].offsetTop) : 0
                })
            },
            init: function() {
                var that = this;
                that.callBase();
                that._columnHeadersView = this.getView("columnHeadersView");
                that._rowsView = this.getView("rowsView");
                that._pagerView = this.getView("pagerView");
                that._rowsView.resizeCompleted.add(function() {
                    that.update()
                })
            },
            ctor: function(component) {
                this.callBase(component);
                this.positionChanged = $.Callbacks()
            }
        });
        dataGrid.DraggingHeaderViewController = dataGrid.ViewController.inherit({
            _subscribeToEvent: function(draggingHeader, draggingPanels) {
                var that = this;
                $.each(draggingPanels, function(_, draggingPanel) {
                    if (draggingPanel) {
                        var columnElements = draggingPanel.getColumnElements() || [],
                            nameDraggingPanel = draggingPanel.getName(),
                            columns = draggingPanel.getColumns() || [];
                        $.each(columnElements, function(index, columnElement) {
                            $(columnElement).off(addNamespace('dxpointerdown', DATAGRID_MODULE_NAMESPACE));
                            $(columnElement).removeClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS);
                            if (draggingPanel.allowDragging(columns[index], draggingPanels)) {
                                $(columnElement).addClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS);
                                $(columnElement).on(addNamespace('dxpointerdown', DATAGRID_MODULE_NAMESPACE), that.createAction(function(args) {
                                    var e = args.jQueryEvent,
                                        eventData = events.eventData(e);
                                    e.preventDefault();
                                    draggingHeader.drag({
                                        deltaX: eventData.x - $(e.currentTarget).offset().left,
                                        deltaY: eventData.y - $(e.currentTarget).offset().top,
                                        sourceColumn: columns[index],
                                        columnIndex: index,
                                        columnElement: $(columnElement),
                                        sourceLocation: draggingPanel.getName(),
                                        draggingPanels: draggingPanels
                                    })
                                }))
                            }
                        })
                    }
                })
            },
            _getSeparator: function(targetLocation) {
                return targetLocation === "headers" ? this._columnsSeparatorView : this._blockSeparatorView
            },
            hideSeparators: function() {
                var blockSeparator = this._blockSeparatorView,
                    columnsSeparator = this._columnsSeparatorView;
                this._animationColumnIndex = null;
                blockSeparator && blockSeparator.hide();
                columnsSeparator && columnsSeparator.hide()
            },
            init: function() {
                var that = this,
                    subscribeToEvent;
                that.callBase();
                that._columnsController = that.getController("columns");
                that._columnHeadersView = that.getView("columnHeadersView");
                that._columnsSeparatorView = that.getView("columnsSeparatorView");
                that._draggingHeaderView = that.getView("draggingHeaderView");
                that._rowsView = that.getView('rowsView');
                that._blockSeparatorView = that.getView("blockSeparatorView");
                that._headerPanelView = that.getView("headerPanel");
                that._columnChooserView = that.getView("columnChooserView");
                subscribeToEvent = function() {
                    if (that._draggingHeaderView)
                        that._subscribeToEvent(that._draggingHeaderView, [that._columnChooserView, that._columnHeadersView, that._headerPanelView])
                };
                that._columnHeadersView.renderCompleted.add(subscribeToEvent);
                that._headerPanelView.renderCompleted.add(subscribeToEvent);
                that._columnChooserView && that._columnChooserView.renderCompleted.add(subscribeToEvent)
            },
            allowDrop: function(parameters) {
                return this._columnsController.allowMoveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation)
            },
            allowDragColumn: function(columns, index, namePanel) {
                var column = columns[index],
                    i,
                    draggableColumnCount = 0;
                var allowDragFromHeaders = function(column) {
                        return column.allowReordering || column.allowGrouping || column.allowHiding
                    };
                if (!column)
                    return false;
                switch (namePanel) {
                    case"headers":
                        for (i = 0; i < columns.length; i++)
                            if (allowDragFromHeaders(columns[i]))
                                draggableColumnCount++;
                        return draggableColumnCount > 1 && allowDragFromHeaders(column);
                    case"group":
                        return column.allowGrouping;
                    case"columnChooser":
                        return column.allowHiding
                }
            },
            dock: function(parameters) {
                var that = this,
                    targetColumnIndex = parameters.targetColumnIndex,
                    sourceLocation = parameters.sourceLocation,
                    sourceColumnIndex = parameters.sourceColumnIndex,
                    sourceColumnElement = parameters.sourceColumnElement,
                    targetLocation = parameters.targetLocation,
                    separator = that._getSeparator(targetLocation),
                    hasTargetColumnIndex = targetColumnIndex >= 0;
                var showSeparator = function() {
                        if (that._animationColumnIndex !== targetColumnIndex) {
                            that.hideSeparators();
                            separator.element()[parameters.isLast ? 'insertAfter' : 'insertBefore'](parameters.targetColumnElement);
                            that._animationColumnIndex = targetColumnIndex;
                            separator.show(targetLocation)
                        }
                    };
                that._columnHeadersView.element().find('.' + DATAGRID_HEADER_ROW_CLASS).first().toggleClass(DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS, sourceLocation !== 'headers' && targetLocation === 'headers' && !hasTargetColumnIndex);
                if (separator) {
                    if (sourceColumnElement) {
                        sourceColumnElement.css({opacity: 0.5});
                        if (sourceLocation === 'headers')
                            that._rowsView.setRowsOpacity(sourceColumnIndex, 0.5)
                    }
                    if (that.allowDrop(parameters) && hasTargetColumnIndex)
                        if (targetLocation === 'group' || targetLocation === 'columnChooser')
                            showSeparator();
                        else {
                            that.hideSeparators();
                            separator.moveByX(parameters.posX - separator.width());
                            separator.show()
                        }
                    else
                        that.hideSeparators()
                }
            },
            drop: function(parameters) {
                var sourceColumnElement = parameters.sourceColumnElement;
                if (sourceColumnElement) {
                    sourceColumnElement.css({opacity: ''});
                    this._rowsView.setRowsOpacity(parameters.sourceColumnIndex, '');
                    this._columnHeadersView.element().find('.' + DATAGRID_HEADER_ROW_CLASS).first().removeClass(DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS)
                }
                if (this.allowDrop(parameters)) {
                    var separator = this._getSeparator(parameters.targetLocation);
                    if (separator)
                        separator.hide();
                    this._columnsController.moveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation)
                }
            }
        });
        dataGrid.__internals = $.extend({}, dataGrid.__internals, {
            DATAGRID_COLUMNS_SEPARATOR_CLASS: DATAGRID_COLUMNS_SEPARATOR_CLASS,
            DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT: DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT,
            DATAGRID_DRAGGING_HEADER_CLASS: DATAGRID_DRAGGING_HEADER_CLASS,
            DATAGRID_HEADERS_DRAG_ACTION_CLASS: DATAGRID_HEADERS_DRAG_ACTION_CLASS,
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_TRACKER_CLASS: DATAGRID_TRACKER_CLASS,
            DATAGRID_MODULE_NAMESPACE: DATAGRID_MODULE_NAMESPACE,
            DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS: DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS,
            WIDGET_CLASS: WIDGET_CLASS
        });
        dataGrid.registerModule("columnsResizingReordering", {
            views: {
                columnsSeparatorView: dataGrid.ColumnsSeparatorView,
                blockSeparatorView: dataGrid.BlockSeparatorView,
                draggingHeaderView: dataGrid.DraggingHeaderView,
                trackerView: dataGrid.TrackerView
            },
            controllers: {
                draggingHeader: dataGrid.DraggingHeaderViewController,
                tablePosition: dataGrid.TablePositionViewController,
                columnsResizer: dataGrid.ColumnsResizerViewController
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.contextMenuView.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_CLASS = "dx-datagrid",
            DATAGRID_CONTEXT_MENU = "dx-context-menu";
        dataGrid.ContextMenuController = dataGrid.ViewController.inherit({getContextMenuItems: function($targetElement) {
                var menuItems;
                $.each(this.getViews(), function() {
                    if (this.getContextMenuItems) {
                        menuItems = this.getContextMenuItems($targetElement);
                        if (menuItems)
                            return false
                    }
                });
                return menuItems
            }});
        dataGrid.ContextMenuView = dataGrid.View.inherit({
            viewNames: function() {
                return ["columnHeadersView"]
            },
            _renderCore: function() {
                var that = this;
                that.element().addClass(DATAGRID_CONTEXT_MENU).dxContextMenu({
                    onPositioning: function(actionArgs) {
                        var event = actionArgs.jQueryEvent,
                            $targetElement = $(event.target),
                            contextMenuInstance = actionArgs.component,
                            items = items = that.getController('contextMenu').getContextMenuItems($targetElement);
                        if (items)
                            contextMenuInstance.option('items', items);
                        else
                            actionArgs.canceled = true
                    },
                    onItemClick: function(params) {
                        params.itemData.onItemClick && params.itemData.onItemClick(params)
                    },
                    rtlEnabled: that.option('rtlEnabled'),
                    cssClass: DATAGRID_CLASS,
                    target: that.component.element()
                })
            }
        });
        dataGrid.registerModule("contextMenu", {
            controllers: {contextMenu: dataGrid.ContextMenuController},
            views: {contextMenuView: dataGrid.ContextMenuView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.keyboardNavigation.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
            DATAGRID_ROWS_VIEW_CLASS = "dx-datagrid-rowsview",
            DATAGRID_MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row",
            DATAGRID_GROUP_FOOTER_CLASS = "dx-datagrid-group-footer",
            DATAGRID_COMMAND_EXPAND_CLASS = "dx-command-expand",
            DATAGRID_VIEWS = ["rowsView"],
            DATAGRID_EDIT_MODE_ROW = "row";
        dataGrid.KeyboardNavigationController = dataGrid.ViewController.inherit({
            _focusView: function(view, viewIndex) {
                this._focusedViews.viewIndex = viewIndex;
                this._focusedView = view
            },
            _initFocusedViews: function() {
                var that = this,
                    $cell,
                    $input,
                    clickHandler = that.createAction(function(e) {
                        var event = e.jQueryEvent,
                            $cell = $(event.currentTarget);
                        if (!that._editingController.isEditing())
                            if (that._isCellValid($cell)) {
                                $cell.focus();
                                that._focusView(event.data.view, event.data.viewIndex);
                                that._updateFocusedCellPosition($cell)
                            }
                            else
                                that._resetFocusedCell(that)
                    });
                that._focusedViews = [];
                $.each(DATAGRID_VIEWS, function(key, viewName) {
                    var view = that.getView(viewName);
                    if (view.isVisible())
                        that._focusedViews.push(view)
                });
                $.each(that._focusedViews, function(index, view) {
                    if (view)
                        view.renderCompleted.add(function() {
                            var $element = view.element();
                            $element.off(events.addNamespace("dxpointerdown", "dxDataGridKeyboardNavigation"), clickHandler);
                            $element.on(events.addNamespace("dxpointerdown", "dxDataGridKeyboardNavigation"), "." + DATAGRID_ROW_CLASS + " td", {
                                viewIndex: index,
                                view: view
                            }, clickHandler);
                            that._initKeyDownProcessor(that, $element, that._keyDownHandler);
                            if (that._focusedView && that._focusedView.name === view.name && that._isKeyDown) {
                                $cell = that._getFocusedCell();
                                if ($cell && $cell.length > 0) {
                                    that._focusView(view, index);
                                    setTimeout(function() {
                                        if (that._editingController.isEditing()) {
                                            $input = $cell.find('input').first();
                                            that._testFocusedInput = $input;
                                            $input.focus()
                                        }
                                        else {
                                            var $row = $cell.parent(),
                                                $focusElement = that._isGroupRow($row) ? $row : $cell;
                                            $focusElement.attr("tabindex", 0);
                                            $focusElement.focus()
                                        }
                                        if (that.getController('editorFactory').focus())
                                            that._focus($cell)
                                    })
                                }
                            }
                        })
                })
            },
            _initKeyDownProcessor: function(context, element, handler) {
                if (this._keyDownProcessor) {
                    this._keyDownProcessor.dispose();
                    this._keyDownProcessor = null
                }
                this._keyDownProcessor = new ui.KeyboardProcessor({
                    element: element,
                    context: context,
                    handler: handler
                })
            },
            _focusCell: function($cell) {
                var that = this;
                if ($cell) {
                    that.getController('editorFactory').focus($cell);
                    that._updateFocusedCellPosition($cell)
                }
            },
            _focusGroupRow: function($row) {
                if ($row) {
                    this.getController('editorFactory').focus($row);
                    this._focusedCellPosition.rowIndex = this._focusedView.getRowIndex($row)
                }
            },
            _getFocusedCell: function() {
                if (this._focusedView && this._focusedCellPosition)
                    return this._focusedView.getCell(this._focusedCellPosition.columnIndex, this._focusedCellPosition.rowIndex)
            },
            _updateFocusedCellPosition: function($cell) {
                var that = this;
                if ($cell.length > 0)
                    this._focusedCellPosition = {
                        columnIndex: $cell[0].cellIndex,
                        rowIndex: $cell.parent().length > 0 && that._focusedView ? that._focusedView.getRowIndex($cell.parent()) : null
                    }
            },
            _isCellValid: function($cell) {
                var visibleColumns = this._columnsController.getVisibleColumns(),
                    columnIndex = $cell[0].cellIndex;
                if (visibleColumns.length > columnIndex && !utils.isDefined(visibleColumns[columnIndex].groupIndex))
                    return !utils.isDefined(visibleColumns[columnIndex].command) || visibleColumns[columnIndex].command === "expand"
            },
            _isGroupRow: function($row) {
                return $row && $row.hasClass(DATAGRID_GROUP_ROW_CLASS)
            },
            _focus: function($cell) {
                var $row = $cell && $cell.parent();
                if (this._isGroupRow($row))
                    this._focusGroupRow($row);
                else
                    this._focusCell($cell)
            },
            _hasSkipRow: function($row) {
                return $row && ($row.hasClass(DATAGRID_MASTER_DETAIL_ROW_CLASS) || $row.hasClass(DATAGRID_GROUP_FOOTER_CLASS))
            },
            _keyDownHandler: function(e) {
                var editingOptions = this.option("editing"),
                    scrollingMode = this.option("scrolling.mode"),
                    isVirtualScrolling = scrollingMode === "virtual" || scrollingMode === "infinite",
                    isEditing = this._editingController.isEditing(),
                    pageIndex = this._dataController.pageIndex(),
                    pageCount = this._dataController.pageCount(),
                    rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null,
                    $row = this._focusedView && this._focusedView.getRow(rowIndex),
                    $cell;
                this._isKeyDown = true;
                switch (e.key) {
                    case"leftArrow":
                    case"rightArrow":
                        if (!isEditing && !this._isGroupRow($row)) {
                            $cell = this._getNextCell(e.key);
                            if ($cell && this._isCellValid($cell))
                                this._focusCell($cell);
                            e.originalEvent.preventDefault()
                        }
                        break;
                    case"upArrow":
                    case"downArrow":
                        if (!isEditing) {
                            if (rowIndex === 0 || this._focusedView && rowIndex === this._focusedView.getRowsCount() - 1);
                            $cell = this._getNextCell(e.key);
                            if ($cell) {
                                $row = $cell.parent();
                                while (this._hasSkipRow($row) && this._focusedCellPosition) {
                                    rowIndex = this._focusedView.getRowIndex($row);
                                    if (!this._isLastRow(rowIndex)) {
                                        $cell = this._getNextCell(e.key, $.extend({}, this._focusedCellPosition, {rowIndex: rowIndex}));
                                        $row = $cell.parent()
                                    }
                                    else {
                                        $cell = null;
                                        break
                                    }
                                }
                                if ($cell && this._isCellValid($cell))
                                    this._focus($cell)
                            }
                            e.originalEvent.preventDefault()
                        }
                        break;
                    case"pageUp":
                        if (pageIndex > 0 && !isVirtualScrolling) {
                            this._dataController.pageIndex(pageIndex - 1);
                            e.originalEvent.preventDefault()
                        }
                        break;
                    case"pageDown":
                        if (pageIndex < pageCount - 1 && !isVirtualScrolling) {
                            this._dataController.pageIndex(pageIndex + 1);
                            e.originalEvent.preventDefault()
                        }
                        break;
                    case"space":
                        if (this.option("selection") && this.option("selection").mode !== "none" && !isEditing)
                            this._selectionController.changeItemSelection(rowIndex, {
                                shift: e.shift,
                                control: e.ctrl
                            });
                        break;
                    case"A":
                        if (e.ctrl && this.option("selection.mode") === "multiple" && this.option("selection.allowSelectAll")) {
                            this._selectionController.selectAll();
                            e.originalEvent.preventDefault()
                        }
                        break;
                    case"tab":
                        if (isEditing && this._editingController.getEditMode() !== DATAGRID_EDIT_MODE_ROW && e.originalEvent.target) {
                            this._updateFocusedCellPosition($(e.originalEvent.target).closest('td'));
                            $cell = this._getNextCell("rightArrow");
                            if (this._isCellValid($cell)) {
                                this._focusCell($cell);
                                this._editingController.editCell(this._focusedCellPosition.rowIndex, this._focusedCellPosition.columnIndex)
                            }
                            e.originalEvent.preventDefault()
                        }
                        break;
                    case"enter":
                        $cell = this._getFocusedCell();
                        if (this.option("grouping.allowCollapsing") && this._isGroupRow($row) || this.option("masterDetail.enabled") && $cell.hasClass(DATAGRID_COMMAND_EXPAND_CLASS)) {
                            var key = this._dataController.getKeyByRowIndex(rowIndex);
                            if (key !== undefined)
                                this._dataController.changeRowExpand(key)
                        }
                        else {
                            var isRowEditMode = this._editingController.getEditMode() === DATAGRID_EDIT_MODE_ROW;
                            if (editingOptions.editEnabled)
                                if (isEditing) {
                                    this._updateFocusedCellPosition($(e.originalEvent.target).closest('td'));
                                    if (isRowEditMode)
                                        setTimeout($.proxy(this._editingController.saveEditData, this._editingController));
                                    else
                                        this._editingController.closeEditCell()
                                }
                                else if (isRowEditMode)
                                    this._editingController.editRow(rowIndex);
                                else
                                    this._focusedCellPosition && this._editingController.editCell(rowIndex, this._focusedCellPosition.columnIndex)
                        }
                        break;
                    case"escape":
                        if (editingOptions.editEnabled)
                            if (isEditing) {
                                this._updateFocusedCellPosition($(e.originalEvent.target).closest('td'));
                                if (this._editingController.getEditMode() !== DATAGRID_EDIT_MODE_ROW)
                                    this._editingController.closeEditCell();
                                else
                                    this._editingController.cancelEditData();
                                e.originalEvent.preventDefault()
                            }
                        break;
                    case"F":
                        if (e.ctrl && this.option("searchPanel") && this.option("searchPanel").visible) {
                            this._testHeaderPanelFocused = true;
                            this._headerPanel.focus();
                            e.originalEvent.preventDefault()
                        }
                        break
                }
                e.originalEvent.stopPropagation()
            },
            _isLastRow: function(rowIndex) {
                return rowIndex === this._dataController.items().length - 1
            },
            _getNextCell: function(keyCode, cellPosition) {
                var focusedCellPosition = cellPosition || this._focusedCellPosition,
                    columnIndex = focusedCellPosition.columnIndex,
                    rowIndex = focusedCellPosition.rowIndex,
                    visibleColumnsCount;
                if (this._focusedView && focusedCellPosition) {
                    visibleColumnsCount = this.getController("columns").getVisibleColumns().length;
                    switch (keyCode) {
                        case"rightArrow":
                            columnIndex = columnIndex < visibleColumnsCount - 1 ? columnIndex + 1 : columnIndex;
                            break;
                        case"leftArrow":
                            columnIndex = columnIndex > 0 ? columnIndex - 1 : columnIndex;
                            break;
                        case"upArrow":
                            rowIndex = rowIndex > 0 ? rowIndex - 1 : rowIndex;
                            break;
                        case"downArrow":
                            rowIndex = !this._isLastRow(rowIndex) ? rowIndex + 1 : rowIndex;
                            break
                    }
                    return this._focusedView.getCell(columnIndex, rowIndex)
                }
                return null
            },
            _resetFocusedCell: function(that) {
                var $cell = that._getFocusedCell();
                $cell && $cell.attr("tabindex", null);
                that._focusedCellPosition = null;
                that._isKeyDown = false
            },
            init: function() {
                var that = this;
                if (that.option("useKeyboard")) {
                    that._dataController = that.getController("data");
                    that._selectionController = that.getController("selection");
                    that._editingController = that.getController("editing");
                    that._headerPanel = that.getView("headerPanel");
                    that._pagerView = that.getView("pagerView");
                    that._columnsController = that.getController("columns");
                    that._focusedCellPosition = {
                        columnIndex: 0,
                        rowIndex: 0
                    };
                    that._dataController.changed.add(function(change) {
                        if (that._focusedCellPosition && change && change.changeType === 'prepend')
                            that._focusedCellPosition.rowIndex += change.items.length
                    });
                    that._initFocusedViews();
                    that._documentClickHandler = that.createAction(function(e) {
                        if (!$(e.jQueryEvent.target).closest("." + DATAGRID_ROWS_VIEW_CLASS).length)
                            that._resetFocusedCell(that)
                    });
                    $(document).on(events.addNamespace("dxpointerdown", "dxDataGridKeyboardNavigation"), that._documentClickHandler)
                }
            },
            dispose: function() {
                this.callBase();
                this._focusedView = null;
                this._focusedViews = null;
                this._keyDownProcessor && this._keyDownProcessor.dispose();
                $(document).off(events.addNamespace("dxpointerdown", "dxDataGridKeyboardNavigation"), this._documentClickHandler)
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_GROUP_ROW_CLASS: DATAGRID_GROUP_ROW_CLASS,
            DATAGRID_ROW_CLASS: DATAGRID_ROW_CLASS
        });
        dataGrid.registerModule("keyboardNavigation", {
            defaultOptions: function() {
                return {useKeyboard: true}
            },
            controllers: {keyboardNavigation: dataGrid.KeyboardNavigationController},
            extenders: {views: {rowsView: {_renderCore: function(change) {
                            this.callBase(change);
                            this.element().attr("tabindex", this.option("useKeyboard") ? 0 : null)
                        }}}}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.errorHandling.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_ERROR_ROW_CLASS = "dx-error-row",
            DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_DATA_ROW_CLASS = "dx-data-row",
            DATAGRID_ERROR_CLOSEBUTTON_CLASS = "dx-closebutton",
            DATAGRID_ACTION_CLASS = "dx-datagrid-action";
        dataGrid.ErrorHandlingController = dataGrid.ViewController.inherit({
            init: function() {
                var that = this;
                that._columnHeadersView = that.getView("columnHeadersView");
                that._rowsView = that.getView("rowsView")
            },
            renderErrorRow: function(message, rowIndex) {
                var that = this,
                    viewElement = rowIndex >= 0 ? that._rowsView : that._columnHeadersView,
                    $tableElement = viewElement.tableElement(),
                    $errorRow = $("<tr />").addClass(DATAGRID_ERROR_ROW_CLASS),
                    $row = $tableElement.find("." + DATAGRID_DATA_ROW_CLASS).eq(rowIndex),
                    $closeButton = $("<div/>").addClass(DATAGRID_ERROR_CLOSEBUTTON_CLASS).addClass(DATAGRID_ACTION_CLASS);
                if (rowIndex >= 0) {
                    that.removeErrorRow($tableElement.find("tr").eq($row.index() + 1));
                    $errorRow.insertAfter($row)
                }
                else {
                    that.removeErrorRow($tableElement.find("tr").last());
                    $tableElement.append($errorRow)
                }
                $closeButton.on("dxclick", that.createAction(function(args) {
                    var e = args.jQueryEvent,
                        $currentErrorRow = $(e.currentTarget).closest("." + DATAGRID_ERROR_ROW_CLASS);
                    e.stopPropagation();
                    that.removeErrorRow($currentErrorRow)
                }));
                $("<td/>").attr("colspan", that._columnHeadersView.getHeadersLength()).text(message).append($closeButton).appendTo($errorRow)
            },
            removeErrorRow: function($row) {
                $row.hasClass(DATAGRID_ERROR_ROW_CLASS) && $row.remove()
            }
        });
        dataGrid.registerModule('errorHandling', {
            defaultOptions: function() {
                return {errorRowEnabled: true}
            },
            controllers: {errorHandling: dataGrid.ErrorHandlingController},
            extenders: {controllers: {
                    data: {init: function() {
                            var that = this,
                                errorHandlingController = that.getController('errorHandling');
                            that.callBase();
                            that.dataErrorOccurred.add(function(error) {
                                var message = error && error.message || error;
                                if (that.option("errorRowEnabled"))
                                    errorHandlingController.renderErrorRow(message)
                            })
                        }},
                    validating: {_rowValidating: function(group, validate) {
                            var that = this,
                                errorHandlingController = that.getController('errorHandling'),
                                result = that.callBase(group, validate);
                            if (!result.isValid && result.errorText)
                                errorHandlingController.renderErrorRow(result.errorText, result.rowIndex);
                            return result
                        }}
                }}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.summaryModule.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid,
            normalizeSortingInfo = DX.data.utils.normalizeSortingInfo;
        var DATAGRID_TOTAL_FOOTER_CLASS = "dx-datagrid-total-footer",
            DATAGRID_SUMMARY_ITEM_CLASS = "dx-datagrid-summary-item",
            DATAGRID_TEXT_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_GROUP_FOOTER_CLASS = "dx-datagrid-group-footer",
            DATAGRID_GROUP_FOOTER_ROW_TYPE = "groupFooter";
        var renderSummaryCell = function(summaryItems, column, summaryTexts) {
                var i,
                    $cell = $("<td>"),
                    summaryItem,
                    $summaryItems = [];
                if (summaryItems) {
                    for (i = 0; i < summaryItems.length; i++) {
                        summaryItem = summaryItems[i];
                        $summaryItems.push($("<div>").css('text-align', summaryItem.alignment || column.alignment).addClass(DATAGRID_SUMMARY_ITEM_CLASS).addClass(DATAGRID_TEXT_CONTENT_CLASS).addClass(summaryItem.cssClass).text(dataGrid.getSummaryText(summaryItem, summaryTexts)))
                    }
                    $cell.append($summaryItems)
                }
                return $cell
            };
        dataGrid.FooterView = dataGrid.ColumnsView.inherit(function() {
            return {
                    _renderTable: function(totalItem) {
                        var $table = this._createTable(),
                            $row = this._createRow(),
                            i,
                            summaryTexts = this.option("summary.texts"),
                            column,
                            columns = this._columnsController.getVisibleColumns(),
                            columnsLength = columns.length;
                        $table.append(dataGrid.createColGroup(columns));
                        for (i = 0; i < columnsLength; i++) {
                            column = columns[i];
                            $row.append(renderSummaryCell(totalItem.summaryCells[i], column, summaryTexts))
                        }
                        return $table.append($row)
                    },
                    _renderCore: function() {
                        var totalItem = this._dataController.footerItems()[0];
                        this.element().empty().addClass(DATAGRID_TOTAL_FOOTER_CLASS);
                        if (totalItem && totalItem.summaryCells && totalItem.summaryCells.length) {
                            this._tableElement = this._renderTable(totalItem);
                            this.wrapTableInScrollContainer(this._tableElement).appendTo(this.element())
                        }
                    },
                    _columnOptionChanged: function(e) {
                        var optionNames = e.optionNames;
                        if (optionNames.width || optionNames.visibleWidth)
                            this.callBase(e)
                    },
                    getHeight: function() {
                        var $element = this.element();
                        return $element ? $element.outerHeight() : 0
                    },
                    isVisible: function() {
                        return !!this._dataController.footerItems().length
                    },
                    init: function() {
                        var that = this;
                        that.callBase();
                        that._dataController.changed.add(function() {
                            that.render()
                        })
                    }
                }
        }());
        var SummaryDataSourceAdapterExtender = function() {
                return {
                        init: function() {
                            this.callBase.apply(this, arguments);
                            this._totalAggregates = []
                        },
                        summary: function(summary) {
                            if (!arguments.length)
                                return this._summary;
                            this._summary = summary
                        },
                        totalAggregates: function() {
                            return this._totalAggregates
                        }
                    }
            }();
        var SummaryDataSourceAdapterClientExtender = function() {
                var calculateAggregates = function(that, summary, data, groupLevel) {
                        var calculator;
                        if (summary) {
                            calculator = new DX.data.AggregateCalculator({
                                totalAggregates: summary.totalAggregates,
                                groupAggregates: summary.groupAggregates,
                                data: data,
                                groupLevel: groupLevel
                            });
                            calculator.calculate()
                        }
                        that._totalAggregates = calculator ? calculator.totalAggregates() : []
                    };
                var sortGroupsBySummaryCore = function(items, groups, sortByGroups) {
                        if (!items || !groups.length)
                            return items;
                        var group = groups[0],
                            sorts = sortByGroups[0],
                            query;
                        if (group && sorts && sorts.length) {
                            query = DX.data.query(items);
                            $.each(sorts, function(index) {
                                if (index === 0)
                                    query = query.sortBy(this.selector, this.desc);
                                else
                                    query = query.thenBy(this.selector, this.desc)
                            });
                            query.enumerate().done(function(sortedItems) {
                                items = sortedItems
                            })
                        }
                        groups = groups.slice(1);
                        sortByGroups = sortByGroups.slice(1);
                        if (groups.length && sortByGroups.length)
                            $.each(items, function() {
                                this.items = sortGroupsBySummaryCore(this.items, groups, sortByGroups)
                            });
                        return items
                    };
                var sortGroupsBySummary = function(data, group, summary) {
                        var sortByGroups = summary && summary.sortByGroups && summary.sortByGroups();
                        if (sortByGroups && sortByGroups.length)
                            return sortGroupsBySummaryCore(data, group, sortByGroups);
                        return data
                    };
                return {_handleDataLoadedCore: function(options) {
                            var that = this,
                                groups = normalizeSortingInfo(options.loadOptions.group || []),
                                summary = that.summary();
                            calculateAggregates(that, summary, options.data, groups.length);
                            options.data = sortGroupsBySummary(options.data, groups, summary);
                            that.callBase(options)
                        }}
            }();
        dataGrid.DataSourceAdapterServer = dataGrid.DataSourceAdapterServer.inherit(SummaryDataSourceAdapterExtender);
        dataGrid.DataSourceAdapterClient = dataGrid.DataSourceAdapterClient.inherit(SummaryDataSourceAdapterExtender).inherit(SummaryDataSourceAdapterClientExtender);
        $.extend(dataGrid.__internals, {
            DATAGRID_TOTAL_FOOTER_CLASS: DATAGRID_TOTAL_FOOTER_CLASS,
            DATAGRID_SUMMARY_ITEM_CLASS: DATAGRID_SUMMARY_ITEM_CLASS,
            DATAGRID_GROUP_FOOTER_CLASS: DATAGRID_GROUP_FOOTER_CLASS
        });
        dataGrid.registerModule('summary', {
            defaultOptions: function() {
                return {
                        summary: {
                            groupItems: undefined,
                            totalItems: undefined,
                            calculateCustomSummary: undefined,
                            texts: {
                                sum: Globalize.localize("dxDataGrid-summarySum"),
                                sumOtherColumn: Globalize.localize("dxDataGrid-summarySumOtherColumn"),
                                min: Globalize.localize("dxDataGrid-summaryMin"),
                                minOtherColumn: Globalize.localize("dxDataGrid-summaryMinOtherColumn"),
                                max: Globalize.localize("dxDataGrid-summaryMax"),
                                maxOtherColumn: Globalize.localize("dxDataGrid-summaryMaxOtherColumn"),
                                avg: Globalize.localize("dxDataGrid-summaryAvg"),
                                avgOtherColumn: Globalize.localize("dxDataGrid-summaryAvgOtherColumn"),
                                count: Globalize.localize("dxDataGrid-summaryCount")
                            }
                        },
                        sortByGroupSummaryInfo: undefined
                    }
            },
            views: {footerView: dataGrid.FooterView},
            extenders: {
                controllers: {data: function() {
                        return {
                                _isGroupFooterVisible: function() {
                                    var groupItems = this.option("summary.groupItems") || [],
                                        i;
                                    for (i = 0; i < groupItems.length; i++)
                                        if (groupItems[i].showInGroupFooter)
                                            return true;
                                    return false
                                },
                                _processGroupItems: function(items, groupCount, options) {
                                    var result = this.callBase.apply(this, arguments);
                                    if (options) {
                                        if (options.isGroupFooterVisible === undefined)
                                            options.isGroupFooterVisible = this._isGroupFooterVisible();
                                        if (options.data && options.data.items && options.isGroupFooterVisible)
                                            result.push({
                                                rowType: "groupFooter",
                                                data: options.data,
                                                groupIndex: options.path.length - 1,
                                                values: options.path
                                            })
                                    }
                                    return result
                                },
                                _processGroupItem: function(groupItem, options) {
                                    var that = this;
                                    if (!options.summaryGroupItems)
                                        options.summaryGroupItems = that.option("summary.groupItems") || [];
                                    if (groupItem.rowType === "group") {
                                        var groupColumnIndex = -1;
                                        $.each(options.visibleColumns, function() {
                                            if (groupItem.groupIndex === this.groupIndex) {
                                                groupColumnIndex = this.index;
                                                return false
                                            }
                                        });
                                        groupItem.summaryCells = this._calculateSummaryCells(options.summaryGroupItems, groupItem.data.aggregates || [], options.visibleColumns, function(summaryItem, column) {
                                            if (summaryItem.showInGroupFooter)
                                                return -1;
                                            if (summaryItem.groupRowDisplayMode === "alignByColumn" && column && !utils.isDefined(column.groupIndex))
                                                return column.index;
                                            else
                                                return groupColumnIndex;
                                            return -1
                                        })
                                    }
                                    if (groupItem.rowType === "groupFooter")
                                        groupItem.summaryCells = this._calculateSummaryCells(options.summaryGroupItems, groupItem.data.aggregates || [], options.visibleColumns, function(summaryItem, column) {
                                            if (summaryItem.showInGroupFooter && column && !utils.isDefined(column.groupIndex))
                                                return column.index;
                                            return -1
                                        });
                                    return groupItem
                                },
                                _calculateSummaryCells: function(summaryItems, aggregates, visibleColumns, calculateTargetColumnIndex) {
                                    var that = this,
                                        summaryCells = [],
                                        summaryCellsByColumns = {};
                                    $.each(summaryItems, function(summaryIndex, summaryItem) {
                                        var column = that._columnsController.columnOption(summaryItem.column),
                                            showInColumn = summaryItem.showInColumn && that._columnsController.columnOption(summaryItem.showInColumn) || column,
                                            columnIndex = calculateTargetColumnIndex(summaryItem, showInColumn),
                                            aggregate;
                                        if (columnIndex >= 0) {
                                            if (!summaryCellsByColumns[columnIndex])
                                                summaryCellsByColumns[columnIndex] = [];
                                            aggregate = aggregates[summaryIndex];
                                            if (utils.isDefined(aggregate) && !isNaN(aggregate))
                                                summaryCellsByColumns[columnIndex].push($.extend({}, summaryItem, {
                                                    value: aggregate,
                                                    columnCaption: column && column.index !== columnIndex ? column.caption : undefined
                                                }))
                                        }
                                    });
                                    $.each(visibleColumns, function() {
                                        summaryCells.push(summaryCellsByColumns[this.index] || [])
                                    });
                                    return summaryCells
                                },
                                _updateItemsCore: function(change) {
                                    var that = this,
                                        summaryCells,
                                        visibleColumns,
                                        totalAggregates,
                                        columnsController = that._columnsController,
                                        dataSource = that._dataSource,
                                        summaryTotalItems = that.option("summary.totalItems");
                                    that.callBase(change);
                                    that._footerItems = [];
                                    if (dataSource && summaryTotalItems && summaryTotalItems.length) {
                                        totalAggregates = dataSource.totalAggregates();
                                        visibleColumns = columnsController.getVisibleColumns();
                                        summaryCells = that._calculateSummaryCells(summaryTotalItems, totalAggregates, visibleColumns, function(summaryItem, column) {
                                            if (column && !utils.isDefined(column.groupIndex))
                                                return column.index;
                                            return -1
                                        });
                                        that._footerItems.push({
                                            rowType: 'totalFooter',
                                            summaryCells: summaryCells
                                        })
                                    }
                                },
                                _getAggregates: function(summaryItems) {
                                    var that = this,
                                        columnsController = that.getController("columns"),
                                        calculateCustomSummary = that.option("summary.calculateCustomSummary");
                                    return $.map(summaryItems || [], function(summaryItem) {
                                            var column = columnsController.columnOption(summaryItem.column),
                                                calculateCellValue = column && column.calculateCellValue ? $.proxy(column, "calculateCellValue") : DX.data.utils.compileGetter(column ? column.dataField : summaryItem.column),
                                                aggregator = summaryItem.summaryType || "count",
                                                selector = calculateCellValue,
                                                options;
                                            if (aggregator === 'avg' || aggregator === 'sum')
                                                selector = function(data) {
                                                    return Number(calculateCellValue(data))
                                                };
                                            if (aggregator === "custom") {
                                                if (!calculateCustomSummary) {
                                                    DX.log("E1026");
                                                    calculateCustomSummary = function(){}
                                                }
                                                options = {
                                                    component: that.component,
                                                    name: summaryItem.name,
                                                    summaryProcess: "start",
                                                    totalValue: undefined
                                                };
                                                calculateCustomSummary(options);
                                                options.summaryProcess = "calculate";
                                                aggregator = {
                                                    seed: options.totalValue,
                                                    step: function(totalValue, value) {
                                                        options.summaryProcess = "calculate";
                                                        options.totalValue = totalValue;
                                                        options.value = value;
                                                        calculateCustomSummary(options);
                                                        return options.totalValue
                                                    },
                                                    finalize: function(totalValue) {
                                                        options.summaryProcess = "finalize";
                                                        options.totalValue = totalValue;
                                                        delete options.value;
                                                        calculateCustomSummary(options);
                                                        return options.totalValue
                                                    }
                                                }
                                            }
                                            return {
                                                    selector: selector,
                                                    aggregator: aggregator
                                                }
                                        })
                                },
                                _addSortInfo: function(sortByGroups, groupColumn, selector, sortOrder) {
                                    var groupIndex;
                                    if (groupColumn) {
                                        groupIndex = groupColumn.groupIndex;
                                        sortOrder = sortOrder || groupColumn.sortOrder;
                                        if (utils.isDefined(groupIndex)) {
                                            sortByGroups[groupIndex] = sortByGroups[groupIndex] || [];
                                            sortByGroups[groupIndex].push({
                                                selector: selector,
                                                desc: sortOrder === "desc"
                                            })
                                        }
                                    }
                                },
                                _findSummaryItem: function(summaryItems, name) {
                                    var summaryItemIndex = -1;
                                    var getFullName = function(summaryItem) {
                                            var summaryType = summaryItem.summaryType,
                                                column = summaryItem.column;
                                            return summaryType && column && summaryType + "_" + column
                                        };
                                    if (utils.isDefined(name))
                                        $.each(summaryItems || [], function(index) {
                                            if (this.name === name || index === name || this.summaryType === name || this.column === name || getFullName(this) === name) {
                                                summaryItemIndex = index;
                                                return false
                                            }
                                        });
                                    return summaryItemIndex
                                },
                                _getSummarySortByGroups: function(sortByGroupSummaryInfo, groupSummaryItems) {
                                    var that = this,
                                        columnsController = that._columnsController,
                                        groupColumns = columnsController.getGroupColumns(),
                                        sortByGroups = [];
                                    if (!groupSummaryItems || !groupSummaryItems.length)
                                        return;
                                    $.each(sortByGroupSummaryInfo || [], function() {
                                        var groupIndex,
                                            sortOrder = this.sortOrder,
                                            groupColumn = this.groupColumn,
                                            summaryItemIndex = that._findSummaryItem(groupSummaryItems, this.summaryItem),
                                            sortItem;
                                        if (summaryItemIndex < 0)
                                            return;
                                        var selector = function(data) {
                                                return data.aggregates[summaryItemIndex]
                                            };
                                        if (utils.isDefined(groupColumn)) {
                                            groupColumn = columnsController.columnOption(groupColumn);
                                            that._addSortInfo(sortByGroups, groupColumn, selector, sortOrder)
                                        }
                                        else
                                            $.each(groupColumns, function(groupIndex, groupColumn) {
                                                that._addSortInfo(sortByGroups, groupColumn, selector, sortOrder)
                                            })
                                    });
                                    return sortByGroups
                                },
                                _createDataSourceAdapterCore: function(dataSource, remoteOperations) {
                                    var summary = this._getSummaryOptions(),
                                        dataSourceAdapter;
                                    if (remoteOperations === 'auto' && summary)
                                        remoteOperations = {
                                            filtering: true,
                                            sorting: true,
                                            paging: false
                                        };
                                    dataSourceAdapter = this.callBase(dataSource, remoteOperations);
                                    dataSourceAdapter.summary(summary);
                                    return dataSourceAdapter
                                },
                                _getSummaryOptions: function() {
                                    var that = this,
                                        groupSummaryItems = that.option("summary.groupItems"),
                                        totalSummaryItems = that.option("summary.totalItems"),
                                        sortByGroupSummaryInfo = that.option("sortByGroupSummaryInfo"),
                                        groupAggregates = that._getAggregates(groupSummaryItems),
                                        totalAggregates = that._getAggregates(totalSummaryItems),
                                        sortByGroups = function() {
                                            return that._getSummarySortByGroups(sortByGroupSummaryInfo, groupSummaryItems)
                                        };
                                    if (groupAggregates.length || totalAggregates.length)
                                        return {
                                                groupAggregates: groupAggregates,
                                                totalAggregates: totalAggregates,
                                                sortByGroups: sortByGroups
                                            }
                                },
                                publicMethods: function() {
                                    var methods = this.callBase();
                                    methods.push("getTotalSummaryValue");
                                    return methods
                                },
                                getTotalSummaryValue: function(summaryItemName) {
                                    var summaryItemIndex = this._findSummaryItem(this.option("summary.totalItems"), summaryItemName),
                                        aggregates = this._dataSource.totalAggregates();
                                    if (aggregates.length && summaryItemIndex > -1)
                                        return aggregates[summaryItemIndex]
                                },
                                optionChanged: function(args) {
                                    if (args.name === "summary")
                                        args.name = "dataSource";
                                    this.callBase(args)
                                },
                                init: function() {
                                    this._footerItems = [];
                                    this.callBase()
                                },
                                footerItems: function() {
                                    return this._footerItems
                                }
                            }
                    }()},
                views: {rowsView: function() {
                        return {
                                _createRow: function(item) {
                                    var $row = this.callBase(item);
                                    item && $row.addClass(item.rowType === DATAGRID_GROUP_FOOTER_ROW_TYPE ? DATAGRID_GROUP_FOOTER_CLASS : "");
                                    return $row
                                },
                                _renderCells: function(item, options) {
                                    var columns = options.columns,
                                        summaryCells,
                                        $summaryCells = [],
                                        summaryTexts = this.option("summary.texts"),
                                        i;
                                    if (item.rowType === DATAGRID_GROUP_FOOTER_ROW_TYPE) {
                                        summaryCells = item.summaryCells;
                                        for (i = 0; i < columns.length; i++)
                                            $summaryCells.push(renderSummaryCell(summaryCells[i], columns[i], summaryTexts));
                                        return $summaryCells
                                    }
                                    else
                                        return this.callBase(item, options)
                                }
                            }
                    }()}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.masterDetailModule.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid,
            DATAGRID_MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell",
            DATAGRID_MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row",
            DATAGRID_ROW_LINES_CLASS = "dx-row-lines";
        $.extend(dataGrid.__internals, {
            DATAGRID_MASTER_DETAIL_CELL_CLASS: DATAGRID_MASTER_DETAIL_CELL_CLASS,
            DATAGRID_MASTER_DETAIL_ROW_CLASS: DATAGRID_MASTER_DETAIL_ROW_CLASS,
            DATAGRID_ROW_LINES_CLASS: DATAGRID_ROW_LINES_CLASS
        });
        dataGrid.registerModule('masterDetail', {
            defaultOptions: function() {
                return {masterDetail: {
                            enabled: false,
                            autoExpandAll: false,
                            template: null
                        }}
            },
            extenders: {
                controllers: {
                    columns: {_getExpandColumnsCore: function() {
                            var expandColumns = this.callBase();
                            if (this.option('masterDetail.enabled'))
                                expandColumns.push({});
                            return expandColumns
                        }},
                    data: function() {
                        var initMasterDetail = function(that) {
                                that._expandedItems = [];
                                that._isExpandAll = that.option('masterDetail.autoExpandAll')
                            };
                        return {
                                init: function() {
                                    initMasterDetail(this);
                                    this.callBase()
                                },
                                expandAll: function(groupIndex) {
                                    var that = this;
                                    if (groupIndex < 0) {
                                        that._isExpandAll = true;
                                        that._expandedItems = [];
                                        that.updateItems()
                                    }
                                    else
                                        that.callBase.apply(that, arguments)
                                },
                                collapseAll: function(groupIndex) {
                                    var that = this;
                                    if (groupIndex < 0) {
                                        that._isExpandAll = false;
                                        that._expandedItems = [];
                                        that.updateItems()
                                    }
                                    else
                                        that.callBase.apply(that, arguments)
                                },
                                isRowExpanded: function(key) {
                                    var that = this;
                                    if (utils.isArray(key))
                                        return that.callBase.apply(that, arguments);
                                    else
                                        return !!(that._isExpandAll ^ dataGrid.getIndexByKey(key, that._expandedItems) >= 0)
                                },
                                changeRowExpand: function(key) {
                                    var that = this,
                                        expandIndex;
                                    if (utils.isArray(key))
                                        return that.callBase.apply(that, arguments);
                                    else {
                                        expandIndex = dataGrid.getIndexByKey(key, that._expandedItems);
                                        if (expandIndex >= 0)
                                            that._expandedItems.splice(expandIndex, 1);
                                        else
                                            that._expandedItems.push({key: key});
                                        var rowIndex = that.getRowIndexByKey(key);
                                        that.updateItems({
                                            changeType: 'update',
                                            rowIndices: [rowIndex, rowIndex + 1]
                                        })
                                    }
                                },
                                _processDataItem: function(data, options) {
                                    var that = this,
                                        dataItem = that.callBase.apply(that, arguments);
                                    dataItem.isExpanded = that.isRowExpanded(dataItem.key);
                                    if (options.detailColumnIndex === undefined) {
                                        options.detailColumnIndex = -1;
                                        $.each(options.visibleColumns, function(index, column) {
                                            if (column.command === 'expand' && !utils.isDefined(column.groupIndex)) {
                                                options.detailColumnIndex = index;
                                                return false
                                            }
                                        })
                                    }
                                    if (options.detailColumnIndex >= 0)
                                        dataItem.values[options.detailColumnIndex] = dataItem.isExpanded;
                                    return dataItem
                                },
                                _processItems: function() {
                                    var that = this,
                                        items = that.callBase.apply(that, arguments),
                                        result = [];
                                    $.each(items, function(index, item) {
                                        result.push(item);
                                        if (item.rowType === 'data' && item.isExpanded)
                                            result.push({
                                                rowType: 'detail',
                                                key: item.key,
                                                data: item.data,
                                                values: []
                                            })
                                    });
                                    return result
                                },
                                optionChanged: function(args) {
                                    var that = this,
                                        value,
                                        previousValue,
                                        isEnabledChanged,
                                        isAutoExpandAllChanged;
                                    if (args.name === 'masterDetail') {
                                        args.name = 'columns';
                                        switch (args.fullName) {
                                            case'masterDetail':
                                                value = args.value || {};
                                                previousValue = args.previousValue || {};
                                                isEnabledChanged = value.enabled !== previousValue.enabled;
                                                isAutoExpandAllChanged = value.autoExpandAll !== previousValue.autoExpandAll;
                                                break;
                                            case'masterDetail.enabled':
                                                isEnabledChanged = true;
                                                break;
                                            case'masterDetail.autoExpandAll':
                                                isAutoExpandAllChanged = true;
                                                break
                                        }
                                        if (isEnabledChanged || isAutoExpandAllChanged)
                                            initMasterDetail(that)
                                    }
                                    that.callBase(args)
                                },
                                refresh: function() {
                                    var that = this;
                                    initMasterDetail(that);
                                    return that.callBase.apply(that, arguments)
                                }
                            }
                    }()
                },
                views: {rowsView: function() {
                        return {
                                _getColumnTemplate: function(options) {
                                    var that = this,
                                        column = options.column,
                                        template;
                                    if (column.command === 'detail') {
                                        template = that.option('masterDetail.template') || that._getDefaultTemplate(column);
                                        options.denyRenderToDetachedContainer = true
                                    }
                                    else
                                        template = that.callBase.apply(that, arguments);
                                    return template
                                },
                                _createRow: function(rowOptions) {
                                    var $row = this.callBase(rowOptions);
                                    if (rowOptions && rowOptions.rowType === "detail") {
                                        this.option('showRowLines') && $row.addClass(DATAGRID_ROW_LINES_CLASS);
                                        $row.addClass(DATAGRID_MASTER_DETAIL_ROW_CLASS)
                                    }
                                    return $row
                                },
                                _renderCells: function(item, options) {
                                    var groupEmptyCellsCount,
                                        $detailCell,
                                        $cells,
                                        emptyCellsCount,
                                        i;
                                    if (item.rowType === 'detail') {
                                        $cells = [];
                                        groupEmptyCellsCount = options.groupColumns.length + options.columnsCountBeforeGroups;
                                        emptyCellsCount = groupEmptyCellsCount + Number(this.option("masterDetail.enabled"));
                                        for (i = 0; i < emptyCellsCount; i++)
                                            $cells.push(this._createCell(null, item, item.rowIndex, options.columns[i]));
                                        $detailCell = this._createCell(null, item, item.rowIndex, {command: 'detail'}, groupEmptyCellsCount);
                                        $detailCell.addClass(DATAGRID_MASTER_DETAIL_CELL_CLASS).attr('colspan', options.columns.length - emptyCellsCount);
                                        $cells.push($detailCell)
                                    }
                                    else
                                        $cells = this.callBase.apply(this, arguments);
                                    return $cells
                                }
                            }
                    }()}
            }
        })
    })(jQuery, DevExpress);
    DevExpress.MOD_WIDGETS_WEB = true
}
if (!DevExpress.MOD_FRAMEWORK) {
    if (!window.DevExpress)
        throw Error('Required module is not referenced: core');
    /*! Module framework, file framework.js */
    (function($, DX, undefined) {
        var mergeWithReplace = function(targetArray, arrayToMerge, needReplaceFn) {
                var result = [];
                for (var i = 0, length = targetArray.length; i < length; i++)
                    if (!needReplaceFn(targetArray[i], arrayToMerge))
                        result.push(targetArray[i]);
                result.push.apply(result, arrayToMerge);
                return result
            };
        var prepareCommandToReplace = function(targetCommand, commandsToMerge) {
                var needToReplace = false;
                $.each(commandsToMerge, function(_, commandToMerge) {
                    var idEqual = targetCommand.option("id") === commandToMerge.option("id") && commandToMerge.option("id"),
                        behaviorEqual = targetCommand.option("behavior") === commandToMerge.option("behavior") && targetCommand.option("behavior");
                    needToReplace = idEqual || behaviorEqual;
                    if (behaviorEqual && commandToMerge.option("onExecute") === null)
                        commandToMerge.option("onExecute", targetCommand.option("onExecute"));
                    if (needToReplace) {
                        targetCommand.element().remove();
                        return false
                    }
                });
                return needToReplace
            };
        var mergeCommands = function(targetCommands, commandsToMerge) {
                return mergeWithReplace(targetCommands, commandsToMerge, prepareCommandToReplace)
            };
        var resolvePropertyValue = function(command, containerOptions, propertyName, defaultValue) {
                var containerOption = containerOptions ? containerOptions[propertyName] : undefined,
                    defaultOption = containerOption === undefined ? defaultValue : containerOption,
                    commandOption = command.option(propertyName);
                return commandOption === undefined || commandOption === defaultValue ? defaultOption : commandOption
            };
        var resolveTextValue = function(command, containerOptions) {
                var showText = resolvePropertyValue(command, containerOptions, "showText"),
                    hasIcon = !!command.option("icon") || command.option("iconSrc"),
                    titleValue = resolvePropertyValue(command, containerOptions, "title", "");
                return showText || !hasIcon ? titleValue : ""
            };
        var resolveIconValue = function(command, containerOptions, propertyName) {
                var showIcon = resolvePropertyValue(command, containerOptions, "showIcon"),
                    hasText = !!command.option("title"),
                    iconValue = resolvePropertyValue(command, containerOptions, propertyName, "");
                return showIcon || !hasText ? iconValue : ""
            };
        var resolveTypeValue = function(command, containerOptions) {
                return resolvePropertyValue(command, containerOptions, "type")
            };
        DX.framework = {
            utils: {
                mergeCommands: mergeCommands,
                commandToContainer: {
                    resolveTypeValue: resolveTypeValue,
                    resolveIconValue: resolveIconValue,
                    resolveTextValue: resolveTextValue,
                    resolvePropertyValue: resolvePropertyValue
                }
            },
            templateProvider: DX.ui.KoTemplateProvider ? new DX.ui.KoTemplateProvider : undefined
        }
    })(jQuery, DevExpress);
    /*! Module framework, file framework.errors.js */
    (function($, DX) {
        $.extend(DX.ERROR_MESSAGES, {
            E3001: "Routing rule is not found for the '{0}' URI.",
            E3002: "The passed object cannot be formatted into a URI string by the application's router. An appropriate route should be registered.",
            E3003: "Unable to navigate. Application is being initialized.",
            E3004: "Cannot execute the command: {0}.",
            E3005: "The '{0}' command {1} is not registered in the application's command mapping. Go to http://dxpr.es/1bTjfj1 for more details.",
            E3006: "Unknown navigation target: '{0}'. Use the 'current', 'back' or 'blank' values.",
            E3007: "Error while restoring the application state. The state has been cleared. Refresh the page.",
            E3008: "Unable to go back.",
            E3009: "Unable to go forward.",
            E3010: "The command's 'id' option should be specified.\r\nProcessed markup: {0}\n",
            E3011: "Layout controller cannot be resolved. There are no appropriate layout controllers for the current context. Check browser console for details.",
            E3012: "Layout controller cannot be resolved. Two or more layout controllers suit the current context. Check browser console for details.",
            E3013: "The '{0}' template with the '{1}' name is not found. Make sure the case is correct in the specified view name and the template fits the current context.",
            E3014: "All the children of the dxView element should be either of the dxCommand or dxContent type.\r\nProcessed markup: {0}",
            E3015: "The 'exec' method should be called before the 'finalize' method.",
            E3016: "Unknown transition type '{0}'.",
            E3018: "Unable to parse options.\nMessage: {0};\nOptions value: {1}.",
            E3019: "View templates should be updated according to the 13.1 changes. Go to http://dxpr.es/15ikrJA for more details.",
            E3020: "Concurrent templates are found:\r\n{0}Target device:\r\n{1}.",
            E3021: "Remote template cannot be loaded.\r\nUrl:{0}\r\nError:{1}.",
            E3022: "Cannot initialize the HtmlApplication component.",
            E3023: "Navigation item is not found",
            W3001: "A view with the '{0}' key doesn't exist.",
            W3002: "A view with the '{0}' key has already been released.",
            W3003: "Layout resolving context:\n{0}\nAvailable layout controller registrations:\n{1}\n",
            W3004: "Layout resolving context:\n{0}\nConcurent layout controller registrations for the context:\n{1}\n",
            W3005: "Direct hash-based navigation is detected. Use data-bind=\"dxAction: url\" instead of href=\"#url\".\nFound markup:\n{0}\n"
        })
    })(jQuery, DevExpress);
    /*! Module framework, file framework.routing.js */
    (function($, DX) {
        var JSON_URI_PREFIX = encodeURIComponent("json:");
        var Class = DX.Class;
        DX.framework.Route = Class.inherit({
            _trimSeparators: function(str) {
                return str.replace(/^[\/.]+|\/+$/g, "")
            },
            _escapeRe: function(str) {
                return str.replace(/\W/g, "\\$1")
            },
            _checkConstraint: function(param, constraint) {
                param = String(param);
                if (typeof constraint === "string")
                    constraint = new RegExp(constraint);
                var match = constraint.exec(param);
                if (!match || match[0] !== param)
                    return false;
                return true
            },
            _ensureReady: function() {
                var that = this;
                if (this._patternRe)
                    return false;
                this._pattern = this._trimSeparators(this._pattern);
                this._patternRe = "";
                this._params = [];
                this._segments = [];
                this._separators = [];
                this._pattern.replace(/[^\/]+/g, function(segment, index) {
                    that._segments.push(segment);
                    if (index)
                        that._separators.push(that._pattern.substr(index - 1, 1))
                });
                $.each(this._segments, function(index) {
                    var isStatic = true,
                        segment = this,
                        separator = index ? that._separators[index - 1] : "";
                    if (segment.charAt(0) === ":") {
                        isStatic = false;
                        segment = segment.substr(1);
                        that._params.push(segment);
                        that._patternRe += "(?:" + separator + "([^/]*))";
                        if (segment in that._defaults)
                            that._patternRe += "?"
                    }
                    else
                        that._patternRe += separator + that._escapeRe(segment)
                });
                this._patternRe = new RegExp("^" + this._patternRe + "$")
            },
            ctor: function(pattern, defaults, constraints) {
                this._pattern = pattern || "";
                this._defaults = defaults || {};
                this._constraints = constraints || {}
            },
            parse: function(uri) {
                var that = this;
                this._ensureReady();
                var matches = this._patternRe.exec(uri);
                if (!matches)
                    return false;
                var result = $.extend({}, this._defaults);
                $.each(this._params, function(i) {
                    var index = i + 1;
                    if (matches.length >= index && matches[index])
                        result[this] = that.parseSegment(matches[index])
                });
                $.each(this._constraints, function(key) {
                    if (!that._checkConstraint(result[key], that._constraints[key])) {
                        result = false;
                        return false
                    }
                });
                return result
            },
            format: function(routeValues) {
                var that = this,
                    query = "";
                this._ensureReady();
                var mergeValues = $.extend({}, this._defaults),
                    useStatic = 0,
                    ret = [],
                    dels = [],
                    unusedRouteValues = {};
                $.each(routeValues, function(paramName, paramValue) {
                    routeValues[paramName] = that.formatSegment(paramValue);
                    if (!(paramName in mergeValues))
                        unusedRouteValues[paramName] = true
                });
                $.each(this._segments, function(index, segment) {
                    ret[index] = index ? that._separators[index - 1] : '';
                    if (segment.charAt(0) === ':') {
                        var paramName = segment.substr(1);
                        if (!(paramName in routeValues) && !(paramName in that._defaults)) {
                            ret = null;
                            return false
                        }
                        if (paramName in that._constraints && !that._checkConstraint(routeValues[paramName], that._constraints[paramName])) {
                            ret = null;
                            return false
                        }
                        if (paramName in routeValues) {
                            if (routeValues[paramName] !== undefined) {
                                mergeValues[paramName] = routeValues[paramName];
                                ret[index] += routeValues[paramName];
                                useStatic = index
                            }
                            delete unusedRouteValues[paramName]
                        }
                        else if (paramName in mergeValues) {
                            ret[index] += mergeValues[paramName];
                            dels.push(index)
                        }
                    }
                    else {
                        ret[index] += segment;
                        useStatic = index
                    }
                });
                $.each(mergeValues, function(key, value) {
                    if (!!value && $.inArray(":" + key, that._segments) === -1 && routeValues[key] !== value) {
                        ret = null;
                        return false
                    }
                });
                var unusedCount = 0;
                if (!$.isEmptyObject(unusedRouteValues)) {
                    query = "?";
                    $.each(unusedRouteValues, function(key) {
                        query += key + "=" + routeValues[key] + "&";
                        unusedCount++
                    });
                    query = query.substr(0, query.length - 1)
                }
                if (ret === null)
                    return false;
                if (dels.length)
                    $.map(dels, function(i) {
                        if (i >= useStatic)
                            ret[i] = ''
                    });
                var path = ret.join('');
                path = path.replace(/\/+$/, "");
                return {
                        uri: path + query,
                        unusedCount: unusedCount
                    }
            },
            formatSegment: function(value) {
                if ($.isArray(value) || $.isPlainObject(value))
                    return JSON_URI_PREFIX + encodeURIComponent(JSON.stringify(value));
                return encodeURIComponent(value)
            },
            parseSegment: function(value) {
                if (value.substr(0, JSON_URI_PREFIX.length) === JSON_URI_PREFIX)
                    try {
                        return $.parseJSON(decodeURIComponent(value.substr(JSON_URI_PREFIX.length)))
                    }
                    catch(x) {}
                return decodeURIComponent(value)
            }
        });
        DX.framework.Router = DX.Class.inherit({
            ctor: function() {
                this._registry = []
            },
            _trimSeparators: function(str) {
                return str.replace(/^[\/.]+|\/+$/g, "")
            },
            _createRoute: function(pattern, defaults, constraints) {
                return new DX.framework.Route(pattern, defaults, constraints)
            },
            register: function(pattern, defaults, constraints) {
                this._registry.push(this._createRoute(pattern, defaults, constraints))
            },
            _parseQuery: function(query) {
                var result = {},
                    values = query.split("&");
                $.each(values, function(index, value) {
                    var keyValuePair = value.split("=");
                    result[keyValuePair[0]] = decodeURIComponent(keyValuePair[1])
                });
                return result
            },
            parse: function(uri) {
                var that = this,
                    ret;
                uri = this._trimSeparators(uri);
                var parts = uri.split("?", 2),
                    path = parts[0],
                    query = parts[1];
                $.each(this._registry, function() {
                    var result = this.parse(path);
                    if (result !== false) {
                        ret = result;
                        if (query)
                            ret = $.extend(ret, that._parseQuery(query));
                        return false
                    }
                });
                return ret ? ret : false
            },
            format: function(obj) {
                var ret = false,
                    minUnusedCount = 99999;
                obj = obj || {};
                $.each(this._registry, function() {
                    var toFormat = $.extend(true, {}, obj);
                    var result = this.format(toFormat);
                    if (result !== false)
                        if (minUnusedCount > result.unusedCount) {
                            minUnusedCount = result.unusedCount;
                            ret = result.uri
                        }
                });
                return ret
            }
        });
        DX.framework.Route.__internals = {JSON_URI_PREFIX: JSON_URI_PREFIX}
    })(jQuery, DevExpress);
    /*! Module framework, file framework.command.js */
    (function($, DX) {
        var ui = DX.ui;
        var Command = DX.DOMComponent.inherit({
                ctor: function(element, options) {
                    if ($.isPlainObject(element)) {
                        options = element;
                        element = $("<div />")
                    }
                    this.beforeExecute = $.Callbacks();
                    this.afterExecute = $.Callbacks();
                    this._callbacksToEvents("Command", ["beforeExecute", "afterExecute"]);
                    this.callBase(element, options)
                },
                _setDeprecatedOptions: function() {
                    this.callBase();
                    $.extend(this._deprecatedOptions, {action: {
                            since: "14.2",
                            alias: "onExecute"
                        }})
                },
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        onExecute: null,
                        id: null,
                        title: "",
                        icon: "",
                        iconSrc: "",
                        visible: true,
                        disabled: false
                    })
                },
                execute: function() {
                    var isDisabled = this._options.disabled;
                    if ($.isFunction(isDisabled))
                        isDisabled = !!isDisabled.apply(this, arguments);
                    if (isDisabled)
                        throw DX.Error("E3004", this._options.id);
                    this.fireEvent("beforeExecute", arguments);
                    this._createActionByOption("onExecute").apply(this, arguments);
                    this.fireEvent("afterExecute", arguments)
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass("dx-command")
                },
                _renderDisabledState: $.noop,
                _dispose: function() {
                    this.callBase();
                    this.element().removeData(this.NAME);
                    this.beforeExecute.empty();
                    this.afterExecute.empty()
                }
            });
        DX.registerComponent("dxCommand", DX.framework, Command)
    })(jQuery, DevExpress);
    /*! Module framework, file framework.commandMapping.js */
    (function($, DX) {
        DX.framework.CommandMapping = DX.Class.inherit({
            ctor: function() {
                this._commandMappings = {};
                this._containerDefaults = {}
            },
            setDefaults: function(containerId, defaults) {
                this._containerDefaults[containerId] = defaults;
                return this
            },
            mapCommands: function(containerId, commandMappings) {
                var that = this;
                $.each(commandMappings, function(index, commandMapping) {
                    if (typeof commandMapping === "string")
                        commandMapping = {id: commandMapping};
                    var commandId = commandMapping.id;
                    var mappings = that._commandMappings[containerId] || {};
                    mappings[commandId] = $.extend({
                        showIcon: true,
                        showText: true
                    }, that._containerDefaults[containerId] || {}, commandMapping);
                    that._commandMappings[containerId] = mappings
                });
                this._initExistingCommands();
                return this
            },
            unmapCommands: function(containerId, commandIds) {
                var that = this;
                $.each(commandIds, function(index, commandId) {
                    var mappings = that._commandMappings[containerId] || {};
                    if (mappings)
                        delete mappings[commandId]
                });
                this._initExistingCommands()
            },
            getCommandMappingForContainer: function(commandId, containerId) {
                return (this._commandMappings[containerId] || {})[commandId]
            },
            checkCommandsExist: function(commands) {
                var that = this,
                    result = $.grep(commands, function(commandName, index) {
                        return $.inArray(commandName, that._existingCommands) < 0 && $.inArray(commandName, commands) === index
                    });
                if (result.length !== 0)
                    throw DX.Error("E3005", result.join("', '"), result.length === 1 ? " is" : "s are");
            },
            load: function(config) {
                if (!config)
                    return;
                var that = this;
                $.each(config, function(name, container) {
                    that.setDefaults(name, container.defaults);
                    that.mapCommands(name, container.commands)
                });
                return this
            },
            _initExistingCommands: function() {
                var that = this;
                this._existingCommands = [];
                $.each(that._commandMappings, function(name, _commands) {
                    $.each(_commands, function(index, command) {
                        if ($.inArray(command.id, that._existingCommands) < 0)
                            that._existingCommands.push(command.id)
                    })
                })
            }
        });
        DX.framework.CommandMapping.defaultMapping = {
            "global-navigation": {
                defaults: {
                    showIcon: true,
                    showText: true
                },
                commands: []
            },
            "ios-header-toolbar": {
                defaults: {
                    showIcon: false,
                    showText: true,
                    location: "after"
                },
                commands: ["edit", "save", {
                        id: "back",
                        location: "before"
                    }, {
                        id: "cancel",
                        location: "before"
                    }, {
                        id: "create",
                        showIcon: true,
                        showText: false
                    }]
            },
            "ios-action-sheet": {
                defaults: {
                    showIcon: false,
                    showText: true
                },
                commands: []
            },
            "ios-view-footer": {
                defaults: {
                    showIcon: false,
                    showText: true
                },
                commands: [{
                        id: "delete",
                        type: "danger"
                    }]
            },
            "android-header-toolbar": {
                defaults: {
                    showIcon: true,
                    showText: false,
                    location: "after"
                },
                commands: [{
                        id: "back",
                        showIcon: false,
                        location: "before"
                    }, "create", "edit", "save", {
                        id: "cancel",
                        showText: true,
                        location: "menu"
                    }, {
                        id: "delete",
                        showText: true,
                        location: "menu"
                    }]
            },
            "android-simple-toolbar": {
                defaults: {
                    showIcon: true,
                    showText: false,
                    location: "after"
                },
                commands: [{
                        id: "back",
                        showIcon: false,
                        location: "before"
                    }, {id: "create"}, {
                        id: "save",
                        showText: true,
                        location: "before"
                    }, {
                        id: "edit",
                        showText: true,
                        location: "menu"
                    }, {
                        id: "cancel",
                        showText: true,
                        location: "menu"
                    }, {
                        id: "delete",
                        showText: true,
                        location: "menu"
                    }]
            },
            "android-footer-toolbar": {
                defaults: {location: "after"},
                commands: [{
                        id: "create",
                        showText: false,
                        location: "center"
                    }, {
                        id: "edit",
                        showText: false,
                        location: "before"
                    }, {
                        id: "delete",
                        location: "menu"
                    }, {
                        id: "save",
                        showIcon: false,
                        location: "before"
                    }]
            },
            "tizen-header-toolbar": {
                defaults: {
                    showIcon: true,
                    showText: false,
                    location: "after"
                },
                commands: [{
                        id: "back",
                        showIcon: false,
                        location: "before"
                    }, "create", "edit", "save", {
                        id: "cancel",
                        showText: true,
                        location: "menu"
                    }, {
                        id: "delete",
                        showText: true,
                        location: "menu"
                    }]
            },
            "tizen-footer-toolbar": {
                defaults: {location: "after"},
                commands: [{
                        id: "create",
                        showText: false
                    }, {
                        id: "edit",
                        showText: false,
                        location: "before"
                    }, {
                        id: "delete",
                        location: "menu"
                    }, {
                        id: "save",
                        showIcon: false,
                        location: "before"
                    }]
            },
            "tizen-simple-toolbar": {
                defaults: {
                    showIcon: true,
                    showText: false,
                    location: "after"
                },
                commands: [{
                        id: "back",
                        showIcon: false,
                        location: "before"
                    }, {id: "create"}, {
                        id: "save",
                        showText: true,
                        location: "before"
                    }, {
                        id: "edit",
                        showText: true,
                        location: "menu"
                    }, {
                        id: "cancel",
                        showText: true,
                        location: "menu"
                    }, {
                        id: "delete",
                        showText: true,
                        location: "menu"
                    }]
            },
            "generic-header-toolbar": {
                defaults: {
                    showIcon: false,
                    showText: true,
                    location: "after"
                },
                commands: ["edit", "save", {
                        id: "back",
                        location: "before"
                    }, {
                        id: "cancel",
                        location: "before"
                    }, {
                        id: "create",
                        showIcon: true,
                        showText: false
                    }]
            },
            "generic-view-footer": {
                defaults: {
                    showIcon: false,
                    showText: true
                },
                commands: [{
                        id: "delete",
                        type: "danger"
                    }]
            },
            "win8-appbar": {
                defaults: {location: "after"},
                commands: ["edit", "cancel", "save", "delete", {
                        id: "create",
                        location: "before"
                    }, {
                        id: "refresh",
                        location: "before"
                    }]
            },
            "win8-toolbar": {
                defaults: {
                    showText: false,
                    location: "before"
                },
                commands: [{id: "previousPage"}]
            },
            "win8-phone-appbar": {
                defaults: {location: "center"},
                commands: ["create", "edit", "cancel", "save", "refresh", {
                        id: "delete",
                        location: "menu"
                    }]
            },
            "win8-split-toolbar": {
                defaults: {
                    showIcon: true,
                    showText: false,
                    location: "after"
                },
                commands: [{
                        id: "back",
                        showIcon: false,
                        location: "before"
                    }, {id: "create"}, {
                        id: "save",
                        showText: true,
                        location: "before"
                    }, {
                        id: "edit",
                        showText: true,
                        location: "menu"
                    }, {
                        id: "cancel",
                        showText: true,
                        location: "menu"
                    }, {
                        id: "delete",
                        showText: true,
                        location: "menu"
                    }]
            },
            "win8-master-detail-toolbar": {
                defaults: {
                    showText: false,
                    location: "before"
                },
                commands: ["back"]
            },
            "desktop-toolbar": {
                defaults: {
                    showIcon: false,
                    showText: true,
                    location: "after"
                },
                commands: ["cancel", "create", "edit", "save", {
                        id: "delete",
                        type: "danger"
                    }]
            }
        }
    })(jQuery, DevExpress);
    /*! Module framework, file framework.viewCache.js */
    (function($, DX, undefined) {
        var Class = DX.Class;
        DX.framework.ViewCache = Class.inherit({
            ctor: function(options) {
                this._cache = {};
                this.viewRemoved = $.Callbacks();
                this._callbacksToEvents("ViewCache", ["viewRemoved"])
            },
            setView: function(key, viewInfo) {
                this._cache[key] = viewInfo
            },
            getView: function(key) {
                return this._cache[key]
            },
            removeView: function(key) {
                var result = this._cache[key];
                if (result) {
                    delete this._cache[key];
                    this.fireEvent("viewRemoved", [{viewInfo: result}])
                }
                return result
            },
            clear: function() {
                var that = this;
                $.each(this._cache, function(key) {
                    that.removeView(key)
                })
            },
            hasView: function(key) {
                return key in this._cache
            }
        }).include(DX.EventsMixin);
        DX.framework.NullViewCache = DX.framework.ViewCache.inherit({setView: function(key, viewInfo) {
                this.callBase(key, viewInfo);
                this.removeView(key)
            }});
        DX.framework.ConditionalViewCacheDecorator = Class.inherit({
            ctor: function(options) {
                this._filter = options.filter;
                this._viewCache = options.viewCache;
                this.viewRemoved = this._viewCache.viewRemoved;
                this._events = this._viewCache._events
            },
            setView: function(key, viewInfo) {
                this._viewCache.setView(key, viewInfo);
                if (!this._filter(key, viewInfo))
                    this._viewCache.removeView(key)
            },
            getView: function(key) {
                return this._viewCache.getView(key)
            },
            removeView: function(key) {
                return this._viewCache.removeView(key)
            },
            clear: function() {
                return this._viewCache.clear()
            },
            hasView: function(key) {
                return this._viewCache.hasView(key)
            }
        }).include(DX.EventsMixin);
        var DEFAULT_VIEW_CACHE_CAPACITY = 10;
        DX.framework.CapacityViewCacheDecorator = Class.inherit({
            ctor: function(options) {
                this._keys = [];
                this._size = options.size || DEFAULT_VIEW_CACHE_CAPACITY;
                this._viewCache = options.viewCache;
                this.viewRemoved = this._viewCache.viewRemoved;
                this._events = this._viewCache._events
            },
            setView: function(key, viewInfo) {
                if (!this.hasView(key)) {
                    if (this._keys.length == this._size)
                        this.removeView(this._keys[0]);
                    this._keys.push(key)
                }
                this._viewCache.setView(key, viewInfo)
            },
            getView: function(key) {
                var index = $.inArray(key, this._keys);
                if (index < 0)
                    return null;
                this._keys.push(key);
                this._keys.splice(index, 1);
                return this._viewCache.getView(key)
            },
            removeView: function(key) {
                var index = $.inArray(key, this._keys);
                if (index > -1)
                    this._keys.splice(index, 1);
                return this._viewCache.removeView(key)
            },
            clear: function() {
                this._keys = [];
                return this._viewCache.clear()
            },
            hasView: function(key) {
                return this._viewCache.hasView(key)
            }
        }).include(DX.EventsMixin);
        DX.framework.HistoryDependentViewCacheDecorator = Class.inherit({
            ctor: function(options) {
                this._viewCache = options.viewCache || new DX.framework.ViewCache;
                this._navigationManager = options.navigationManager;
                this._navigationManager.on("itemRemoved", $.proxy(this._onNavigationItemRemoved, this));
                this.viewRemoved = this._viewCache.viewRemoved;
                this._events = this._viewCache._events
            },
            _onNavigationItemRemoved: function(item) {
                this.removeView(item.key)
            },
            setView: function(key, viewInfo) {
                this._viewCache.setView(key, viewInfo)
            },
            getView: function(key) {
                return this._viewCache.getView(key)
            },
            removeView: function(key) {
                return this._viewCache.removeView(key)
            },
            clear: function() {
                return this._viewCache.clear()
            },
            hasView: function(key) {
                return this._viewCache.hasView(key)
            }
        }).include(DX.EventsMixin)
    })(jQuery, DevExpress);
    /*! Module framework, file framework.stateManager.js */
    (function($, DX, undefined) {
        var Class = DX.Class;
        DX.framework.MemoryKeyValueStorage = Class.inherit({
            ctor: function() {
                this.storage = {}
            },
            getItem: function(key) {
                return this.storage[key]
            },
            setItem: function(key, value) {
                this.storage[key] = value
            },
            removeItem: function(key) {
                delete this.storage[key]
            }
        });
        DX.framework.StateManager = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this.storage = options.storage || new DX.framework.MemoryKeyValueStorage;
                this.stateSources = options.stateSources || []
            },
            addStateSource: function(stateSource) {
                this.stateSources.push(stateSource)
            },
            removeStateSource: function(stateSource) {
                var index = $.inArray(stateSource, this.stateSources);
                if (index > -1) {
                    this.stateSources.splice(index, 1);
                    stateSource.removeState(this.storage)
                }
            },
            saveState: function() {
                var that = this;
                $.each(this.stateSources, function(index, stateSource) {
                    stateSource.saveState(that.storage)
                })
            },
            restoreState: function() {
                var that = this;
                $.each(this.stateSources, function(index, stateSource) {
                    stateSource.restoreState(that.storage)
                })
            },
            clearState: function() {
                var that = this;
                $.each(this.stateSources, function(index, stateSource) {
                    stateSource.removeState(that.storage)
                })
            }
        })
    })(jQuery, DevExpress);
    /*! Module framework, file framework.browserAdapters.js */
    (function($, DX, undefined) {
        var Class = DX.Class;
        var ROOT_PAGE_URL = "__root__",
            BUGGY_ANDROID_BUFFER_PAGE_URL = "__buffer__";
        DX.framework.DefaultBrowserAdapter = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this._window = options.window || window;
                this.popState = $.Callbacks();
                $(this._window).on("hashchange", $.proxy(this._onHashChange, this));
                this._tasks = DX.createQueue();
                this.canWorkInPureBrowser = true
            },
            replaceState: function(uri) {
                var that = this;
                return this._addTask(function() {
                        uri = that._normalizeUri(uri);
                        that._window.history.replaceState(null, null, "#" + uri);
                        that._currentTask.resolve()
                    })
            },
            pushState: function(uri) {
                var that = this;
                return this._addTask(function() {
                        uri = that._normalizeUri(uri);
                        that._window.history.pushState(null, null, "#" + uri);
                        that._currentTask.resolve()
                    })
            },
            createRootPage: function() {
                return this.replaceState(ROOT_PAGE_URL)
            },
            _onHashChange: function() {
                if (this._currentTask)
                    this._currentTask.resolve();
                this.popState.fire()
            },
            back: function() {
                var that = this;
                return this._addTask(function() {
                        that._window.history.back()
                    })
            },
            getHash: function() {
                return this._normalizeUri(this._window.location.hash)
            },
            isRootPage: function() {
                return this.getHash() === ROOT_PAGE_URL
            },
            _normalizeUri: function(uri) {
                return (uri || "").replace(/^#+/, "")
            },
            _addTask: function(task) {
                var that = this,
                    d = $.Deferred();
                this._tasks.add(function() {
                    that._currentTask = d;
                    task();
                    return d
                });
                return d.promise()
            }
        });
        DX.framework.OldBrowserAdapter = DX.framework.DefaultBrowserAdapter.inherit({
            ctor: function() {
                this._innerEventCount = 0;
                this.callBase.apply(this, arguments);
                this._skipNextEvent = false
            },
            replaceState: function(uri) {
                var that = this;
                uri = that._normalizeUri(uri);
                if (that.getHash() !== uri) {
                    that._addTask(function() {
                        that._skipNextEvent = true;
                        that._window.history.back()
                    });
                    return that._addTask(function() {
                            that._skipNextEvent = true;
                            that._window.location.hash = uri
                        })
                }
                return $.Deferred().resolve().promise()
            },
            pushState: function(uri) {
                var that = this;
                uri = this._normalizeUri(uri);
                if (this.getHash() !== uri)
                    return that._addTask(function() {
                            that._skipNextEvent = true;
                            that._window.location.hash = uri
                        });
                return $.Deferred().resolve().promise()
            },
            createRootPage: function() {
                return this.pushState(ROOT_PAGE_URL)
            },
            _onHashChange: function() {
                var currentTask = this._currentTask;
                this._currentTask = null;
                if (this._skipNextEvent)
                    this._skipNextEvent = false;
                else
                    this.popState.fire();
                if (currentTask)
                    currentTask.resolve()
            }
        });
        DX.framework.BuggyAndroidBrowserAdapter = DX.framework.OldBrowserAdapter.inherit({createRootPage: function() {
                this.pushState(BUGGY_ANDROID_BUFFER_PAGE_URL);
                return this.callBase()
            }});
        DX.framework.HistorylessBrowserAdapter = DX.framework.DefaultBrowserAdapter.inherit({
            ctor: function(options) {
                options = options || {};
                this._window = options.window || window;
                this.popState = $.Callbacks();
                $(this._window).on("dxback", $.proxy(this._onHashChange, this));
                this._currentHash = this._window.location.hash
            },
            replaceState: function(uri) {
                this._currentHash = this._normalizeUri(uri);
                return $.Deferred().resolve().promise()
            },
            pushState: function(uri) {
                return this.replaceState(uri)
            },
            createRootPage: function() {
                return this.replaceState(ROOT_PAGE_URL)
            },
            getHash: function() {
                return this._normalizeUri(this._currentHash)
            },
            back: function() {
                return this.replaceState(ROOT_PAGE_URL)
            },
            _onHashChange: function() {
                var promise = this.back();
                this.popState.fire();
                return promise
            }
        });
        DX.framework.BuggyCordovaWP81BrowserAdapter = DX.framework.DefaultBrowserAdapter.inherit({ctor: function(options) {
                this.callBase(options);
                this.canWorkInPureBrowser = false
            }})
    })(jQuery, DevExpress);
    /*! Module framework, file framework.navigationDevices.js */
    (function($, DX, undefined) {
        var Class = DX.Class;
        var SESSION_KEY = "dxPhoneJSApplication";
        DX.framework.HistoryBasedNavigationDevice = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this._browserAdapter = options.browserAdapter || this._createBrowserAdapter(options);
                this.uriChanged = $.Callbacks();
                this._browserAdapter.popState.add($.proxy(this._onPopState, this))
            },
            init: $.noop,
            getUri: function() {
                return this._browserAdapter.getHash()
            },
            setUri: function(uri, replaceCurrent) {
                if (replaceCurrent)
                    return this._browserAdapter.replaceState(uri);
                else if (uri !== this.getUri())
                    return this._browserAdapter.pushState(uri);
                else
                    return $.Deferred().resolve().promise()
            },
            back: function() {
                return this._browserAdapter.back()
            },
            _onPopState: function() {
                this.uriChanged.fire(this.getUri())
            },
            _isBuggyAndroid2: function() {
                var realDevice = DX.devices.real();
                var version = realDevice.version;
                return realDevice.platform === "android" && version.length > 1 && (version[0] === 2 && version[1] < 4 || version[0] < 2)
            },
            _isBuggyAndroid4: function() {
                var realDevice = DX.devices.real();
                var version = realDevice.version;
                return realDevice.platform === "android" && version.length > 1 && version[0] === 4 && version[1] === 0
            },
            _isWindowsPhone8: function() {
                var realDevice = DX.devices.real();
                return realDevice.platform === "win8" && realDevice.phone
            },
            _createBrowserAdapter: function(options) {
                var sourceWindow = options.window || window,
                    supportPushReplace = sourceWindow.history.replaceState && sourceWindow.history.pushState,
                    result;
                if (this._isWindowsPhone8())
                    result = new DX.framework.BuggyCordovaWP81BrowserAdapter(options);
                else if (sourceWindow !== sourceWindow.top)
                    result = new DX.framework.HistorylessBrowserAdapter(options);
                else if (this._isBuggyAndroid4())
                    result = new DX.framework.BuggyAndroidBrowserAdapter(options);
                else if (this._isBuggyAndroid2() || !supportPushReplace)
                    result = new DX.framework.OldBrowserAdapter(options);
                else
                    result = new DX.framework.DefaultBrowserAdapter(options);
                return result
            }
        });
        DX.framework.StackBasedNavigationDevice = DX.framework.HistoryBasedNavigationDevice.inherit({
            ctor: function(options) {
                this.callBase(options);
                this.backInitiated = $.Callbacks();
                this._deferredNavigate = null;
                $(window).on("unload", this._saveBrowserState)
            },
            init: function() {
                var that = this;
                if (that._browserAdapter.canWorkInPureBrowser)
                    return that._initRootPage().done(function() {
                            if (that._browserAdapter.isRootPage())
                                that._browserAdapter.pushState("")
                        });
                else
                    return $.Deferred().resolve().promise()
            },
            setUri: function(uri) {
                return this.callBase(uri, !this._browserAdapter.isRootPage())
            },
            _saveBrowserState: function() {
                if (window.sessionStorage)
                    sessionStorage.setItem(SESSION_KEY, true)
            },
            _initRootPage: function() {
                var hash = this.getUri();
                if (!window.sessionStorage || sessionStorage.getItem(SESSION_KEY))
                    return $.Deferred().resolve().promise();
                sessionStorage.removeItem(SESSION_KEY);
                this._browserAdapter.createRootPage();
                return this._browserAdapter.pushState(hash)
            },
            _onPopState: function() {
                var navigationPending = this._deferredNavigate && this._deferredNavigate.state() === "pending";
                if (this._browserAdapter.isRootPage())
                    if (navigationPending)
                        this._deferredNavigate.resolve();
                    else
                        this.backInitiated.fire();
                else {
                    if (!navigationPending)
                        this._deferredNavigate = $.Deferred().done($.proxy(this.callBase, this));
                    this.back()
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module framework, file framework.navigationManager.js */
    (function($, DX, undefined) {
        var Class = DX.Class;
        var NAVIGATION_TARGETS = {
                current: "current",
                blank: "blank",
                back: "back"
            },
            STORAGE_HISTORY_KEY = "__history";
        DX.framework.HistoryBasedNavigationManager = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this._currentItem = undefined;
                this._previousItem = undefined;
                this.navigating = $.Callbacks();
                this.navigated = $.Callbacks();
                this.navigationCanceled = $.Callbacks();
                this.navigatingBack = $.Callbacks();
                this.itemRemoved = $.Callbacks();
                this._callbacksToEvents("DefaultLayoutController", ["navigating", "navigated", "navigationCanceled", "navigatingBack", "itemRemoved"]);
                this._createNavigationDevice(options)
            },
            _createNavigationDevice: function(options) {
                this._navigationDevice = options.navigationDevice || new DX.framework.HistoryBasedNavigationDevice;
                this._navigationDevice.uriChanged.add($.proxy(this._uriChangedHandler, this))
            },
            _uriChangedHandler: function(uri) {
                while (DX.hideTopOverlayCallback.fire());
                this.navigate(uri, {target: "none"})
            },
            _cancelNavigation: function(args) {
                this.fireEvent("navigationCanceled", [args])
            },
            _getDefaultOptions: function() {
                return {
                        direction: "none",
                        target: NAVIGATION_TARGETS.blank
                    }
            },
            _updateHistory: function(uri, options) {
                this._previousItem = this._currentItem;
                this._currentItem = {
                    uri: uri,
                    key: uri
                };
                if (options.target !== "none")
                    this._navigationDevice.setUri(uri, options.target === "current")
            },
            _setCurrentItem: function(item) {
                this._currentItem = item
            },
            navigate: function(uri, options) {
                options = options || {};
                var that = this,
                    currentItem = that._currentItem || {},
                    targetItem = options.item || {},
                    currentUri = currentItem.uri,
                    currentKey = currentItem.key,
                    targetKey = targetItem.key,
                    args;
                if (uri === undefined)
                    uri = that._navigationDevice.getUri();
                if (/^_back$/.test(uri)) {
                    that.back();
                    return
                }
                options = $.extend(that._getDefaultOptions(), options || {});
                args = {
                    currentUri: currentUri,
                    uri: uri,
                    cancel: false,
                    navigateWhen: [],
                    options: options
                };
                that.fireEvent("navigating", [args]);
                uri = args.uri;
                if (args.cancel || currentUri === uri && (targetKey === undefined || targetKey === currentKey) && !that._forceNavigate)
                    that._cancelNavigation(args);
                else {
                    that._forceNavigate = false;
                    $.when.apply($, args.navigateWhen).done(function() {
                        DX.utils.executeAsync(function() {
                            that._updateHistory(uri, options);
                            that.fireEvent("navigated", [{
                                    uri: uri,
                                    previousUri: currentUri,
                                    options: options,
                                    item: that._currentItem
                                }])
                        })
                    })
                }
            },
            back: function() {
                return this._navigationDevice.back()
            },
            previousItem: function() {
                return this._previousItem
            },
            currentItem: function(item) {
                if (arguments.length > 0) {
                    if (!item)
                        throw DX.Error("E3023");
                    this._setCurrentItem(item)
                }
                else
                    return this._currentItem
            },
            rootUri: function() {
                return this._currentItem && this._currentItem.uri
            },
            canBack: function() {
                return true
            },
            saveState: $.noop,
            restoreState: $.noop,
            removeState: $.noop
        }).include(DX.EventsMixin);
        DX.framework.StackBasedNavigationManager = DX.framework.HistoryBasedNavigationManager.inherit({
            ctor: function(options) {
                options = options || {};
                this.callBase(options);
                this._createNavigationStacks(options);
                DX.hardwareBackButton.add($.proxy(this._deviceBackInitiated, this));
                this._stateStorageKey = options.stateStorageKey || STORAGE_HISTORY_KEY
            },
            init: function() {
                return this._navigationDevice.init()
            },
            _createNavigationDevice: function(options) {
                if (!options.navigationDevice)
                    options.navigationDevice = new DX.framework.StackBasedNavigationDevice;
                this.callBase(options);
                this._navigationDevice.backInitiated.add($.proxy(this._deviceBackInitiated, this))
            },
            _uriChangedHandler: function(uri) {
                this.navigate(uri)
            },
            _createNavigationStacks: function(options) {
                this.navigationStacks = {};
                this._keepPositionInStack = options.keepPositionInStack;
                this.currentStack = new DX.framework.NavigationStack
            },
            _deviceBackInitiated: function() {
                if (!DX.hideTopOverlayCallback.fire())
                    this.back({isHardwareButton: true});
                else
                    this._syncUriWithCurrentNavigationItem()
            },
            _syncUriWithCurrentNavigationItem: function() {
                var currentUri = this._currentItem && this._currentItem.uri;
                this._navigationDevice.setUri(currentUri)
            },
            _cancelNavigation: function(args) {
                this._syncUriWithCurrentNavigationItem();
                this.callBase(args)
            },
            _getDefaultOptions: function() {
                return {target: NAVIGATION_TARGETS.blank}
            },
            _createNavigationStack: function() {
                var result = new DX.framework.NavigationStack;
                result.itemsRemoved.add($.proxy(this._removeItems, this));
                return result
            },
            _setCurrentItem: function(item) {
                this._setCurrentStack(item.stack);
                this.currentStack.currentItem(item);
                this.callBase(item);
                this._syncUriWithCurrentNavigationItem()
            },
            _setCurrentStack: function(stackOrStackKey) {
                var stack,
                    stackKey;
                if (typeof stackOrStackKey === "string") {
                    stackKey = stackOrStackKey;
                    if (!(stackKey in this.navigationStacks))
                        this.navigationStacks[stackKey] = this._createNavigationStack();
                    stack = this.navigationStacks[stackKey]
                }
                else {
                    stack = stackOrStackKey;
                    stackKey = $.map(this.navigationStacks, function(stack, key) {
                        if (stack === stackOrStackKey)
                            return key;
                        return null
                    })[0]
                }
                this.currentStack = stack;
                this.currentStackKey = stackKey
            },
            _updateHistory: function(uri, options) {
                var isRoot = options.root,
                    forceIsRoot = isRoot,
                    forceToRoot = false,
                    stackKey = options.stack || (isRoot ? uri : this.currentStackKey || uri),
                    previousStack = this.currentStack,
                    keepPositionInStack = options.keepPositionInStack !== undefined ? options.keepPositionInStack : this._keepPositionInStack;
                this._setCurrentStack(stackKey);
                if (isRoot || !this.currentStack.items.length) {
                    forceToRoot = this.currentStack === previousStack;
                    forceIsRoot = true
                }
                if (isRoot && this.currentStack.items.length) {
                    if (!keepPositionInStack || forceToRoot) {
                        this.currentStack.currentIndex = 0;
                        if (this.currentItem().uri !== uri)
                            this.currentStack.navigate(uri, true)
                    }
                }
                else {
                    var prevIndex = this.currentStack.currentIndex,
                        prevItem = this.currentItem() || {};
                    switch (options.target) {
                        case NAVIGATION_TARGETS.blank:
                            this.currentStack.navigate(uri);
                            break;
                        case NAVIGATION_TARGETS.current:
                            this.currentStack.navigate(uri, true);
                            break;
                        case NAVIGATION_TARGETS.back:
                            if (this.currentStack.currentIndex > 0)
                                this.currentStack.back(uri);
                            else
                                this.currentStack.navigate(uri, true);
                            break;
                        default:
                            throw DX.Error("E3006", options.target);
                    }
                    if (options.direction === undefined) {
                        var indexDelta = this.currentStack.currentIndex - prevIndex;
                        if (indexDelta < 0)
                            options.direction = this.currentStack.currentItem().backDirection || "backward";
                        else if (indexDelta > 0 && this.currentStack.currentIndex > 0)
                            options.direction = "forward";
                        else
                            options.direction = "none"
                    }
                    prevItem.backDirection = options.direction === "forward" ? "backward" : "none"
                }
                options.root = forceIsRoot;
                this._currentItem = this.currentStack.currentItem();
                this._syncUriWithCurrentNavigationItem()
            },
            _removeItems: function(items) {
                var that = this;
                $.each(items, function(index, item) {
                    that.fireEvent("itemRemoved", [item])
                })
            },
            back: function(options) {
                options = options || {};
                var navigatingBackArgs = $.extend({cancel: false}, options);
                this.fireEvent("navigatingBack", [navigatingBackArgs]);
                if (navigatingBackArgs.cancel) {
                    this._syncUriWithCurrentNavigationItem();
                    return
                }
                var item = this.previousItem(navigatingBackArgs.stack);
                if (item)
                    this.navigate(item.uri, {
                        stack: navigatingBackArgs.stack,
                        target: NAVIGATION_TARGETS.back,
                        item: item
                    });
                else
                    this.callBase()
            },
            rootUri: function() {
                return this.currentStack.items.length ? this.currentStack.items[0].uri : this.callBase()
            },
            canBack: function(stackKey) {
                var stack = stackKey ? this.navigationStacks[stackKey] : this.currentStack;
                return stack.canBack()
            },
            saveState: function(storage) {
                if (this.currentStack.items.length) {
                    var state = {
                            items: $.map(this.currentStack.items, function(item) {
                                return {
                                        key: item.key,
                                        uri: item.uri
                                    }
                            }),
                            currentIndex: this.currentStack.currentIndex,
                            currentStackKey: this.currentStack.items[0].uri
                        };
                    var json = JSON.stringify(state);
                    storage.setItem(this._stateStorageKey, json)
                }
                else
                    this.removeState(storage)
            },
            restoreState: function(storage) {
                if (this.disableRestoreState)
                    return;
                var json = storage.getItem(this._stateStorageKey);
                if (json)
                    try {
                        var state = JSON.parse(json),
                            stack = this._createNavigationStack();
                        if (!state.items[0].uri)
                            throw DX.Error("E3007");
                        stack.items = $.map(state.items, function(item) {
                            item.stack = stack;
                            return item
                        });
                        stack.currentIndex = state.currentIndex;
                        this.navigationStacks[stack.items[0].uri] = stack;
                        this.currentStackKey = state.currentStackKey;
                        this.currentStack = this.navigationStacks[this.currentStackKey];
                        this._currentItem = this.currentStack.currentItem();
                        this._navigationDevice.setUri(this.currentItem().uri);
                        this._forceNavigate = true
                    }
                    catch(e) {
                        this.removeState(storage);
                        throw e;
                    }
            },
            removeState: function(storage) {
                storage.removeItem(this._stateStorageKey)
            },
            currentIndex: function() {
                return this.currentStack.currentIndex
            },
            previousItem: function(stackKey) {
                var stack = stackKey ? this.navigationStacks[stackKey] : this.currentStack;
                return stack.previousItem()
            },
            getItemByIndex: function(index) {
                return this.currentStack.items[index]
            },
            clearHistory: function() {
                this.currentStack.clear()
            },
            itemByKey: function(itemKey) {
                var result;
                $.each(this.navigationStacks, function(stackKey, stack) {
                    var item = stack.itemByKey(itemKey);
                    if (item) {
                        result = item;
                        return false
                    }
                });
                return result
            },
            currentItem: function(itemOrItemKey) {
                var item;
                if (arguments.length > 0) {
                    if (typeof itemOrItemKey === "string")
                        item = this.itemByKey(itemOrItemKey);
                    else if ($.isPlainObject(itemOrItemKey))
                        item = itemOrItemKey;
                    this.callBase(item)
                }
                else
                    return this.callBase()
            }
        });
        DX.framework.NavigationStack = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this.itemsRemoved = $.Callbacks();
                this.clear()
            },
            currentItem: function(item) {
                if (item) {
                    for (var i = 0; i < this.items.length; i++)
                        if (item === this.items[i]) {
                            this.currentIndex = i;
                            break
                        }
                }
                else
                    return this.items[this.currentIndex]
            },
            previousItem: function() {
                return this.items.length > 1 ? this.items[this.currentIndex - 1] : undefined
            },
            canBack: function() {
                return this.currentIndex > 0
            },
            clear: function() {
                this._deleteItems(this.items);
                this.items = [];
                this.currentIndex = -1
            },
            back: function(uri) {
                this.currentIndex--;
                if (this.currentIndex < 0)
                    throw DX.Error("E3008");
                var currentItem = this.currentItem();
                if (currentItem.uri !== uri)
                    this._updateItem(this.currentIndex, uri)
            },
            forward: function() {
                this.currentIndex++;
                if (this.currentIndex >= this.items.length)
                    throw DX.Error("E3009");
            },
            navigate: function(uri, replaceCurrent) {
                if (this.currentIndex < this.items.length && this.currentIndex > -1 && this.items[this.currentIndex].uri === uri)
                    return;
                if (replaceCurrent && this.currentIndex > -1)
                    this.currentIndex--;
                if (this.currentIndex + 1 < this.items.length && this.items[this.currentIndex + 1].uri === uri)
                    this.currentIndex++;
                else {
                    var toDelete = this.items.splice(this.currentIndex + 1, this.items.length - this.currentIndex - 1);
                    this.items.push({stack: this});
                    this.currentIndex++;
                    this._updateItem(this.currentIndex, uri);
                    this._deleteItems(toDelete)
                }
                return this.currentItem()
            },
            itemByKey: function(key) {
                for (var i = 0; i < this.items.length; i++) {
                    var item = this.items[i];
                    if (item.key === key)
                        return item
                }
            },
            _updateItem: function(index, uri) {
                var item = this.items[index];
                item.uri = uri;
                item.key = this.items[0].uri + "_" + index + "_" + uri
            },
            _deleteItems: function(items) {
                if (items)
                    this.itemsRemoved.fire(items)
            }
        });
        DX.framework.HistoryBasedNavigationManager.NAVIGATION_TARGETS = NAVIGATION_TARGETS
    })(jQuery, DevExpress);
    /*! Module framework, file framework.actionExecutors.js */
    (function($, DX, undefined) {
        function prepareNavigateOptions(options, actionArguments) {
            if (actionArguments.args) {
                var sourceEventArguments = actionArguments.args[0];
                options.jQueryEvent = sourceEventArguments.jQueryEvent
            }
            if ((actionArguments.component || {}).NAME === "dxCommand")
                $.extend(options, actionArguments.component.option())
        }
        DX.framework.createActionExecutors = function(app) {
            return {
                    routing: {execute: function(e) {
                            var action = e.action,
                                options = {},
                                routeValues,
                                uri;
                            if ($.isPlainObject(action)) {
                                routeValues = action.routeValues;
                                if (routeValues && $.isPlainObject(routeValues))
                                    options = action.options;
                                else
                                    routeValues = action;
                                uri = app.router.format(routeValues);
                                prepareNavigateOptions(options, e);
                                app.navigate(uri, options);
                                e.handled = true
                            }
                        }},
                    hash: {execute: function(e) {
                            if (typeof e.action !== "string" || e.action.charAt(0) !== "#")
                                return;
                            var uriTemplate = e.action.substr(1),
                                args = e.args[0],
                                uri = uriTemplate;
                            var defaultEvaluate = function(expr) {
                                    var getter = DX.data.utils.compileGetter(expr),
                                        model = e.args[0].model;
                                    return getter(model)
                                };
                            var evaluate = args.evaluate || defaultEvaluate;
                            uri = uriTemplate.replace(/\{([^}]+)\}/g, function(entry, expr) {
                                expr = $.trim(expr);
                                if (expr.indexOf(",") > -1)
                                    expr = $.map(expr.split(","), $.trim);
                                var value = evaluate(expr);
                                if (value === undefined)
                                    value = "";
                                value = DX.framework.Route.prototype.formatSegment(value);
                                return value
                            });
                            var options = {};
                            prepareNavigateOptions(options, e);
                            app.navigate(uri, options);
                            e.handled = true
                        }}
                }
        }
    })(jQuery, DevExpress);
    /*! Module framework, file framework.application.js */
    (function($, DX) {
        var Class = DX.Class,
            BACK_COMMAND_TITLE,
            INIT_IN_PROGRESS = "InProgress",
            INIT_COMPLETE = "Inited",
            frameworkNS = DX.framework;
        DX.framework.Application = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this._options = options;
                this.namespace = options.namespace || options.ns || window;
                this._applicationMode = options.mode ? options.mode : "mobileApp";
                this.components = [];
                BACK_COMMAND_TITLE = DX.localization.localizeString("@Back");
                this.router = options.router || new DX.framework.Router;
                var navigationManagers = {
                        mobileApp: DX.framework.StackBasedNavigationManager,
                        webSite: DX.framework.HistoryBasedNavigationManager
                    };
                this.navigationManager = options.navigationManager || new navigationManagers[this._applicationMode]({keepPositionInStack: options.navigateToRootViewMode === "keepHistory"});
                this.navigationManager.on("navigating", $.proxy(this._onNavigating, this));
                this.navigationManager.on("navigatingBack", $.proxy(this._onNavigatingBack, this));
                this.navigationManager.on("navigated", $.proxy(this._onNavigated, this));
                this.navigationManager.on("navigationCanceled", $.proxy(this._onNavigationCanceled, this));
                this.stateManager = options.stateManager || new DX.framework.StateManager({storage: options.stateStorage || sessionStorage});
                this.stateManager.addStateSource(this.navigationManager);
                this.viewCache = this._createViewCache(options);
                this.commandMapping = this._createCommandMapping(options.commandMapping);
                this.createNavigation(options.navigation);
                this.beforeViewSetup = $.Callbacks();
                this.afterViewSetup = $.Callbacks();
                this.viewShowing = $.Callbacks();
                this.viewShown = $.Callbacks();
                this.viewHidden = $.Callbacks();
                this.viewDisposing = $.Callbacks();
                this.viewDisposed = $.Callbacks();
                this.navigating = $.Callbacks();
                this.navigatingBack = $.Callbacks();
                this.initialized = $.Callbacks();
                this._callbacksToEvents("HtmlApplication", ["beforeViewSetup", "afterViewSetup", "viewShowing", "viewShown", "viewHidden", "viewDisposing", "viewDisposed", "navigating", "navigatingBack", "initialized"]);
                this._isNavigating = false;
                this._viewLinksHash = {};
                DX.registerActionExecutor(DX.framework.createActionExecutors(this));
                this.components.push(this.router);
                this.components.push(this.navigationManager)
            },
            _createViewCache: function(options) {
                var result;
                if (options.viewCache)
                    result = options.viewCache;
                else if (options.disableViewCache)
                    result = new DX.framework.NullViewCache;
                else
                    result = new DX.framework.CapacityViewCacheDecorator({
                        size: options.viewCacheSize,
                        viewCache: new DX.framework.ViewCache
                    });
                result.on("viewRemoved", $.proxy(function(e) {
                    this._releaseViewLink(e.viewInfo)
                }, this));
                return result
            },
            _createCommandMapping: function(commandMapping) {
                var result = commandMapping;
                if (!(commandMapping instanceof DX.framework.CommandMapping)) {
                    result = new DX.framework.CommandMapping;
                    result.load(DX.framework.CommandMapping.defaultMapping || {}).load(commandMapping || {})
                }
                return result
            },
            createNavigation: function(navigationConfig) {
                this.navigation = this._createNavigationCommands(navigationConfig);
                this._mapNavigationCommands(this.navigation, this.commandMapping)
            },
            _createNavigationCommands: function(commandConfig) {
                if (!commandConfig)
                    return [];
                var that = this,
                    generatedIdCount = 0;
                return $.map(commandConfig, function(item) {
                        var command;
                        if (item instanceof frameworkNS.dxCommand)
                            command = item;
                        else
                            command = new frameworkNS.dxCommand($.extend({root: true}, item));
                        if (!command.option("id"))
                            command.option("id", "navigation_" + generatedIdCount++);
                        return command
                    })
            },
            _mapNavigationCommands: function(navigationCommands, commandMapping) {
                var navigationCommandIds = $.map(navigationCommands, function(command) {
                        return command.option("id")
                    });
                commandMapping.mapCommands("global-navigation", navigationCommandIds)
            },
            _callComponentMethod: function(methodName, args) {
                var tasks = [];
                $.each(this.components, function(index, component) {
                    if (component[methodName] && $.isFunction(component[methodName])) {
                        var result = component[methodName](args);
                        if (result && result.done)
                            tasks.push(result)
                    }
                });
                return $.when.apply($, tasks)
            },
            init: function() {
                var that = this;
                that._initState = INIT_IN_PROGRESS;
                return that._callComponentMethod("init").done(function() {
                        that._initState = INIT_COMPLETE;
                        that._processEvent("initialized")
                    }).fail(function(error) {
                        throw error || DX.Error("E3022");
                    })
            },
            _onNavigatingBack: function(args) {
                this._processEvent("navigatingBack", args)
            },
            _onNavigating: function(args) {
                var that = this;
                if (that._isNavigating) {
                    that._pendingNavigationArgs = args;
                    args.cancel = true;
                    return
                }
                else {
                    that._isNavigating = true;
                    delete that._pendingNavigationArgs
                }
                var routeData = this.router.parse(args.uri);
                if (!routeData)
                    throw DX.Error("E3001", args.uri);
                var uri = this.router.format(routeData);
                if (args.uri !== uri && uri) {
                    args.cancel = true;
                    DX.utils.executeAsync(function() {
                        that.navigate(uri, args.options)
                    })
                }
                else
                    that._processEvent("navigating", args)
            },
            _onNavigated: function(args) {
                var that = this,
                    direction = args.options.direction,
                    deferred = $.Deferred(),
                    viewInfo = that._acquireViewInfo(args.item, args.options);
                if (!that._isViewReadyToShow(viewInfo))
                    that._setViewLoadingState(viewInfo, direction).done(function() {
                        DX.utils.executeAsync(function() {
                            that._createViewModel(viewInfo);
                            that._createViewCommands(viewInfo);
                            deferred.resolve()
                        })
                    }).fail(function() {
                        that._isNavigating = false;
                        deferred.reject()
                    });
                else
                    deferred.resolve();
                deferred.done(function() {
                    that._highlightCurrentNavigationCommand(viewInfo);
                    that._showView(viewInfo, direction).always(function() {
                        that._isNavigating = false;
                        var pendingArgs = that._pendingNavigationArgs;
                        if (pendingArgs)
                            DX.utils.executeAsync(function() {
                                that.navigate(pendingArgs.uri, pendingArgs.options)
                            })
                    })
                })
            },
            _isViewReadyToShow: function(viewInfo) {
                return !!viewInfo.model
            },
            _onNavigationCanceled: function(args) {
                var that = this;
                if (!that._pendingNavigationArgs || that._pendingNavigationArgs.uri !== args.uri) {
                    var currentItem = that.navigationManager.currentItem();
                    if (currentItem)
                        DX.utils.executeAsync(function() {
                            var viewInfo = that._acquireViewInfo(currentItem, args.options);
                            that._highlightCurrentNavigationCommand(viewInfo)
                        });
                    that._isNavigating = false
                }
            },
            _disposeRemovedViews: function() {
                var that = this,
                    args;
                $.each(that._viewLinksHash, function(key, link) {
                    if (!link.linkCount) {
                        args = {viewInfo: link.viewInfo};
                        that._processEvent("viewDisposing", args, args.viewInfo.model);
                        that._disposeView(link.viewInfo);
                        that._processEvent("viewDisposed", args, args.viewInfo.model);
                        delete that._viewLinksHash[key]
                    }
                })
            },
            _onViewHidden: function(viewInfo) {
                var args = {viewInfo: viewInfo};
                this._processEvent("viewHidden", args, args.viewInfo.model)
            },
            _disposeView: function(viewInfo) {
                var commands = viewInfo.commands || [];
                $.each(commands, function(index, command) {
                    command._dispose()
                })
            },
            _acquireViewInfo: function(navigationItem, navigateOptions) {
                var viewInfo = this.viewCache.getView(navigationItem.key);
                if (!viewInfo) {
                    viewInfo = this._createViewInfo(navigationItem, navigateOptions);
                    this._obtainViewLink(viewInfo);
                    this.viewCache.setView(navigationItem.key, viewInfo)
                }
                return viewInfo
            },
            _processEvent: function(eventName, args, model) {
                this._callComponentMethod(eventName, args);
                this.fireEvent(eventName, [args]);
                var modelMethod = (model || {})[eventName];
                if (modelMethod)
                    modelMethod.call(model, args)
            },
            _createViewInfo: function(navigationItem, navigateOptions) {
                var uri = navigationItem.uri,
                    routeData = this.router.parse(uri);
                var viewInfo = {
                        viewName: routeData.view,
                        routeData: routeData,
                        uri: uri,
                        key: navigationItem.key,
                        canBack: this.canBack(),
                        navigateOptions: navigateOptions,
                        previousViewInfo: this._getPreviousViewInfo(navigateOptions)
                    };
                return viewInfo
            },
            _createViewModel: function(viewInfo) {
                this._processEvent("beforeViewSetup", {viewInfo: viewInfo});
                viewInfo.model = viewInfo.model || this._callViewCodeBehind(viewInfo);
                this._processEvent("afterViewSetup", {viewInfo: viewInfo})
            },
            _createViewCommands: function(viewInfo) {
                viewInfo.commands = viewInfo.model.commands || [];
                if (viewInfo.canBack && this._applicationMode !== "webSite")
                    this._appendBackCommand(viewInfo)
            },
            _callViewCodeBehind: function(viewInfo) {
                var setupFunc = $.noop,
                    routeData = viewInfo.routeData;
                if (routeData.view in this.namespace)
                    setupFunc = this.namespace[routeData.view];
                return setupFunc.call(this.namespace, routeData, viewInfo) || {}
            },
            _appendBackCommand: function(viewInfo) {
                var commands = viewInfo.commands,
                    that = this,
                    stackKey = this.navigationManager.currentStackKey,
                    backTitle = BACK_COMMAND_TITLE;
                if (that._options.useViewTitleAsBackText)
                    backTitle = ((viewInfo.previousViewInfo || {}).model || {}).title || backTitle;
                var toMergeTo = [new DX.framework.dxCommand({
                            id: "back",
                            title: backTitle,
                            behavior: "back",
                            onExecute: function() {
                                that.back({stack: stackKey})
                            },
                            icon: "arrowleft",
                            type: "back"
                        })];
                var result = DX.framework.utils.mergeCommands(toMergeTo, commands);
                commands.length = 0;
                commands.push.apply(commands, result)
            },
            _showView: function(viewInfo, direction) {
                var that = this;
                var eventArgs = {
                        viewInfo: viewInfo,
                        direction: direction
                    };
                that._processEvent("viewShowing", eventArgs, viewInfo.model);
                return that._showViewImpl(eventArgs.viewInfo, eventArgs.direction).done(function() {
                        DX.utils.executeAsync(function() {
                            that._processEvent("viewShown", eventArgs, viewInfo.model);
                            that._disposeRemovedViews()
                        })
                    })
            },
            _highlightCurrentNavigationCommand: function(viewInfo) {
                var that = this,
                    selectedCommand,
                    currentUri = viewInfo.uri,
                    currentNavigationItemId = viewInfo.model && viewInfo.model.currentNavigationItemId;
                if (currentNavigationItemId !== undefined)
                    $.each(this.navigation, function(index, command) {
                        if (command.option("id") === currentNavigationItemId) {
                            selectedCommand = command;
                            return false
                        }
                    });
                if (!selectedCommand)
                    $.each(this.navigation, function(index, command) {
                        var commandUri = command.option("onExecute");
                        if (DX.utils.isString(commandUri)) {
                            commandUri = commandUri.replace(/^#+/, "");
                            if (commandUri === that.navigationManager.rootUri()) {
                                selectedCommand = command;
                                return false
                            }
                        }
                    });
                $.each(this.navigation, function(index, command) {
                    if (command === selectedCommand && command.option("highlighted"))
                        command.fireEvent("optionChanged", [{
                                name: "highlighted",
                                value: true,
                                previousValue: true
                            }]);
                    command.option("highlighted", command === selectedCommand)
                })
            },
            _setViewLoadingState: DX.abstract,
            _showViewImpl: DX.abstract,
            _obtainViewLink: function(viewInfo) {
                var key = viewInfo.key;
                if (!this._viewLinksHash[key])
                    this._viewLinksHash[key] = {
                        viewInfo: viewInfo,
                        linkCount: 1
                    };
                else
                    this._viewLinksHash[key].linkCount++
            },
            _releaseViewLink: function(viewInfo) {
                if (this._viewLinksHash[viewInfo.key] === undefined)
                    DX.log("W3001", viewInfo.key);
                if (this._viewLinksHash[viewInfo.key].linkCount === 0)
                    DX.log("W3002", viewInfo.key);
                this._viewLinksHash[viewInfo.key].linkCount--
            },
            navigate: function(uri, options) {
                var that = this;
                if ($.isPlainObject(uri)) {
                    uri = that.router.format(uri);
                    if (uri === false)
                        throw DX.Error("E3002");
                }
                if (!that._initState)
                    that.init().done(function() {
                        that.restoreState();
                        that.navigate(uri, options)
                    });
                else if (that._initState === INIT_COMPLETE)
                    that.navigationManager.navigate(uri, options);
                else
                    throw DX.Error("E3003");
            },
            canBack: function(stackKey) {
                return this.navigationManager.canBack(stackKey)
            },
            _getPreviousViewInfo: function(navigateOptions) {
                var previousNavigationItem = this.navigationManager.previousItem(navigateOptions.stack),
                    result;
                if (previousNavigationItem)
                    result = this.viewCache.getView(previousNavigationItem.key);
                return result
            },
            back: function(options) {
                this.navigationManager.back(options)
            },
            saveState: function() {
                this.stateManager.saveState()
            },
            restoreState: function() {
                this.stateManager.restoreState()
            },
            clearState: function() {
                this.stateManager.clearState()
            }
        }).include(DX.EventsMixin)
    })(jQuery, DevExpress);
    /*! Module framework, file framework.html.js */
    (function($, DX, undefined) {
        DX.framework.html = {
            layoutControllers: [],
            layoutSets: {}
        }
    })(jQuery, DevExpress);
    /*! Module framework, file framework.widgetCommandAdapters.js */
    (function($, DX) {
        var commandToContainer = DX.framework.utils.commandToContainer,
            DX_COMMAND_TO_WIDGET_ADAPTER = "dxCommandToWidgetAdapter";
        var WidgetItemWrapperBase = DX.Class.inherit({
                ctor: function(command, containerOptions) {
                    this.command = command;
                    this.containerOptions = containerOptions;
                    this._createWidgetItem(command, containerOptions);
                    this._commandChangedHandler = $.proxy(this._onCommandChanged, this);
                    command.on("optionChanged", this._commandChangedHandler)
                },
                _createWidgetItem: function(command, containerOptions) {
                    this.widgetItem = $.extend({
                        command: command,
                        containerOptions: containerOptions
                    }, containerOptions, command.option());
                    this._updateItem()
                },
                _onCommandChanged: function(args) {
                    var optionName = args.name,
                        newValue = args.value,
                        oldValue = args.previousValue;
                    this.widgetItem[optionName] = newValue;
                    this._updateItem(optionName, newValue, oldValue)
                },
                _updateItem: function(optionName, newValue, oldValue){},
                dispose: function() {
                    if (this.command)
                        this.command.off("optionChanged", this._commandChangedHandler);
                    delete this.command;
                    delete this.containerOptions;
                    delete this.widgetItem;
                    delete this.updateItemHandler
                }
            });
        var WidgetAdapterBase = DX.Class.inherit({
                ctor: function($widgetElement) {
                    this.$widgetElement = $widgetElement;
                    this.$widgetElement.data(DX_COMMAND_TO_WIDGET_ADAPTER, this);
                    this.widget = this._getWidgetByElement($widgetElement);
                    this._widgetDisposingHandler = $.proxy(this._onWidgetDisposing, this);
                    this.widget.on("disposing", this._widgetDisposingHandler);
                    this.itemWrappers = []
                },
                addCommand: function(command, containerOptions) {
                    var itemWrapper = this._createItemWrapper(command, containerOptions);
                    this.itemWrappers.push(itemWrapper);
                    this._addItemToWidget(itemWrapper);
                    this.refresh();
                    this._commandChangedHandler = $.proxy(this._onCommandChanged, this);
                    itemWrapper.command.on("optionChanged", this._commandChangedHandler)
                },
                beginUpdate: function() {
                    this.widget.beginUpdate()
                },
                endUpdate: function() {
                    this.widget.endUpdate()
                },
                _onWidgetDisposing: function() {
                    this.dispose(true)
                },
                _onCommandChanged: function(args) {
                    if (args.name !== "highlighted")
                        this.refresh()
                },
                _addItemToWidget: function(itemWrapper) {
                    var items = this.widget.option("items");
                    items.push(itemWrapper.widgetItem)
                },
                refresh: function() {
                    var items = this.widget.option("items");
                    this.widget.option("items", items)
                },
                clear: function(widgetDisposing) {
                    var that = this;
                    $.each(that.itemWrappers, function(index, itemWrapper) {
                        itemWrapper.command.off("optionChanged", that._commandChangedHandler);
                        itemWrapper.dispose()
                    });
                    this.itemWrappers.length = 0;
                    if (!widgetDisposing)
                        this._clearWidgetItems()
                },
                _clearWidgetItems: function() {
                    this.widget.option("items", [])
                },
                dispose: function(widgetDisposing) {
                    this.clear(widgetDisposing);
                    if (this.widget) {
                        this.widget.off("disposing", this._widgetDisposingHandler);
                        this.$widgetElement.removeData(DX_COMMAND_TO_WIDGET_ADAPTER);
                        delete this.widget;
                        delete this.$widgetElement
                    }
                }
            });
        var CommandToWidgetAdapter = DX.Class.inherit({
                ctor: function(createAdapter) {
                    this.createAdapter = createAdapter
                },
                _getWidgetAdapter: function($container) {
                    var widgetAdapter = $container.data(DX_COMMAND_TO_WIDGET_ADAPTER);
                    if (!widgetAdapter)
                        widgetAdapter = this.createAdapter($container);
                    return widgetAdapter
                },
                addCommand: function($container, command, containerOptions) {
                    var widgetAdapter = this._getWidgetAdapter($container);
                    widgetAdapter.addCommand(command, containerOptions)
                },
                clearContainer: function($container) {
                    var widgetAdapter = this._getWidgetAdapter($container);
                    widgetAdapter.clear()
                },
                beginUpdate: function($container) {
                    var widgetAdapter = this._getWidgetAdapter($container);
                    widgetAdapter.beginUpdate()
                },
                endUpdate: function($container) {
                    var widgetAdapter = this._getWidgetAdapter($container);
                    widgetAdapter.endUpdate()
                }
            });
        var dxToolbarItemWrapper = WidgetItemWrapperBase.inherit({_updateItem: function() {
                    var widgetItem = this.widgetItem,
                        command = this.command,
                        containerOptions = this.containerOptions,
                        location = commandToContainer.resolvePropertyValue(command, containerOptions, "location"),
                        optionsTarget;
                    widgetItem.location = location;
                    if (location === "menu")
                        optionsTarget = widgetItem;
                    else {
                        optionsTarget = $.extend({}, widgetItem);
                        widgetItem.options = optionsTarget;
                        widgetItem.widget = "button"
                    }
                    optionsTarget.text = commandToContainer.resolveTextValue(command, containerOptions);
                    optionsTarget.disabled = command.option("disabled");
                    optionsTarget.icon = commandToContainer.resolveIconValue(command, containerOptions, "icon");
                    optionsTarget.iconSrc = commandToContainer.resolveIconValue(command, containerOptions, "iconSrc");
                    optionsTarget.type = commandToContainer.resolveTypeValue(command, containerOptions)
                }});
        var dxToolbarAdapter = WidgetAdapterBase.inherit({
                ctor: function($widgetElement) {
                    this.callBase($widgetElement);
                    this.widget.option("onItemClick", $.proxy(this._onToolbarItemClick, this))
                },
                _onToolbarItemClick: function(e) {
                    if (e.itemData.command)
                        e.itemData.command.execute(e)
                },
                _getWidgetByElement: function($element) {
                    return $element.dxToolbar("instance")
                },
                _createItemWrapper: function(command, containerOptions) {
                    return new dxToolbarItemWrapper(command, containerOptions)
                },
                addCommand: function(command, containerOptions) {
                    this.callBase(command, containerOptions);
                    this.widget.option("visible", true)
                }
            });
        var dxActionSheetItemWrapper = WidgetItemWrapperBase.inherit({_updateItem: function() {
                    var widgetItem = this.widgetItem,
                        command = this.command,
                        containerOptions = this.containerOptions;
                    widgetItem.text = commandToContainer.resolveTextValue(command, containerOptions);
                    widgetItem.icon = commandToContainer.resolveIconValue(command, containerOptions, "icon");
                    widgetItem.iconSrc = commandToContainer.resolveIconValue(command, containerOptions, "iconSrc")
                }});
        var dxActionSheetAdapter = WidgetAdapterBase.inherit({
                _createItemWrapper: function(command, containerOptions) {
                    return new dxActionSheetItemWrapper(command, containerOptions)
                },
                _getWidgetByElement: function($element) {
                    return $element.dxActionSheet("instance")
                }
            });
        var dxListItemWrapper = WidgetItemWrapperBase.inherit({
                _createWidgetItem: function(command, containerOptions) {
                    this.callBase(command, containerOptions);
                    this.widgetItem.click = $.proxy(this._itemClick, this)
                },
                _updateItem: function() {
                    var widgetItem = this.widgetItem,
                        command = this.command,
                        containerOptions = this.containerOptions;
                    widgetItem.title = commandToContainer.resolveTextValue(command, containerOptions);
                    widgetItem.icon = commandToContainer.resolveIconValue(command, containerOptions, "icon");
                    widgetItem.iconSrc = commandToContainer.resolveIconValue(command, containerOptions, "iconSrc")
                },
                _itemClick: function(e) {
                    if (!this.widgetItem.disabled)
                        this.command.execute(e)
                }
            });
        var dxListAdapter = WidgetAdapterBase.inherit({
                _createItemWrapper: function(command, containerOptions) {
                    return new dxListItemWrapper(command, containerOptions)
                },
                _getWidgetByElement: function($element) {
                    return $element.dxList("instance")
                }
            });
        var dxNavBarItemWrapper = WidgetItemWrapperBase.inherit({_updateItem: function(optionName, newValue, oldValue) {
                    var command = this.command,
                        containerOptions = this.containerOptions;
                    if (optionName !== "highlighted") {
                        this.widgetItem.text = commandToContainer.resolveTextValue(command, containerOptions);
                        this.widgetItem.icon = commandToContainer.resolveIconValue(command, containerOptions, "icon");
                        this.widgetItem.iconSrc = commandToContainer.resolveIconValue(command, containerOptions, "iconSrc")
                    }
                }});
        var dxNavBarAdapter = WidgetAdapterBase.inherit({
                ctor: function($widgetElement) {
                    this.callBase($widgetElement);
                    this.widget.option("onItemClick", $.proxy(this._onNavBarItemClick, this))
                },
                _onNavBarItemClick: function(e) {
                    var items = this.widget.option("items");
                    for (var i = items.length; --i; )
                        items[i].command.option("highlighted", false);
                    e.itemData.command.execute(e)
                },
                _getWidgetByElement: function($element) {
                    return $element.dxNavBar("instance")
                },
                _createItemWrapper: function(command, containerOptions) {
                    return new dxNavBarItemWrapper(command, containerOptions)
                },
                addCommand: function(command, containerOptions) {
                    this.callBase(command, containerOptions);
                    this._updateSelectedIndex()
                },
                _onCommandChanged: function(args) {
                    var optionName = args.name,
                        newValue = args.value,
                        oldValue = args.previousValue;
                    if (optionName !== "highlighted" || newValue)
                        this._updateSelectedIndex();
                    this.callBase(args)
                },
                _updateSelectedIndex: function() {
                    var items = this.widget.option("items");
                    for (var i = 0, itemsCount = items.length; i < itemsCount; i++)
                        if (items[i].highlighted) {
                            this.widget.option("selectedIndex", i);
                            break
                        }
                }
            });
        var dxPivotItemWrapper = WidgetItemWrapperBase.inherit({_updateItem: function(optionName, newValue, oldValue) {
                    if (optionName === "title")
                        this.widgetItem.title = commandToContainer.resolveTextValue(this.command, this.containerOptions)
                }});
        var dxPivotAdapter = WidgetAdapterBase.inherit({
                ctor: function($widgetElement) {
                    this.callBase($widgetElement);
                    this._highlighting = false;
                    this.widget.option("onSelectionChanged", $.proxy(this._onPivotSelectionChange, this))
                },
                _onPivotSelectionChange: function(e) {
                    if (e.addedItems.length && e.removedItems.length && e.addedItems[0] && e.addedItems[0].command)
                        e.addedItems[0].command.execute(e)
                },
                _getWidgetByElement: function($element) {
                    return $element.dxPivot("instance")
                },
                _createItemWrapper: function(command, containerOptions) {
                    return new dxToolbarItemWrapper(command, containerOptions)
                },
                addCommand: function(command, containerOptions) {
                    this.callBase(command, containerOptions);
                    this._updateSelectedIndex()
                },
                _onCommandChanged: function(args) {
                    var optionName = args.name,
                        newValue = args.value;
                    if (optionName === "visible")
                        this._rerenderPivot();
                    else if (optionName !== "highlighted" || newValue)
                        this._updateSelectedIndex()
                },
                _addItemToWidget: function(itemWrapper) {
                    if (itemWrapper.command.option("visible"))
                        this.callBase(itemWrapper)
                },
                _updateSelectedIndex: function() {
                    var pivot = this.widget,
                        items = pivot.option("items") || [];
                    DX.fx.off = true;
                    for (var i = 0, itemsCount = items.length; i < itemsCount; i++)
                        if (items[i].highlighted) {
                            if (this._highlighting && pivot.option("selectedIndex") === i)
                                this._highlighting = false;
                            pivot.option("selectedIndex", i);
                            break
                        }
                    DX.fx.off = false
                },
                _rerenderPivot: function() {
                    var that = this;
                    that.widget.option("items", []);
                    $.each(that.itemWrappers, function(index, itemWrapper) {
                        if (itemWrapper.command.option("visible"))
                            that._addItemToWidget(itemWrapper)
                    });
                    that.refresh();
                    that._updateSelectedIndex()
                }
            });
        var dxSlideOutItemWrapper = WidgetItemWrapperBase.inherit({_updateItem: function(optionName, newValue, oldValue) {
                    var widgetItem = this.widgetItem,
                        command = this.command,
                        containerOptions = this.containerOptions;
                    if (name !== "highlighted") {
                        widgetItem.title = commandToContainer.resolveTextValue(command, containerOptions);
                        widgetItem.icon = commandToContainer.resolveIconValue(command, containerOptions, "icon");
                        widgetItem.iconSrc = commandToContainer.resolveIconValue(command, containerOptions, "iconSrc")
                    }
                }});
        var dxSlideOutAdapter = WidgetAdapterBase.inherit({
                ctor: function($widgetElement) {
                    this.callBase($widgetElement);
                    this.widget.option("onItemClick", $.proxy(this._onSlideOutItemClick, this))
                },
                _onSlideOutItemClick: function(e) {
                    e.itemData.command.execute(e)
                },
                _getWidgetByElement: function($element) {
                    return $element.dxSlideOut("instance")
                },
                _createItemWrapper: function(command, containerOptions) {
                    return new dxSlideOutItemWrapper(command, containerOptions)
                },
                _updateSelectedIndex: function() {
                    var items = this.widget.option("items") || [];
                    for (var i = 0, itemsCount = items.length; i < itemsCount; i++)
                        if (items[i].highlighted) {
                            this.widget.option("selectedIndex", i);
                            break
                        }
                },
                addCommand: function(command, containerOptions) {
                    this.callBase(command, containerOptions);
                    this._updateSelectedIndex()
                },
                _onCommandChanged: function(args) {
                    var optionName = args.name,
                        newValue = args.value,
                        oldValue = args.previousValue;
                    if (optionName !== "highlighted" || newValue)
                        this._updateSelectedIndex();
                    this.callBase(args)
                }
            });
        var adapters = DX.framework.html.commandToDXWidgetAdapters = {};
        adapters.dxToolbar = new CommandToWidgetAdapter(function($widgetElement) {
            return new dxToolbarAdapter($widgetElement)
        });
        adapters.dxActionSheet = new CommandToWidgetAdapter(function($widgetElement) {
            return new dxActionSheetAdapter($widgetElement)
        });
        adapters.dxList = new CommandToWidgetAdapter(function($widgetElement) {
            return new dxListAdapter($widgetElement)
        });
        adapters.dxNavBar = new CommandToWidgetAdapter(function($widgetElement) {
            return new dxNavBarAdapter($widgetElement)
        });
        adapters.dxPivot = new CommandToWidgetAdapter(function($widgetElement) {
            return new dxPivotAdapter($widgetElement)
        });
        adapters.dxSlideOut = new CommandToWidgetAdapter(function($widgetElement) {
            return new dxSlideOutAdapter($widgetElement)
        });
        DX.framework.html.WidgetItemWrapperBase = WidgetItemWrapperBase;
        DX.framework.html.WidgetAdapterBase = WidgetAdapterBase
    })(jQuery, DevExpress);
    /*! Module framework, file framework.commandManager.js */
    (function($, DX, undefined) {
        var Class = DX.Class,
            ui = DevExpress.ui;
        var CommandContainer = DX.DOMComponent.inherit({
                ctor: function(element, options) {
                    if ($.isPlainObject(element)) {
                        options = element;
                        element = $("<div />")
                    }
                    this.callBase(element, options)
                },
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({id: null})
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass("dx-command-container")
                }
            });
        DX.registerComponent("dxCommandContainer", DX.framework, CommandContainer);
        DX.framework.html.CommandManager = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this.defaultWidgetAdapter = options.defaultWidgetAdapter || this._getDefaultWidgetAdapter();
                this.commandMapping = options.commandMapping || new DX.framework.CommandMapping
            },
            _getDefaultWidgetAdapter: function() {
                return {
                        addCommand: this._defaultAddCommand,
                        clearContainer: $.noop
                    }
            },
            _getContainerAdapter: function($container) {
                var componentNames = $container.data("dxComponents"),
                    adapters = DX.framework.html.commandToDXWidgetAdapters;
                if (componentNames)
                    for (var index in componentNames) {
                        var widgetName = componentNames[index];
                        if (widgetName in adapters)
                            return adapters[widgetName]
                    }
                return this.defaultWidgetAdapter
            },
            findCommands: function($view) {
                var result = $.map($view.addBack().find(".dx-command"), function(element) {
                        return $(element).dxCommand("instance")
                    });
                return result
            },
            findCommandContainers: function($markup) {
                var result = $.map($markup.find(".dx-command-container"), function(element) {
                        return $(element).dxCommandContainer("instance")
                    });
                return result
            },
            _checkCommandId: function(id, command) {
                if (id === null)
                    throw DX.Error("E3010", command.element().get(0).outerHTML);
            },
            renderCommandsToContainers: function(commands, containers) {
                var that = this,
                    commandHash = {},
                    commandIds = [];
                $.each(commands, function(i, command) {
                    var id = command.option("id");
                    that._checkCommandId(id, command);
                    commandIds.push(id);
                    commandHash[id] = command
                });
                that.commandMapping.checkCommandsExist(commandIds);
                $.each(containers, function(k, container) {
                    var commandInfos = [];
                    $.each(commandHash, function(id, command) {
                        var commandId = id;
                        var commandOptions = that.commandMapping.getCommandMappingForContainer(commandId, container.option("id"));
                        if (commandOptions)
                            commandInfos.push({
                                command: command,
                                options: commandOptions
                            })
                    });
                    if (commandInfos.length)
                        that._attachCommandsToContainer(container.element(), commandInfos)
                })
            },
            clearContainer: function(container) {
                var $container = container.element(),
                    adapter = this._getContainerAdapter($container);
                adapter.clearContainer($container)
            },
            _arrangeCommandsToContainers: function(commands, containers) {
                DX.log("W0002", "CommandManager", "_arrangeCommandsToContainers", "14.1", "Use the 'renderCommandsToContainers' method instead.");
                this.renderCommandsToContainers(commands, containers)
            },
            _attachCommandsToContainer: function($container, commandInfos) {
                var adapter = this._getContainerAdapter($container);
                if (adapter.beginUpdate)
                    adapter.beginUpdate($container);
                $.each(commandInfos, function(index, commandInfo) {
                    adapter.addCommand($container, commandInfo.command, commandInfo.options)
                });
                if (adapter.endUpdate)
                    adapter.endUpdate($container);
                return true
            },
            _defaultAddCommand: function($container, command, options) {
                var $source = command.element();
                if ($source) {
                    $container.append($source);
                    $source.on("dxclick", function() {
                        command.execute()
                    })
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module framework, file framework.layoutController.js */
    (function($, DX, undefined) {
        var Class = DX.Class;
        var HIDDEN_BAG_ID = "__hidden-bag";
        var TRANSITION_SELECTOR = ".dx-transition:not(.dx-transition .dx-transition)";
        var transitionSelector = function(transitionName) {
                return ".dx-transition-" + transitionName
            };
        DX.framework.html.DefaultLayoutController = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this.name = options.layoutTemplateName || options.name || "";
                this._disableViewLoadingState = options.disableViewLoadingState;
                this._layoutModel = options.layoutModel || {};
                this._defaultPaneName = options.defaultPaneName || "content";
                this.viewReleased = $.Callbacks();
                this.viewRendered = $.Callbacks();
                this._callbacksToEvents("DefaultLayoutController", ["viewReleased", "viewRendered"])
            },
            init: function(options) {
                options = options || {};
                this._visibleViews = {};
                this._$viewPort = options.$viewPort || $("body");
                this._commandManager = options.commandManager;
                this._viewEngine = options.viewEngine;
                this._prepareTemplates();
                this._$viewPort.append(this._getRootElement());
                this._hideElements(this._getRootElement());
                this.DEFAULT_LOADING_TITLE = DX.localization.localizeString("@Loading");
                if (options.templateContext) {
                    this._templateContext = options.templateContext;
                    this._proxiedTemplateContextChangedHandler = $.proxy(this._templateContextChangedHandler, this)
                }
            },
            activate: function() {
                var $rootElement = this._getRootElement();
                this._showElements($rootElement);
                this._attachRefreshViewRequiredHandler();
                return $.Deferred().resolve().promise()
            },
            deactivate: function() {
                this._releaseVisibleViews();
                this._hideElements(this._getRootElement());
                this._detachRefreshViewRequiredHandler();
                return $.Deferred().resolve().promise()
            },
            activeViewInfo: function() {
                return this._visibleViews[this._defaultPaneName]
            },
            _applyTemplate: function($elements, model) {
                $elements.each(function(i, element) {
                    DX.framework.templateProvider.applyTemplate(element, model)
                })
            },
            _releaseVisibleViews: function() {
                var that = this;
                $.each(this._visibleViews, function(index, viewInfo) {
                    that._hideView(viewInfo);
                    that._releaseView(viewInfo)
                });
                this._visibleViews = {}
            },
            _templateContextChangedHandler: function() {
                $.each(this._visibleViews, $.proxy(function(index, viewInfo) {
                    this.showView(viewInfo)
                }, this))
            },
            _attachRefreshViewRequiredHandler: function() {
                if (this._templateContext)
                    this._templateContext.on("optionChanged", this._proxiedTemplateContextChangedHandler)
            },
            _detachRefreshViewRequiredHandler: function() {
                if (this._templateContextChanged)
                    this._templateContext.off("optionChanged", this._proxiedTemplateContextChangedHandler)
            },
            _getPreviousViewInfo: function(viewInfo) {
                return this._visibleViews[this._getViewPaneName(viewInfo.viewTemplateInfo)]
            },
            _prepareTemplates: function() {
                var that = this;
                var $layoutTemplate = that._viewEngine.getLayoutTemplate(this._getLayoutTemplateName()).removeClass("dx-hidden");
                that._$layoutTemplate = $layoutTemplate;
                that._$mainLayout = that._createEmptyLayout();
                that._showElements(that._$mainLayout);
                that._applyTemplate(that._$mainLayout, that._layoutModel);
                that._$navigationWidget = that._createNavigationWidget();
                that._loadingStateViewInfo = that._createLoadingStateViewInfo($layoutTemplate)
            },
            renderNavigation: function(navigationCommands) {
                this._clearNavigationWidget();
                this._renderNavigationImpl(navigationCommands)
            },
            _renderNavigationImpl: function(navigationCommands) {
                this._renderCommands(this._$mainLayout, navigationCommands)
            },
            _createNavigationWidget: function() {
                var result;
                this._$mainLayout.find(".dx-command-container").each(function() {
                    var container = $(this).dxCommandContainer("instance");
                    if (container.option("id") === "global-navigation")
                        result = $(this)
                });
                return result
            },
            _clearNavigationWidget: function() {
                if (this._$navigationWidget)
                    this._commandManager.clearContainer(this._$navigationWidget.dxCommandContainer("instance"))
            },
            _getRootElement: function() {
                return this._$mainLayout
            },
            _getViewFrame: function(viewInfo) {
                return this._$mainLayout
            },
            _getLayoutTemplateName: function() {
                return this.name
            },
            _applyModelToTransitionElements: function($markup, model) {
                var that = this;
                this._getTransitionElements($markup).each(function(i, item) {
                    that._applyTemplate($(item).children(), model)
                })
            },
            _createLoadingStateViewModel: function() {
                return {title: ko.observable()}
            },
            _createLoadingStateViewInfo: function($layoutTemplate) {
                var $loadingStateView = $layoutTemplate.clone().addClass("dx-loading-state-view"),
                    model = this._createLoadingStateViewModel();
                this._hideElements($loadingStateView);
                DX.utils.createComponents($loadingStateView);
                this._applyModelToTransitionElements($loadingStateView, model);
                var result = {
                        model: model,
                        renderResult: {
                            $markup: $loadingStateView,
                            $viewItems: $()
                        },
                        isLoadingStateView: true
                    };
                this._appendViewToLayout(result);
                return result
            },
            _createViewLayoutTemplate: function() {
                var that = this;
                var $viewLayoutTemplate = that._$layoutTemplate.clone();
                this._hideElements($viewLayoutTemplate);
                DX.utils.createComponents($viewLayoutTemplate);
                return $viewLayoutTemplate
            },
            _createEmptyLayout: function() {
                var that = this;
                var $result = that._$layoutTemplate.clone();
                this._hideElements($result);
                DX.utils.createComponents($result);
                that._removeTransitionContent($result);
                return $result
            },
            _removeTransitionContent: function($markup) {
                var $transitionElements = this._getTransitionElements($markup);
                $transitionElements.children().remove()
            },
            _getTransitionElements: function($markup) {
                return $markup.find(TRANSITION_SELECTOR).addBack(TRANSITION_SELECTOR)
            },
            setViewLoadingState: function(viewInfo, direction) {
                var that = this;
                if (that._disableViewLoadingState)
                    return $.Deferred().resolve().promise();
                var loadingStateViewInfo = $.extend({}, viewInfo, that._loadingStateViewInfo);
                that._loadingStateViewInfo.model.title((viewInfo.viewTemplateInfo || {}).title || this.DEFAULT_LOADING_TITLE);
                return that._showViewImpl(loadingStateViewInfo, direction)
            },
            showView: function(viewInfo, direction) {
                var that = this;
                var previousViewInfo = that._getPreviousViewInfo(viewInfo);
                if (previousViewInfo && previousViewInfo.isLoadingStateView)
                    direction = "none";
                that._ensureViewRendered(viewInfo);
                return this._showViewImpl(viewInfo, direction).done(function() {
                        that._onViewShown(viewInfo)
                    })
            },
            disposeView: function(viewInfo) {
                this._clearRenderResult(viewInfo)
            },
            _clearRenderResult: function(viewInfo) {
                if (viewInfo.renderResult) {
                    viewInfo.renderResult.$markup.remove();
                    viewInfo.renderResult.$viewItems.remove();
                    delete viewInfo.renderResult
                }
            },
            _prepareViewTemplate: function($viewTemplate, viewInfo) {
                DX.utils.createComponents($viewTemplate)
            },
            _renderViewImpl: function($viewTemplate, viewInfo) {
                var that = this,
                    allowedChildrenSelector = ".dx-command,.dx-content,script",
                    $layout = this._createViewLayoutTemplate(),
                    $viewItems,
                    isSimplifiedMarkup = true,
                    outOfContentItems = $();
                if ($viewTemplate.children(allowedChildrenSelector).length === 0)
                    this._viewEngine._wrapViewDefaultContent($viewTemplate);
                $viewItems = $viewTemplate.children();
                this._applyModelToTransitionElements($layout, viewInfo.model);
                this._viewEngine.applyLayout($viewTemplate, $layout);
                $viewItems.each(function(i, item) {
                    var $item = $(item);
                    that._applyTemplate($item, viewInfo.model);
                    if ($item.is(allowedChildrenSelector))
                        isSimplifiedMarkup = false;
                    else
                        outOfContentItems = outOfContentItems.add($item)
                });
                if (outOfContentItems.length && !isSimplifiedMarkup)
                    throw DX.Error("E3014", outOfContentItems[0].outerHTML);
                viewInfo.renderResult = viewInfo.renderResult || {};
                viewInfo.renderResult.$viewItems = $viewItems;
                viewInfo.renderResult.$markup = $layout
            },
            _renderCommands: function($markup, commands) {
                var commandContainers = this._findCommandContainers($markup);
                this._commandManager.renderCommandsToContainers(commands, commandContainers)
            },
            _applyViewCommands: function(viewInfo) {
                var $viewItems = viewInfo.renderResult.$viewItems,
                    $markup = viewInfo.renderResult.$markup,
                    viewCommands = this._commandManager.findCommands($viewItems);
                viewInfo.commands = DX.framework.utils.mergeCommands(viewInfo.commands || [], viewCommands);
                this._renderCommands($markup, viewInfo.commands)
            },
            _findCommandContainers: function($markup) {
                return DX.utils.createComponents($markup, ["dxCommandContainer"])
            },
            _ensureViewRendered: function(viewInfo) {
                var viewTemplateInstance = viewInfo.$viewTemplate ? viewInfo.$viewTemplate.dxView("instance") : this._viewEngine.getViewTemplateInfo(viewInfo.viewName),
                    currentViewId = viewTemplateInstance.getId(),
                    $cachedMarkup = viewInfo.renderResult && viewInfo.renderResult.markupCache[currentViewId];
                if ($cachedMarkup)
                    viewInfo.renderResult.$markup = $cachedMarkup;
                else {
                    this._renderView(viewInfo);
                    viewInfo.renderResult.markupCache = viewInfo.renderResult.markupCache || {};
                    viewInfo.renderResult.markupCache[currentViewId] = viewInfo.renderResult.$markup
                }
            },
            _renderView: function(viewInfo) {
                var $viewTemplate = viewInfo.$viewTemplate || this._viewEngine.getViewTemplate(viewInfo.viewName);
                this._prepareViewTemplate($viewTemplate, viewInfo);
                this._renderViewImpl($viewTemplate, viewInfo);
                this._applyViewCommands(viewInfo);
                this._appendViewToLayout(viewInfo);
                $viewTemplate.remove();
                this._onRenderComplete(viewInfo);
                this.fireEvent("viewRendered", [viewInfo])
            },
            _appendViewToLayout: function(viewInfo) {
                var that = this,
                    $viewFrame = that._getViewFrame(viewInfo),
                    $markup = viewInfo.renderResult.$markup,
                    $transitionContentElements = $();
                $.each($markup.find(".dx-content-placeholder"), function(index, el) {
                    var placeholder = $(el).dxContentPlaceholder("instance");
                    placeholder.prepareTransition()
                });
                $.each(that._getTransitionElements($viewFrame), function(index, transitionElement) {
                    var $transition = $(transitionElement),
                        $viewElement = $markup.find(transitionSelector($transition.data("dx-transition-name"))).children();
                    that._hideViewElements($viewElement);
                    $transition.append($viewElement);
                    $transitionContentElements = $transitionContentElements.add($viewElement)
                });
                that._$mainLayout.append(viewInfo.renderResult.$viewItems.filter(".dx-command"));
                $markup.remove();
                viewInfo.renderResult.$markup = $transitionContentElements
            },
            _onRenderComplete: function(viewInfo){},
            _onViewShown: function(viewInfo) {
                $(document).trigger("dx.viewchanged")
            },
            _doTransition: function(viewInfo, direction) {
                var that = this,
                    deferred = $.Deferred();
                var transitions = $.map(viewInfo.renderResult.$markup, function(transitionContent) {
                        var $transitionContent = $(transitionContent),
                            $transition = $transitionContent.parent(),
                            transitionType = that._disableTransitions ? "none" : $transition.data("dx-transition-type");
                        return {
                                destination: $transition,
                                source: $transitionContent,
                                type: transitionType || "none",
                                direction: direction || "none"
                            }
                    });
                that._executeTransitions(transitions).done(function() {
                    deferred.resolve()
                });
                return deferred.promise()
            },
            _hideView: function(viewInfo) {
                if (viewInfo.renderResult)
                    this._hideViewElements(viewInfo.renderResult.$markup)
            },
            _showViewImpl: function(viewInfo, direction) {
                var that = this,
                    deferred = $.Deferred(),
                    previousViewInfo = this._getPreviousViewInfo(viewInfo);
                if (!previousViewInfo || previousViewInfo === viewInfo)
                    direction = "none";
                return that._doTransition(viewInfo, direction).done(function() {
                        that._changeView(viewInfo)
                    })
            },
            _releaseView: function(viewInfo) {
                this.viewReleased.fireWith(this, [viewInfo])
            },
            _changeView: function(viewInfo) {
                var that = this;
                var previousViewInfo = that._getPreviousViewInfo(viewInfo);
                if (previousViewInfo && previousViewInfo !== viewInfo) {
                    that._hideView(previousViewInfo);
                    if (!previousViewInfo.isLoadingStateView)
                        this._releaseView(previousViewInfo)
                }
                this._visibleViews[this._getViewPaneName(viewInfo.viewTemplateInfo)] = viewInfo
            },
            _getViewPaneName: function(viewTemplateInfo) {
                return this._defaultPaneName
            },
            _hideElements: function($elements) {
                $elements.addClass("dx-hidden")
            },
            _showElements: function($elements) {
                $elements.removeClass("dx-hidden");
                $elements.find(".dx-visibility-change-handler").each(function() {
                    $(this).triggerHandler("dxshown")
                })
            },
            _hideViewElements: function($elements) {
                DX.utils.triggerHidingEvent($elements.filter(".dx-active-view"));
                this._patchIDs($elements);
                this._disableInputs($elements);
                $elements.removeClass("dx-active-view").addClass("dx-inactive-view")
            },
            _showViewElements: function($elements) {
                this._unpatchIDs($elements);
                this._enableInputs($elements);
                $elements.removeClass("dx-inactive-view").addClass("dx-active-view");
                DX.utils.triggerShownEvent($elements.filter(".dx-active-view"))
            },
            _executeTransitions: function(transitions) {
                var that = this;
                var animatedTransitions = $.map(transitions, function(transitionOptions) {
                        that._showViewElements(transitionOptions.source);
                        if (transitionOptions.source.children().length)
                            return DX.framework.html.TransitionExecutor.create(transitionOptions.destination, transitionOptions)
                    });
                var animatedDeferreds = $.map(animatedTransitions, function(transition) {
                        transition.options.source.addClass("dx-transition-source");
                        return transition.exec()
                    });
                var result = $.when.apply($, animatedDeferreds).done(function() {
                        $.each(animatedTransitions, function(index, transition) {
                            transition.finalize();
                            that._hideViewElements(transition.options.source.parent().find(".dx-active-view:not(.dx-transition-source)"));
                            transition.options.source.removeClass("dx-transition-source")
                        })
                    });
                return result
            },
            _patchIDs: function($markup) {
                this._processIDs($markup, function(id) {
                    var result = id;
                    if (id.indexOf(HIDDEN_BAG_ID) === -1)
                        result = HIDDEN_BAG_ID + "-" + id;
                    return result
                })
            },
            _unpatchIDs: function($markup) {
                this._processIDs($markup, function(id) {
                    var result = id;
                    if (id.indexOf(HIDDEN_BAG_ID) === 0)
                        result = id.substr(HIDDEN_BAG_ID.length + 1);
                    return result
                })
            },
            _processIDs: function($markup, process) {
                var elementsWithIds = $markup.find("[id]");
                $.each(elementsWithIds, function(index, element) {
                    var $el = $(element),
                        id = $el.attr("id");
                    $el.attr("id", process(id))
                })
            },
            _enableInputs: function($markup) {
                var $inputs = $markup.find(":input[data-disabled=true]");
                $.each($inputs, function(index, input) {
                    $(input).removeAttr("disabled").removeAttr("data-disabled")
                })
            },
            _disableInputs: function($markup) {
                var $inputs = $markup.find(":input:not([disabled], [disabled=true])");
                $.each($inputs, function(index, input) {
                    $(input).attr({
                        disabled: true,
                        "data-disabled": true
                    })
                })
            }
        }).include(DX.EventsMixin);
        var layoutSets = DX.framework.html.layoutSets;
        layoutSets["default"] = layoutSets["default"] || [];
        layoutSets["default"].push({controller: new DX.framework.html.DefaultLayoutController})
    })(jQuery, DevExpress);
    /*! Module framework, file framework.viewEngine.js */
    (function($, DX, undefined) {
        var Class = DX.Class,
            framework = DX.framework,
            _VIEW_ROLE = "dxView",
            _LAYOUT_ROLE = "dxLayout",
            lastViewId = 0;
        DX.registerComponent(_VIEW_ROLE, framework, DX.DOMComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    name: null,
                    title: null,
                    layout: null
                })
            },
            ctor: function() {
                this.callBase.apply(this, arguments);
                this._id = ++lastViewId
            },
            _render: function() {
                this.callBase();
                this.element().addClass("dx-view")
            },
            getId: function() {
                return this._id
            }
        }), framework);
        DX.registerComponent(_LAYOUT_ROLE, framework, DX.DOMComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({name: null})
            },
            _render: function() {
                this.callBase();
                this.element().addClass("dx-layout")
            }
        }));
        DX.registerComponent("dxViewPlaceholder", framework, DX.DOMComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({viewName: null})
            },
            _render: function() {
                this.callBase();
                this.element().addClass("dx-view-placeholder")
            }
        }));
        var setupTransitionElement = function($element, transitionType, transitionName, contentCssPosition) {
                if (contentCssPosition === "absolute")
                    $element.addClass("dx-transition-absolute");
                else
                    $element.addClass("dx-transition-static");
                $element.addClass("dx-transition").addClass("dx-transition-" + transitionName);
                $element.data("dx-transition-type", transitionType);
                $element.data("dx-transition-name", transitionName)
            };
        var setupTransitionInnerElement = function($element) {
                $element.addClass("dx-transition-inner-wrapper")
            };
        DX.registerComponent("dxTransition", framework, DX.DOMComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    name: null,
                    type: "slide"
                })
            },
            _render: function() {
                this.callBase();
                var element = this.element();
                setupTransitionElement(element, this.option("type"), this.option("name"), "absolute");
                element.wrapInner("<div/>");
                setupTransitionInnerElement(element.children())
            },
            _clean: function() {
                this.callBase();
                this.element().empty()
            }
        }));
        DX.registerComponent("dxContentPlaceholder", framework, DX.DOMComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    name: null,
                    transition: "none",
                    contentCssPosition: "absolute"
                })
            },
            _render: function() {
                this.callBase();
                var $element = this.element();
                $element.addClass("dx-content-placeholder").addClass("dx-content-placeholder-" + this.option("name"));
                setupTransitionElement($element, this.option("transition"), this.option("name"), this.option("contentCssPosition"))
            },
            prepareTransition: function() {
                var $element = this.element();
                if ($element.children(".dx-content").length === 0) {
                    $element.wrapInner("<div>");
                    $element.children().dxContent({targetPlaceholder: this.option("name")})
                }
            }
        }));
        DX.registerComponent("dxContent", framework, DX.DOMComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({targetPlaceholder: null})
            },
            _optionChanged: function(args) {
                this._refresh()
            },
            _clean: function() {
                this.callBase();
                this.element().removeClass(this._currentClass)
            },
            _render: function() {
                this.callBase();
                var element = this.element();
                element.addClass("dx-content");
                this._currentClass = "dx-content-" + this.option("targetPlaceholder");
                element.addClass(this._currentClass);
                setupTransitionInnerElement(element)
            }
        }));
        framework.html.ViewEngine = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this.$root = options.$root;
                this.device = options.device || {};
                this.dataOptionsAttributeName = options.dataOptionsAttributeName || "data-options";
                this._templateMap = {};
                this._pendingViewContainer = null;
                this.markupLoaded = $.Callbacks();
                this._templateContext = options.templateContext
            },
            _enumerateTemplates: function(processFn) {
                var that = this;
                $.each(that._templateMap, function(name, templatesByRoleMap) {
                    $.each(templatesByRoleMap, function(role, templates) {
                        $.each(templates, function(index, template) {
                            processFn(template)
                        })
                    })
                })
            },
            _findComponent: function(name, role) {
                var components = (this._templateMap[name] || {})[role] || [],
                    filter = this._templateContext && this._templateContext.option() || {};
                components = this._filterTemplates(filter, components);
                this._checkMatchedTemplates(components);
                return components[0]
            },
            _findTemplate: function(name, role) {
                var component = this._findComponent(name, role);
                if (!component)
                    throw DX.Error("E3013", role, name);
                var $template = component.element(),
                    $result = $template.clone();
                DX.utils.createComponents($result, [role]);
                return $result
            },
            _extendModelFromViewData: function($view, model) {
                DX.utils.extendFromObject(model, $view.data(_VIEW_ROLE).option())
            },
            _loadTemplatesFromMarkupCore: function($markup) {
                var that = this;
                if ($markup.find("[data-dx-role]").length)
                    throw DX.Error("E3019");
                that.markupLoaded.fire({markup: $markup});
                $markup.appendTo(that.$root);
                var components = DX.utils.createComponents($markup, [_VIEW_ROLE, _LAYOUT_ROLE]);
                $.each(components, function(index, component) {
                    var $element = component.element();
                    $element.addClass("dx-hidden");
                    that._registerTemplateComponent(component);
                    component.element().detach()
                })
            },
            _registerTemplateComponent: function(component) {
                var role = component.NAME,
                    options = component.option(),
                    templateName = options.name,
                    componentsByRoleMap = this._templateMap[templateName] || {};
                componentsByRoleMap[role] = componentsByRoleMap[role] || [];
                componentsByRoleMap[role].push(component);
                this._templateMap[templateName] = componentsByRoleMap
            },
            _applyPartialViews: function($render) {
                var that = this;
                DX.utils.createComponents($render, ["dxViewPlaceholder"]);
                $.each($render.find(".dx-view-placeholder"), function() {
                    var $partialPlaceholder = $(this);
                    if ($partialPlaceholder.children().length)
                        return;
                    var viewName = $partialPlaceholder.data("dxViewPlaceholder").option("viewName"),
                        $view = that._findTemplate(viewName, _VIEW_ROLE);
                    that._applyPartialViews($view);
                    $partialPlaceholder.append($view);
                    $view.removeClass("dx-hidden")
                })
            },
            _ajaxImpl: function() {
                return $.ajax.apply($, arguments)
            },
            _loadTemplatesFromURL: function(url) {
                var that = this,
                    options = this._getLoadOptions(),
                    deferred = $.Deferred(),
                    url = options.winPhonePrefix + url;
                this._ajaxImpl({
                    url: url,
                    isLocal: options.isLocal,
                    dataType: "html"
                }).done(function(data) {
                    that._loadTemplatesFromMarkupCore(DX.utils.createMarkupFromString(data));
                    deferred.resolve()
                }).fail(function(jqXHR, textStatus, errorThrown) {
                    var error = DX.Error("E3021", url, errorThrown);
                    deferred.reject(error)
                });
                return deferred.promise()
            },
            _getLoadOptions: function() {
                if (location.protocol.indexOf("wmapp") >= 0)
                    return {
                            winPhonePrefix: location.protocol + "www/",
                            isLocal: true
                        };
                return {
                        winPhonePrefix: "",
                        isLocal: undefined
                    }
            },
            _loadExternalTemplates: function() {
                var tasks = [],
                    that = this;
                $("head").find("link[rel='dx-template']").each(function(index, link) {
                    var task = that._loadTemplatesFromURL($(link).attr("href"));
                    tasks.push(task)
                });
                return $.when.apply($, tasks)
            },
            _processTemplates: function() {
                var that = this;
                $.each(that._templateMap, function(name, templatesByRoleMap) {
                    $.each(templatesByRoleMap, function(role, templates) {
                        that._filterTemplatesByDevice(templates)
                    })
                });
                that._enumerateTemplates(function(template) {
                    that._applyPartialViews(template.element())
                })
            },
            _filterTemplatesByDevice: function(components) {
                var filteredComponents = this._filterTemplates(this.device, components);
                $.each(components, function(index, component) {
                    if ($.inArray(component, filteredComponents) < 0) {
                        component._dispose();
                        component.element().remove()
                    }
                });
                components.length = 0;
                components.push.apply(components, filteredComponents)
            },
            _filterTemplates: function(filter, components) {
                return DX.utils.findBestMatches(filter, components, function(component) {
                        return component.option()
                    })
            },
            _checkMatchedTemplates: function(bestMatches) {
                if (bestMatches.length > 1) {
                    var message = "";
                    $.each(bestMatches, function(index, match) {
                        message += match.element().attr("data-options") + "\r\n"
                    });
                    throw DX.Error("E3020", message, JSON.stringify(this.device));
                }
            },
            _extendModelFormViewTemplate: function($viewTemplate, model) {
                this._extendModelFromViewData($viewTemplate, model)
            },
            _ensureTemplates: function(viewInfo) {
                this._ensureViewTemplate(viewInfo)
            },
            _ensureViewTemplate: function(viewInfo) {
                viewInfo.$viewTemplate = viewInfo.$viewTemplate || this.getViewTemplate(viewInfo.viewName);
                return viewInfo.$viewTemplate
            },
            _wrapViewDefaultContent: function($viewTemplate) {
                $viewTemplate.wrapInner("<div class=\"dx-full-height\"></div>");
                $viewTemplate.children().eq(0).dxContent({targetPlaceholder: 'content'})
            },
            _initDefaultLayout: function() {
                this._$defaultLayoutTemplate = $("<div class=\"dx-full-height\" data-options=\"dxLayout : { name: 'default' } \"> \
                <div class=\"dx-full-height\" data-options=\"dxContentPlaceholder : { name: 'content' } \" ></div> \
            </div>")
            },
            _getDefaultLayoutTemplate: function() {
                var $result = this._$defaultLayoutTemplate.clone();
                DX.utils.createComponents($result);
                return $result
            },
            applyLayout: function($view, $layout) {
                if ($layout === undefined || $layout.length === 0)
                    $layout = this._getDefaultLayoutTemplate();
                if ($view.children(".dx-content").length === 0)
                    this._wrapViewDefaultContent($view);
                var $toMerge = $().add($layout).add($view);
                var $placeholderContents = $toMerge.find(".dx-content");
                $.each($placeholderContents, function() {
                    var $placeholderContent = $(this);
                    var placeholderId = $placeholderContent.data("dxContent").option("targetPlaceholder");
                    var $placeholder = $toMerge.find(".dx-content-placeholder-" + placeholderId);
                    $placeholder.empty();
                    $placeholder.append($placeholderContent)
                });
                $placeholderContents.filter(":not(.dx-content-placeholder .dx-content)").remove();
                return $layout
            },
            init: function() {
                var that = this;
                this._initDefaultLayout();
                return this._loadExternalTemplates().done(function() {
                        that._loadTemplatesFromMarkupCore(that.$root.children());
                        that._processTemplates()
                    })
            },
            getViewTemplate: function(viewName) {
                return this._findTemplate(viewName, _VIEW_ROLE)
            },
            getViewTemplateInfo: function(name) {
                return this._findComponent(name, _VIEW_ROLE)
            },
            getLayoutTemplate: function(layoutName) {
                if (!layoutName)
                    return this._getDefaultLayoutTemplate();
                return this._findTemplate(layoutName, _LAYOUT_ROLE)
            },
            getLayoutTemplateInfo: function(name) {
                return this._findComponent(name, _LAYOUT_ROLE)
            },
            loadTemplates: function(source) {
                var result;
                if (typeof source === "string")
                    result = this._loadTemplatesFromURL(source);
                else {
                    this._loadTemplatesFromMarkupCore(source);
                    result = $.Deferred().resolve().promise()
                }
                return result.done($.proxy(this._processTemplates, this))
            }
        })
    })(jQuery, DevExpress);
    /*! Module framework, file framework.htmlApplication.js */
    (function($, DX, undefined) {
        var frameworkNS = DX.framework,
            htmlNS = frameworkNS.html;
        var VIEW_PORT_CLASSNAME = "dx-viewport";
        htmlNS.HtmlApplication = frameworkNS.Application.inherit({
            ctor: function(options) {
                options = options || {};
                this.callBase(options);
                this._$root = $(options.rootNode || document.body);
                this._initViewport(options.viewPort);
                if (this._applicationMode === "mobileApp")
                    DX.utils.initMobileViewport(options.viewPort);
                this.device = options.device || DX.devices.current();
                var layoutSets = DX.framework.html.layoutSets;
                this.commandManager = options.commandManager || new DX.framework.html.CommandManager({commandMapping: this.commandMapping});
                $.each(options.layoutControllers || DX.framework.html.layoutControllers, function(_, layoutControllerInfo) {
                    var targetLayoutSet = layoutControllerInfo.navigationType;
                    layoutSets[targetLayoutSet] = layoutSets[targetLayoutSet] || [];
                    layoutSets[targetLayoutSet].push(layoutControllerInfo);
                    delete layoutControllerInfo.navigationType
                });
                if (options.navigationType)
                    DX.log("W0001", "HtmlApplication", "navigationType", "14.1", "Use the 'layoutSet' option instead.");
                if (options.defaultLayout)
                    DX.log("W0001", "HtmlApplication", "defaultLayout", "13.2", "Use the 'layoutSet' option instead.");
                var navigationType = options.navigationType || options.defaultLayout;
                if (navigationType)
                    options.layoutSet = layoutSets[navigationType];
                this._initTemplateContext();
                this.viewEngine = options.viewEngine || new htmlNS.ViewEngine({
                    $root: this._$root,
                    device: this.device,
                    templateContext: this._templateContext
                });
                this.components.push(this.viewEngine);
                this._initMarkupFilters(this.viewEngine);
                this.viewRendered = $.Callbacks();
                this._layoutSet = options.layoutSet || (options.layoutControllers && options.layoutControllers.length ? options.layoutControllers : layoutSets["default"]);
                this._availableLayoutControllers = [];
                this._activeLayoutControllersStack = [];
                this.resolveLayoutController = $.Callbacks();
                this._callbacksToEvents("HtmlApplication", ["viewRendered", "resolveLayoutController"])
            },
            _localizeMarkup: function($markup) {
                DX.localization.localizeNode($markup)
            },
            _notifyIfBadMarkup: function($markup) {
                $markup.each(function() {
                    var html = $(this).html();
                    if (/href="#/.test(html))
                        DX.log("W3005", html)
                })
            },
            _initMarkupFilters: function(viewEngine) {
                var filters = [];
                filters.push(this._localizeMarkup);
                filters.push(this._notifyIfBadMarkup);
                if (viewEngine.markupLoaded)
                    viewEngine.markupLoaded.add(function(args) {
                        $.each(filters, function(_, filter) {
                            filter(args.markup)
                        })
                    })
            },
            _createViewCache: function(options) {
                var result = this.callBase(options);
                if (!options.viewCache)
                    result = new DX.framework.ConditionalViewCacheDecorator({
                        filter: function(key, viewInfo) {
                            return !viewInfo.viewTemplateInfo.disableCache
                        },
                        viewCache: result
                    });
                return result
            },
            _initViewport: function() {
                this._$viewPort = this._getViewPort();
                DX.viewPort(this._$viewPort)
            },
            _getViewPort: function() {
                var $viewPort = $("." + VIEW_PORT_CLASSNAME);
                if (!$viewPort.length)
                    $viewPort = $("<div>").addClass(VIEW_PORT_CLASSNAME).appendTo(this._$root);
                return $viewPort
            },
            _initTemplateContext: function() {
                this._templateContext = new DX.Component({orientation: DX.devices.orientation()});
                DX.devices.on("orientationChanged", $.proxy(function(args) {
                    this._templateContext.option("orientation", args.orientation)
                }, this))
            },
            _showViewImpl: function(viewInfo, direction) {
                var that = this,
                    result = $.Deferred(),
                    layoutController = viewInfo.layoutController;
                that._obtainViewLink(viewInfo);
                layoutController.showView(viewInfo, direction).done(function() {
                    that._activateLayoutController(layoutController, that._getTargetNode(viewInfo)).done(function() {
                        result.resolve()
                    })
                });
                return result.promise()
            },
            _setViewLoadingState: function(viewInfo, direction) {
                var that = this,
                    result = $.Deferred(),
                    layoutController = viewInfo.layoutController;
                layoutController.setViewLoadingState(viewInfo, direction).done(function() {
                    that._activateLayoutController(layoutController, that._getTargetNode(viewInfo)).done(function() {
                        result.resolve()
                    })
                });
                return result.promise()
            },
            _resolveLayoutController: function(viewInfo) {
                var args = {
                        viewInfo: viewInfo,
                        layoutController: null,
                        availableLayoutControllers: this._availableLayoutControllers
                    };
                this._processEvent("resolveLayoutController", args, viewInfo.model);
                return args.layoutController || this._resolveLayoutControllerImpl(viewInfo)
            },
            _ensureOneLayoutControllerFound: function(target, matches) {
                var toJSONInterceptor = function(key, value) {
                        if (key === "controller")
                            return "[controller]: { name:" + value.name + " }";
                        return value
                    };
                if (!matches.length) {
                    DX.log("W3003", JSON.stringify(target, null, 4), JSON.stringify(this._availableLayoutControllers, toJSONInterceptor, 4));
                    throw DX.Error("E3011");
                }
                if (matches.length > 1) {
                    DX.log("W3004", JSON.stringify(target, null, 4), JSON.stringify(matches, toJSONInterceptor, 4));
                    throw DX.Error("E3012");
                }
            },
            _resolveLayoutControllerImpl: function(viewInfo) {
                var templateInfo = viewInfo.viewTemplateInfo || {},
                    navigateOptions = viewInfo.navigateOptions || {},
                    target = $.extend({
                        root: !viewInfo.canBack,
                        customResolveRequired: false,
                        pane: templateInfo.pane,
                        modal: navigateOptions.modal !== undefined ? navigateOptions.modal : templateInfo.modal || false
                    }, DX.devices.current());
                var matches = DX.utils.findBestMatches(target, this._availableLayoutControllers);
                this._ensureOneLayoutControllerFound(target, matches);
                return matches[0].controller
            },
            _onNavigatingBack: function(args) {
                this.callBase.apply(this, arguments);
                if (!args.cancel && !this.canBack() && this._activeLayoutControllersStack.length > 1) {
                    var previousActiveLayoutController = this._activeLayoutControllersStack[this._activeLayoutControllersStack.length - 2],
                        previousViewInfo = previousActiveLayoutController.activeViewInfo();
                    args.cancel = true;
                    this._activateLayoutController(previousActiveLayoutController);
                    this.navigationManager.currentItem(previousViewInfo.key)
                }
            },
            _activeLayoutController: function() {
                return this._activeLayoutControllersStack.length ? this._activeLayoutControllersStack[this._activeLayoutControllersStack.length - 1] : undefined
            },
            _getTargetNode: function(viewInfo) {
                var jQueryEvent = (viewInfo.navigateOptions || {}).jQueryEvent;
                return jQueryEvent ? $(jQueryEvent.target) : undefined
            },
            _activateLayoutController: function(layoutController, targetNode) {
                var that = this,
                    result = $.Deferred(),
                    activeLayoutController = that._activeLayoutController();
                if (activeLayoutController !== layoutController)
                    layoutController.activate(targetNode).done(function() {
                        if (activeLayoutController && !layoutController.isOverlay)
                            activeLayoutController.deactivate().done(function() {
                                that._activeLayoutControllersStack.pop();
                                that._activeLayoutControllersStack.push(layoutController);
                                result.resolve()
                            });
                        else {
                            that._activeLayoutControllersStack.push(layoutController);
                            result.resolve()
                        }
                    });
                else
                    result.resolve();
                return result.promise()
            },
            init: function() {
                var that = this,
                    result = this.callBase();
                result.done(function() {
                    that._initLayoutControllers();
                    that.renderNavigation()
                });
                return result
            },
            _disposeView: function(viewInfo) {
                if (viewInfo.layoutController.disposeView)
                    viewInfo.layoutController.disposeView(viewInfo);
                this.callBase(viewInfo)
            },
            viewPort: function() {
                return this._$viewPort
            },
            _createViewInfo: function(navigationItem, navigateOptions) {
                var viewInfo = this.callBase.apply(this, arguments),
                    templateInfo = this.getViewTemplateInfo(viewInfo.viewName);
                if (!templateInfo)
                    throw DX.Error("E3013", "dxView", viewInfo.viewName);
                viewInfo.viewTemplateInfo = templateInfo;
                viewInfo.layoutController = this._resolveLayoutController(viewInfo);
                return viewInfo
            },
            _createViewModel: function(viewInfo) {
                this.callBase(viewInfo);
                var templateInfo = viewInfo.viewTemplateInfo,
                    model = viewInfo.model;
                for (var name in templateInfo)
                    if (!(name in model))
                        model[name] = templateInfo[name]
            },
            _initLayoutControllers: function() {
                var that = this;
                $.each(that._layoutSet, function(index, controllerInfo) {
                    var controller = controllerInfo.controller,
                        target = DX.devices.current();
                    if (DX.utils.findBestMatches(target, [controllerInfo]).length) {
                        that._availableLayoutControllers.push(controllerInfo);
                        if (controller.init)
                            controller.init({
                                app: that,
                                $viewPort: that._$viewPort,
                                navigationManager: that.navigationManager,
                                viewEngine: that.viewEngine,
                                templateContext: that._templateContext,
                                commandManager: that.commandManager
                            });
                        if (controller.on) {
                            controller.on("viewReleased", function(viewInfo) {
                                that._onViewReleased(viewInfo)
                            });
                            controller.on("viewRendered", function(viewInfo) {
                                that._processEvent("viewRendered", {viewInfo: viewInfo}, viewInfo.model)
                            })
                        }
                    }
                })
            },
            _onViewReleased: function(viewInfo) {
                this._onViewHidden(viewInfo);
                this._releaseViewLink(viewInfo)
            },
            renderNavigation: function() {
                var that = this;
                $.each(that._availableLayoutControllers, function(index, controllerInfo) {
                    var controller = controllerInfo.controller;
                    if (controller.renderNavigation)
                        controller.renderNavigation(that.navigation)
                })
            },
            getViewTemplate: function(viewName) {
                return this.viewEngine.getViewTemplate(viewName)
            },
            getViewTemplateInfo: function(viewName) {
                var viewComponent = this.viewEngine.getViewTemplateInfo(viewName);
                return viewComponent && viewComponent.option()
            },
            loadTemplates: function(source) {
                return this.viewEngine.loadTemplates(source)
            },
            templateContext: function() {
                return this._templateContext
            }
        })
    })(jQuery, DevExpress);
    /*! Module framework, file framework.transitionExecutor.js */
    (function($, DX) {
        $.fn.extend({unwrapInner: function(selector) {
                return this.each(function() {
                        var t = this,
                            c = $(t).children(selector);
                        c.each(function() {
                            var e = $(this);
                            e.contents().appendTo(t);
                            e.remove()
                        })
                    })
            }});
        var TRANSITION_DURATION = 400;
        var TransitionExecutor = DX.Class.inherit({
                ctor: function(container, options) {
                    this.container = container;
                    this.options = options
                },
                exec: function() {
                    var that = this,
                        options = that.options;
                    var $source = options.source,
                        $destination = options.destination;
                    var $sourceAbsoluteWrapper = $source,
                        $destinationRelativeWrapper = $destination,
                        $destinationAbsoluteWrapper = that._getTransitionInnerElement($destination);
                    this._finalize = function(){};
                    return that._animate($.extend({}, options, {
                            source: $sourceAbsoluteWrapper,
                            destination: $destinationAbsoluteWrapper
                        }))
                },
                finalize: function() {
                    if (!this._finalize)
                        throw DX.Error("E3015");
                    this._finalize()
                },
                _getTransitionInnerElement: function($transitionElement) {
                    return $transitionElement.children(".dx-active-view:not(.dx-transition-source)")
                },
                _animate: function() {
                    return (new $.Deferred).resolve().promise()
                }
            });
        var NoneTransitionExecutor = TransitionExecutor.inherit({_animate: function(options) {
                    var $source = options.source,
                        $destination = options.destination;
                    var containerWidth = this.container.width();
                    DX.fx.animate($source, {
                        type: "slide",
                        from: {left: 0},
                        to: {left: 0},
                        duration: 0
                    });
                    DX.fx.animate($destination, {
                        type: "slide",
                        from: {left: -containerWidth},
                        to: {left: -containerWidth},
                        duration: 0
                    });
                    return $.Deferred().resolve().promise()
                }});
        var SlideTransitionExecutor = TransitionExecutor.inherit({_animate: function(options) {
                    if (options.direction === "none")
                        return $.Deferred().resolve().promise();
                    var $source = options.source,
                        $destination = options.destination;
                    var directionModifier = options.direction === "backward" ? -1 : 1,
                        rtlModifier = DX.rtlEnabled ? -1 : 1,
                        containerWidth = this.container.width() * directionModifier * rtlModifier;
                    var promiseSource = DX.fx.animate($source, {
                            type: "slide",
                            from: {left: containerWidth},
                            to: {left: 0},
                            duration: TRANSITION_DURATION
                        });
                    var promiseDestination = DX.fx.animate($destination, {
                            type: "slide",
                            from: {left: 0},
                            to: {left: -containerWidth},
                            duration: TRANSITION_DURATION
                        });
                    return $.when(promiseDestination, promiseSource)
                }});
        var SlideIOS7TransitionExecutor = TransitionExecutor.inherit({_animate: function(options) {
                    if (options.direction === "none")
                        return $.Deferred().resolve().promise();
                    var $source = options.source,
                        $destination = options.destination;
                    var rtlModifier = DX.rtlEnabled ? -1 : 1,
                        containerWidth = this.container.width() * rtlModifier,
                        slowTransitionWidth = containerWidth / 5,
                        sourceLeftFrom,
                        sourceLeftTo,
                        destinationLeftFrom,
                        destinationLeftTo,
                        sourceZIndex = $source.css("z-index"),
                        destinationZIndex = $destination.css("z-index");
                    if (options.direction === "backward") {
                        sourceLeftFrom = -slowTransitionWidth;
                        sourceLeftTo = 0;
                        destinationLeftFrom = 0;
                        destinationLeftTo = containerWidth;
                        $source.css("z-index", 1);
                        $destination.css("z-index", 2)
                    }
                    else {
                        sourceLeftFrom = containerWidth;
                        sourceLeftTo = 0;
                        destinationLeftFrom = 0;
                        destinationLeftTo = -slowTransitionWidth;
                        $source.css("z-index", 2);
                        $destination.css("z-index", 1)
                    }
                    var promiseSource = DX.fx.animate($source, {
                            type: "slide",
                            from: {left: sourceLeftFrom},
                            to: {left: sourceLeftTo},
                            duration: TRANSITION_DURATION
                        });
                    var promiseDestination = DX.fx.animate($destination, {
                            type: "slide",
                            from: {left: destinationLeftFrom},
                            to: {left: destinationLeftTo},
                            duration: TRANSITION_DURATION
                        });
                    return $.when(promiseDestination, promiseSource).done(function() {
                            $source.css("z-index", sourceZIndex);
                            $destination.css("z-index", destinationZIndex)
                        })
                }});
        var OverflowTransitionExecutor = TransitionExecutor.inherit({_animate: function(options) {
                    var $source = options.source,
                        $destination = options.destination,
                        destinationTop = $destination.position().top,
                        destinationLeft = $destination.position().left,
                        containerWidth = this.container.width();
                    if (options.direction === "backward")
                        containerWidth = -containerWidth;
                    var animations = [];
                    if (options.direction === "forward")
                        animations.push(DX.fx.animate($source, {
                            type: "slide",
                            from: {
                                top: destinationTop,
                                left: containerWidth + destinationLeft,
                                "z-index": 1
                            },
                            to: {left: destinationLeft},
                            duration: TRANSITION_DURATION
                        }));
                    else {
                        animations.push(DX.fx.animate($source, {
                            type: "slide",
                            from: {
                                left: destinationLeft,
                                "z-index": 1
                            },
                            to: {left: destinationLeft},
                            duration: TRANSITION_DURATION
                        }));
                        animations.push(DX.fx.animate($destination, {
                            type: "slide",
                            from: {"z-index": 2},
                            to: {left: destinationLeft - containerWidth},
                            duration: TRANSITION_DURATION
                        }))
                    }
                    return $.when.apply($, animations)
                }});
        var FadeTransitionExecutor = TransitionExecutor.inherit({_animate: function(options) {
                    var $source = options.source,
                        $destination = options.destination,
                        d = new $.Deferred;
                    $source.css({opacity: 0});
                    $destination.animate({opacity: 0}, TRANSITION_DURATION);
                    $source.animate({opacity: 1}, TRANSITION_DURATION, function() {
                        d.resolve()
                    });
                    return d.promise()
                }});
        var transitionType = function(options) {
                if (options.type === "fade")
                    return options.type;
                if (options.direction === "none")
                    return "none";
                return options.type
            };
        TransitionExecutor.create = function(container, options) {
            var device = DX.devices.current();
            switch (transitionType(options)) {
                case"none":
                    return new NoneTransitionExecutor(container, options);
                case"slide":
                    if (device.platform === "ios" && device.version[0] === 7)
                        return new SlideIOS7TransitionExecutor(container, options);
                    else
                        return new SlideTransitionExecutor(container, options);
                case"fade":
                    return new FadeTransitionExecutor(container, options);
                case"overflow":
                    return new OverflowTransitionExecutor(container, options);
                default:
                    throw DX.Error("E3016", options.type);
            }
        };
        DX.framework.html.TransitionExecutor = TransitionExecutor;
        DX.framework.html.NoneTransitionExecutor = NoneTransitionExecutor;
        DX.framework.html.SlideIOS7TransitionExecutor = SlideIOS7TransitionExecutor;
        DX.framework.html.SlideTransitionExecutor = SlideTransitionExecutor;
        DX.framework.html.OverflowTransitionExecutor = OverflowTransitionExecutor;
        DX.framework.html.FadeTransitionExecutor = FadeTransitionExecutor
    })(jQuery, DevExpress);
    DevExpress.MOD_FRAMEWORK = true
}
if (!DevExpress.MOD_VIZ_CORE) {
    if (!window.DevExpress)
        throw Error('Required module is not referenced: core');
    /*! Module viz-core, file namespaces.js */
    (function(DevExpress) {
        DevExpress.viz = {}
    })(DevExpress);
    /*! Module viz-core, file namespaces.js */
    (function(DevExpress) {
        DevExpress.viz.core = {}
    })(DevExpress);
    /*! Module viz-core, file errorsWarnings.js */
    (function(DX) {
        $.extend(DX.ERROR_MESSAGES, {
            E2001: "Invalid data source",
            E2002: "Axis type and data type are incompatible",
            E2003: "\"{0}\" data source field contains data of unsupported type",
            E2004: "\"{0}\" data source field is inconsistent",
            E2101: "Unknown series type was specified: {0}",
            E2102: "Ambiguity occurred between two value axes with the same name",
            E2103: "\"{0}\" option must be a function",
            E2104: "Invalid logarithm base",
            E2105: "Invalid value of a \"{0}\"",
            E2106: "Invalid visible range",
            E2202: "Invalid scale {0} value",
            E2203: "The \"{0}\" field of the \"selectedRange\" configuration object is not valid",
            W2001: "{0} cannot be drawn because its container is invisible",
            W2002: "The {0} data field is absent",
            W2003: "Tick interval is too small",
            W2101: "\"{0}\" pane does not exist; \"{1}\" pane is used instead",
            W2102: "Value axis with the \"{0}\" name was created automatically",
            W2103: "Chart title was hidden due to container size",
            W2104: "Legend was hidden due to container size",
            W2105: "Title of \"{0}\" axis was hidden due to container size",
            W2106: "Labels of \"{0}\" axis were hidden due to container size",
            W2301: "Invalid value range"
        })
    })(DevExpress);
    /*! Module viz-core, file numericTickManager.js */
    (function($, DX, undefined) {
        var core = DX.viz.core,
            utils = DX.utils,
            _isDefined = utils.isDefined,
            _adjustValue = utils.adjustValue,
            _math = Math,
            _abs = _math.abs,
            _ceil = _math.ceil,
            _floor = _math.floor,
            _noop = $.noop,
            MINOR_TICKS_COUNT_LIMIT = 200;
        core.outOfScreen = {
            x: -1000,
            y: -1000
        };
        core.tickManager = {};
        core.tickManager.continuous = {
            _hasUnitBeginningTickCorrection: _noop,
            _removeInvalidDatesWithUnitBegining: _noop,
            _checkLabelFormat: _noop,
            _correctInterval: function(step) {
                this._tickInterval *= step
            },
            _correctMax: function(tickInterval) {
                this._max = this._adjustNumericTickValue(_ceil(this._max / tickInterval) * tickInterval, tickInterval, this._min)
            },
            _correctMin: function(tickInterval) {
                this._min = this._adjustNumericTickValue(_floor(this._min / tickInterval) * tickInterval, tickInterval, this._min)
            },
            _correctTimeZoneGaps: function(value1, value2) {
                return value2
            },
            _findBusinessDelta: function(min, max) {
                return _adjustValue(_abs(min - max))
            },
            _findTickIntervalForCustomTicks: function() {
                return _abs(this._customTicks[1] - this._customTicks[0])
            },
            _getBoundInterval: function() {
                var that = this,
                    boundCoef = that._options.boundCoef;
                return _isDefined(boundCoef) && isFinite(boundCoef) ? that._tickInterval * _abs(boundCoef) : that._tickInterval / 2
            },
            _getInterval: function(deltaCoef) {
                var interval = deltaCoef || this._getDeltaCoef(),
                    multipliers = this._options.numberMultipliers,
                    factor,
                    result = 0,
                    newResult,
                    hasResult = false,
                    i;
                if (interval > 1.0)
                    for (factor = 1; !hasResult; factor *= 10)
                        for (i = 0; i < multipliers.length; i++) {
                            result = multipliers[i] * factor;
                            if (interval <= result) {
                                hasResult = true;
                                break
                            }
                        }
                else if (interval > 0) {
                    result = 1;
                    for (factor = 0.1; !hasResult; factor /= 10)
                        for (i = multipliers.length - 1; i >= 0; i--) {
                            newResult = multipliers[i] * factor;
                            if (interval > newResult) {
                                hasResult = true;
                                break
                            }
                            result = newResult
                        }
                }
                return _adjustValue(result)
            },
            _getMarginValue: function(min, max, margin) {
                return utils.applyPrecisionByMinDelta(min, margin, _abs(max - min) * margin)
            },
            _getMinorInterval: function(screenDelta, businessDelta, firstTick, secondTick) {
                var that = this,
                    options = that._options,
                    minorTickInterval = options.minorTickInterval,
                    minorTickCount = options.minorTickCount,
                    interval,
                    intervalsCount,
                    count;
                if (isFinite(minorTickInterval) && that._isTickIntervalCorrect(minorTickInterval, MINOR_TICKS_COUNT_LIMIT, businessDelta)) {
                    interval = minorTickInterval;
                    count = interval < businessDelta ? _ceil(businessDelta / interval) - 1 : 0
                }
                else {
                    intervalsCount = _isDefined(minorTickCount) ? minorTickCount + 1 : _floor(screenDelta / options.minorGridSpacingFactor);
                    count = intervalsCount - 1;
                    interval = count > 0 ? businessDelta / intervalsCount : 0;
                    interval = options.withMinorCorrection ? that._adjustNumericTickValue(interval, firstTick, secondTick) : interval
                }
                that._minorTickInterval = interval;
                that._minorTickCount = count
            },
            _getNextTickValue: function(value, tickInterval, isTickIntervalNegative) {
                var tickInterval = _isDefined(isTickIntervalNegative) && isTickIntervalNegative ? -tickInterval : tickInterval,
                    newValue = value + tickInterval;
                return this._adjustNumericTickValue(newValue, tickInterval, this._min)
            },
            _isTickIntervalValid: function(tickInterval) {
                return _isDefined(tickInterval) && isFinite(tickInterval) && tickInterval !== 0
            }
        }
    })(jQuery, DevExpress);
    /*! Module viz-core, file datetimeTickManager.js */
    (function($, DX, undefined) {
        var core = DX.viz.core,
            utils = DX.utils,
            _isDefined = utils.isDefined,
            _convertDateUnitToMilliseconds = utils.convertDateUnitToMilliseconds,
            _correctDateWithUnitBeginning = utils.correctDateWithUnitBeginning,
            _convertDateTickIntervalToMilliseconds = utils.convertDateTickIntervalToMilliseconds,
            _convertMillisecondsToDateUnits = utils.convertMillisecondsToDateUnits,
            _math = Math,
            _abs = _math.abs,
            _ceil = _math.ceil,
            _floor = _math.floor,
            _round = _math.round,
            MINOR_TICKS_COUNT_LIMIT = 50,
            DEFAULT_DATETIME_MULTIPLIERS = {
                millisecond: [1, 2, 5, 10, 25, 100, 250, 300, 500],
                second: [1, 2, 3, 5, 10, 15, 20, 30],
                minute: [1, 2, 3, 5, 10, 15, 20, 30],
                hour: [1, 2, 3, 4, 6, 8, 12],
                day: [1, 2, 3, 5, 7, 10, 14],
                month: [1, 2, 3, 6]
            };
        core.tickManager.datetime = $.extend({}, core.tickManager.continuous, {
            _checkLabelFormat: function() {
                var options = this._options;
                if (!options.hasLabelFormat && this._ticks.length)
                    options.labelOptions.format = DX.formatHelper.getDateFormatByTicks(this._ticks)
            },
            _correctInterval: function(step) {
                var tickIntervalInMs = _convertDateTickIntervalToMilliseconds(this._tickInterval);
                this._tickInterval = _convertMillisecondsToDateUnits(tickIntervalInMs * step)
            },
            _correctMax: function(tickInterval) {
                var interval = _convertDateTickIntervalToMilliseconds(tickInterval);
                this._max = new Date(_ceil(this._max / interval) * interval)
            },
            _correctMin: function(tickInterval) {
                var interval = _convertDateTickIntervalToMilliseconds(tickInterval);
                this._min = new Date(_floor(this._min / interval) * interval);
                if (this._options.setTicksAtUnitBeginning)
                    _correctDateWithUnitBeginning(this._min, tickInterval)
            },
            _correctTimeZoneGaps: function(value1, value2) {
                var diff,
                    sign,
                    trial;
                diff = value1.getHours() - value2.getHours();
                if (diff == 0 || _convertDateTickIntervalToMilliseconds(this._tickInterval) !== _convertDateUnitToMilliseconds("day", 1))
                    return value2;
                sign = diff == 1 || diff == -23 ? -1 : 1;
                trial = new Date(value2.getTime() + sign * 3600000);
                if (sign > 0 || trial.getDate() == value2.getDate())
                    value2.setTime(trial.getTime());
                return value2
            },
            _findTickIntervalForCustomTicks: function() {
                return _convertMillisecondsToDateUnits(_abs(this._customTicks[1] - this._customTicks[0]))
            },
            _getBoundInterval: function() {
                var that = this,
                    interval = that._tickInterval,
                    intervalInMs = _convertDateTickIntervalToMilliseconds(interval),
                    boundCoef = that._options.boundCoef,
                    boundIntervalInMs = _isDefined(boundCoef) && isFinite(boundCoef) ? intervalInMs * _abs(boundCoef) : intervalInMs / 2;
                return _convertMillisecondsToDateUnits(boundIntervalInMs)
            },
            _getInterval: function(deltaCoef) {
                var interval = deltaCoef || this._getDeltaCoef(),
                    multipliers = this._options.numberMultipliers,
                    result = {},
                    factor,
                    key,
                    specificMultipliers,
                    yearsCount,
                    i;
                if (interval > 0 && interval < 1.0)
                    return {milliseconds: 1};
                else if (interval === 0)
                    return 0;
                for (key in DEFAULT_DATETIME_MULTIPLIERS)
                    if (DEFAULT_DATETIME_MULTIPLIERS.hasOwnProperty(key)) {
                        specificMultipliers = DEFAULT_DATETIME_MULTIPLIERS[key];
                        for (i = 0; i < specificMultipliers.length; i++)
                            if (interval <= _convertDateUnitToMilliseconds(key, specificMultipliers[i])) {
                                result[key + 's'] = specificMultipliers[i];
                                return result
                            }
                    }
                for (factor = 1; ; factor *= 10)
                    for (i = 0; i < multipliers.length; i++) {
                        yearsCount = factor * multipliers[i];
                        if (interval <= _convertDateUnitToMilliseconds('year', yearsCount))
                            return {years: yearsCount}
                    }
                return 0
            },
            _getMarginValue: function(min, max, margin) {
                return _convertMillisecondsToDateUnits(_round(_abs(max - min) * margin))
            },
            _getMinorInterval: function(screenDelta, businessDelta) {
                var that = this,
                    options = that._options,
                    interval,
                    intervalInMs,
                    intervalsCount,
                    count;
                if (_isDefined(options.minorTickInterval) && that._isTickIntervalCorrect(options.minorTickInterval, MINOR_TICKS_COUNT_LIMIT, businessDelta)) {
                    interval = options.minorTickInterval;
                    intervalInMs = _convertDateTickIntervalToMilliseconds(interval);
                    count = intervalInMs < businessDelta ? _ceil(businessDelta / intervalInMs) - 1 : 0
                }
                else {
                    intervalsCount = _isDefined(options.minorTickCount) ? options.minorTickCount + 1 : _floor(screenDelta / options.minorGridSpacingFactor);
                    count = intervalsCount - 1;
                    interval = count > 0 ? _convertMillisecondsToDateUnits(businessDelta / intervalsCount) : 0
                }
                that._minorTickInterval = interval;
                that._minorTickCount = count
            },
            _getNextTickValue: function(value, tickInterval, isTickIntervalNegative, isTickIntervalWithPow, withCorrection) {
                var value = utils.addInterval(value, tickInterval, isTickIntervalNegative);
                if (this._options.setTicksAtUnitBeginning && withCorrection !== false) {
                    _correctDateWithUnitBeginning(value, tickInterval);
                    this._correctDateWithUnitBeginningCalled = true
                }
                return value
            },
            _getUnitBeginningMinorTicks: function(minorTicks) {
                var that = this,
                    ticks = that._ticks,
                    tickInterval = that._findMinorTickInterval(ticks[1], ticks[2]),
                    isTickIntervalNegative = true,
                    isTickIntervalWithPow = false,
                    needCorrectTick = false,
                    startTick = that._getNextTickValue(ticks[1], tickInterval, isTickIntervalNegative, isTickIntervalWithPow, needCorrectTick);
                if (that._isTickIntervalValid(tickInterval))
                    minorTicks = that._createTicks(minorTicks, tickInterval, startTick, ticks[0], isTickIntervalNegative, isTickIntervalWithPow, needCorrectTick);
                return minorTicks
            },
            _hasUnitBeginningTickCorrection: function() {
                var ticks = this._ticks;
                if (ticks.length < 3)
                    return false;
                return ticks[1] - ticks[0] !== ticks[2] - ticks[1] && this._options.setTicksAtUnitBeginning && this._options.minorTickCount
            },
            _isTickIntervalValid: function(tickInterval) {
                return _isDefined(tickInterval) && _convertDateTickIntervalToMilliseconds(tickInterval) !== 0
            },
            _removeInvalidDatesWithUnitBegining: function() {
                var dates = this._ticks;
                if (dates.length <= 2 || !this._options.setTicksAtUnitBeginning)
                    return;
                if (!this._areDisplayValuesValid(dates[0], dates[1]))
                    dates.splice(1, 1)
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file logarithmicTickManager.js */
    (function($, DX, undefined) {
        var core = DX.viz.core,
            utils = DX.utils,
            _isDefined = utils.isDefined,
            _addInterval = utils.addInterval,
            _adjustValue = utils.adjustValue,
            _getLog = utils.getLog,
            _raiseTo = utils.raiseTo,
            _math = Math,
            _abs = _math.abs,
            _ceil = _math.ceil,
            _floor = _math.floor,
            _round = _math.round,
            _noop = $.noop;
        core.tickManager.logarithmic = $.extend({}, core.tickManager.continuous, {
            _correctMax: function(tickInterval) {
                this._max = _raiseTo(_ceil(_adjustValue(_getLog(this._max, this._options.base)) / tickInterval * tickInterval), this._options.base)
            },
            _correctMin: function(tickInterval) {
                this._min = _raiseTo(_floor(_adjustValue(_getLog(this._min, this._options.base)) / tickInterval * tickInterval), this._options.base)
            },
            _findBusinessDelta: function(min, max, isTickIntervalWithPow) {
                if (isTickIntervalWithPow === false)
                    return core.tickManager.continuous._findBusinessDelta(min, max);
                else
                    return _round(_abs(_getLog(min, this._options.base) - _getLog(max, this._options.base)))
            },
            _findTickIntervalForCustomTicks: function() {
                return _adjustValue(_getLog(this._customTicks[1] / this._customTicks[0], this._options.base))
            },
            _getInterval: function(deltaCoef) {
                var interval = deltaCoef || this._getDeltaCoef(),
                    multipliers = this._options.numberMultipliers,
                    factor,
                    result = 0,
                    newResult,
                    hasResult = false,
                    i;
                if (interval !== 0)
                    for (factor = 1; !hasResult; factor *= 10)
                        for (i = 0; i < multipliers.length; i++) {
                            result = multipliers[i] * factor;
                            if (interval <= result) {
                                hasResult = true;
                                break
                            }
                        }
                return _adjustValue(result)
            },
            _getMinorInterval: function(screenDelta, businessDelta) {
                var that = this,
                    options = that._options,
                    minorTickCount = options.minorTickCount,
                    intervalsCount = _isDefined(minorTickCount) ? minorTickCount + 1 : _floor(screenDelta / options.minorGridSpacingFactor),
                    count = intervalsCount - 1,
                    interval = count > 0 ? businessDelta / intervalsCount : 0;
                that._minorTickInterval = interval;
                that._minorTickCount = count
            },
            _getMarginValue: function() {
                return null
            },
            _getNextTickValue: function(value, tickInterval, isTickIntervalNegative, isTickIntervalWithPow) {
                var that = this,
                    tickInterval = _isDefined(isTickIntervalNegative) && isTickIntervalNegative ? -tickInterval : tickInterval,
                    pow,
                    nextTickValue;
                if (isTickIntervalWithPow === false)
                    nextTickValue = value + tickInterval;
                else {
                    pow = _addInterval(_adjustValue(_getLog(value, that._options.base)), tickInterval, that._min > that._max);
                    nextTickValue = _raiseTo(pow, that._options.base)
                }
                return nextTickValue
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file tickOverlappingManager.js */
    (function($, DX, undefined) {
        var core = DX.viz.core,
            coreTickManager = core.tickManager,
            utils = DX.utils,
            _isDefined = utils.isDefined,
            _isNumber = utils.isNumber,
            _math = Math,
            _abs = _math.abs,
            _ceil = _math.ceil,
            _floor = _math.floor,
            _atan = _math.atan,
            _max = _math.max,
            _each = $.each,
            _map = $.map,
            _noop = $.noop,
            _isFunction = $.isFunction,
            SCREEN_DELTA_KOEF = 4,
            AXIS_STAGGER_OVERLAPPING_KOEF = 2,
            STAGGER = "stagger",
            ROTATE = "rotate",
            MIN_ARRANGEMENT_TICKS_COUNT = 2;
        var nextState = function(state) {
                switch (state) {
                    case"overlap":
                        return STAGGER;
                    case STAGGER:
                        return ROTATE;
                    case ROTATE:
                    default:
                        return "end"
                }
            };
        var defaultGetTextFunc = function(value) {
                return value.toString()
            };
        coreTickManager.overlappingMethods = {};
        coreTickManager.overlappingMethods.base = {
            _applyOverlappingBehavior: function() {
                var that = this,
                    options = that._options,
                    overlappingBehavior = options && options.overlappingBehavior;
                if (overlappingBehavior && overlappingBehavior.mode !== "ignore") {
                    that._useAutoArrangement = true;
                    that._correctTicks();
                    if (overlappingBehavior.mode === "auto") {
                        that._applyAutoOverlappingBehavior();
                        that._useAutoArrangement = options.overlappingBehavior.isOverlapped
                    }
                    if (that._useAutoArrangement) {
                        if (overlappingBehavior.mode === STAGGER)
                            that._screenDelta *= AXIS_STAGGER_OVERLAPPING_KOEF;
                        that._applyAutoArrangement()
                    }
                }
            },
            getMaxLabelParams: function(ticks) {
                var that = this,
                    ticks = ticks || that._getMajorTicks(),
                    getText = that._options.getText || defaultGetTextFunc,
                    tickWithMaxLength,
                    tickTextWithMaxLength,
                    maxLength = 0,
                    bbox;
                if (!ticks.length)
                    return {
                            width: 0,
                            height: 0,
                            length: 0,
                            y: 0
                        };
                _each(ticks, function(_, item) {
                    var text = getText(item, that._options.labelOptions),
                        length = text.length;
                    if (maxLength < length) {
                        maxLength = length;
                        tickWithMaxLength = item;
                        tickTextWithMaxLength = text
                    }
                });
                bbox = that._getTextElementBbox(tickWithMaxLength, tickTextWithMaxLength);
                return {
                        width: bbox.width,
                        height: bbox.height,
                        y: bbox.y,
                        length: maxLength
                    }
            },
            _correctTicks: function() {
                var getIntervalFunc = coreTickManager.continuous._getInterval,
                    arrangementStep;
                if (this._testingGetIntervalFunc)
                    getIntervalFunc = this._testingGetIntervalFunc;
                arrangementStep = _ceil(getIntervalFunc.call(this, this._getDeltaCoef(this._screenDelta * SCREEN_DELTA_KOEF, this._ticks.length))) || this._ticks.length;
                this._appliedArrangementStep = arrangementStep;
                this._ticks = this._getAutoArrangementTicks(arrangementStep)
            },
            _applyAutoArrangement: function() {
                var that = this,
                    options = that._options,
                    arrangementStep,
                    maxDisplayValueSize;
                if (that._useAutoArrangement) {
                    maxDisplayValueSize = that._getTicksSize();
                    arrangementStep = that._getAutoArrangementStep(maxDisplayValueSize);
                    if (arrangementStep > 1)
                        if (_isDefined(that._tickInterval) || _isDefined(that._customTicks))
                            that._ticks = that._getAutoArrangementTicks(arrangementStep);
                        else {
                            options.gridSpacingFactor = maxDisplayValueSize;
                            that._ticks = that._createTicks([], that._findTickInterval(), that._min, that._max)
                        }
                    that._removeInvalidDatesWithUnitBegining();
                    that._applyStartEndTicksCorrection()
                }
            },
            _getAutoArrangementTicks: function(step) {
                var that = this,
                    ticks = that._ticks,
                    ticksLength = ticks.length,
                    resultTicks = ticks,
                    decimatedTicks = that._decimatedTicks || [],
                    i;
                if (step > 1) {
                    resultTicks = [];
                    for (i = 0; i < ticksLength; i++)
                        if (i % step === 0)
                            resultTicks.push(ticks[i]);
                        else
                            decimatedTicks.push(ticks[i]);
                    that._correctInterval(step)
                }
                return resultTicks
            },
            _isOverlappedTicks: function(screenDelta) {
                return this._getAutoArrangementStep(this._getTicksSize(), screenDelta, -1) > 1
            },
            _areDisplayValuesValid: function(value1, value2) {
                var that = this,
                    options = that._options,
                    getText = options.getText || defaultGetTextFunc,
                    rotationAngle = options.overlappingBehavior && _isNumber(options.overlappingBehavior.rotationAngle) ? options.overlappingBehavior.rotationAngle : 0,
                    bBox1 = that._getTextElementBbox(value1, getText(value1, options.labelOptions)),
                    bBox2 = that._getTextElementBbox(value2, getText(value2, options.labelOptions)),
                    horizontalInverted = bBox1.x > bBox2.x,
                    verticalInverted = bBox1.y > bBox2.y,
                    hasHorizontalOverlapping,
                    hasVerticalOverlapping,
                    result;
                if (rotationAngle !== 0)
                    result = that._getDistanceByAngle(bBox1.height, rotationAngle) <= _abs(bBox2.x - bBox1.x);
                else {
                    hasHorizontalOverlapping = !horizontalInverted ? bBox1.x + bBox1.width > bBox2.x : bBox2.x + bBox2.width > bBox1.x;
                    hasVerticalOverlapping = !verticalInverted ? bBox1.y + bBox1.height > bBox2.y : bBox2.y + bBox2.height > bBox1.y;
                    result = !(hasHorizontalOverlapping && hasVerticalOverlapping)
                }
                return result
            }
        };
        coreTickManager.overlappingMethods.circular = $.extend({}, coreTickManager.overlappingMethods.base, {
            _applyAutoOverlappingBehavior: function() {
                this._options.overlappingBehavior.isOverlapped = true
            },
            _getTextElementBbox: function(value, text) {
                var textOptions = $.extend({}, this._options.textOptions, {rotate: 0}),
                    delta = _isFunction(this._options.translate) ? this._options.translate(value) : {
                        x: 0,
                        y: 0
                    },
                    text = this._options.renderText(text, delta.x, delta.y).css(this._options.textFontStyles).attr(textOptions),
                    bbox = text.getBBox();
                text.remove();
                return bbox
            },
            _getTicksSize: function() {
                return this.getMaxLabelParams(this._ticks)
            },
            _applyStartEndTicksCorrection: function() {
                var ticks = this._ticks,
                    lastTick = ticks[ticks.length - 1];
                if (ticks.length > 1 && !this._areDisplayValuesValid(ticks[0], lastTick)) {
                    this._decimatedTicks.push(lastTick);
                    ticks.pop()
                }
            },
            _getAutoArrangementStep: function(maxDisplayValueSize) {
                var that = this,
                    options = that._options,
                    radius = options.circularRadius,
                    startAngle = options.circularStartAngle,
                    endAngle = options.circularEndAngle,
                    circleDelta = startAngle === endAngle ? 360 : _abs(startAngle - endAngle),
                    degreesPerTick = that._tickInterval * circleDelta / that._businessDelta,
                    width = maxDisplayValueSize.width,
                    height = maxDisplayValueSize.height,
                    angle1 = _abs(2 * _atan(height / (2 * radius - width)) * 180 / _math.PI),
                    angle2 = _abs(2 * _atan(width / (2 * radius - height)) * 180 / _math.PI),
                    minAngleForTick = _max(angle1, angle2),
                    step = 1;
                if (degreesPerTick < minAngleForTick)
                    step = _ceil(minAngleForTick / degreesPerTick);
                return _max(1, step)
            }
        });
        coreTickManager.overlappingMethods.linear = $.extend({}, coreTickManager.overlappingMethods.base, {
            _getTextElementBbox: function(value, text) {
                var textOptions = $.extend({}, this._options.textOptions, {rotate: 0}),
                    x = 0,
                    y = 0,
                    delta = _isFunction(this._options.translate) ? this._options.translate(value) : 0,
                    text,
                    bbox;
                if (this._options.isHorizontal)
                    x += delta;
                else
                    y += delta;
                text = this._options.renderText(text, x, y).css(this._options.textFontStyles).attr(textOptions);
                bbox = text.getBBox();
                text.remove();
                return bbox
            },
            _applyStartEndTicksCorrection: _noop,
            _getAutoArrangementStep: function(maxDisplayValueSize, screenDelta, minArrangementTicksStep) {
                var that = this,
                    options = that._options,
                    requiredValuesCount,
                    textSpacing = options.textSpacing || 0,
                    addedSpacing = options.isHorizontal ? textSpacing : 0;
                screenDelta = screenDelta || that._screenDelta;
                minArrangementTicksStep = _isDefined(minArrangementTicksStep) ? minArrangementTicksStep : 1;
                if (options.getCustomAutoArrangementStep)
                    return options.getCustomAutoArrangementStep(that._ticks, options);
                if (maxDisplayValueSize > 0) {
                    requiredValuesCount = _floor((screenDelta + textSpacing) / (maxDisplayValueSize + addedSpacing));
                    requiredValuesCount = requiredValuesCount <= minArrangementTicksStep ? MIN_ARRANGEMENT_TICKS_COUNT : requiredValuesCount;
                    return _ceil((options.ticksCount || that._ticks.length) / requiredValuesCount)
                }
                return 1
            },
            _getOptimalRotationAngle: function() {
                var that = this,
                    options = that._options,
                    tick1 = that._ticks[0],
                    tick2 = that._ticks[1],
                    outOfScreen = core.outOfScreen,
                    textOptions = that._textOptions,
                    getText = options.getText || defaultGetTextFunc,
                    textFontStyles = options.textFontStyles,
                    svgElement1 = options.renderText(getText(tick1, options.labelOptions), outOfScreen.x + options.translate(tick1, !options.isHorizontal), outOfScreen.y).css(textFontStyles).attr(textOptions),
                    svgElement2 = options.renderText(getText(tick2, options.labelOptions), outOfScreen.x + options.translate(tick2, !options.isHorizontal), outOfScreen.y).css(textFontStyles).attr(textOptions),
                    bBox1 = svgElement1.getBBox(),
                    bBox2 = svgElement2.getBBox(),
                    angle = _math.asin((bBox1.height + options.textSpacing) / (bBox2.x - bBox1.x)) * 180 / Math.PI;
                svgElement1.remove();
                svgElement2.remove();
                return isNaN(angle) ? 90 : _ceil(angle)
            },
            _applyAutoOverlappingBehavior: function() {
                var that = this,
                    overlappingBehavior = that._options.overlappingBehavior,
                    screenDelta = that._screenDelta,
                    isOverlapped = false,
                    rotationAngle = null,
                    mode = null,
                    state = "overlap";
                while (state !== "end") {
                    isOverlapped = rotationAngle && rotationAngle !== 90 ? false : that._isOverlappedTicks(screenDelta);
                    state = nextState(isOverlapped ? state : null);
                    switch (state) {
                        case STAGGER:
                            screenDelta *= AXIS_STAGGER_OVERLAPPING_KOEF;
                            mode = state;
                            break;
                        case ROTATE:
                            rotationAngle = that._getOptimalRotationAngle();
                            screenDelta = that._screenDelta;
                            mode = state;
                            break
                    }
                }
                overlappingBehavior.isOverlapped = isOverlapped;
                overlappingBehavior.mode = mode;
                overlappingBehavior.rotationAngle = rotationAngle
            },
            _getDistanceByAngle: function(elementHeight, rotationAngle) {
                return elementHeight / _abs(_math.sin(rotationAngle * (_math.PI / 180)))
            },
            _getTicksSize: function() {
                var that = this,
                    options = that._options,
                    ticks = that._ticks,
                    ticksString,
                    rotationAngle = options.overlappingBehavior ? options.overlappingBehavior.rotationAngle : 0,
                    bBox,
                    result,
                    getText = options.getText || defaultGetTextFunc,
                    isRotate = _isNumber(rotationAngle) && rotationAngle !== 0,
                    joinNeeded = !isRotate && options.isHorizontal;
                if (ticks.length === 0)
                    return 0;
                ticksString = joinNeeded ? _map(ticks, function(tick) {
                    return getText(tick, options.labelOptions)
                }).join("\n") : getText(ticks[0], options.labelOptions);
                bBox = that._getTextElementBbox(ticksString, ticksString);
                result = isRotate ? that._getDistanceByAngle(bBox.height, rotationAngle) : options.isHorizontal ? bBox.width : bBox.height;
                return _ceil(result)
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file baseTickManager.js */
    (function($, DX, undefined) {
        var core = DX.viz.core,
            coreTickManager = core.tickManager,
            utils = DX.utils,
            _isDefined = utils.isDefined,
            _isNumber = utils.isNumber,
            _addInterval = utils.addInterval,
            _adjustValue = utils.adjustValue,
            _math = Math,
            _each = $.each,
            _map = $.map,
            _inArray = $.inArray,
            _noop = $.noop,
            DEFAULT_GRID_SPACING_FACTOR = 30,
            DEFAULT_MINOR_GRID_SPACING_FACTOR = 15,
            DEFAULT_NUMBER_MULTIPLIERS = [1, 2, 3, 5],
            DEFAULT_DATETIME_MULTIPLIERS = {
                millisecond: [1, 2, 5, 10, 25, 100, 250, 300, 500],
                second: [1, 2, 3, 5, 10, 15, 20, 30],
                minute: [1, 2, 3, 5, 10, 15, 20, 30],
                hour: [1, 2, 3, 4, 6, 8, 12],
                day: [1, 2, 3, 5, 7, 10, 14],
                month: [1, 2, 3, 6]
            },
            TICKS_COUNT_LIMIT = 2000,
            MIN_ARRANGEMENT_TICKS_COUNT = 2;
        var concatAndSort = function(array1, array2) {
                var array = array1.concat(array2).sort(function(x, y) {
                        return _isDefined(x) && _isDefined(y) && x.valueOf() - y.valueOf()
                    }),
                    length = array.length,
                    i;
                for (i = length - 1; i > 0; i--)
                    if (_isDefined(array[i]) && _isDefined(array[i - 1]) && array[i].valueOf() == array[i - 1].valueOf())
                        array.splice(i, 1);
                return array
            };
        var defaultGetTextFunc = function(value) {
                return value.toString()
            };
        coreTickManager.discrete = $.extend({}, coreTickManager.continuous, {
            _getMinorTicks: _noop,
            _getMarginValue: _noop,
            _generateBounds: _noop,
            _correctMin: _noop,
            _correctMax: _noop,
            _findBusinessDelta: _noop,
            _addBoundedTicks: _noop,
            getFullTicks: function() {
                return this._customTicks
            },
            getMinorTicks: function() {
                return this._decimatedTicks || []
            },
            _findTickIntervalForCustomTicks: function() {
                return 1
            }
        });
        coreTickManager.TickManager = DX.Class.inherit({
            ctor: function(types, data, options) {
                options = options || {};
                this.update(types || {}, data || {}, options);
                this._initOverlappingMethods(options.overlappingBehaviorType)
            },
            dispose: function() {
                this._ticks = null;
                this._minorTicks = null;
                this._decimatedTicks = null;
                this._boundaryTicks = null;
                this._options = null
            },
            update: function(types, data, options) {
                this.updateOptions(options || {});
                this._min = data.min || 0;
                this.updateTypes(types || {});
                this.updateData(data || {})
            },
            updateMinMax: function(data) {
                var min = data.min || 0,
                    max = data.max || 0,
                    newMinMax = this._applyMinMaxMargins(min, max);
                this._min = this._originalMin = newMinMax.min;
                this._max = this._originalMax = newMinMax.max;
                this.updateBusinessDelta()
            },
            updateBusinessDelta: function() {
                this._businessDelta = this._findBusinessDelta && this._findBusinessDelta(this._min, this._max)
            },
            updateTypes: function(types) {
                var that = this,
                    axisType = that._validateAxisType(types.axisType),
                    dataType = that._validateDataType(types.dataType, that._min);
                that._resetMethods();
                this._axisType = axisType;
                this._dataType = dataType;
                this._initMethods();
                that.updateMinMax({
                    min: that._min,
                    max: that._max
                })
            },
            updateData: function(data) {
                data.min = _isDefined(data.min) ? data.min : this._originalMin;
                data.max = _isDefined(data.max) ? data.max : this._originalMax;
                this.updateMinMax(data);
                this._customTicks = data.customTicks && data.customTicks.slice();
                this._customMinorTicks = data.customMinorTicks;
                this._screenDelta = data.screenDelta || 0
            },
            updateOptions: function(options) {
                var opt;
                this._options = opt = options;
                this._useAutoArrangement = !!this._options.useTicksAutoArrangement;
                opt.gridSpacingFactor = opt.gridSpacingFactor || DEFAULT_GRID_SPACING_FACTOR;
                opt.minorGridSpacingFactor = opt.minorGridSpacingFactor || DEFAULT_MINOR_GRID_SPACING_FACTOR;
                opt.numberMultipliers = opt.numberMultipliers || DEFAULT_NUMBER_MULTIPLIERS
            },
            getTickBounds: function() {
                return {
                        minVisible: this._minBound,
                        maxVisible: this._maxBound
                    }
            },
            getTicks: function(withoutOverlappingBehavior) {
                var that = this,
                    options = that._options;
                that._ticks = that._getMajorTicks();
                that._checkLabelFormat();
                that._decimatedTicks = [];
                that._applyAutoArrangement();
                if (!withoutOverlappingBehavior)
                    that._applyOverlappingBehavior();
                that._generateBounds();
                if (options.showMinorTicks)
                    that._minorTicks = that._customMinorTicks || that._getMinorTicks();
                that._addBoundedTicks();
                return that._ticks
            },
            getMinorTicks: function() {
                var that = this,
                    decimatedTicks = that._decimatedTicks || [],
                    options = that._options || {},
                    hasDecimatedTicks = decimatedTicks.length,
                    hasMinorTickOptions = _isDefined(options.minorTickInterval) || _isDefined(options.minorTickCount),
                    hasCustomMinorTicks = that._customMinorTicks && that._customMinorTicks.length,
                    hasMinorTicks = options.showMinorTicks && (hasMinorTickOptions || hasCustomMinorTicks),
                    ticks = hasDecimatedTicks && !hasMinorTicks ? decimatedTicks : that._minorTicks || [];
                return concatAndSort(ticks, [])
            },
            getDecimatedTicks: function() {
                return concatAndSort(this._decimatedTicks || [], [])
            },
            getFullTicks: function() {
                return concatAndSort(this._ticks || [], this.getMinorTicks(), this._axisType)
            },
            getBoundaryTicks: function() {
                return concatAndSort(this._boundaryTicks || [], [])
            },
            getTickInterval: function() {
                return this._tickInterval
            },
            getMinorTickInterval: function() {
                return this._minorTickInterval
            },
            getOverlappingBehavior: function() {
                return this._options.overlappingBehavior
            },
            getOptions: function() {
                return this._options
            },
            getTypes: function() {
                return {
                        axisType: this._axisType,
                        dataType: this._dataType
                    }
            },
            getData: function() {
                return {
                        min: this._min,
                        max: this._max,
                        customTicks: this._customTicks,
                        customMinorTicks: this._customMinorTicks,
                        screenDelta: this._screenDelta
                    }
            },
            _getMajorTicks: function() {
                var ticks;
                if (this._customTicks) {
                    ticks = this._customTicks.slice();
                    this._tickInterval = ticks.length > 1 ? this._findTickIntervalForCustomTicks() : 0
                }
                else
                    ticks = this._createTicks([], this._findTickInterval(), this._min, this._max);
                return ticks
            },
            _applyMargin: function(margin, min, max, isNegative) {
                var coef,
                    value = min;
                if (isFinite(margin)) {
                    coef = this._getMarginValue(min, max, margin);
                    if (coef)
                        value = this._getNextTickValue(min, coef, isNegative, false)
                }
                return value
            },
            _applyMinMaxMargins: function(min, max) {
                var options = this._options,
                    coef,
                    newMin = min > max ? max : min,
                    newMax = max > min ? max : min;
                this._minCorrectionEnabled = this._getCorrectionEnabled(min, "min");
                this._maxCorrectionEnabled = this._getCorrectionEnabled(max, "max");
                if (options && !options.stick) {
                    newMin = this._applyMargin(options.minValueMargin, min, max, true);
                    newMax = this._applyMargin(options.maxValueMargin, max, min, false)
                }
                return {
                        min: newMin,
                        max: newMax
                    }
            },
            _checkBoundedTickInArray: function(value, array) {
                var arrayValues = _map(array || [], function(item) {
                        return item.valueOf()
                    }),
                    minorTicksIndex = _inArray(value.valueOf(), arrayValues);
                if (minorTicksIndex !== -1)
                    array.splice(minorTicksIndex, 1)
            },
            _generateBounds: function() {
                var that = this,
                    interval = that._getBoundInterval(),
                    stick = that._options.stick,
                    minStickValue = that._options.minStickValue,
                    maxStickValue = that._options.maxStickValue,
                    minBound = that._minCorrectionEnabled && !stick ? that._getNextTickValue(that._min, interval, true) : that._originalMin,
                    maxBound = that._maxCorrectionEnabled && !stick ? that._getNextTickValue(that._max, interval) : that._originalMax;
                that._minBound = minBound < minStickValue ? minStickValue : minBound;
                that._maxBound = maxBound > maxStickValue ? maxStickValue : maxBound
            },
            _initOverlappingMethods: function(type) {
                this._initMethods(coreTickManager.overlappingMethods[type || "linear"])
            },
            _addBoundedTicks: function() {
                var that = this,
                    tickValues = _map(that._ticks, function(tick) {
                        return tick.valueOf()
                    }),
                    min = that._originalMin,
                    max = that._originalMax,
                    addMinMax = that._options.addMinMax || {};
                that._boundaryTicks = [];
                if (addMinMax.min && _inArray(min.valueOf(), tickValues) === -1) {
                    that._ticks.splice(0, 0, min);
                    that._boundaryTicks.push(min);
                    that._checkBoundedTickInArray(min, that._minorTicks);
                    that._checkBoundedTickInArray(min, that._decimatedTicks)
                }
                if (addMinMax.max && _inArray(max.valueOf(), tickValues) === -1) {
                    that._ticks.push(max);
                    that._boundaryTicks.push(max);
                    that._checkBoundedTickInArray(max, that._minorTicks);
                    that._checkBoundedTickInArray(max, that._decimatedTicks)
                }
            },
            _getCorrectionEnabled: function(value, marginSelector) {
                var options = this._options || {},
                    hasPercentStick = options.percentStick && value === 1,
                    hasValueMargin = options[marginSelector + "ValueMargin"];
                return !hasPercentStick && !hasValueMargin
            },
            _validateAxisType: function(type) {
                var defaultType = "continuous",
                    allowedTypes = {
                        continuous: true,
                        discrete: true,
                        logarithmic: true
                    };
                return allowedTypes[type] ? type : defaultType
            },
            _validateDataType: function(type, min) {
                var allowedTypes = {
                        numeric: true,
                        datetime: true,
                        string: true
                    },
                    min = min || this._min,
                    defaultType;
                if (allowedTypes[type])
                    return type;
                else
                    return _isDefined(min) ? this._getDataType(min) : "numeric"
            },
            _getDataType: function(value) {
                return utils.isDate(value) ? 'datetime' : 'numeric'
            },
            _getMethods: function() {
                if (this._axisType === "continuous")
                    return this._dataType === "datetime" ? coreTickManager.datetime : coreTickManager.continuous;
                else
                    return coreTickManager[this._axisType] || coreTickManager.continuous
            },
            _resetMethods: function() {
                var that = this,
                    methods = that._getMethods();
                _each(methods, function(name, func) {
                    if (that[name])
                        delete that[name]
                })
            },
            _initMethods: function(methods) {
                var that = this,
                    methods = methods || that._getMethods();
                _each(methods, function(name, func) {
                    that[name] = func
                })
            },
            _getDeltaCoef: function(screenDelta, businessDelta) {
                var gridSpacingFactor = this._options.gridSpacingFactor,
                    screenDelta = screenDelta || this._screenDelta,
                    businessDelta = businessDelta || this._businessDelta,
                    count = screenDelta / gridSpacingFactor;
                count = count <= 1 ? MIN_ARRANGEMENT_TICKS_COUNT : count;
                return businessDelta / count
            },
            _adjustNumericTickValue: function(value, interval, min) {
                return utils.isExponential(value) ? _adjustValue(value) : utils.applyPrecisionByMinDelta(min, interval, value)
            },
            _isTickIntervalCorrect: function(tickInterval, tickCountLimit, businessDelta) {
                var date,
                    businessDelta = businessDelta || this._businessDelta;
                if (!_isNumber(tickInterval)) {
                    date = new Date;
                    tickInterval = _addInterval(date, tickInterval) - date;
                    if (!tickInterval)
                        return false
                }
                if (_isNumber(tickInterval))
                    if (tickInterval > 0 && businessDelta / tickInterval > tickCountLimit) {
                        if (this._options.incidentOccured)
                            this._options.incidentOccured('W2003')
                    }
                    else
                        return true;
                return false
            },
            _correctValue: function(valueTypeSelector, tickInterval, correctionMethod) {
                var that = this,
                    correctionEnabledSelector = "_" + valueTypeSelector + "CorrectionEnabled",
                    spaceCorrectionSelector = valueTypeSelector + "SpaceCorrection",
                    valueSelector = "_" + valueTypeSelector,
                    minStickValue = that._options.minStickValue,
                    maxStickValue = that._options.maxStickValue;
                if (that[correctionEnabledSelector]) {
                    if (that._options[spaceCorrectionSelector])
                        that[valueSelector] = that._getNextTickValue(that[valueSelector], tickInterval, valueTypeSelector === "min");
                    correctionMethod.call(this, tickInterval)
                }
                valueTypeSelector === "min" && (that[valueSelector] = that[valueSelector] < minStickValue ? minStickValue : that[valueSelector]);
                valueTypeSelector === "max" && (that[valueSelector] = that[valueSelector] > maxStickValue ? maxStickValue : that[valueSelector])
            },
            _findTickInterval: function() {
                var that = this,
                    options = that._options,
                    tickInterval;
                tickInterval = that._isTickIntervalValid(options.tickInterval) && that._isTickIntervalCorrect(options.tickInterval, TICKS_COUNT_LIMIT) ? options.tickInterval : that._getInterval();
                if (that._isTickIntervalValid(tickInterval)) {
                    that._correctValue("min", tickInterval, that._correctMin);
                    that._correctValue("max", tickInterval, that._correctMax);
                    that.updateBusinessDelta()
                }
                that._tickInterval = tickInterval;
                return tickInterval
            },
            _findMinorTickInterval: function(firstTick, secondTick) {
                var that = this,
                    ticks = that._ticks,
                    intervals = that._options.stick ? ticks.length - 1 : ticks.length;
                if (intervals < 1)
                    intervals = 1;
                that._getMinorInterval(that._screenDelta / intervals, that._findBusinessDelta(firstTick, secondTick, false), firstTick, secondTick);
                return that._minorTickInterval
            },
            _createMinorTicks: function(ticks, firstTick, secondTick) {
                var that = this,
                    tickInterval = that._findMinorTickInterval(firstTick, secondTick),
                    isTickIntervalNegative = false,
                    isTickIntervalWithPow = false,
                    needCorrectTick = false,
                    startTick = that._getNextTickValue(firstTick, tickInterval, isTickIntervalNegative, isTickIntervalWithPow, needCorrectTick);
                if (that._isTickIntervalValid(tickInterval))
                    ticks = that._createCountedTicks(ticks, tickInterval, startTick, secondTick, that._minorTickCount, isTickIntervalNegative, isTickIntervalWithPow, needCorrectTick);
                return ticks
            },
            _getMinorTicks: function() {
                var that = this,
                    minorTicks = [],
                    ticks = that._ticks,
                    ticksLength = ticks.length,
                    tickInterval,
                    hasUnitBeginningTick = that._hasUnitBeginningTickCorrection(),
                    i = hasUnitBeginningTick ? 1 : 0;
                if (ticks.length) {
                    minorTicks = that._getBoundedMinorTicks(minorTicks, that._minBound, ticks[0], true);
                    if (hasUnitBeginningTick)
                        minorTicks = that._getUnitBeginningMinorTicks(minorTicks);
                    for (i; i < ticksLength - 1; i++)
                        minorTicks = that._createMinorTicks(minorTicks, ticks[i], ticks[i + 1]);
                    minorTicks = that._getBoundedMinorTicks(minorTicks, that._maxBound, ticks[ticksLength - 1])
                }
                else
                    minorTicks = that._createMinorTicks(minorTicks, that._minBound, that._maxBound);
                return minorTicks
            },
            _createCountedTicks: function(ticks, tickInterval, min, max, count, isTickIntervalWithPow, needMax) {
                var value = min,
                    i;
                for (i = 0; i < count; i++) {
                    if (!(needMax === false && value.valueOf() === max.valueOf()))
                        ticks.push(value);
                    value = this._getNextTickValue(value, tickInterval, false, isTickIntervalWithPow, false)
                }
                return ticks
            },
            _createTicks: function(ticks, tickInterval, min, max, isTickIntervalNegative, isTickIntervalWithPow, withCorrection) {
                var that = this,
                    value = min,
                    newValue = min,
                    leftBound,
                    rightBound,
                    boundedRule,
                    i;
                if (that._isTickIntervalValid(tickInterval)) {
                    boundedRule = min - max < 0;
                    do {
                        value = newValue;
                        if (that._options.stick) {
                            if (value >= that._originalMin && value <= that._originalMax)
                                ticks.push(value)
                        }
                        else
                            ticks.push(value);
                        newValue = that._getNextTickValue(value, tickInterval, isTickIntervalNegative, isTickIntervalWithPow, withCorrection);
                        if (value.valueOf() === newValue.valueOf())
                            break;
                        newValue = that._correctTimeZoneGaps(value, newValue);
                        leftBound = newValue - min >= 0;
                        rightBound = max - newValue >= 0
                    } while (boundedRule === leftBound && boundedRule === rightBound)
                }
                else
                    ticks.push(value);
                return ticks
            },
            _getBoundedMinorTicks: function(minorTicks, boundedTick, tick, isNegative) {
                var that = this,
                    needCorrectTick = false,
                    secondTick = that._tickInterval ? this._getNextTickValue(tick, that._tickInterval, isNegative, true, needCorrectTick) : boundedTick,
                    tickInterval = that._findMinorTickInterval(tick, secondTick),
                    startTick = that._getNextTickValue(tick, tickInterval, isNegative, false, false);
                if (that._isTickIntervalCorrect(tickInterval, TICKS_COUNT_LIMIT, that._findBusinessDelta(tick, boundedTick, false)) && that._isTickIntervalValid(tickInterval))
                    minorTicks = that._createTicks(minorTicks, tickInterval, startTick, boundedTick, isNegative, false, needCorrectTick);
                return minorTicks
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file numericTranslator.js */
    (function($, DX, undefined) {
        var utils = DX.utils,
            isDefined = utils.isDefined,
            getPower = utils.getPower,
            round = Math.round;
        DX.viz.core.numericTranslatorFunctions = {
            translate: function(bp) {
                var that = this,
                    canvasOptions = that._canvasOptions,
                    doubleError = canvasOptions.rangeDoubleError,
                    specialValue = that.translateSpecialCase(bp);
                if (isDefined(specialValue))
                    return specialValue;
                if (isNaN(bp) || bp.valueOf() + doubleError < canvasOptions.rangeMin || bp.valueOf() - doubleError > canvasOptions.rangeMax)
                    return null;
                return round(that._calculateProjection((bp - canvasOptions.rangeMinVisible) * canvasOptions.ratioOfCanvasRange))
            },
            untranslate: function(pos, _directionOffset, enableOutOfCanvas) {
                var canvasOptions = this._canvasOptions,
                    startPoint = canvasOptions.startPoint;
                if (!enableOutOfCanvas && (pos < startPoint || pos > canvasOptions.endPoint) || !isDefined(canvasOptions.rangeMin) || !isDefined(canvasOptions.rangeMax))
                    return null;
                return this._calculateUnProjection((pos - startPoint) / canvasOptions.ratioOfCanvasRange)
            },
            getInterval: function() {
                return round(this._canvasOptions.ratioOfCanvasRange * (this._businessRange.interval || Math.abs(this._canvasOptions.rangeMax - this._canvasOptions.rangeMin)))
            },
            _getValue: function(val) {
                return val
            },
            zoom: function(translate, scale) {
                var that = this,
                    canvasOptions = that._canvasOptions,
                    startPoint = canvasOptions.startPoint,
                    endPoint = canvasOptions.endPoint,
                    newStart = (startPoint + translate) / scale,
                    newEnd = (endPoint + translate) / scale,
                    minPoint = Math.min(that.translate(that._getValue(canvasOptions.rangeMin)), that.translate(that._getValue(canvasOptions.rangeMax))),
                    maxPoint = Math.max(that.translate(that._getValue(canvasOptions.rangeMin)), that.translate(that._getValue(canvasOptions.rangeMax)));
                if (minPoint > newStart) {
                    newEnd -= newStart - minPoint;
                    newStart = minPoint
                }
                if (maxPoint < newEnd) {
                    newStart -= newEnd - maxPoint;
                    newEnd = maxPoint
                }
                if (maxPoint - minPoint < newEnd - newStart) {
                    newStart = minPoint;
                    newEnd = maxPoint
                }
                translate = (endPoint - startPoint) * newStart / (newEnd - newStart) - startPoint;
                scale = (startPoint + translate) / newStart || 1;
                return {
                        min: that.untranslate(newStart, undefined, true),
                        max: that.untranslate(newEnd, undefined, true),
                        translate: translate,
                        scale: scale
                    }
            },
            getMinScale: function(zoom) {
                return zoom ? 1.1 : 0.9
            },
            getScale: function(val1, val2) {
                var canvasOptions = this._canvasOptions;
                val1 = isDefined(val1) ? val1 : canvasOptions.rangeMin;
                val2 = isDefined(val2) ? val2 : canvasOptions.rangeMax;
                return (canvasOptions.rangeMax - canvasOptions.rangeMin) / Math.abs(val1 - val2)
            }
        }
    })(jQuery, DevExpress);
    /*! Module viz-core, file datetimeTranslator.js */
    (function($, DX, undefined) {
        var core = DX.viz.core,
            numericTranslator = core.numericTranslatorFunctions;
        core.datetimeTranslatorFunctions = {
            translate: numericTranslator.translate,
            untranslate: function(pos) {
                var result = numericTranslator.untranslate.apply(this, arguments);
                return result === null ? result : new Date(result)
            },
            _getValue: numericTranslator._getValue,
            getInterval: numericTranslator.getInterval,
            zoom: numericTranslator.zoom,
            getMinScale: numericTranslator.getMinScale,
            getScale: numericTranslator.getScale
        }
    })(jQuery, DevExpress);
    /*! Module viz-core, file categoryTranslator.js */
    (function($, DX, undefined) {
        var isDefined = DX.utils.isDefined,
            round = Math.round;
        DX.viz.core.categoryTranslatorFunctions = {
            translate: function(category, directionOffset) {
                var that = this,
                    canvasOptions = that._canvasOptions,
                    categoryRecord = that._categoriesToPoints[category],
                    stickDelta,
                    specialValue = that.translateSpecialCase(category),
                    startPointIndex = canvasOptions.startPointIndex || 0,
                    stickInterval = that._businessRange.stick ? 0 : 0.5;
                if (isDefined(specialValue))
                    return specialValue;
                if (!categoryRecord)
                    return 0;
                directionOffset = directionOffset || 0;
                stickDelta = categoryRecord.index + stickInterval - startPointIndex + directionOffset * 0.5;
                return round(canvasOptions.startPoint + canvasOptions.interval * stickDelta)
            },
            untranslate: function(pos, directionOffset, enableOutOfCanvas) {
                var that = this,
                    canvasOptions = that._canvasOptions,
                    startPoint = canvasOptions.startPoint,
                    categories = that.visibleCategories || that._categories,
                    categoriesLength = categories.length,
                    result = 0,
                    stickInterval = that._businessRange.stick ? 0.5 : 0;
                if (!enableOutOfCanvas && (pos < startPoint || pos > canvasOptions.endPoint))
                    return null;
                directionOffset = directionOffset || 0;
                result = round((pos - startPoint) / canvasOptions.interval + stickInterval - 0.5 - directionOffset * 0.5);
                if (categoriesLength === result)
                    result--;
                if (result === -1)
                    result = 0;
                if (canvasOptions.invert)
                    result = categoriesLength - result - 1;
                return categories[result]
            },
            getInterval: function() {
                return this._canvasOptions.interval
            },
            zoom: function(translate, scale) {
                var that = this,
                    canvasOptions = that._canvasOptions,
                    interval = canvasOptions.interval * scale,
                    translateCaltegories = translate / interval,
                    stick = that._businessRange.stick,
                    startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + translateCaltegories + 0.5),
                    categoriesLength = parseInt(canvasOptions.canvasLength / interval + (stick ? 1 : 0)) || 1,
                    endCategoryIndex,
                    newVisibleCategories,
                    categories = that._categories,
                    newInterval;
                canvasOptions.invert && (categories = categories.slice().reverse());
                if (startCategoryIndex < 0)
                    startCategoryIndex = 0;
                endCategoryIndex = startCategoryIndex + categoriesLength;
                if (endCategoryIndex > categories.length) {
                    endCategoryIndex = categories.length;
                    startCategoryIndex = endCategoryIndex - categoriesLength;
                    if (startCategoryIndex < 0)
                        startCategoryIndex = 0
                }
                newVisibleCategories = categories.slice(parseInt(startCategoryIndex), parseInt(endCategoryIndex));
                newInterval = that._getDiscreteInterval(newVisibleCategories.length, canvasOptions);
                scale = newInterval / canvasOptions.interval;
                translate = that.translate(newVisibleCategories[0]) * scale - (canvasOptions.startPoint + (stick ? 0 : newInterval / 2));
                return {
                        min: newVisibleCategories[0],
                        max: newVisibleCategories[newVisibleCategories.length - 1],
                        translate: translate,
                        scale: scale
                    }
            },
            getMinScale: function(zoom) {
                var that = this,
                    canvasOptions = that._canvasOptions,
                    interval = canvasOptions.interval,
                    categoriesLength = (that.visibleCategories || that._categories).length;
                categoriesLength += (parseInt(categoriesLength * 0.1) || 1) * (zoom ? -2 : 2);
                return canvasOptions.canvasLength / (Math.max(categoriesLength, 1) * canvasOptions.interval)
            },
            getScale: function(min, max) {
                var that = this,
                    visibleArea = that.getCanvasVisibleArea(),
                    stickOffset = !that._businessRange.stick && 1,
                    minPoint = that.translate(min, -stickOffset) || visibleArea.min,
                    maxPoint = that.translate(max, +stickOffset) || visibleArea.max;
                return that.canvasLength / Math.abs(maxPoint - minPoint)
            }
        }
    })(jQuery, DevExpress);
    /*! Module viz-core, file logarithmicTranslator.js */
    (function($, DX, undefined) {
        var core = DX.viz.core,
            numericTranslator = core.numericTranslatorFunctions,
            utils = DX.utils,
            raiseTo = utils.raiseTo,
            getLog = utils.getLog;
        core.logarithmicTranslatorFunctions = {
            translate: function(bp) {
                var that = this,
                    specialValue = that.translateSpecialCase(bp);
                if (utils.isDefined(specialValue))
                    return specialValue;
                return numericTranslator.translate.call(that, getLog(bp, that._businessRange.base))
            },
            untranslate: function(pos) {
                var result = numericTranslator.untranslate.apply(this, arguments);
                return result === null ? result : raiseTo(result, this._businessRange.base)
            },
            getInterval: numericTranslator.getInterval,
            _getValue: function(value) {
                return Math.pow(this._canvasOptions.base, value)
            },
            zoom: numericTranslator.zoom,
            getMinScale: numericTranslator.getMinScale,
            getScale: function(val1, val2) {
                var base = this._businessRange.base;
                val1 = utils.isDefined(val1) ? getLog(val1, base) : undefined;
                val2 = utils.isDefined(val2) ? getLog(val2, base) : undefined;
                return numericTranslator.getScale.call(this, val1, val2)
            }
        }
    })(jQuery, DevExpress);
    /*! Module viz-core, file translator1D.js */
    (function(DX, undefined) {
        var _Number = Number;
        function Translator1D() {
            this.setDomain(arguments[0], arguments[1]).setCodomain(arguments[2], arguments[3])
        }
        Translator1D.prototype = {
            constructor: Translator1D,
            setDomain: function(domain1, domain2) {
                var that = this;
                that._domain1 = _Number(domain1);
                that._domain2 = _Number(domain2);
                that._domainDelta = that._domain2 - that._domain1;
                return that
            },
            setCodomain: function(codomain1, codomain2) {
                var that = this;
                that._codomain1 = _Number(codomain1);
                that._codomain2 = _Number(codomain2);
                that._codomainDelta = that._codomain2 - that._codomain1;
                return that
            },
            getDomain: function() {
                return [this._domain1, this._domain2]
            },
            getCodomain: function() {
                return [this._codomain1, this._codomain2]
            },
            getDomainStart: function() {
                return this._domain1
            },
            getDomainEnd: function() {
                return this._domain2
            },
            getCodomainStart: function() {
                return this._codomain1
            },
            getCodomainEnd: function() {
                return this._codomain2
            },
            getDomainRange: function() {
                return this._domainDelta
            },
            getCodomainRange: function() {
                return this._codomainDelta
            },
            translate: function(value) {
                var ratio = (_Number(value) - this._domain1) / this._domainDelta;
                return 0 <= ratio && ratio <= 1 ? this._codomain1 + ratio * this._codomainDelta : NaN
            },
            adjust: function(value) {
                var ratio = (_Number(value) - this._domain1) / this._domainDelta,
                    result = NaN;
                if (ratio < 0)
                    result = this._domain1;
                else if (ratio > 1)
                    result = this._domain2;
                else if (0 <= ratio && ratio <= 1)
                    result = _Number(value);
                return result
            }
        };
        DX.viz.core.Translator1D = Translator1D
    })(DevExpress);
    /*! Module viz-core, file translator2D.js */
    (function($, DX, undefined) {
        var core = DX.viz.core,
            utils = DX.utils,
            getLog = utils.getLog,
            getPower = utils.getPower,
            raiseTo = utils.raiseTo,
            isDefined = utils.isDefined,
            _abs = Math.abs,
            CANVAS_PROP = ["width", "height", "left", "top", "bottom", "right"],
            NUMBER_EQUALITY_CORRECTION = 1,
            DATETIME_EQUALITY_CORRECTION = 60000,
            _noop = $.noop,
            _Translator2d;
        var validateCanvas = function(canvas) {
                $.each(CANVAS_PROP, function(_, prop) {
                    canvas[prop] = parseInt(canvas[prop]) || 0
                });
                return canvas
            };
        var makeCategoriesToPoints = function(categories, invert) {
                var categoriesToPoints = {},
                    category,
                    length = categories.length,
                    i;
                for (i = 0; i < length; i++) {
                    category = categories[i];
                    categoriesToPoints[category] = {
                        name: category,
                        index: invert ? length - 1 - i : i
                    }
                }
                return categoriesToPoints
            };
        var validateBusinessRange = function(businessRange) {
                function validate(valueSelector, baseValueSeletor) {
                    if (!isDefined(businessRange[valueSelector]) && isDefined(businessRange[baseValueSeletor]))
                        businessRange[valueSelector] = businessRange[baseValueSeletor]
                }
                validate("minVisible", "min");
                validate("maxVisible", "max");
                return businessRange
            };
        _Translator2d = core.Translator2D = function(businessRange, canvas, options) {
            this.update(businessRange, canvas, options)
        };
        _Translator2d.prototype = {
            constructor: _Translator2d,
            reinit: function() {
                var that = this,
                    range = that._businessRange,
                    categories = range.categories || [],
                    script = {},
                    canvasOptions = that._prepareCanvasOptions(),
                    visibleCategories = utils.getCategoriesInfo(categories, range.startCategories, range.endCategories).categories;
                switch (range.axisType) {
                    case"logarithmic":
                        script = core.logarithmicTranslatorFunctions;
                        break;
                    case"discrete":
                        script = core.categoryTranslatorFunctions;
                        that._categories = categories;
                        canvasOptions.interval = that._getDiscreteInterval((visibleCategories || categories).length, canvasOptions);
                        that._categoriesToPoints = makeCategoriesToPoints(categories, canvasOptions.invert);
                        if (visibleCategories && visibleCategories.length) {
                            canvasOptions.startPointIndex = that._categoriesToPoints[visibleCategories[canvasOptions.invert ? visibleCategories.length - 1 : 0]].index;
                            that.visibleCategories = visibleCategories
                        }
                        break;
                    default:
                        if (range.dataType === "datetime")
                            script = core.datetimeTranslatorFunctions;
                        else
                            script = core.numericTranslatorFunctions
                }
                that.translate = script.translate;
                that.untranslate = script.untranslate;
                that.getInterval = script.getInterval;
                that.zoom = script.zoom;
                that.getMinScale = script.getMinScale;
                that._getValue = script._getValue;
                that.getScale = script.getScale
            },
            _getDiscreteInterval: function(categoriesLength, canvasOptions) {
                var correctedCategoriesCount = categoriesLength - (this._businessRange.stick ? 1 : 0);
                return correctedCategoriesCount > 0 ? canvasOptions.canvasLength / correctedCategoriesCount : canvasOptions.canvasLength
            },
            _getCanvasBounds: function(range) {
                var min = range.min,
                    max = range.max,
                    minVisible = range.minVisible,
                    maxVisible = range.maxVisible,
                    newMin,
                    newMax,
                    base = range.base,
                    isDateTime = utils.isDate(max) || utils.isDate(min),
                    correction = isDateTime ? DATETIME_EQUALITY_CORRECTION : NUMBER_EQUALITY_CORRECTION;
                if (isDefined(min) && isDefined(max) && min.valueOf() === max.valueOf()) {
                    newMin = min.valueOf() - correction;
                    newMax = max.valueOf() + correction;
                    if (isDateTime) {
                        min = new Date(newMin);
                        max = new Date(newMax)
                    }
                    else {
                        min = min !== 0 ? newMin : 0;
                        max = newMax
                    }
                }
                if (isDefined(minVisible) && isDefined(maxVisible) && minVisible.valueOf() === maxVisible.valueOf()) {
                    newMin = minVisible.valueOf() - correction;
                    newMax = maxVisible.valueOf() + correction;
                    if (isDateTime) {
                        minVisible = newMin < min.valueOf() ? min : new Date(newMin);
                        maxVisible = newMax > max.valueOf() ? max : new Date(newMax)
                    }
                    else {
                        if (minVisible !== 0)
                            minVisible = newMin < min ? min : newMin;
                        maxVisible = newMax > max ? max : newMax
                    }
                }
                if (range.axisType === 'logarithmic') {
                    maxVisible = getLog(maxVisible, base);
                    minVisible = getLog(minVisible, base);
                    min = getLog(min, base);
                    max = getLog(max, base)
                }
                return {
                        base: base,
                        rangeMin: min,
                        rangeMax: max,
                        rangeMinVisible: minVisible,
                        rangeMaxVisible: maxVisible
                    }
            },
            _prepareCanvasOptions: function() {
                var that = this,
                    businessRange = that._businessRange,
                    canvasOptions = that._canvasOptions = that._getCanvasBounds(businessRange),
                    length,
                    canvas = that._canvas;
                if (that._options.direction === "horizontal") {
                    canvasOptions.startPoint = canvas.left;
                    length = canvas.width;
                    canvasOptions.endPoint = canvas.width - canvas.right;
                    canvasOptions.invert = businessRange.invert
                }
                else {
                    canvasOptions.startPoint = canvas.top;
                    length = canvas.height;
                    canvasOptions.endPoint = canvas.height - canvas.bottom;
                    canvasOptions.invert = !businessRange.invert
                }
                that.canvasLength = canvasOptions.canvasLength = canvasOptions.endPoint - canvasOptions.startPoint;
                canvasOptions.rangeDoubleError = Math.pow(10, getPower(canvasOptions.rangeMax - canvasOptions.rangeMin) - getPower(length) - 2);
                canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (canvasOptions.rangeMaxVisible - canvasOptions.rangeMinVisible);
                return canvasOptions
            },
            updateBusinessRange: function(businessRange) {
                this._businessRange = validateBusinessRange(businessRange);
                this.reinit()
            },
            update: function(businessRange, canvas, options) {
                var that = this;
                that._options = $.extend(that._options || {}, options);
                that._canvas = validateCanvas(canvas);
                that.updateBusinessRange(businessRange)
            },
            getBusinessRange: function() {
                return this._businessRange
            },
            getCanvasVisibleArea: function() {
                return {
                        min: this._canvasOptions.startPoint,
                        max: this._canvasOptions.endPoint
                    }
            },
            translateSpecialCase: function(value) {
                var that = this,
                    canvasOptions = that._canvasOptions,
                    startPoint = canvasOptions.startPoint,
                    endPoint = canvasOptions.endPoint,
                    range = that._businessRange,
                    minVisible = range.minVisible,
                    maxVisible = range.maxVisible,
                    invert,
                    result = null;
                switch (value) {
                    case"canvas_position_default":
                        if (minVisible <= 0 && maxVisible >= 0)
                            result = that.translate(0);
                        else {
                            invert = range.invert ^ (minVisible <= 0 && maxVisible <= 0);
                            if (that._options.direction === "horizontal")
                                result = invert ? endPoint : startPoint;
                            else
                                result = invert ? startPoint : endPoint
                        }
                        break;
                    case"canvas_position_left":
                    case"canvas_position_top":
                        result = startPoint;
                        break;
                    case"canvas_position_center":
                    case"canvas_position_middle":
                        result = startPoint + canvasOptions.canvasLength / 2;
                        break;
                    case"canvas_position_right":
                    case"canvas_position_bottom":
                        result = endPoint;
                        break;
                    case"canvas_position_start":
                        result = range.invert ? endPoint : startPoint;
                        break;
                    case"canvas_position_end":
                        result = range.invert ? startPoint : endPoint;
                        break
                }
                return result
            },
            _calculateProjection: function(distance) {
                var canvasOptions = this._canvasOptions;
                return canvasOptions.invert ? canvasOptions.endPoint - distance : canvasOptions.startPoint + distance
            },
            _calculateUnProjection: function(distance) {
                var canvasOptions = this._canvasOptions;
                return canvasOptions.invert ? canvasOptions.rangeMaxVisible.valueOf() - distance : canvasOptions.rangeMinVisible.valueOf() + distance
            },
            getVisibleCategories: function() {
                return this.visibleCategories
            },
            getMinBarSize: function(minBarSize) {
                var visibleArea = this.getCanvasVisibleArea(),
                    minValue = this.untranslate(visibleArea.min + minBarSize);
                return _abs(this.untranslate(visibleArea.min) - (!isDefined(minValue) ? this.untranslate(visibleArea.max) : minValue))
            },
            translate: _noop,
            untranslate: _noop,
            getInterval: _noop,
            zoom: _noop,
            getMinScale: _noop
        }
    })(jQuery, DevExpress);
    /*! Module viz-core, file polarTranslator.js */
    (function($, DX, undefined) {
        var utils = DX.utils,
            SHIFT_ANGLE = 90,
            _round = Math.round;
        function PolarTranslator(businessRange, canvas, options) {
            var that = this,
                argRange = businessRange.arg,
                categories = argRange.categories;
            that._argCanvas = {
                left: 0,
                right: 0,
                width: this._getAngle()
            };
            that._valCanvas = {
                left: 0,
                right: 0
            };
            that.canvas = canvas;
            that._init();
            if (categories && options.firstPointOnStartAngle) {
                if (categories[categories.length - 1] !== null)
                    categories.push(null);
                argRange.stick = true
            }
            that._arg = new DX.viz.core.Translator2D(businessRange.arg, that._argCanvas, {direction: "horizontal"});
            that._val = new DX.viz.core.Translator2D(businessRange.val, that._valCanvas, {direction: "horizontal"});
            that._businessRange = businessRange;
            that.startAngle = utils.isNumber(options.startAngle) ? options.startAngle : 0
        }
        PolarTranslator.prototype = {
            _init: function() {
                var canvas = this.canvas;
                this._setCoords({
                    x: canvas.left + (canvas.width - canvas.right - canvas.left) / 2,
                    y: canvas.top + (canvas.height - canvas.top - canvas.bottom) / 2,
                    r: Math.min(canvas.width - canvas.left - canvas.right, canvas.height - canvas.top - canvas.bottom) / 2
                });
                this._valCanvas.width = this._rad
            },
            reinit: function() {
                this._init();
                this._arg.reinit();
                this._val.reinit()
            },
            _setCoords: function(coord) {
                this._x0 = coord.x;
                this._y0 = coord.y;
                this._rad = coord.r < 0 ? 0 : coord.r
            },
            getBusinessRange: function() {
                return this._businessRange
            },
            translate: function(arg, val, argOffset, valueOffset) {
                var that = this,
                    radius = that._val.translate(val, valueOffset),
                    angle = that._arg.translate(arg, argOffset) + that.startAngle - SHIFT_ANGLE,
                    cossin = utils.getCosAndSin(angle),
                    x,
                    y;
                y = _round(this._y0 + radius * cossin.sin);
                x = _round(this._x0 + radius * cossin.cos);
                return {
                        x: x,
                        y: y,
                        angle: angle,
                        radius: radius
                    }
            },
            getValLength: function() {
                return this._rad
            },
            getInterval: function() {
                return this._arg.getInterval()
            },
            getValInterval: function() {
                return this._val.getInterval()
            },
            _getAngle: function() {
                return 360
            },
            getStartAngle: function() {
                return this.startAngle
            },
            _untranslate: function(x, y) {
                var radius = utils.getDistance(this._x0, this._y0, x, y),
                    angle = Math.atan2(y - this._y0, x - this._x0);
                return {
                        r: radius,
                        phi: angle
                    }
            },
            checkVisibility: function(rad, minRad) {
                var radiusRange = this._val.getCanvasVisibleArea();
                return radiusRange.min <= minRad && radiusRange.max >= minRad || radiusRange.max >= rad && radiusRange.min <= rad
            },
            untranslate: function(x, y) {
                var pos = this._untranslate(x, y);
                pos.phi = _round(utils.normalizeAngle(pos.phi * 180 / Math.PI));
                pos.r = _round(pos.r);
                return pos
            },
            getVisibleCategories: $.noop,
            getCanvasVisibleArea: function() {
                return {}
            },
            getMinBarSize: function(minBarSize) {
                return this._val.getMinBarSize(minBarSize)
            }
        };
        DX.viz.core.PolarTranslator = PolarTranslator
    })(jQuery, DevExpress);
    /*! Module viz-core, file rectangle.js */
    (function(DX, undefined) {
        var isFinite = window.isFinite;
        DX.viz.core.Rectangle = DX.Class.inherit({
            ctor: function(options) {
                var that = this;
                options = options || {};
                that.left = Number(options.left) || 0;
                that.right = Number(options.right) || 0;
                that.top = Number(options.top) || 0;
                that.bottom = Number(options.bottom) || 0
            },
            width: function() {
                return this.right - this.left
            },
            height: function() {
                return this.bottom - this.top
            },
            horizontalMiddle: function() {
                return (this.left + this.right) / 2
            },
            verticalMiddle: function() {
                return (this.top + this.bottom) / 2
            },
            raw: function() {
                var that = this;
                return {
                        left: that.left,
                        top: that.top,
                        right: that.right,
                        bottom: that.bottom
                    }
            },
            clone: function() {
                return new this.constructor(this.raw())
            },
            move: function(dx, dy) {
                var result = this.clone();
                if (isFinite(dx) && isFinite(dy)) {
                    result.left += Number(dx);
                    result.right += Number(dx);
                    result.top += Number(dy);
                    result.bottom += Number(dy)
                }
                return result
            },
            inflate: function(dx, dy) {
                var result = this.clone();
                if (isFinite(dx) && isFinite(dy)) {
                    result.left -= Number(dx);
                    result.right += Number(dx);
                    result.top -= Number(dy);
                    result.bottom += Number(dy)
                }
                return result
            },
            scale: function(factor) {
                var that = this;
                if (factor > 0)
                    return that.inflate(that.width() * (factor - 1) / 2, that.height() * (factor - 1) / 2);
                return that.clone()
            }
        })
    })(DevExpress);
    /*! Module viz-core, file themes.js */
    (function(DX, $, undefined) {
        var themes = DX.viz.themes = [],
            currentThemeId = 0;
        function findThemeId(themeName) {
            var i,
                ii = themes.length;
            for (i = 0; i < ii; ++i)
                if (themes[i].name === themeName)
                    return i;
            return -1
        }
        function findTheme(themeName) {
            return themes[findThemeId(themeName)] || themes[currentThemeId]
        }
        function currentTheme(themeName, colorScheme, version) {
            if (arguments.length === 0)
                return themes[currentThemeId].name;
            var themeId = -1;
            if (version && colorScheme)
                themeId = findThemeId(themeName + ':' + version + '-' + colorScheme);
            if (themeId < 0 && version)
                themeId = findThemeId(themeName + ':' + version);
            if (themeId < 0 && colorScheme)
                themeId = findThemeId(themeName + '-' + colorScheme);
            if (themeId < 0)
                themeId = findThemeId(themeName);
            currentThemeId = themeId >= 0 ? themeId : 0
        }
        function registerTheme(theme, basedOnThemeName) {
            if (theme && theme.name)
                themes.push($.extend(true, {}, findTheme(basedOnThemeName), theme))
        }
        $.extend(DX.viz.core, {
            findTheme: findTheme,
            currentTheme: currentTheme,
            registerTheme: registerTheme
        })
    })(DevExpress, jQuery);
    /*! Module viz-core, file palette.js */
    (function(DX, $, undefined) {
        var _String = window.String,
            _floor = Math.floor,
            _ceil = Math.ceil,
            _Color = DX.Color,
            _isArray = DX.utils.isArray,
            _isString = DX.utils.isString,
            _extend = $.extend;
        var palettes = {
                'default': {
                    simpleSet: ['#5f8b95', '#ba4d51', '#af8a53', '#955f71', '#859666', '#7e688c'],
                    indicatingSet: ['#a3b97c', '#e1b676', '#ec7f83'],
                    gradientSet: ['#5f8b95', '#ba4d51']
                },
                'harmony light': {
                    simpleSet: ['#fcb65e', '#679ec5', '#ad79ce', '#7abd5c', '#e18e92', '#b6d623', '#b7abea', '#85dbd5'],
                    indicatingSet: ['#b6d623', '#fcb65e', '#e18e92'],
                    gradientSet: ['#7abd5c', '#fcb65e']
                },
                'soft pastel': {
                    simpleSet: ['#60a69f', '#78b6d9', '#6682bb', '#a37182', '#eeba69', '#90ba58', '#456c68', '#7565a4'],
                    indicatingSet: ['#90ba58', '#eeba69', '#a37182'],
                    gradientSet: ['#78b6d9', '#eeba69']
                },
                pastel: {
                    simpleSet: ['#bb7862', '#70b3a1', '#bb626a', '#057d85', '#ab394b', '#dac599', '#153459', '#b1d2c6'],
                    indicatingSet: ['#70b3a1', '#dac599', '#bb626a'],
                    gradientSet: ['#bb7862', '#70b3a1']
                },
                bright: {
                    simpleSet: ['#70c92f', '#f8ca00', '#bd1550', '#e97f02', '#9d419c', '#7e4452', '#9ab57e', '#36a3a6'],
                    indicatingSet: ['#70c92f', '#f8ca00', '#bd1550'],
                    gradientSet: ['#e97f02', '#f8ca00']
                },
                soft: {
                    simpleSet: ['#cbc87b', '#9ab57e', '#e55253', '#7e4452', '#e8c267', '#565077', '#6babac', '#ad6082'],
                    indicatingSet: ['#9ab57e', '#e8c267', '#e55253'],
                    gradientSet: ['#9ab57e', '#e8c267']
                },
                ocean: {
                    simpleSet: ['#75c099', '#acc371', '#378a8a', '#5fa26a', '#064970', '#38c5d2', '#00a7c6', '#6f84bb'],
                    indicatingSet: ['#c8e394', '#7bc59d', '#397c8b'],
                    gradientSet: ['#acc371', '#38c5d2']
                },
                vintage: {
                    simpleSet: ['#dea484', '#efc59c', '#cb715e', '#eb9692', '#a85c4c', '#f2c0b5', '#c96374', '#dd956c'],
                    indicatingSet: ['#ffe5c6', '#f4bb9d', '#e57660'],
                    gradientSet: ['#efc59c', '#cb715e']
                },
                violet: {
                    simpleSet: ['#d1a1d1', '#eeacc5', '#7b5685', '#7e7cad', '#a13d73', '#5b41ab', '#e287e2', '#689cc1'],
                    indicatingSet: ['#d8e2f6', '#d0b2da', '#d56a8a'],
                    gradientSet: ['#eeacc5', '#7b5685']
                }
            };
        var currentPaletteName = 'default';
        function currentPalette(name) {
            if (name === undefined)
                return currentPaletteName;
            else {
                name = String(name).toLowerCase();
                currentPaletteName = name in palettes ? name : 'default'
            }
        }
        function getPalette(palette, parameters) {
            var result;
            if (_isArray(palette))
                result = palette;
            else {
                parameters = parameters || {};
                var type = parameters.type || 'simpleSet';
                if (_isString(palette)) {
                    var name = palette.toLowerCase(),
                        baseContainer = palettes[name],
                        themedContainer = parameters.theme && palettes[name + '_' + _String(parameters.theme).toLowerCase()];
                    result = themedContainer && themedContainer[type] || baseContainer && baseContainer[type]
                }
                if (!result)
                    result = palettes[currentPaletteName][type]
            }
            return result ? result.slice(0) : null
        }
        function registerPalette(name, palette, theme) {
            var item = {};
            if (_isArray(palette))
                item.simpleSet = palette.slice(0);
            else if (palette) {
                item.simpleSet = _isArray(palette.simpleSet) ? palette.simpleSet.slice(0) : undefined;
                item.indicatingSet = _isArray(palette.indicatingSet) ? palette.indicatingSet.slice(0) : undefined;
                item.gradientSet = _isArray(palette.gradientSet) ? palette.gradientSet.slice(0) : undefined
            }
            if (item.simpleSet || item.indicatingSet || item.gradientSet) {
                var paletteName = _String(name).toLowerCase();
                if (theme)
                    paletteName = paletteName + '_' + _String(theme).toLowerCase();
                _extend(palettes[paletteName] = palettes[paletteName] || {}, item)
            }
        }
        function RingBuf(buf) {
            var ind = 0;
            this.next = function() {
                var res = buf[ind++];
                if (ind == buf.length)
                    this.reset();
                return res
            };
            this.reset = function() {
                ind = 0
            }
        }
        function Palette(palette, parameters) {
            parameters = parameters || {};
            this._originalPalette = getPalette(palette, parameters);
            var stepHighlight = parameters ? parameters.stepHighlight || 0 : 0;
            this._paletteSteps = new RingBuf([0, stepHighlight, -stepHighlight]);
            this._resetPalette()
        }
        _extend(Palette.prototype, {
            dispose: function() {
                this._originalPalette = this._palette = this._paletteSteps = null;
                return this
            },
            getNextColor: function() {
                var that = this;
                if (that._currentColor >= that._palette.length)
                    that._resetPalette();
                return that._palette[that._currentColor++]
            },
            _resetPalette: function() {
                var that = this;
                that._currentColor = 0;
                var step = that._paletteSteps.next(),
                    originalPalette = that._originalPalette;
                if (step) {
                    var palette = that._palette = [],
                        i = 0,
                        ii = originalPalette.length;
                    for (; i < ii; ++i)
                        palette[i] = getNewColor(originalPalette[i], step)
                }
                else
                    that._palette = originalPalette.slice(0)
            },
            reset: function() {
                this._paletteSteps.reset();
                this._resetPalette();
                return this
            }
        });
        function getNewColor(currentColor, step) {
            var newColor = new _Color(currentColor).alter(step),
                lightness = getLightness(newColor);
            if (lightness > 200 || lightness < 55)
                newColor = new _Color(currentColor).alter(-step / 2);
            return newColor.toHex()
        }
        function getLightness(color) {
            return color.r * 0.3 + color.g * 0.59 + color.b * 0.11
        }
        function GradientPalette(source, size) {
            var palette = getPalette(source, {type: 'gradientSet'});
            palette = size > 0 ? createGradientColors(palette, size) : [];
            this.getColor = function(index) {
                return palette[index] || null
            };
            this._DEBUG_source = source;
            this._DEBUG_size = size
        }
        function createGradientColors(source, count) {
            var ncolors = count - 1,
                nsource = source.length - 1,
                colors = [],
                gradient = [],
                i,
                k,
                kl,
                kr;
            for (i = 0; i <= nsource; ++i)
                colors.push(new _Color(source[i]));
            if (ncolors > 0)
                for (i = 0; i <= ncolors; ++i)
                    addColor(i / ncolors);
            else
                addColor(0.5);
            return gradient;
            function addColor(pos) {
                var k = nsource * pos,
                    kl = _floor(k),
                    kr = _ceil(k);
                gradient.push(colors[kl].blend(colors[kr], k - kl).toHex())
            }
        }
        _extend(DX.viz.core, {
            registerPalette: registerPalette,
            getPalette: getPalette,
            Palette: Palette,
            GradientPalette: GradientPalette,
            currentPalette: currentPalette
        });
        DX.viz.core._DEBUG_palettes = palettes
    })(DevExpress, jQuery);
    /*! Module viz-core, file baseThemeManager.js */
    (function(DX, $, undefined) {
        var _isString = DX.utils.isString,
            _findTheme = DX.viz.core.findTheme,
            _extend = $.extend,
            _each = $.each;
        function getThemePart(theme, path) {
            var _theme = theme;
            path && _each(path.split('.'), function(_, pathItem) {
                return _theme = _theme[pathItem]
            });
            return _theme
        }
        DX.viz.core.BaseThemeManager = DX.Class.inherit({
            dispose: function() {
                this._theme = this._font = null;
                return this
            },
            setTheme: function(theme) {
                theme = theme || {};
                var that = this,
                    themeObj = _findTheme(_isString(theme) ? theme : theme.name);
                that._themeName = themeObj.name;
                that._font = _extend({}, themeObj.font, theme.font);
                that._themeSection && _each(that._themeSection.split('.'), function(_, path) {
                    themeObj = _extend(true, {}, themeObj[path], that._IE8 ? themeObj[path + 'IE8'] : {})
                });
                that._theme = _extend(true, {}, themeObj, _isString(theme) ? {} : theme);
                that._initializeTheme();
                return that
            },
            theme: function(path) {
                return getThemePart(this._theme, path)
            },
            themeName: function() {
                return this._themeName
            },
            _initializeTheme: function() {
                var that = this;
                _each(that._fontFields || [], function(_, path) {
                    that._initializeFont(getThemePart(that._theme, path))
                })
            },
            _initializeFont: function(font) {
                _extend(font, this._font, _extend({}, font))
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz-core, file textCloud.js */
    (function(DX, undefined) {
        var min = Math.min;
        DX.viz.core.TextCloud = DX.Class.inherit(function() {
            var DEFAULT_OPTIONS = {
                    horMargin: 8,
                    verMargin: 4,
                    tailLength: 10
                };
            var COEFFICIENTS_MAP = {};
            COEFFICIENTS_MAP['right-bottom'] = COEFFICIENTS_MAP['rb'] = [0, -1, -1, 0, 0, 1, 1, 0];
            COEFFICIENTS_MAP['bottom-right'] = COEFFICIENTS_MAP['br'] = [-1, 0, 0, -1, 1, 0, 0, 1];
            COEFFICIENTS_MAP['left-bottom'] = COEFFICIENTS_MAP['lb'] = [0, -1, 1, 0, 0, 1, -1, 0];
            COEFFICIENTS_MAP['bottom-left'] = COEFFICIENTS_MAP['bl'] = [1, 0, 0, -1, -1, 0, 0, 1];
            COEFFICIENTS_MAP['left-top'] = COEFFICIENTS_MAP['lt'] = [0, 1, 1, 0, 0, -1, -1, 0];
            COEFFICIENTS_MAP['top-left'] = COEFFICIENTS_MAP['tl'] = [1, 0, 0, 1, -1, 0, 0, -1];
            COEFFICIENTS_MAP['right-top'] = COEFFICIENTS_MAP['rt'] = [0, 1, -1, 0, 0, -1, 1, 0];
            COEFFICIENTS_MAP['top-right'] = COEFFICIENTS_MAP['tr'] = [-1, 0, 0, 1, 1, 0, 0, -1];
            return {
                    setup: function(options) {
                        var that = this,
                            ops = $.extend({}, DEFAULT_OPTIONS, options),
                            x = ops.x,
                            y = ops.y,
                            type = COEFFICIENTS_MAP[ops.type],
                            cloudWidth = ops.textWidth + 2 * ops.horMargin,
                            cloudHeight = ops.textHeight + 2 * ops.verMargin,
                            tailWidth = ops.tailLength,
                            tailHeight = tailWidth,
                            cx = x,
                            cy = y;
                        if (type[0] & 1)
                            tailHeight = min(tailHeight, cloudHeight / 3);
                        else
                            tailWidth = min(tailWidth, cloudWidth / 3);
                        that._points = [x, y, x += type[0] * (cloudWidth + tailWidth), y += type[1] * (cloudHeight + tailHeight), x += type[2] * cloudWidth, y += type[3] * cloudHeight, x += type[4] * cloudWidth, y += type[5] * cloudHeight, x += type[6] * (cloudWidth - tailWidth), y += type[7] * (cloudHeight - tailHeight)];
                        that._cx = cx + type[0] * tailWidth + (type[0] + type[2]) * cloudWidth / 2;
                        that._cy = cy + type[1] * tailHeight + (type[1] + type[3]) * cloudHeight / 2;
                        that._cloudWidth = cloudWidth;
                        that._cloudHeight = cloudHeight;
                        that._tailLength = ops.tailLength;
                        return that
                    },
                    points: function() {
                        return this._points.slice(0)
                    },
                    cx: function() {
                        return this._cx
                    },
                    cy: function() {
                        return this._cy
                    },
                    width: function() {
                        return this._cloudWidth
                    },
                    height: function() {
                        return this._cloudHeight
                    },
                    tailLength: function() {
                        return this._tailLength
                    }
                }
        }())
    })(DevExpress);
    /*! Module viz-core, file parseUtils.js */
    (function($, DX) {
        var viz = DX.viz,
            core = viz.core,
            Class = DX.Class,
            isDefined = DX.utils.isDefined;
        var parseUtils = Class.inherit({
                ctor: function(options) {
                    options = options || {};
                    this._incidentOccured = $.isFunction(options.incidentOccured) ? options.incidentOccured : $.noop
                },
                correctValueType: function(type) {
                    return type === 'numeric' || type === 'datetime' || type === 'string' ? type : ''
                },
                _parsers: {
                    string: function(val) {
                        return isDefined(val) ? '' + val : val
                    },
                    numeric: function(val) {
                        if (!isDefined(val))
                            return val;
                        var parsedVal = Number(val);
                        if (isNaN(parsedVal))
                            parsedVal = undefined;
                        return parsedVal
                    },
                    datetime: function(val) {
                        if (!isDefined(val))
                            return val;
                        var parsedVal,
                            numVal = Number(val);
                        if (!isNaN(numVal))
                            parsedVal = new Date(numVal);
                        else
                            parsedVal = new Date(val);
                        if (isNaN(Number(parsedVal)))
                            parsedVal = undefined;
                        return parsedVal
                    }
                },
                getParser: function(valueType, entity) {
                    var that = this,
                        parser,
                        message = 'valueType is unknown.';
                    if (entity)
                        message = 'The type specified as the "valueType" field of the ' + entity + ' configuration object is unknown.';
                    valueType = that.correctValueType(valueType);
                    parser = that._parsers[valueType];
                    if (!parser)
                        this._incidentOccured.call(null, message);
                    return parser || $.noop
                }
            });
        core.ParseUtils = parseUtils
    })(jQuery, DevExpress);
    /*! Module viz-core, file utils.js */
    (function($, DX) {
        var core = DX.viz.core,
            math = Math,
            _each = $.each;
        core.utils = {
            decreaseGaps: function(object, keys, decrease) {
                var arrayGaps,
                    eachDecrease,
                    middleValue;
                do {
                    arrayGaps = $.map(keys, function(key) {
                        return object[key] ? object[key] : null
                    });
                    middleValue = math.ceil(decrease / arrayGaps.length);
                    arrayGaps.push(middleValue);
                    eachDecrease = math.min.apply(null, arrayGaps);
                    _each(keys, function(_, key) {
                        if (object[key]) {
                            object[key] -= eachDecrease;
                            decrease -= eachDecrease
                        }
                    })
                } while (decrease > 0 && arrayGaps.length > 1);
                return decrease
            },
            parseBool: function(value, defaultValue) {
                return value !== undefined ? !!value : defaultValue
            },
            parseEnum: function(value, validValues, defaultValue) {
                var _value = String(value).toLowerCase();
                return $.inArray(_value, validValues) >= 0 ? _value : defaultValue
            },
            patchFontOptions: function(options) {
                var fontOptions = {};
                _each(options || {}, function(key, value) {
                    if (/^(cursor|opacity)$/i.test(key));
                    else if (key === "color")
                        key = "fill";
                    else
                        key = "font-" + key;
                    fontOptions[key] = value
                });
                return fontOptions
            }
        }
    })(jQuery, DevExpress);
    /*! Module viz-core, file loadIndicator.js */
    (function($, DX) {
        var core = DX.viz.core,
            ANIMATION_SETTINGS = {
                easing: 'linear',
                duration: 150
            },
            INVISIBLE_POINT = {
                x: -10000,
                y: -10000
            };
        var applySettings = function(element, settings, animate, complete) {
                var prevAnimation = element.animation;
                if (prevAnimation) {
                    prevAnimation.options.complete = null;
                    prevAnimation.stop()
                }
                if (animate)
                    element.animate(settings, {complete: complete});
                else {
                    element.attr(settings);
                    complete && complete()
                }
            };
        function LoadIndicator() {
            this.ctor.apply(this, arguments)
        }
        core.LoadIndicator = LoadIndicator;
        LoadIndicator.prototype = {
            ctor: function(options, widgetContainer) {
                var that = this;
                that._$widgetContainer = $(widgetContainer);
                that._$container = $('<div>', {css: {
                        position: 'relative',
                        height: 0,
                        padding: 0,
                        margin: 0,
                        border: 0
                    }}).appendTo(that._$widgetContainer);
                that._updateContainer();
                that.applyOptions(options);
                that._endLoadingCompleteHandler = function() {
                    that._endLoad = false;
                    that._externalComplete && that._externalComplete();
                    that._externalComplete = null;
                    that._onCompleteAction && that[that._onCompleteAction]();
                    that._onCompleteAction = null
                };
                that._$container.hide()
            },
            _updateRenderer: function(width, height, top) {
                var that = this;
                if (that._renderer)
                    that._renderer.resize(width, height);
                else if (that._$container.get(0)) {
                    that._renderer = core.CoreFactory.createRenderer({
                        width: width,
                        height: height,
                        animation: ANIMATION_SETTINGS
                    });
                    that._renderer.draw(that._$container[0])
                }
                that._renderer && this._renderer.root.css({
                    position: 'absolute',
                    top: top,
                    left: 0
                });
                return that._renderer
            },
            applyOptions: function(options, width, height) {
                var that = this,
                    pane = that._pane;
                if (pane && options) {
                    if ("backgroundColor" in options)
                        pane.rect.attr({fill: options.backgroundColor});
                    pane.text.css(core.utils.patchFontOptions(options.font)).attr({text: options.text})
                }
                if (that.isShown && (width || height))
                    that._updateContainer(width, height)
            },
            _draw: function() {
                var pane,
                    renderer = this._renderer;
                if (renderer) {
                    pane = this._pane = {};
                    pane.rect = renderer.rect(0, 0, 0, 0).attr({opacity: 0}).append(renderer.root);
                    pane.text = renderer.text('', 0, 0).attr({
                        align: 'center',
                        translateX: INVISIBLE_POINT.x,
                        translateY: INVISIBLE_POINT.y
                    }).append(renderer.root)
                }
            },
            _updateContainer: function(width, height) {
                var that = this,
                    $widgetContainer = that._$widgetContainer,
                    canvasTop;
                width = width || $widgetContainer.width();
                height = height || $widgetContainer.height();
                if ($widgetContainer.get(0))
                    canvasTop = $widgetContainer.offset().top - that._$container.offset().top;
                else
                    canvasTop = -height;
                that._updateRenderer(width, height, canvasTop);
                if (!that._pane)
                    that._draw();
                else {
                    that._pane.rect.attr({
                        width: width,
                        height: height
                    });
                    that._pane.text.move(width / 2, height / 2)
                }
            },
            dispose: function() {
                var that = this;
                that._$widgetContainer = null;
                that._$container.remove().detach();
                that._$container = null;
                that._renderer.dispose();
                that._renderer = null;
                that._pane = null
            },
            toForeground: function() {
                this._$container.appendTo(this._$widgetContainer)
            },
            show: function(width, height) {
                var that = this;
                if (that._endLoad) {
                    that._onCompleteAction = 'show';
                    return
                }
                that._$container.show();
                that._updateContainer(width, height);
                applySettings(that._pane.rect, {opacity: 0.85}, true);
                that.isShown = true
            },
            endLoading: function(complete, disableAnimation) {
                var that = this;
                that._externalComplete = complete;
                if (that._endLoad)
                    return;
                if (that.isShown) {
                    that._endLoad = true;
                    applySettings(that._pane.rect, {opacity: 1}, !disableAnimation, that._endLoadingCompleteHandler)
                }
                else
                    complete && complete()
            },
            hide: function() {
                var that = this;
                if (that._endLoad) {
                    that._onCompleteAction = 'hide';
                    return
                }
                if (that.isShown) {
                    that._pane.text.move(INVISIBLE_POINT.x, INVISIBLE_POINT.y);
                    applySettings(that._pane.rect, {opacity: 0}, true, function() {
                        that._$container.hide()
                    });
                    that.isShown = false
                }
            }
        }
    })(jQuery, DevExpress);
    /*! Module viz-core, file tooltip.js */
    (function($, DX, undefined) {
        var ARROW_WIDTH = 20,
            MAX_SHADOW_SIZE = 10,
            formatHelper = DX.formatHelper,
            core = DX.viz.core,
            X_INTERVAL = 15,
            _max = Math.max,
            _round = Math.round,
            _isFunction = DX.utils.isFunction,
            _isDefined = DX.utils.isDefined,
            _extend = $.extend,
            FORMAT_PRECISION = {
                argument: ['argumentFormat', 'argumentPrecision'],
                percent: ['percent', 'percentPrecision'],
                value: ['format', 'precision']
            },
            VISIBLE = {visibility: 'visible'},
            HIDDEN = {visibility: 'hidden'},
            LEFT = 'left',
            RIGHT = 'right';
        core.Tooltip = DX.Class.inherit({
            ctor: function(options, group, renderer) {
                var that = this;
                that._state = {};
                that._options = {};
                that._renderer = renderer;
                that._group = group;
                that._cloud = renderer.path([], "area");
                that._textGroup = renderer.g();
                if (!$.isEmptyObject(options))
                    that.update(options);
                that._createTextContent()
            },
            dispose: function() {
                var that = this;
                that.off();
                that._shadow.dispose();
                that._shadow = that._cloud = that._text = that._group = that._options = that._renderer = that._tooltipTextArray = that._textGroup = null;
                return that
            },
            update: function(options) {
                options = options || {};
                var that = this,
                    group = that._group,
                    shadowOptions = options.shadow || {},
                    shadow = that._shadow = that._shadow || that._renderer.shadowFilter('-50%', '-50%', '200%', '200%', shadowOptions.offsetX, shadowOptions.offsetY, shadowOptions.blur, shadowOptions.color, shadowOptions.opacity),
                    borderSettings = options.border,
                    shapeSettings = _extend({
                        opacity: options.opacity,
                        filter: shadow.ref
                    }, borderSettings && borderSettings.visible ? {
                        "stroke-width": borderSettings.width,
                        stroke: borderSettings.color,
                        "stroke-opacity": borderSettings.opacity,
                        dashStyle: borderSettings.dashStyle
                    } : {
                        "stroke-width": null,
                        stroke: null
                    }),
                    textSettings = _extend({}, {align: 'center'}, options.text);
                that._options = options;
                that._textFontStyles = core.utils.patchFontOptions(options.font);
                that.setSize(options.canvasWidth, options.canvasHeight);
                that._customizeTooltip = _isFunction(options.customizeTooltip) ? options.customizeTooltip : null;
                if (!that._customizeTooltip && _isFunction(options.customizeText))
                    that._customizeTooltip = function() {
                        return {text: options.customizeText.apply(this, arguments)}
                    };
                that._cloud.attr(shapeSettings).append(group);
                that._text && that._text.css(that._textFontStyles);
                that._textGroup.attr(textSettings).css(that._textFontStyles).append(group);
                that.hide();
                return that
            },
            formatValue: function(value, specialFormat) {
                var formatObj = FORMAT_PRECISION[specialFormat || 'value'],
                    format = formatObj[0] in this._options ? this._options[formatObj[0]] : specialFormat;
                return formatHelper.format(value, format, this._options[formatObj[1]] || 0)
            },
            getLocation: function() {
                return (this._options.location + '').toLowerCase()
            },
            prepare: function(formatObject, params, defaultTextValueField) {
                var that = this,
                    options = that._options,
                    defaultText = formatObject[defaultTextValueField || 'valueText'] || '',
                    state = that._state = that._state || {},
                    customize;
                _extend(state, params);
                if (that._customizeTooltip) {
                    customize = that._customizeTooltip.call(formatObject, formatObject);
                    customize = $.isPlainObject(customize) ? customize : {};
                    if ('text' in customize)
                        state.text = _isDefined(customize.text) ? String(customize.text) : '';
                    else {
                        if ($.isArray(defaultText)) {
                            options._justify = true;
                            that._createTextContent();
                            defaultText = defaultText.join('<br/>')
                        }
                        state.text = defaultText
                    }
                    state.color = customize.color || options.color;
                    state.borderColor = customize.borderColor || (options.border || {}).color;
                    state.textColor = customize.fontColor || (options.font || {}).color
                }
                else {
                    state.text = defaultText;
                    state.color = options.color;
                    state.borderColor = (options.border || {}).color;
                    state.textColor = (options.font || {}).color
                }
                if (options._justify)
                    state.text = state.text.split('<br/>');
                if (state.visibility == VISIBLE && !!state.text)
                    that.show();
                return !!state.text
            },
            enabled: function() {
                return !!this._options.enabled
            },
            shared: function() {
                return !!this._options.shared
            },
            formatColorTooltip: function(that) {
                return that._customizeTooltip && that._customizeTooltip.call(this, this)
            },
            _getHorizontalData: function(cloudWidth, cloudHeight, arrowLength, paddingLeftRight) {
                var that = this,
                    horPosition = that._state.cloudHorizontalPosition,
                    x = that._state.x,
                    y = that._state.y,
                    xt = x,
                    points = [],
                    align = 'center',
                    inverted;
                if (_isDefined(that._state.arrowSide)) {
                    points = that._setArrowOnSide(cloudWidth, cloudHeight, arrowLength, x, y);
                    inverted = that._getHorizontalInvert(cloudWidth, arrowLength, x);
                    xt = inverted ? xt - cloudWidth / 2 - arrowLength : xt + cloudWidth / 2 + arrowLength
                }
                else if (_isDefined(horPosition) ? horPosition === RIGHT : cloudWidth / 2 > x) {
                    points = that._setArrowLeft(cloudWidth, cloudHeight, arrowLength, x, y);
                    align = LEFT;
                    xt += paddingLeftRight
                }
                else if (_isDefined(horPosition) ? horPosition === LEFT : x + cloudWidth / 2 > that._canvasWidth) {
                    points = that._setArrowRight(cloudWidth, cloudHeight, arrowLength, x, y);
                    align = RIGHT;
                    xt -= paddingLeftRight
                }
                else
                    points = that._setArrowCenter(cloudWidth, cloudHeight, arrowLength, x, y);
                return {
                        points: points,
                        align: align,
                        xt: xt
                    }
            },
            _getVerticalData: function(cloudHeight, arrowLength) {
                var that = this,
                    state = that._state,
                    bbox = state.textBBox,
                    yt = state.y,
                    invert,
                    delta;
                if (_isDefined(that._state.arrowSide))
                    yt += bbox.height / 2;
                else {
                    invert = that._getVerticalInvert(cloudHeight, arrowLength, state.y);
                    delta = arrowLength + cloudHeight / 2 + state.offset;
                    yt = invert ? yt + bbox.height / 2 + delta : yt - delta + bbox.height / 2
                }
                return {yt: that._correctYTextContent(yt)}
            },
            _getData: function() {
                var that = this,
                    bbox = that._state.textBBox,
                    options = that._options,
                    paddingLeftRight = options.paddingLeftRight,
                    paddingTopBottom = options.paddingTopBottom,
                    arrowLength = options.arrowLength > 0 ? options.arrowLength : 0,
                    cloudWidth = bbox.width + paddingLeftRight * 2,
                    cloudHeight = bbox.height + paddingTopBottom * 2,
                    updatedText,
                    horizontalData,
                    verticalData;
                updatedText = that._checkWidthText(cloudWidth, cloudHeight);
                if (updatedText) {
                    that._state.textBBox = bbox = updatedText.bbox;
                    cloudWidth = updatedText.cloudWidth;
                    cloudHeight = updatedText.cloudHeight;
                    paddingLeftRight = updatedText.paddingLeftRight;
                    paddingTopBottom = updatedText.paddingTopBottom
                }
                horizontalData = that._getHorizontalData(cloudWidth, cloudHeight, arrowLength, paddingLeftRight);
                verticalData = that._getVerticalData(cloudHeight, arrowLength);
                return {
                        points: horizontalData.points,
                        text: {
                            x: horizontalData.xt,
                            y: verticalData.yt,
                            align: horizontalData.align
                        }
                    }
            },
            _updateTextContent: function() {
                if (this._options._justify) {
                    this._textGroup.clear();
                    this._calculateTextContent();
                    this._locateTextContent(0, 0, 'center')
                }
                else
                    this._text.attr({text: this._state.text}).css({fill: this._state.textColor});
                this._textGroup.css({fill: this._state.textColor});
                this._state.textBBox = this._textGroup.getBBox()
            },
            _correctYTextContent: function(y) {
                var bbox;
                if (this._options._justify) {
                    this._locateTextContent(0, y, 'center');
                    bbox = this._textGroup.getBBox()
                }
                else {
                    this._text.attr({y: y});
                    bbox = this._text.getBBox()
                }
                return y - (bbox.y + bbox.height - y)
            },
            _adjustTextContent: function(data) {
                if (this._options._justify)
                    this._locateTextContent(data.text.x, data.text.y, data.text.align);
                else
                    this._text.attr({
                        x: data.text.x,
                        y: data.text.y,
                        align: data.text.align
                    })
            },
            _updateTooltip: function() {
                var that = this,
                    box,
                    data,
                    scale;
                data = that._getData();
                that._cloud.attr({
                    points: data.points,
                    fill: that._state.color,
                    'class': that._state.className,
                    stroke: that._state.borderColor
                }).sharp();
                that._adjustTextContent(data);
                box = that._group.getBBox();
                if (box.y + box.height > that._canvasHeight) {
                    scale = (that._canvasHeight - box.y) / box.height;
                    that._group.attr({
                        scaleX: scale,
                        scaleY: scale,
                        translateX: that._state.x * (1 - scale),
                        translateY: that._state.y * (1 - scale)
                    })
                }
                else
                    that._group.attr({
                        scaleX: 1,
                        scaleY: 1,
                        translateX: 0,
                        translateY: 0
                    })
            },
            _createTextContent: function() {
                var that = this;
                that._textGroup.clear();
                that._text = null;
                if (!that._options._justify)
                    that._text = that._renderer.text(undefined, 0, 0).css(that._textFontStyles).append(that._textGroup)
            },
            _getTextContentParams: function() {
                var that = this,
                    i,
                    text,
                    textBBox,
                    textArray = that._state.text,
                    textArrayLength = textArray.length,
                    textParams = {
                        width: [],
                        height: []
                    };
                that._tooltipTextArray = [];
                for (i = 0; i < textArrayLength; i++) {
                    text = that._renderer.text(textArray[i], 0, 0).append(that._textGroup);
                    that._tooltipTextArray.push(text);
                    textBBox = text.getBBox();
                    textParams.width.push(textBBox.width)
                }
                that._lineHeight = -2 * textBBox.y - textBBox.height;
                return textParams
            },
            _locateTextContent: function(x, y, alignment) {
                var that = this,
                    tooltipTextArray = that._tooltipTextArray,
                    textWidth = that._textContentWidth,
                    lineSpacing = that._options.lineSpacing,
                    yDelta = (lineSpacing > 0 ? lineSpacing : 0) + that._lineHeight,
                    leftXCoord,
                    rightXCoord,
                    i,
                    rtl = that._options._rtl;
                if (alignment === LEFT)
                    leftXCoord = x;
                else if (alignment === RIGHT)
                    leftXCoord = x - textWidth;
                else
                    leftXCoord = _round(x - textWidth / 2);
                rightXCoord = leftXCoord + textWidth;
                for (i = tooltipTextArray.length - 1; i >= 0; i -= 2) {
                    tooltipTextArray[i].attr({
                        x: !rtl ? rightXCoord : leftXCoord,
                        y: y,
                        align: !rtl ? RIGHT : LEFT
                    });
                    if (tooltipTextArray[i - 1])
                        tooltipTextArray[i - 1].attr({
                            x: !rtl ? leftXCoord : rightXCoord,
                            y: y,
                            align: !rtl ? LEFT : RIGHT
                        });
                    y -= yDelta
                }
            },
            _calculateTextContent: function() {
                var that = this,
                    textArray = that._state.text,
                    textArrayLength = textArray.length,
                    textParams,
                    width,
                    stringWidthArray = [],
                    i;
                textParams = that._getTextContentParams();
                for (i = 0; i < textArrayLength; i += 2) {
                    if (textParams.width[i + 1])
                        width = textParams.width[i] + X_INTERVAL + textParams.width[i + 1];
                    else
                        width = textParams.width[i];
                    stringWidthArray.push(width)
                }
                that._textContentWidth = _max.apply(null, stringWidthArray)
            },
            setSize: function(width, height) {
                this._canvasWidth = _isDefined(width) ? width : this._canvasWidth;
                this._canvasHeight = _isDefined(height) ? height : this._canvasHeight;
                return this
            },
            getBBox: function() {
                var that = this,
                    options = that._options,
                    paddingLeftRight = options.paddingLeftRight || 0,
                    paddingTopBottom = options.paddingTopBottom || 0,
                    borderWidth = options.border.visible && options.border.width || 0,
                    tooltipBBox = that._textGroup.getBBox();
                return tooltipBBox.isEmpty ? tooltipBBox : {
                        x: tooltipBBox.x - paddingLeftRight - borderWidth / 2 - MAX_SHADOW_SIZE,
                        y: tooltipBBox.y - paddingTopBottom - borderWidth / 2 - MAX_SHADOW_SIZE,
                        height: tooltipBBox.height + 2 * paddingTopBottom + borderWidth + MAX_SHADOW_SIZE * 2,
                        width: tooltipBBox.width + 2 * paddingLeftRight + borderWidth + MAX_SHADOW_SIZE * 2,
                        isEmpty: false
                    }
            },
            show: function() {
                this._state.visibility = VISIBLE;
                this._updateTextContent();
                this.move(this._state.x, this._state.y, this._state.offset);
                this._cloud.attr(VISIBLE);
                this._textGroup.attr(VISIBLE);
                return this
            },
            hide: function() {
                this._state.visibility = HIDDEN;
                this._cloud.attr(HIDDEN);
                this._textGroup.attr(HIDDEN);
                return this
            },
            move: function(x, y, offset) {
                this._state.x = _isDefined(x) ? x : this._state.x || 0;
                this._state.y = _isDefined(y) ? y : this._state.y || 0;
                this._state.offset = _isDefined(offset) ? offset : this._state.offset || 0;
                this._updateTooltip();
                return this
            },
            _getVerticalInvert: function(cloudHeight, arrowLength, y) {
                var pos = this._state.cloudVerticalPosition;
                if (_isDefined(pos) && pos === 'bottom')
                    return cloudHeight + arrowLength < this._canvasHeight - y;
                else
                    return !(cloudHeight + arrowLength < y)
            },
            _getHorizontalInvert: function(cloudWidth, arrowLength, x) {
                var arrowSide = this._state.arrowSide;
                if (arrowSide === 'right')
                    return cloudWidth + arrowLength < x;
                else
                    return cloudWidth + arrowLength > this._canvasWidth - x
            },
            _setArrowCenter: function(cloudWidth, cloudHeight, arrowLength, x, y) {
                var that = this,
                    verticalInvert = that._getVerticalInvert(cloudHeight, arrowLength, y),
                    x0 = x,
                    y0 = verticalInvert ? y + that._state.offset : y - that._state.offset,
                    x1 = x0 + ARROW_WIDTH / 2,
                    y1 = verticalInvert ? y0 + arrowLength : y0 - arrowLength,
                    x2 = x1 + cloudWidth / 2 - ARROW_WIDTH / 2,
                    y2 = y1,
                    x3 = x2,
                    y3 = verticalInvert ? y2 + cloudHeight : y2 - cloudHeight,
                    x4 = x3 - cloudWidth,
                    y4 = y3,
                    x5 = x4,
                    y5 = verticalInvert ? y4 - cloudHeight : y4 + cloudHeight,
                    x6 = x5 + cloudWidth / 2 - ARROW_WIDTH / 2,
                    y6 = y5;
                return [x0, y0, x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6]
            },
            _setArrowOnSide: function(cloudWidth, cloudHeight, arrowLength, x, y) {
                var that = this,
                    horizontalInvert = that._getHorizontalInvert(cloudWidth, arrowLength, x),
                    halfSideWithoutArrow = (cloudHeight - ARROW_WIDTH) / 2,
                    x0 = horizontalInvert ? x - that._state.offset : x + that._state.offset,
                    y0 = y,
                    x1 = horizontalInvert ? x0 - arrowLength : x0 + arrowLength,
                    y1 = y0 - ARROW_WIDTH / 2,
                    x2 = x1,
                    y2 = y1 - halfSideWithoutArrow,
                    x3 = horizontalInvert ? x2 - cloudWidth : x2 + cloudWidth,
                    y3 = y2,
                    x4 = x3,
                    y4 = y3 + cloudHeight,
                    x5 = horizontalInvert ? x4 + cloudWidth : x4 - cloudWidth,
                    y5 = y4,
                    x6 = x5,
                    y6 = y5 - halfSideWithoutArrow;
                return [x0, y0, x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6]
            },
            _setArrowLeft: function(cloudWidth, cloudHeight, arrowLength, x, y) {
                var that = this,
                    verticalInvert = that._getVerticalInvert(cloudHeight, arrowLength, y),
                    x0 = x,
                    y0 = verticalInvert ? y + that._state.offset : y - that._state.offset,
                    x1 = x0 + ARROW_WIDTH,
                    y1 = verticalInvert ? y0 + arrowLength : y0 - arrowLength,
                    x2 = x1 + cloudWidth - ARROW_WIDTH,
                    y2 = y1,
                    x3 = x2,
                    y3 = verticalInvert ? y2 + cloudHeight : y2 - cloudHeight,
                    x4 = x3 - cloudWidth,
                    y4 = y3,
                    x5 = x4,
                    y5 = verticalInvert ? y4 - cloudHeight - arrowLength : y4 + cloudHeight + arrowLength;
                return [x0, y0, x1, y1, x2, y2, x3, y3, x4, y4, x5, y5]
            },
            _setArrowRight: function(cloudWidth, cloudHeight, arrowLength, x, y) {
                var that = this,
                    verticalInvert = that._getVerticalInvert(cloudHeight, arrowLength, y),
                    x0 = x,
                    y0 = verticalInvert ? y + that._state.offset : y - that._state.offset,
                    x1 = x0,
                    y1 = verticalInvert ? y0 + arrowLength + cloudHeight : y0 - arrowLength - cloudHeight,
                    x2 = x1 - cloudWidth,
                    y2 = y1,
                    x3 = x2,
                    y3 = verticalInvert ? y2 - cloudHeight : y2 + cloudHeight,
                    x4 = x3 + cloudWidth - ARROW_WIDTH,
                    y4 = y3,
                    x5 = x4 + ARROW_WIDTH,
                    y5 = verticalInvert ? y4 - arrowLength : y4 + arrowLength;
                return [x0, y0, x1, y1, x2, y2, x3, y3, x4, y4, x5, y5]
            },
            _checkWidthText: function(cloudWidth, cloudHeight) {
                if (this._options._justify)
                    return;
                var x = this._state.x,
                    text = this._state.text,
                    index,
                    paddingLeftRight = this._options.paddingLeftRight,
                    paddingTopBottom = this._options.paddingTopBottom,
                    textLength,
                    maxTooltipWidth,
                    remainLength,
                    newIndex,
                    bbox = this._state.textBBox;
                if (cloudWidth < x || x + cloudWidth < this._canvasWidth || cloudWidth / 2 < x && x + cloudWidth / 2 < this._canvasWidth)
                    return false;
                if (text.indexOf("<br/>") === -1 && text.indexOf(" ") !== -1) {
                    maxTooltipWidth = _max(x, this._canvasWidth - x, 2 * Math.min(x, this._canvasWidth - x));
                    textLength = text.length * maxTooltipWidth / bbox.width;
                    index = text.substr(0, ~~textLength).lastIndexOf(" ");
                    if (index === -1)
                        index = text.substr(0).indexOf(" ");
                    remainLength = text.substr(index + 1).length;
                    this._state.text = text.substr(0, index) + "<br/>";
                    while (textLength <= remainLength) {
                        newIndex = text.substr(index + 1, ~~textLength).lastIndexOf(" ");
                        if (newIndex === -1)
                            newIndex = text.substr(index + 1).indexOf(" ");
                        if (newIndex !== -1) {
                            this._state.text += text.substr(index + 1, newIndex) + "<br/>";
                            remainLength = text.substr(index + 1 + newIndex).length;
                            index += newIndex + 1
                        }
                        else
                            break
                    }
                    this._state.text += text.substr(index + 1);
                    this._text.attr({text: this._state.text});
                    bbox = this._text.getBBox();
                    cloudWidth = bbox.width + paddingLeftRight * 2;
                    cloudHeight = bbox.height + paddingTopBottom * 2
                }
                if (cloudWidth > x && x + cloudWidth > this._canvasWidth && (cloudWidth / 2 > x || x + cloudWidth / 2 > this._canvasWidth)) {
                    paddingLeftRight = 5;
                    paddingTopBottom = 5;
                    cloudWidth = bbox.width + 2 * paddingLeftRight;
                    cloudHeight = bbox.height + 2 * paddingTopBottom
                }
                return {
                        bbox: bbox,
                        cloudWidth: cloudWidth,
                        cloudHeight: cloudHeight,
                        paddingTopBottom: paddingTopBottom,
                        paddingLeftRight: paddingLeftRight
                    }
            },
            on: function() {
                var $groupElement = $(this._group.element);
                $groupElement.on.apply($groupElement, arguments);
                return this
            },
            off: function() {
                $(this._group.element).off();
                return this
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file legend.js */
    (function(DX, $, undefined) {
        var core = DX.viz.core,
            _Number = Number,
            _String = String,
            _round = Math.round,
            _ceil = Math.ceil,
            _floor = Math.floor,
            _max = Math.max,
            _isDefined = DX.utils.isDefined,
            _isFunction = DX.utils.isFunction,
            _parseEnum = DX.viz.core.utils.parseEnum,
            _decreaseGaps = DX.viz.core.utils.decreaseGaps,
            _extend = $.extend,
            _each = $.each,
            _map = $.map,
            _inArray = $.inArray;
        var DEFAULT_MARGIN = 10,
            DEFAULT_MARKER_HATCHING_WIDTH = 2,
            DEFAULT_MARKER_HATCHING_STEP = 5,
            CENTER = 'center',
            RIGHT = 'right',
            LEFT = 'left',
            TOP = 'top',
            BOTTOM = 'bottom',
            HORIZONTAL = 'horizontal',
            VERTICAL = 'vertical',
            INSIDE = 'inside',
            OUTSIDE = 'outside',
            NONE = 'none';
        function getPattern(renderer, states, action, color) {
            if (!states || !states[action])
                return;
            var direction = states[action].hatching.direction,
                hatching,
                colorFromAction = states[action].fill;
            color = colorFromAction === NONE ? color : colorFromAction;
            direction = !direction || direction === NONE ? RIGHT : direction;
            hatching = _extend({}, states[action].hatching, {
                direction: direction,
                step: DEFAULT_MARKER_HATCHING_STEP,
                width: DEFAULT_MARKER_HATCHING_WIDTH
            });
            return renderer.pattern(color, hatching)
        }
        function parseMargins(options) {
            var margin = options.margin;
            if (margin >= 0) {
                margin = _Number(options.margin);
                margin = {
                    top: margin,
                    bottom: margin,
                    left: margin,
                    right: margin
                }
            }
            else
                margin = {
                    top: margin.top >= 0 ? _Number(margin.top) : DEFAULT_MARGIN,
                    bottom: margin.bottom >= 0 ? _Number(margin.bottom) : DEFAULT_MARGIN,
                    left: margin.left >= 0 ? _Number(margin.left) : DEFAULT_MARGIN,
                    right: margin.right >= 0 ? _Number(margin.right) : DEFAULT_MARGIN
                };
            options.margin = margin
        }
        function takeElementIndex(rowCount, colCount, rowIndex, colIndex) {
            if (rowCount < colCount)
                return rowIndex * colCount + colIndex;
            else
                return rowIndex + colIndex * rowCount
        }
        function getMaxBBox(items) {
            var maxWidth = 0,
                maxHeight = 0,
                bbox;
            _each(items, function(_, item) {
                bbox = item.bbox;
                if (bbox.width > maxWidth)
                    maxWidth = bbox.width;
                if (bbox.height > maxHeight)
                    maxHeight = bbox.height
            });
            return {
                    width: maxWidth,
                    height: maxHeight
                }
        }
        function moveItems(data, items, horizontalTextPosition, options) {
            var i,
                j,
                rows = data.rows,
                cols = data.cols,
                item,
                box,
                xShift = 0,
                yShift = 0,
                widthColumn,
                xPadding = options.columnItemSpacing,
                yPadding = options.rowItemSpacing,
                delta,
                x,
                trackerX;
            for (i = 0; i < rows; i++) {
                delta = data.itemsAlignmentDelta[i];
                for (j = 0; j < cols; j++) {
                    item = items[takeElementIndex(rows, cols, i, j)];
                    if (!item)
                        break;
                    box = item.bbox;
                    widthColumn = data.maxWidthPerColumn[j] || box.width;
                    if (horizontalTextPosition === RIGHT) {
                        x = xShift - box.x;
                        trackerX = xShift - xPadding / 2
                    }
                    else if (horizontalTextPosition === LEFT) {
                        x = box.x + widthColumn - box.width + xShift - xPadding / 2;
                        trackerX = box.x + widthColumn - box.width + xShift - xPadding / 2
                    }
                    else {
                        x = xShift - box.x - box.width / 2 + widthColumn / 2;
                        trackerX = xShift - xPadding / 2
                    }
                    item.group.move(_ceil(x + delta), _ceil(yShift));
                    item.tracker.left = trackerX + delta;
                    item.tracker.top = yShift + box.y - yPadding / 2;
                    item.tracker.bottom = yShift + box.y - yPadding / 2 + data.maxHeightRow + yPadding;
                    item.tracker.right = trackerX + delta + widthColumn + xPadding;
                    xShift = xShift + widthColumn + xPadding
                }
                yShift = yShift + data.maxHeightRow + yPadding;
                xShift = 0
            }
        }
        function getRowsColumns(count, options) {
            var isHorizontal = options.orientation === HORIZONTAL,
                rows = options.rowCount > 0 ? _Number(options.rowCount) : 0,
                columns = options.columnCount > 0 ? _Number(options.columnCount) : 0,
                onRows = _ceil(count / rows),
                onColumns = _ceil(count / columns),
                autoEdit = false;
            if (columns && !rows)
                rows = onColumns;
            else if (!columns && rows)
                columns = onRows;
            else if (columns && rows) {
                if (isHorizontal && columns < onRows)
                    columns = onRows;
                else if (!isHorizontal && rows < onColumns)
                    rows = onColumns
            }
            else {
                autoEdit = true;
                if (isHorizontal) {
                    rows = 1;
                    columns = count
                }
                else {
                    columns = 1;
                    rows = count
                }
            }
            return {
                    rows: rows,
                    columns: columns,
                    autoEdit: autoEdit
                }
        }
        function locateLabelAndMarker(label, marker, options, markerSize, maxMarkerSize) {
            var defaultXMargin = 7,
                defaultTopMargin = 4,
                defaultBottomMargin = 2,
                labelX = 0,
                labelY = 0,
                markerX,
                markerY,
                labelBox = label.getBBox(),
                approximateLabelY = _round(maxMarkerSize / 2 - (labelBox.y + labelBox.height / 2)),
                approximateLabelX = _round(maxMarkerSize / 2 - (labelBox.x + labelBox.width / 2));
            switch (options.itemTextPosition) {
                case LEFT:
                    labelY = approximateLabelY;
                    markerX = labelBox.width + defaultXMargin;
                    break;
                case RIGHT:
                    labelX = maxMarkerSize + defaultXMargin;
                    labelY = approximateLabelY;
                    break;
                case TOP:
                    labelX = approximateLabelX;
                    markerY = labelBox.y + labelBox.height + defaultTopMargin;
                    break;
                case BOTTOM:
                    labelX = approximateLabelX;
                    markerY = labelBox.y - markerSize - defaultTopMargin;
                    break
            }
            label.attr({
                x: labelX,
                y: labelY
            });
            marker.attr({
                translateX: markerX,
                translateY: markerY
            })
        }
        function getItemsAlignmentDelta(alignment, maxRowWidth, rowWidth) {
            if (alignment === RIGHT)
                return maxRowWidth - rowWidth;
            else if (alignment === CENTER)
                return (maxRowWidth - rowWidth) / 2;
            else
                return 0
        }
        function getDataRowsColumns(items, rows, cols, options) {
            var i,
                j,
                columnPadding = options.columnItemSpacing,
                itemsAlignment = options.itemsAlignment,
                rowsWidth = [],
                maxWidthPerColumn = [],
                itemsAlignmentDelta = [],
                maxHeight = 0,
                value;
            for (j = 0; j < cols; j++)
                maxWidthPerColumn[j] = 0;
            for (i = 0; i < rows; i++) {
                rowsWidth[i] = itemsAlignmentDelta[i] = 0;
                for (j = 0; j < cols; j++) {
                    value = items[takeElementIndex(rows, cols, i, j)];
                    if (value) {
                        value = value.bbox;
                        if (maxHeight < value.height)
                            maxHeight = value.height;
                        if (maxWidthPerColumn[j] < value.width)
                            maxWidthPerColumn[j] = value.width;
                        rowsWidth[i] += value.width + columnPadding
                    }
                }
                rowsWidth[i] -= columnPadding
            }
            if (itemsAlignment) {
                value = _max.apply(null, rowsWidth);
                for (i = 0; i < rows; ++i)
                    itemsAlignmentDelta[i] = getItemsAlignmentDelta(itemsAlignment, value, rowsWidth[i]);
                maxWidthPerColumn = []
            }
            else if (options.equalColumnWidth) {
                value = _max.apply(null, maxWidthPerColumn);
                for (j = 0; j < cols; ++j)
                    maxWidthPerColumn[j] = value
            }
            return {
                    rows: rows,
                    cols: cols,
                    maxWidthPerColumn: maxWidthPerColumn,
                    maxHeightRow: maxHeight,
                    itemsAlignmentDelta: itemsAlignmentDelta
                }
        }
        function validateRowsOrColumnsCount(rowsOrColumnsCount, count) {
            return rowsOrColumnsCount < 1 || rowsOrColumnsCount > count ? count : rowsOrColumnsCount
        }
        function applyMarkerState(id, idToIndexMap, items, stateName) {
            var item = idToIndexMap && items[idToIndexMap[id]];
            if (item)
                item.marker.attr(item.states[stateName])
        }
        function parseOptions(options, defaults) {
            if (!options)
                return null;
            DX.utils.debug.assertParam(options.visible, 'Visibility was not passed');
            DX.utils.debug.assertParam(options.markerSize, 'markerSize was not passed');
            DX.utils.debug.assertParam(options.font.color, 'fontColor was not passed');
            DX.utils.debug.assertParam(options.font.family, 'fontFamily was not passed');
            DX.utils.debug.assertParam(options.font.size, 'fontSize was not passed');
            DX.utils.debug.assertParam(options.paddingLeftRight, 'paddingLeftRight was not passed');
            DX.utils.debug.assertParam(options.paddingTopBottom, 'paddingTopBottom was not passed');
            DX.utils.debug.assertParam(options.columnItemSpacing, 'columnItemSpacing was not passed');
            DX.utils.debug.assertParam(options.rowItemSpacing, 'rowItemSpacing was not passed');
            DX.utils.debug.assertParam(options.equalColumnWidth, 'equalColumnWidth was not passed');
            parseMargins(options);
            options.horizontalAlignment = _parseEnum(options.horizontalAlignment, [LEFT, CENTER, RIGHT], RIGHT);
            options.verticalAlignment = _parseEnum(options.verticalAlignment, [TOP, BOTTOM], options.horizontalAlignment === CENTER ? BOTTOM : TOP);
            options.orientation = _parseEnum(options.orientation, [VERTICAL, HORIZONTAL], options.horizontalAlignment === CENTER ? HORIZONTAL : VERTICAL);
            options.itemTextPosition = _parseEnum(options.itemTextPosition, [LEFT, RIGHT, TOP, BOTTOM], options.orientation === HORIZONTAL ? BOTTOM : RIGHT);
            options.position = _parseEnum(options.position, [OUTSIDE, INSIDE], OUTSIDE);
            options.itemsAlignment = _parseEnum(options.itemsAlignment, [LEFT, CENTER, RIGHT], null);
            options.hoverMode = _String(options.hoverMode || '').toLowerCase();
            options.customizeText = _isFunction(options.customizeText) ? options.customizeText : defaults.customizeText;
            options.customizeHint = _isFunction(options.customizeHint) ? options.customizeHint : defaults.customizeHint;
            return options
        }
        function createSquareMarker(renderer, size) {
            return renderer.rect(0, 0, size, size)
        }
        function createCircleMarker(renderer, size) {
            return renderer.circle(size / 2, size / 2, size / 2)
        }
        function isCircle(type) {
            return _String(type).toLowerCase() === 'circle'
        }
        function getMarkerCreator(type) {
            return isCircle(type) ? createCircleMarker : createSquareMarker
        }
        function getMarkerResizer(type) {
            return isCircle(type) ? resizeCircleMarker : resizeSquareMarker
        }
        function resizeSquareMarker(marker, size, maxSize) {
            var centerOfMarker = _ceil((maxSize - size) / 2),
                markerX = centerOfMarker,
                markerY = centerOfMarker;
            marker.attr({
                width: size,
                height: size,
                x: markerX,
                y: markerY
            })
        }
        function resizeCircleMarker(marker, size, _maxSize) {
            marker.attr({r: _ceil(size / 2)})
        }
        function inRect(rect, x, y) {
            return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom
        }
        function updateItemsSize(maxSize, markersOptions, markerResizer) {
            _each(markersOptions, function(i, item) {
                markerResizer(item.marker, item.size, maxSize)
            })
        }
        var _Legend = DX.viz.core.Legend = function(data, options, renderer, group) {
                this._renderer = renderer;
                this._legendGroup = group;
                this.update(data, options);
                this._patterns = []
            };
        _Legend.prototype = {
            constructor: _Legend,
            _backgroundClass: 'dxc-border',
            _itemGroupClass: 'dxc-item',
            _defaults: {
                customizeText: function() {
                    return this.seriesName
                },
                customizeHint: $.noop
            },
            update: function(data, options) {
                this._data = data;
                this._boundingRect = {
                    width: 0,
                    height: 0,
                    x: 0,
                    y: 0
                };
                this._options = parseOptions(options, this._defaults);
                return this
            },
            setSize: function(size) {
                this._size = {
                    width: size.width,
                    height: size.height
                };
                return this
            },
            draw: function() {
                var that = this,
                    options = that._options,
                    renderer = that._renderer,
                    createMarker,
                    items,
                    maxMarkerSize = 0,
                    initMarkerSize,
                    markersOptions = [],
                    resizeMarker,
                    markerType,
                    i = 0;
                if (!(options && options.visible && that._data && that._data.length))
                    return that;
                that.erase();
                markerType = options.markerType;
                initMarkerSize = options.markerSize;
                that._insideLegendGroup = renderer.g().append(that._legendGroup);
                that._createBackground();
                createMarker = getMarkerCreator(markerType);
                resizeMarker = getMarkerResizer(markerType);
                that._markersId = {};
                items = that._data;
                if (options.inverted)
                    items = items.slice().reverse();
                _each(items, function(_i, item) {
                    maxMarkerSize = _max(maxMarkerSize, _Number(item.size > 0 ? item.size : initMarkerSize))
                });
                for (; i < that._patterns.length; i++)
                    that._patterns[i].dispose();
                that._patterns = [];
                that._items = _map(items, function(dataItem, i) {
                    var group = renderer.g().attr({'class': that._itemGroupClass}).append(that._insideLegendGroup),
                        markerSize = _Number(dataItem.size > 0 ? dataItem.size : initMarkerSize),
                        states = dataItem.states,
                        normalState = states.normal,
                        normalStateFill = normalState.fill,
                        marker = createMarker(renderer, maxMarkerSize).attr({
                            fill: normalStateFill || options.markerColor,
                            opacity: normalState.opacity
                        }).append(group),
                        label = that._createLabel(dataItem, group),
                        hoverPattern = getPattern(renderer, states, 'hover', normalStateFill),
                        selectionPattern = getPattern(renderer, states, 'selection', normalStateFill),
                        states = {normal: {fill: normalStateFill}};
                    hoverPattern && (states.hovered = {fill: hoverPattern.id}, that._patterns.push(hoverPattern));
                    selectionPattern && (states.selected = {fill: selectionPattern.id}, that._patterns.push(selectionPattern));
                    if (dataItem.id !== undefined)
                        that._markersId[dataItem.id] = i;
                    locateLabelAndMarker(label, marker, options, markerSize, maxMarkerSize);
                    markersOptions.push({
                        size: markerSize,
                        marker: marker
                    });
                    that._createHint(dataItem, label);
                    return {
                            group: group,
                            marker: marker,
                            tracker: {id: dataItem.id},
                            states: states,
                            bbox: group.getBBox()
                        }
                });
                that._locateElements(options);
                updateItemsSize(maxMarkerSize, markersOptions, resizeMarker);
                that._finalUpdate(options);
                return that
            },
            _finalUpdate: function(options) {
                this._adjustBackgroundSettings(options);
                this._setBoundingRect(options)
            },
            erase: function() {
                var that = this;
                that._insideLegendGroup && that._insideLegendGroup.remove();
                that._insideLegendGroup = that._width = that._height = that._x = that._y = null;
                return that
            },
            _locateElements: function(locationOptions) {
                this._moveInInitialValues();
                this._locateRowsColumns(locationOptions)
            },
            _moveInInitialValues: function() {
                var that = this;
                that._legendGroup && that._legendGroup.move(0, 0);
                that._background && that._background.attr({
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                })
            },
            applySelected: function(id) {
                applyMarkerState(id, this._markersId, this._items, 'selected');
                return this
            },
            applyHover: function(id) {
                applyMarkerState(id, this._markersId, this._items, 'hovered');
                return this
            },
            resetItem: function(id) {
                applyMarkerState(id, this._markersId, this._items, 'normal');
                return this
            },
            _createLabelFormatObject: function(data) {
                return {
                        seriesName: data.text,
                        seriesNumber: data.id,
                        seriesColor: data.states.normal.fill
                    }
            },
            _createLabel: function(data, group) {
                var position = this._options.itemTextPosition,
                    align = position === TOP || position === BOTTOM ? CENTER : LEFT,
                    labelFormatObject = this._createLabelFormatObject(data),
                    text = this._options.customizeText.call(labelFormatObject, labelFormatObject),
                    label = this._renderer.text(text, 0, 0).css(core.utils.patchFontOptions(this._options.font)).attr({align: align}).append(group);
                return label
            },
            _createHint: function(data, label) {
                var labelFormatObject = this._createLabelFormatObject(data),
                    text = this._options.customizeHint.call(labelFormatObject, labelFormatObject);
                if (_isDefined(text) && text !== '')
                    label.setTitle(text)
            },
            _createBackground: function() {
                var that = this,
                    isInside = that._options.position === INSIDE,
                    color = that._options.backgroundColor,
                    fill = color || (isInside ? that._options.containerBackgroundColor : NONE),
                    border = that._options.border,
                    borderVisible = border.visible && border.width && border.color && border.color !== NONE;
                if (isInside || color || borderVisible)
                    that._background = that._renderer.rect(0, 0, 0, 0).attr({
                        fill: fill,
                        'class': that._backgroundClass
                    }).append(that._insideLegendGroup)
            },
            _DEBUG_getDataRowsColumns: getDataRowsColumns,
            _moveRowsColumns: function(rowCount, colCount, locationOptions) {
                var rowsColumnsData = getDataRowsColumns(this._items, rowCount, colCount, locationOptions);
                moveItems(rowsColumnsData, this._items, locationOptions.itemTextPosition, locationOptions)
            },
            _locateRowsColumns: function(locationOptions) {
                var that = this,
                    count = that._data.length,
                    legendBox,
                    rowsColumns = getRowsColumns(count, locationOptions),
                    rows = rowsColumns.rows,
                    columns = rowsColumns.columns,
                    margin = locationOptions.margin,
                    paddingLeftRight = that._background ? locationOptions.paddingLeftRight : 0,
                    paddingTopBottom = that._background ? locationOptions.paddingTopBottom : 0,
                    placeholderWidth = that._size.width - margin.left - margin.right - 2 * paddingLeftRight,
                    placeholderHeight = that._size.height - margin.top - margin.bottom - 2 * paddingTopBottom,
                    maxBBox = getMaxBBox(that._items);
                that._moveRowsColumns(rows, columns, locationOptions);
                legendBox = that._insideLegendGroup.getBBox();
                if (rowsColumns.autoEdit)
                    if (rows === 1) {
                        if (legendBox.width > placeholderWidth && columns > 1) {
                            columns = _floor(placeholderWidth / (maxBBox.width + locationOptions.columnItemSpacing)) || 1;
                            columns = validateRowsOrColumnsCount(columns, count);
                            rows = _ceil(count / columns);
                            that._moveRowsColumns(rows, columns, locationOptions)
                        }
                    }
                    else if (columns === 1)
                        if (legendBox.height > placeholderHeight && rows > 1) {
                            rows = _floor(placeholderHeight / (maxBBox.height + locationOptions.rowItemSpacing)) || 1;
                            rows = validateRowsOrColumnsCount(rows, count);
                            columns = _ceil(count / rows);
                            that._moveRowsColumns(rows, columns, locationOptions)
                        }
                that._rowsCountDrawed = rows;
                that._columnsCountDrawed = columns
            },
            _adjustBackgroundSettings: function(locationOptions) {
                if (!this._background)
                    return;
                var border = locationOptions.border,
                    legendBox = this._insideLegendGroup.getBBox(),
                    backgroundSettings = {
                        x: _round(legendBox.x - locationOptions.paddingLeftRight),
                        y: _round(legendBox.y - locationOptions.paddingTopBottom),
                        width: _round(legendBox.width) + 2 * locationOptions.paddingLeftRight,
                        height: _round(legendBox.height) + 2 * locationOptions.paddingTopBottom,
                        opacity: locationOptions.backgroundOpacity
                    };
                if (border.visible && border.width && border.color && border.color !== NONE) {
                    backgroundSettings["stroke-width"] = border.width;
                    backgroundSettings.stroke = border.color;
                    backgroundSettings["stroke-opacity"] = border.opacity;
                    backgroundSettings.dashStyle = border.dashStyle;
                    backgroundSettings.rx = border.cornerRadius || 0;
                    backgroundSettings.ry = border.cornerRadius || 0
                }
                this._background.attr(backgroundSettings)
            },
            _setBoundingRect: function(locationOptions) {
                if (!this._insideLegendGroup)
                    return;
                var box = this._insideLegendGroup.getBBox(),
                    margin = locationOptions.margin;
                box.height += margin.top + margin.bottom;
                box.width += margin.left + margin.right;
                box.x -= margin.left;
                box.y -= margin.top;
                this._boundingRect = box
            },
            changeSize: function(sizeForDecrease) {
                var that = this,
                    widthForDecrease = sizeForDecrease.width,
                    heightForDecrease = sizeForDecrease.height,
                    options = _extend(true, {}, that._options),
                    margin = options.margin;
                if (heightForDecrease >= 0) {
                    heightForDecrease = _decreaseGaps(margin, ["top", "bottom"], heightForDecrease);
                    if (options.border.visible)
                        heightForDecrease = 2 * _decreaseGaps(options, ["paddingTopBottom"], heightForDecrease / 2);
                    if (that._rowsCountDrawed - 1)
                        heightForDecrease = (that._rowsCountDrawed - 1) * _decreaseGaps(options, ["rowItemSpacing"], heightForDecrease / (that._rowsCountDrawed - 1))
                }
                if (widthForDecrease >= 0) {
                    widthForDecrease = _decreaseGaps(margin, ["left", "right"], widthForDecrease);
                    if (options.border.visible)
                        widthForDecrease = 2 * _decreaseGaps(options, ["paddingLeftRight"], widthForDecrease / 2);
                    if (that._columnsCountDrawed - 1)
                        widthForDecrease = (that._columnsCountDrawed - 1) * _decreaseGaps(options, ["columnItemSpacing"], widthForDecrease / (that._columnsCountDrawed - 1))
                }
                if (that._insideLegendGroup)
                    if (widthForDecrease > 0 || heightForDecrease > 0) {
                        that._options._incidentOccured("W2104");
                        that.erase()
                    }
                    else {
                        that._locateElements(options);
                        that._finalUpdate(options)
                    }
            },
            getActionCallback: function(point) {
                var that = this;
                if (that._options.visible)
                    return function(act) {
                            var pointType = point.type,
                                seriesType = pointType || point.series.type;
                            if (pointType || seriesType === 'pie' || seriesType === 'doughnut' || seriesType === 'donut')
                                that[act] && that[act](point.index)
                        };
                else
                    return $.noop
            },
            getLayoutOptions: function() {
                var options = this._options,
                    boundingRect = this._insideLegendGroup ? this._boundingRect : {
                        width: 0,
                        height: 0,
                        x: 0,
                        y: 0
                    };
                if (options) {
                    boundingRect.verticalAlignment = options.verticalAlignment;
                    boundingRect.horizontalAlignment = options.horizontalAlignment;
                    if (options.orientation === HORIZONTAL)
                        boundingRect.cutLayoutSide = options.verticalAlignment;
                    else
                        boundingRect.cutLayoutSide = options.horizontalAlignment === CENTER ? options.verticalAlignment : options.horizontalAlignment;
                    return boundingRect
                }
                return null
            },
            shift: function(x, y) {
                var that = this,
                    box = that.getLayoutOptions(),
                    settings = {
                        translateX: x - box.x,
                        translateY: y - box.y
                    };
                that._insideLegendGroup && that._insideLegendGroup.attr(settings);
                that._width = box.width;
                that._height = box.height;
                that._x = x;
                that._y = y;
                return that
            },
            getPosition: function() {
                return this._options.position
            },
            coordsIn: function(x, y) {
                return x >= this._x && x <= this._x + this._width && y >= this._y && y <= this._y + this._height
            },
            getItemByCoord: function(x, y) {
                var items = this._items,
                    legendGroup = this._insideLegendGroup;
                x = x - legendGroup.attr("translateX");
                y = y - legendGroup.attr("translateY");
                for (var i = 0; i < items.length; i++)
                    if (inRect(items[i].tracker, x, y))
                        return items[i].tracker;
                return null
            },
            dispose: function() {
                var that = this;
                that._legendGroup = that._insideLegendGroup = that._renderer = that._options = that._data = that._items = null;
                return that
            }
        };
        var __getMarkerCreator = getMarkerCreator;
        DX.viz.core._DEBUG_stubMarkerCreator = function(callback) {
            getMarkerCreator = function() {
                return callback
            }
        };
        DX.viz.core._DEBUG_restoreMarkerCreator = function() {
            getMarkerCreator = __getMarkerCreator
        }
    })(DevExpress, jQuery);
    /*! Module viz-core, file range.js */
    (function($, DX, undefined) {
        var core = DX.viz.core,
            utils = DX.utils,
            _isDefined = utils.isDefined,
            _isDate = utils.isDate,
            getLogUtils = utils.getLog,
            raiseToUtils = utils.raiseTo;
        var NUMBER_EQUALITY_CORRECTION = 1,
            DATETIME_EQUALITY_CORRECTION = 60000;
        var minSelector = "min",
            maxSelector = "max",
            minVisibleSelector = "minVisible",
            maxVisibleSelector = "maxVisible",
            categoriesSelector = "categories",
            baseSelector = "base",
            axisTypeSelector = "axisType",
            _Range;
        var raiseToFlooredLog = function(value, base, correction) {
                return raiseToUtils(Math.floor(getLogUtils(value, base)) + (correction || 0), base)
            };
        var otherLessThan = function(thisValue, otherValue) {
                return otherValue < thisValue
            };
        var otherGreaterThan = function(thisValue, otherValue) {
                return otherValue > thisValue
            };
        var compareAndReplace = function(thisValue, otherValue, setValue, compare) {
                var otherValueDefined = _isDefined(otherValue);
                if (_isDefined(thisValue)) {
                    if (otherValueDefined && compare(thisValue, otherValue))
                        setValue(otherValue)
                }
                else if (otherValueDefined)
                    setValue(otherValue)
            };
        DX.viz.core.__NUMBER_EQUALITY_CORRECTION = NUMBER_EQUALITY_CORRECTION;
        DX.viz.core.__DATETIME_EQUALITY_CORRECTION = DATETIME_EQUALITY_CORRECTION;
        _Range = core.Range = function(range) {
            range && $.extend(this, range)
        };
        _Range.prototype = {
            constructor: _Range,
            dispose: function() {
                this[categoriesSelector] = null
            },
            addRange: function(otherRange) {
                var that = this,
                    categories = that[categoriesSelector],
                    categoriesValues,
                    otherCategories = otherRange[categoriesSelector],
                    i,
                    j,
                    length,
                    found;
                var compareAndReplaceByField = function(field, compare) {
                        compareAndReplace(that[field], otherRange[field], function(value) {
                            that[field] = value
                        }, compare)
                    };
                var controlValuesByVisibleBounds = function(valueField, visibleValueField, compare) {
                        compareAndReplace(that[valueField], that[visibleValueField], function(value) {
                            _isDefined(that[valueField]) && (that[valueField] = value)
                        }, compare)
                    };
                var checkField = function(field) {
                        that[field] = that[field] || otherRange[field]
                    };
                if (utils.isDefined(otherRange.stick))
                    that.stick = otherRange.stick;
                checkField("percentStick");
                checkField("minSpaceCorrection");
                checkField("maxSpaceCorrection");
                checkField("invert");
                checkField(axisTypeSelector);
                checkField("dataType");
                checkField("startCategories");
                checkField("endCategories");
                if (that[axisTypeSelector] === "logarithmic")
                    checkField(baseSelector);
                else
                    that[baseSelector] = undefined;
                compareAndReplaceByField(minSelector, otherLessThan);
                compareAndReplaceByField(maxSelector, otherGreaterThan);
                compareAndReplaceByField(minVisibleSelector, otherLessThan);
                compareAndReplaceByField(maxVisibleSelector, otherGreaterThan);
                compareAndReplaceByField("interval", otherLessThan);
                controlValuesByVisibleBounds(minSelector, minVisibleSelector, otherLessThan);
                controlValuesByVisibleBounds(minSelector, maxVisibleSelector, otherLessThan);
                controlValuesByVisibleBounds(maxSelector, maxVisibleSelector, otherGreaterThan);
                controlValuesByVisibleBounds(maxSelector, minVisibleSelector, otherGreaterThan);
                if (categories === undefined)
                    that[categoriesSelector] = otherCategories;
                else {
                    length = categories.length;
                    if (otherCategories && otherCategories.length)
                        for (i = 0; i < otherCategories.length; i++) {
                            for (j = 0, found = false; j < length; j++)
                                if (categories[j].valueOf() === otherCategories[i].valueOf()) {
                                    found = true;
                                    break
                                }
                            !found && categories.push(otherCategories[i])
                        }
                }
                return this
            },
            isDefined: function() {
                return _isDefined(this[minSelector]) && _isDefined(this[maxSelector]) || _isDefined(this[categoriesSelector])
            },
            setStubData: function(dataType) {
                var that = this,
                    year = (new Date).getYear() - 1,
                    isDate = dataType === "datetime",
                    isCategories = that.axisType === "discrete";
                if (isCategories)
                    that.categories = ["0", "1", "2"];
                else {
                    that[minSelector] = isDate ? new Date(year, 0, 1) : 0;
                    that[maxSelector] = isDate ? new Date(year, 11, 31) : 10
                }
                that.stubData = true;
                return that
            },
            correctValueZeroLevel: function() {
                var that = this;
                if (_isDate(that[maxSelector]) || _isDate(that[minSelector]))
                    return that;
                function setZeroLevel(min, max) {
                    that[min] < 0 && that[max] < 0 && (that[max] = 0);
                    that[min] > 0 && that[max] > 0 && (that[min] = 0)
                }
                setZeroLevel(minSelector, maxSelector);
                setZeroLevel(minVisibleSelector, maxVisibleSelector);
                return that
            },
            checkZeroStick: function() {
                var that = this;
                if (that.min >= 0 && that.max >= 0)
                    that.minStickValue = 0;
                else if (that.min <= 0 && that.max <= 0)
                    that.maxStickValue = 0;
                return that
            }
        }
    })(jQuery, DevExpress);
    /*! Module viz-core, file svgRenderer.js */
    (function(DX, doc) {
        DX.viz.renderers = DX.viz.renderers || {};
        var rendererNS = DX.viz.renderers,
            math = Math,
            mathMin = math.min,
            mathMax = math.max,
            mathCeil = math.ceil,
            mathFloor = math.floor,
            mathRound = math.round,
            mathSin = math.sin,
            mathCos = math.cos,
            mathAbs = math.abs,
            mathPI = math.PI,
            _parseInt = parseInt,
            MAX_PIXEL_COUNT = 10000000000,
            SHARPING_CORRECTION = 0.5,
            ARC_COORD_PREC = 5;
        var pxAddingExceptions = {
                "column-count": true,
                "fill-opacity": true,
                "flex-grow": true,
                "flex-shrink": true,
                "font-weight": true,
                "line-height": true,
                opacity: true,
                order: true,
                orphans: true,
                widows: true,
                "z-index": true,
                zoom: true
            };
        var DEFAULTS = {
                scaleX: 1,
                scaleY: 1
            };
        var getNextDefsSvgId = function() {
                var numDefsSvgElements = 1;
                return function() {
                        return "DevExpress_" + numDefsSvgElements++
                    }
            }();
        function isDefined(value) {
            return value !== null && value !== undefined
        }
        function isArray(value) {
            return Object.prototype.toString.call(value) === "[object Array]"
        }
        function isObject(value) {
            return Object.prototype.toString.call(value) === "[object Object]"
        }
        function createElement(tagName) {
            return doc.createElementNS("http://www.w3.org/2000/svg", tagName)
        }
        function getPatternUrl(id, pathModified) {
            return id !== null ? "url(" + (pathModified ? window.location.href : "") + "#" + id + ")" : ""
        }
        function extend(a, b, skipNonDefined) {
            var value;
            for (var key in b) {
                value = b[key];
                if (!skipNonDefined || skipNonDefined && value !== undefined && value !== null)
                    a[key] = value
            }
            return a
        }
        function normalizeBBox(bBox) {
            var rxl = mathFloor(bBox.x),
                ryt = mathFloor(bBox.y),
                rxr = mathCeil(bBox.width + bBox.x),
                ryb = mathCeil(bBox.height + bBox.y),
                width,
                height,
                ret = {};
            ret.x = rxl < MAX_PIXEL_COUNT && rxl > -MAX_PIXEL_COUNT ? rxl : 0;
            ret.y = ryt < MAX_PIXEL_COUNT && ryt > -MAX_PIXEL_COUNT ? ryt : 0;
            width = rxr - rxl;
            height = ryb - ryt;
            ret.width = width < MAX_PIXEL_COUNT && width > -MAX_PIXEL_COUNT ? width : 0;
            ret.height = height < MAX_PIXEL_COUNT && height > -MAX_PIXEL_COUNT ? height : 0;
            ret.isEmpty = !ret.x && !ret.y && !ret.width && !ret.height;
            return ret
        }
        function getPreserveAspectRatio(location) {
            return {
                    full: "none",
                    lefttop: "xMinYMin",
                    leftcenter: "xMinYMid",
                    leftbottom: "xMinYMax",
                    centertop: "xMidYMin",
                    center: "xMidYMid",
                    centerbottom: "xMidYMax",
                    righttop: "xMaxYMin",
                    rightcenter: "xMaxYMid",
                    rightbottom: "xMaxYMax"
                }[(location || "").toLowerCase()] || "none"
        }
        rendererNS._normalizeArcParams = function(x, y, innerR, outerR, startAngle, endAngle) {
            var isCircle,
                longFlag,
                startAngleCos,
                startAngleSin,
                endAngleCos,
                endAngleSin,
                noArc = true;
            if (mathRound(startAngle) !== mathRound(endAngle)) {
                if (mathAbs(endAngle - startAngle) % 360 === 0) {
                    startAngle = 0;
                    endAngle = 360;
                    isCircle = true;
                    endAngle -= 0.0001
                }
                if (startAngle > 360)
                    startAngle = startAngle % 360;
                if (endAngle > 360)
                    endAngle = endAngle % 360;
                if (startAngle > endAngle)
                    startAngle -= 360;
                noArc = false
            }
            startAngle = startAngle * mathPI / 180;
            endAngle = endAngle * mathPI / 180;
            longFlag = mathFloor(mathAbs(endAngle - startAngle) / mathPI) % 2 ? "1" : "0";
            startAngleCos = mathCos(startAngle);
            startAngleSin = mathSin(startAngle);
            endAngleCos = mathCos(endAngle);
            endAngleSin = mathSin(endAngle);
            return [x, y, mathMin(outerR, innerR), mathMax(outerR, innerR), mathCos(startAngle), mathSin(startAngle), mathCos(endAngle), mathSin(endAngle), isCircle, mathFloor(mathAbs(endAngle - startAngle) / mathPI) % 2 ? "1" : "0", noArc]
        };
        function buildPath(points, type) {
            return combinePathParam(buildPathSegments(points, type))
        }
        function buildArcPath(x, y, innerR, outerR, startAngleCos, startAngleSin, endAngleCos, endAngleSin, isCircle, longFlag) {
            return ["M", (x + outerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * startAngleSin).toFixed(ARC_COORD_PREC), "A", outerR.toFixed(ARC_COORD_PREC), outerR.toFixed(ARC_COORD_PREC), 0, longFlag, 0, (x + outerR * endAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * endAngleSin).toFixed(ARC_COORD_PREC), isCircle ? "M" : "L", (x + innerR * endAngleCos).toFixed(5), (y - innerR * endAngleSin).toFixed(ARC_COORD_PREC), "A", innerR.toFixed(ARC_COORD_PREC), innerR.toFixed(ARC_COORD_PREC), 0, longFlag, 1, (x + innerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - innerR * startAngleSin).toFixed(ARC_COORD_PREC), "Z"].join(" ")
        }
        function buildPathSegments(points, type) {
            var list = [["M", 0, 0]];
            switch (type) {
                case"line":
                    list = buildLineSegments(points);
                    break;
                case"area":
                    list = buildLineSegments(points, true);
                    break;
                case"bezier":
                    list = buildCurveSegments(points);
                    break;
                case"bezierarea":
                    list = buildCurveSegments(points, true);
                    break
            }
            return list
        }
        function buildLineSegments(points, close) {
            return buildSegments(points, buildSimpleLineSegment, close)
        }
        function buildCurveSegments(points, close) {
            return buildSegments(points, buildSimpleCurveSegment, close)
        }
        function buildSegments(points, buildSimpleSegment, close) {
            var i = 0,
                ii = (points || []).length,
                list = [];
            if (isArray(points[0]))
                for (; i < ii; )
                    buildSimpleSegment(points[i++], close, list);
            else
                buildSimpleSegment(points, close, list);
            return list
        }
        function buildSimpleLineSegment(points, close, list) {
            var i = 0,
                ii = (points || []).length;
            if (ii)
                if (isObject(points[0]))
                    for (; i < ii; )
                        list.push([!i ? "M" : "L", points[i].x, points[i++].y]);
                else
                    for (; i < ii; )
                        list.push([!i ? "M" : "L", points[i++], points[i++]]);
            else
                list.push(["M", 0, 0]);
            close && list.push(["Z"]);
            return list
        }
        function buildSimpleCurveSegment(points, close, list) {
            var i = 2,
                ii = (points || []).length;
            if (ii)
                if (isObject(points[0])) {
                    i = 1;
                    list.push(["M", points[0].x, points[0].y]);
                    for (; i < ii; )
                        list.push(["C", points[i].x, points[i++].y, points[i].x, points[i++].y, points[i].x, points[i++].y])
                }
                else {
                    list.push(["M", points[0], points[1]]);
                    for (; i < ii; )
                        list.push(["C", points[i++], points[i++], points[i++], points[i++], points[i++], points[i++]])
                }
            else
                list.push(["M", 0, 0]);
            close && list.push(["Z"]);
            return list
        }
        function combinePathParam(segments) {
            var d = [],
                i = 0,
                length = segments.length;
            for (; i < length; i++)
                d.push(segments[i].join(" "));
            return d.join(" ")
        }
        function compensateSegments(oldSegments, newSegments, type) {
            var oldLength = oldSegments.length,
                newLength = newSegments.length,
                i,
                originalNewSegments,
                makeEqualSegments = type.indexOf("area") !== -1 ? makeEqualAreaSegments : makeEqualLineSegments;
            if (oldLength === 0)
                for (i = 0; i < newLength; i++)
                    oldSegments.push(newSegments[i].slice(0));
            else if (oldLength < newLength)
                makeEqualSegments(oldSegments, newSegments, type);
            else if (oldLength > newLength) {
                originalNewSegments = newSegments.slice(0);
                makeEqualSegments(newSegments, oldSegments, type)
            }
            return originalNewSegments
        }
        function prepareConstSegment(constSeg, type) {
            var x = constSeg[constSeg.length - 2],
                y = constSeg[constSeg.length - 1];
            switch (type) {
                case"line":
                case"area":
                    constSeg[0] = "L";
                    break;
                case"bezier":
                case"bezierarea":
                    constSeg[0] = "C";
                    constSeg[1] = constSeg[3] = constSeg[5] = x;
                    constSeg[2] = constSeg[4] = constSeg[6] = y;
                    break
            }
        }
        function makeEqualLineSegments(short, long, type) {
            var constSeg = short[short.length - 1].slice(),
                i = short.length;
            prepareConstSegment(constSeg, type);
            for (; i < long.length; i++)
                short[i] = constSeg.slice(0)
        }
        function makeEqualAreaSegments(short, long, type) {
            var i,
                head,
                shortLength = short.length,
                longLength = long.length,
                constsSeg1,
                constsSeg2;
            if ((shortLength - 1) % 2 === 0 && (longLength - 1) % 2 === 0) {
                i = (shortLength - 1) / 2 - 1;
                head = short.slice(0, i + 1);
                constsSeg1 = head[head.length - 1].slice(0);
                constsSeg2 = short.slice(i + 1)[0].slice(0);
                prepareConstSegment(constsSeg1, type);
                prepareConstSegment(constsSeg2, type);
                for (var j = i; j < (longLength - 1) / 2 - 1; j++) {
                    short.splice(j + 1, 0, constsSeg1);
                    short.splice(j + 3, 0, constsSeg2)
                }
            }
        }
        function baseCss(styles) {
            var elemStyles = this._styles,
                str = "",
                key,
                value;
            extend(elemStyles, styles || {}, true);
            for (key in elemStyles) {
                value = elemStyles[key];
                if (value === "")
                    continue;
                if (typeof value === "number" && !pxAddingExceptions[key])
                    value += "px";
                str += key + ":" + value + ";"
            }
            str && this.element.setAttribute("style", str);
            return this
        }
        function baseAttr(attrs) {
            attrs = attrs || {};
            var that = this,
                settings = that._settings,
                attributes = {},
                key,
                value,
                elem = that.element,
                renderer = that.renderer,
                rtl = renderer.rtl,
                hasTransformations,
                recalculateDashStyle,
                sw,
                i;
            if (typeof attrs === "string") {
                if (attrs in settings)
                    return settings[attrs];
                if (attrs in DEFAULTS)
                    return DEFAULTS[attrs];
                return 0
            }
            extend(attributes, attrs);
            for (key in attributes) {
                value = attributes[key];
                if (value === undefined)
                    continue;
                settings[key] = value;
                if (key === "align") {
                    key = "text-anchor";
                    value = {
                        left: rtl ? "end" : "start",
                        center: "middle",
                        right: rtl ? "start" : "end"
                    }[value] || ""
                }
                else if (key === "dashStyle") {
                    recalculateDashStyle = true;
                    continue
                }
                else if (key === "stroke-width")
                    recalculateDashStyle = true;
                else if (key === "clipId") {
                    key = "clip-path";
                    value = getPatternUrl(value, renderer.pathModified)
                }
                else if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y))$/i.test(key)) {
                    hasTransformations = true;
                    continue
                }
                else if (/^(x|y)$/i.test(key))
                    hasTransformations = true;
                if (value === null)
                    elem.removeAttribute(key);
                else
                    elem.setAttribute(key, value)
            }
            if (recalculateDashStyle && "dashStyle" in settings) {
                value = settings.dashStyle;
                sw = ("_originalSW" in that ? that._originalSW : settings["stroke-width"]) || 1;
                key = "stroke-dasharray";
                if (value === null)
                    that.element.removeAttribute(key);
                else {
                    value = value.toLowerCase();
                    if (value === "solid" || value === "none")
                        value = "";
                    else {
                        value = value.replace(/longdash/g, "8,3,").replace(/dash/g, "4,3,").replace(/dot/g, "1,3,").replace(/,$/, "").split(",");
                        i = value.length;
                        while (i--)
                            value[i] = _parseInt(value[i]) * sw;
                        value = value.join(",")
                    }
                    that.element.setAttribute(key, value)
                }
            }
            if (hasTransformations || "sharp" in settings)
                that._applyTransformation();
            return that
        }
        function createPathAttr(baseAttr) {
            return function(attrs, inh) {
                    var that = this,
                        segments;
                    if (typeof attrs !== "string") {
                        attrs = extend({}, attrs);
                        segments = attrs.segments;
                        if ("points" in attrs) {
                            segments = buildPathSegments(attrs.points, that.type);
                            delete attrs.points
                        }
                        if (segments) {
                            attrs.d = combinePathParam(segments);
                            that.segments = segments;
                            delete attrs.segments
                        }
                    }
                    return baseAttr.call(that, attrs, inh)
                }
        }
        function createArcAttr(baseAttr, buildArcPath) {
            return function(attrs, inh) {
                    var settings = this._settings,
                        x,
                        y,
                        innerRadius,
                        outerRadius,
                        startAngle,
                        endAngle;
                    if (typeof attrs !== "string") {
                        attrs = extend({}, attrs);
                        if ("x" in attrs || "y" in attrs || "innerRadius" in attrs || "outerRadius" in attrs || "startAngle" in attrs || "endAngle" in attrs) {
                            settings.x = x = "x" in attrs ? attrs.x : settings.x;
                            delete attrs.x;
                            settings.y = y = "y" in attrs ? attrs.y : settings.y;
                            delete attrs.y;
                            settings.innerRadius = innerRadius = "innerRadius" in attrs ? attrs.innerRadius : settings.innerRadius;
                            delete attrs.innerRadius;
                            settings.outerRadius = outerRadius = "outerRadius" in attrs ? attrs.outerRadius : settings.outerRadius;
                            delete attrs.outerRadius;
                            settings.startAngle = startAngle = "startAngle" in attrs ? attrs.startAngle : settings.startAngle;
                            delete attrs.startAngle;
                            settings.endAngle = endAngle = "endAngle" in attrs ? attrs.endAngle : settings.endAngle;
                            delete attrs.endAngle;
                            attrs.d = buildArcPath.apply(this, rendererNS._normalizeArcParams(x, y, innerRadius, outerRadius, startAngle, endAngle))
                        }
                    }
                    return baseAttr.call(this, attrs, inh)
                }
        }
        function createRectAttr(baseAttr) {
            return function(attrs, inh) {
                    var that = this,
                        x,
                        y,
                        width,
                        height,
                        sw,
                        maxSW,
                        newSW;
                    if (typeof attrs !== "string") {
                        attrs = extend({}, attrs);
                        if (!inh && (attrs.x !== undefined || attrs.y !== undefined || attrs.width !== undefined || attrs.height !== undefined || attrs["stroke-width"] !== undefined)) {
                            attrs.x !== undefined ? x = that._originalX = mathFloor(attrs.x) : x = that._originalX || 0;
                            attrs.y !== undefined ? y = that._originalY = mathFloor(attrs.y) : y = that._originalY || 0;
                            attrs.width !== undefined ? width = that._originalWidth = mathFloor(attrs.width) : width = that._originalWidth || 0;
                            attrs.height !== undefined ? height = that._originalHeight = mathFloor(attrs.height) : height = that._originalHeight || 0;
                            attrs["stroke-width"] !== undefined ? sw = that._originalSW = mathFloor(attrs["stroke-width"]) : sw = that._originalSW;
                            maxSW = ~~((width < height ? width : height) / 2);
                            newSW = (sw || 0) < maxSW ? sw || 0 : maxSW;
                            attrs.x = x + newSW / 2;
                            attrs.y = y + newSW / 2;
                            attrs.width = width - newSW;
                            attrs.height = height - newSW;
                            ((sw || 0) !== newSW || !(newSW === 0 && sw === undefined)) && (attrs["stroke-width"] = newSW)
                        }
                        if ("sharp" in attrs)
                            delete attrs.sharp
                    }
                    return baseAttr.call(that, attrs, inh)
                }
        }
        var pathAttr = createPathAttr(baseAttr),
            arcAttr = createArcAttr(baseAttr, buildArcPath),
            rectAttr = createRectAttr(baseAttr);
        function textAttr(attrs) {
            var that = this,
                settings,
                isResetRequired,
                wasStroked,
                isStroked;
            if (typeof attrs === "string")
                return baseAttr.call(that, attrs);
            attrs = extend({}, attrs);
            settings = that._settings;
            wasStroked = isDefined(settings["stroke"]) && isDefined(settings["stroke-width"]);
            if (attrs["text"] !== undefined) {
                settings["text"] = attrs["text"];
                delete attrs["text"];
                isResetRequired = true
            }
            if (attrs["stroke"] !== undefined) {
                settings["stroke"] = attrs["stroke"];
                delete attrs["stroke"]
            }
            if (attrs["stroke-width"] !== undefined) {
                settings["stroke-width"] = attrs["stroke-width"];
                delete attrs["stroke-width"]
            }
            if (attrs["stroke-opacity"] !== undefined) {
                settings["stroke-opacity"] = attrs["stroke-opacity"];
                delete attrs["stroke-opacity"]
            }
            isStroked = isDefined(settings["stroke"]) && isDefined(settings["stroke-width"]);
            baseAttr.call(that, attrs);
            isResetRequired = isResetRequired || isStroked !== wasStroked && settings["text"];
            if (isResetRequired)
                createTextNodes(that, settings.text, isStroked);
            if (isResetRequired || attrs["x"] !== undefined || attrs["y"] !== undefined)
                locateTextNodes(that);
            if (isStroked)
                strokeTextNodes(that);
            return that
        }
        function textCss(styles) {
            styles = styles || {};
            baseCss.call(this, styles);
            if ("font-size" in styles)
                locateTextNodes(this);
            return this
        }
        function orderHtmlTree(strCount, node, textArray) {
            var nodeParams = node.params = node.params || {style: {}},
                nodeStyle = nodeParams.style,
                parentStyle = node.parentNode && node.parentNode.params && node.parentNode.params.style || {},
                nativeElementStyle = node.style,
                childCount = node.childNodes.length,
                count = 0;
            if (node.nodeName !== '#text')
                extend(nodeStyle, parentStyle);
            switch (node.tagName) {
                case'B':
                case'STRONG':
                    nodeStyle['font-weight'] = 'bold';
                    break;
                case'I':
                case'EM':
                    nodeStyle['font-style'] = 'italic';
                    break;
                case'U':
                    nodeStyle['text-decoration'] = 'underline';
                    break;
                case'BR':
                    strCount++;
                    break
            }
            if (nativeElementStyle) {
                if (nativeElementStyle.fontSize)
                    nodeStyle['font-size'] = (_parseInt(nativeElementStyle.fontSize, 10) || nodeStyle['font-size']) + 'px';
                nodeStyle.fill = nativeElementStyle.color || nodeStyle.fill;
                nodeStyle['font-style'] = nativeElementStyle.fontStyle || nodeStyle['font-style'];
                nodeStyle['font-weight'] = nativeElementStyle.fontWeight || nodeStyle['font-weight'];
                nodeStyle['text-decoration'] = nativeElementStyle.textDecoration || nodeStyle['text-decoration']
            }
            while (count !== childCount)
                strCount = orderHtmlTree(strCount, node.childNodes[count++], textArray);
            if (node.wholeText !== undefined) {
                extend(nodeStyle, parentStyle);
                textArray.push({
                    value: node.wholeText,
                    style: nodeStyle,
                    line: strCount,
                    height: _parseInt(nodeStyle['font-size'], 10) || 0
                })
            }
            return strCount
        }
        function adjustLineHeights(items) {
            var i,
                ii,
                currentItem = items[0],
                item;
            for (i = 1, ii = items.length; i < ii; ++i) {
                item = items[i];
                if (item.line === currentItem.line) {
                    currentItem.height = mathMax(currentItem.height, item.height);
                    currentItem.inherits = currentItem.inherits || item.height === 0;
                    item.height = NaN
                }
                else
                    currentItem = item
            }
        }
        function parseHTML(text) {
            var items = [],
                div = doc.createElement("div");
            div.innerHTML = text.replace(/\r/g, "").replace(/\n/g, "<br/>");
            orderHtmlTree(0, div, items);
            adjustLineHeights(items);
            return items
        }
        function parseMultiline(text) {
            var texts = text.replace(/\r/g, "").split("\n"),
                i = 0,
                items = [];
            for (; i < texts.length; i++)
                items.push({
                    value: texts[i],
                    height: 0
                });
            return items
        }
        function createTspans(items, element, fieldName) {
            var i,
                ii,
                item;
            for (i = 0, ii = items.length; i < ii; ++i) {
                item = items[i];
                item[fieldName] = createElement("tspan");
                item[fieldName].appendChild(doc.createTextNode(item.value));
                item.style && baseCss.call({
                    element: item[fieldName],
                    _styles: {}
                }, item.style);
                element.appendChild(item[fieldName])
            }
        }
        function createTextNodes(wrapper, text, isStroked) {
            var items;
            wrapper._texts = null;
            wrapper.clear();
            if (text === null)
                return;
            text = "" + text;
            if (text.indexOf("<") !== -1 || text.indexOf("&") !== -1)
                items = parseHTML(text);
            else if (text.indexOf("\n") !== -1)
                items = parseMultiline(text);
            else if (isStroked)
                items = [{
                        value: text,
                        height: 0
                    }];
            if (items) {
                wrapper._texts = items;
                if (isStroked)
                    createTspans(items, wrapper.element, "stroke");
                createTspans(items, wrapper.element, "tspan")
            }
            else
                wrapper.element.appendChild(doc.createTextNode(text))
        }
        function setTextNodeAttribute(item, name, value) {
            item.tspan.setAttribute(name, value);
            item.stroke && item.stroke.setAttribute(name, value)
        }
        function locateTextNodes(wrapper) {
            if (!wrapper._texts)
                return;
            var items = wrapper._texts,
                x = wrapper._settings.x,
                lineHeight = wrapper._styles["font-size"] || 12,
                i,
                ii,
                item = items[0];
            setTextNodeAttribute(item, "x", x);
            setTextNodeAttribute(item, "y", wrapper._settings.y);
            for (i = 1, ii = items.length; i < ii; ++i) {
                item = items[i];
                if (item.height >= 0) {
                    setTextNodeAttribute(item, "x", x);
                    setTextNodeAttribute(item, "dy", item.inherits ? mathMax(item.height, lineHeight) : item.height || lineHeight)
                }
            }
        }
        function strokeTextNodes(wrapper) {
            if (!wrapper._texts)
                return;
            var items = wrapper._texts,
                stroke = wrapper._settings["stroke"],
                strokeWidth = wrapper._settings["stroke-width"],
                strokeOpacity = wrapper._settings["stroke-opacity"] || 1,
                tspan,
                i,
                ii;
            for (i = 0, ii = items.length; i < ii; ++i) {
                tspan = items[i].stroke;
                tspan.setAttribute("stroke", stroke);
                tspan.setAttribute("stroke-width", strokeWidth);
                tspan.setAttribute("stroke-opacity", strokeOpacity);
                tspan.setAttribute("stroke-linejoin", "round")
            }
        }
        function baseAnimate(params, options, complete) {
            options = options || {};
            var that = this,
                key,
                value,
                renderer = that.renderer,
                settings = that._settings,
                animationParams = {};
            var defaults = {
                    translateX: 0,
                    translateY: 0,
                    scaleX: 1,
                    scaleY: 1,
                    rotate: 0,
                    rotateX: 0,
                    rotateY: 0
                };
            if (complete)
                options.complete = complete;
            if (renderer.animationEnabled()) {
                for (key in params) {
                    value = params[key];
                    if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y))$/i.test(key)) {
                        animationParams.transform = animationParams.transform || {
                            from: {},
                            to: {}
                        };
                        animationParams.transform.from[key] = key in settings ? settings[key] : defaults[key];
                        animationParams.transform.to[key] = value
                    }
                    else if (key === "arc" || key === "segments")
                        animationParams[key] = value;
                    else
                        animationParams[key] = {
                            from: key in settings ? settings[key] : parseFloat(that.element.getAttribute(key) || 0),
                            to: value
                        }
                }
                renderer.animateElement(that, animationParams, extend(extend({}, renderer.animOptions), options))
            }
            else {
                options.step && options.step.call(that, 1, 1);
                options.complete && options.complete.call(that);
                that.attr(params)
            }
            return that
        }
        function pathAnimate(params, options, complete) {
            var that = this,
                curSegments = that.segments || [],
                newSegments,
                endSegments;
            if (that.renderer.animationEnabled() && "points" in params) {
                newSegments = buildPathSegments(params.points, that.type);
                endSegments = compensateSegments(curSegments, newSegments, that.type);
                params.segments = {
                    from: curSegments,
                    to: newSegments,
                    end: endSegments
                };
                delete params.points
            }
            return baseAnimate.call(that, params, options, complete)
        }
        function arcAnimate(params, options, complete) {
            var that = this,
                settings = that._settings,
                arcParams = {
                    from: {},
                    to: {}
                };
            if (that.renderer.animationEnabled() && ("x" in params || "y" in params || "innerRadius" in params || "outerRadius" in params || "startAngle" in params || "endAngle" in params)) {
                arcParams.from.x = settings.x || 0;
                arcParams.from.y = settings.y || 0;
                arcParams.from.innerRadius = settings.innerRadius || 0;
                arcParams.from.outerRadius = settings.outerRadius || 0;
                arcParams.from.startAngle = settings.startAngle || 0;
                arcParams.from.endAngle = settings.endAngle || 0;
                arcParams.to.x = "x" in params ? params.x : settings.x;
                delete params.x;
                arcParams.to.y = "y" in params ? params.y : settings.y;
                delete params.y;
                arcParams.to.innerRadius = "innerRadius" in params ? params.innerRadius : settings.innerRadius;
                delete params.innerRadius;
                arcParams.to.outerRadius = "outerRadius" in params ? params.outerRadius : settings.outerRadius;
                delete params.outerRadius;
                arcParams.to.startAngle = "startAngle" in params ? params.startAngle : settings.startAngle;
                delete params.startAngle;
                arcParams.to.endAngle = "endAngle" in params ? params.endAngle : settings.endAngle;
                delete params.endAngle;
                params.arc = arcParams
            }
            return baseAnimate.call(that, params, options, complete)
        }
        rendererNS.__mockPrivateFunctions = function(fs) {
            fs = fs || {};
            function mockFunction(mock, orig) {
                if (!mock)
                    return orig;
                var originalFunction = orig;
                orig = mock;
                orig._originalFunction = originalFunction;
                return orig
            }
            baseAttr = mockFunction(fs.baseAttr, baseAttr);
            baseAnimate = mockFunction(fs.baseAnimate, baseAnimate);
            getNextDefsSvgId = mockFunction(fs.getNextDefsSvgId, getNextDefsSvgId);
            compensateSegments = mockFunction(fs.compensateSegments, compensateSegments);
            buildPathSegments = mockFunction(fs.buildPathSegments, buildPathSegments);
            buildArcPath = mockFunction(fs.buildArcPath, buildArcPath);
            pathAttr = createPathAttr(baseAttr);
            arcAttr = createArcAttr(baseAttr, buildArcPath);
            rectAttr = createRectAttr(baseAttr);
            return {
                    buildArcPath: buildArcPath,
                    buildPath: buildPath,
                    buildPathSegments: buildPathSegments,
                    baseAttr: baseAttr,
                    baseAnimate: baseAnimate,
                    getNextDefsSvgId: getNextDefsSvgId,
                    compensateSegments: compensateSegments
                }
        };
        rendererNS.__restoreMockPrivateFunctions = function() {
            function restoreFunction(func) {
                return func._originalFunction || func
            }
            baseAttr = restoreFunction(baseAttr);
            baseAnimate = restoreFunction(baseAnimate);
            getNextDefsSvgId = restoreFunction(getNextDefsSvgId);
            compensateSegments = restoreFunction(compensateSegments);
            buildPathSegments = restoreFunction(buildPathSegments);
            buildArcPath = restoreFunction(buildArcPath);
            pathAttr = createPathAttr(baseAttr);
            arcAttr = createArcAttr(baseAttr, buildArcPath);
            rectAttr = createRectAttr(baseAttr)
        };
        function SvgElement(renderer, tagName) {
            this.ctor.apply(this, arguments)
        }
        rendererNS.SvgElement = SvgElement;
        SvgElement.prototype = {
            ctor: function(renderer, tagName, type) {
                var that = this;
                that.renderer = renderer;
                that.element = createElement(tagName);
                that._settings = {};
                that._styles = {};
                if (tagName === "path")
                    that.type = type || "line";
                if (tagName === "text") {
                    that.attr = textAttr;
                    that.css = textCss
                }
                else if (tagName === "path")
                    if (that.type === "arc") {
                        that.attr = arcAttr;
                        that.animate = arcAnimate
                    }
                    else {
                        that.attr = pathAttr;
                        that.animate = pathAnimate
                    }
                else if (tagName === "rect") {
                    that.attr = rectAttr;
                    that.sharp = function() {
                        return this
                    }
                }
            },
            dispose: function() {
                var that = this,
                    key;
                that.element && that.remove();
                for (key in that)
                    that[key] = null;
                return null
            },
            append: function(parent) {
                parent = parent || this.renderer.root;
                (parent.element || parent).appendChild(this.element);
                return this
            },
            remove: function() {
                var elem = this.element,
                    parent = elem.parentNode;
                parent && parent.removeChild(elem);
                return this
            },
            clear: function() {
                var elem = this.element;
                while (elem.firstChild)
                    elem.removeChild(elem.firstChild);
                return this
            },
            toBackground: function() {
                var elem = this.element,
                    parent = elem.parentNode;
                parent && parent.insertBefore(elem, parent.firstChild);
                return this
            },
            toForeground: function() {
                var elem = this.element,
                    parent = elem.parentNode;
                parent && parent.appendChild(elem);
                return this
            },
            css: baseCss,
            attr: baseAttr,
            sharp: function() {
                return this.attr({sharp: true})
            },
            _applyTransformation: function() {
                var tr = this._settings,
                    scaleXDefined,
                    scaleYDefined,
                    transformations = [],
                    rotateX,
                    rotateY,
                    correction = tr["stroke-width"] % 2 && tr.sharp ? SHARPING_CORRECTION : 0;
                if (!("rotateX" in tr))
                    rotateX = tr.x;
                else
                    rotateX = tr.rotateX;
                if (!("rotateY" in tr))
                    rotateY = tr.y;
                else
                    rotateY = tr.rotateY;
                transformations.push("translate(" + ((tr.translateX || 0) + correction) + "," + ((tr.translateY || 0) + correction) + ")");
                if (tr.rotate)
                    transformations.push("rotate(" + tr.rotate + "," + (rotateX || 0) + "," + (rotateY || 0) + ")");
                scaleXDefined = isDefined(tr.scaleX);
                scaleYDefined = isDefined(tr.scaleY);
                if (scaleXDefined || scaleYDefined)
                    transformations.push("scale(" + (scaleXDefined ? tr.scaleX : 1) + "," + (scaleYDefined ? tr.scaleY : 1) + ")");
                if (transformations.length)
                    this.element.setAttribute("transform", transformations.join(" "))
            },
            move: function(x, y, animate, animOptions) {
                var obj = {};
                isDefined(x) && (obj.translateX = x);
                isDefined(y) && (obj.translateY = y);
                if (!animate)
                    this.attr(obj);
                else
                    this.animate(obj, animOptions);
                return this
            },
            rotate: function(angle, x, y, animate, animOptions) {
                var obj = {rotate: angle || 0};
                isDefined(x) && (obj.rotateX = x);
                isDefined(y) && (obj.rotateY = y);
                if (!animate)
                    this.attr(obj);
                else
                    this.animate(obj, animOptions);
                return this
            },
            getBBox: function() {
                var that = this,
                    elem = that.element,
                    transformation = that._settings,
                    rotateAngle = mathPI * (transformation.rotate || 0) / 180,
                    rotateX = ("rotateX" in transformation ? transformation.rotateX : transformation.x) || 0,
                    rotateY = ("rotateY" in transformation ? transformation.rotateY : transformation.y) || 0,
                    bBox;
                try {
                    bBox = elem.getBBox ? elem.getBBox() : null
                }
                catch(e) {}
                if (!bBox)
                    bBox = {
                        x: 0,
                        y: 0,
                        width: elem.offsetWidth || 0,
                        height: elem.offsetHeight || 0
                    };
                bBox = extend({}, bBox);
                if (rotateAngle) {
                    var cos = mathCos(rotateAngle).toFixed(3),
                        sin = mathSin(rotateAngle).toFixed(3),
                        ltx = bBox.x - rotateX,
                        lty = bBox.y - rotateY,
                        rtx = bBox.x + bBox.width - rotateX,
                        rty = bBox.y - rotateY,
                        lbx = bBox.x - rotateX,
                        lby = bBox.y + bBox.height - rotateY,
                        rbx = bBox.x + bBox.width - rotateX,
                        rby = bBox.y + bBox.height - rotateY,
                        w,
                        h;
                    w = mathAbs(bBox.height * sin) + mathAbs(bBox.width * cos);
                    h = mathAbs(bBox.height * cos) + mathAbs(bBox.width * sin);
                    bBox.x = mathMin(ltx * cos - lty * sin + rotateX, rtx * cos - rty * sin + rotateX, lbx * cos - lby * sin + rotateX, rbx * cos - rby * sin + rotateX);
                    bBox.y = mathMin(ltx * sin + lty * cos + rotateY, rtx * sin + rty * cos + rotateY, lbx * sin + lby * cos + rotateY, rbx * sin + rby * cos + rotateY);
                    bBox.width = w;
                    bBox.height = h
                }
                return normalizeBBox(bBox)
            },
            markup: function() {
                var temp = doc.createElement('div'),
                    node = this.element.cloneNode(true);
                temp.appendChild(node);
                return temp.innerHTML
            },
            animate: baseAnimate,
            stopAnimation: function(disableComplete) {
                var animation = this.animation;
                animation && animation.stop(true, disableComplete);
                return this
            },
            setTitle: function(text) {
                var titleElem = createElement('title');
                titleElem.innerHTML = text || '';
                this.element.appendChild(titleElem)
            }
        };
        function SvgRenderer() {
            this.ctor.apply(this, arguments)
        }
        rendererNS.SvgRenderer = SvgRenderer;
        SvgRenderer.prototype = {
            ctor: function(options) {
                var that = this;
                options = options || {};
                that.pathModified = !!options.pathModified;
                that.rtl = !!options.rtl;
                that.cssClass = options.cssClass || "";
                that.root = that._createRoot();
                that.resize(options.width, options.height);
                that._init(options)
            },
            _createElement: function(tagName, attr, type) {
                var elem = new rendererNS.SvgElement(this, tagName, type);
                attr && elem.attr(attr);
                return elem
            },
            _createRoot: function() {
                return this._createElement("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        "xmlns:xlink": "http://www.w3.org/1999/xlink",
                        version: "1.1",
                        "class": this.cssClass,
                        direction: this.rtl ? "rtl" : "ltr",
                        fill: "none",
                        stroke: "none",
                        "stroke-width": 0
                    }).css({
                        "-webkit-tap-highlight-color": "rgba(0, 0, 0, 0)",
                        display: "block",
                        overflow: "hidden"
                    })
            },
            _init: function(options) {
                var that = this;
                that.defs = that._createElement("defs");
                that.animOptions = {
                    enabled: true,
                    duration: 1000,
                    easing: "easeOutCubic"
                };
                that.updateAnimationOptions(options.animation);
                that.animationController = new rendererNS.AnimationController(that.root.element)
            },
            draw: function(container) {
                var that = this;
                if (!container || that.drawn)
                    return that;
                that.root.append(container);
                that.defs.append(that.root);
                that.drawn = true;
                return that
            },
            resize: function(width, height) {
                if (width >= 0 && height >= 0)
                    this.root.attr({
                        width: width,
                        height: height
                    });
                return this
            },
            clear: function() {
                var that = this;
                that.root.remove();
                that.defs.remove();
                that.drawn = null;
                return this
            },
            dispose: function() {
                var that = this,
                    key;
                that.root.dispose();
                that.defs.dispose();
                that.animationController.dispose();
                for (key in that)
                    that[key] = null;
                return null
            },
            animationEnabled: function() {
                return !!this.animOptions.enabled
            },
            updateAnimationOptions: function(newOptions) {
                extend(this.animOptions, newOptions);
                return this
            },
            stopAllAnimations: function(lock) {
                this.animationController[lock ? "lock" : "stop"]();
                return this
            },
            animateElement: function(element, params, options) {
                this.animationController.animateElement(element, params, options);
                return this
            },
            svg: function() {
                return this.root.markup()
            },
            rect: function(x, y, width, height) {
                return this._createElement("rect", {
                        x: x || 0,
                        y: y || 0,
                        width: width || 0,
                        height: height || 0
                    })
            },
            circle: function(x, y, r) {
                return this._createElement("circle", {
                        cx: x || 0,
                        cy: y || 0,
                        r: r || 0
                    })
            },
            g: function() {
                return this._createElement("g")
            },
            image: function(x, y, w, h, href, location) {
                var image = this._createElement("image", {
                        x: x || 0,
                        y: y || 0,
                        width: w || 0,
                        height: h || 0,
                        preserveAspectRatio: getPreserveAspectRatio(location)
                    });
                image.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", href || "");
                return image
            },
            path: function(points, type) {
                return this._createElement("path", {points: points || []}, type)
            },
            arc: function(x, y, innerRadius, outerRadius, startAngle, endAngle) {
                return this._createElement("path", {
                        x: x || 0,
                        y: y || 0,
                        innerRadius: innerRadius || 0,
                        outerRadius: outerRadius || 0,
                        startAngle: startAngle || 0,
                        endAngle: endAngle || 0
                    }, "arc")
            },
            text: function(text, x, y) {
                return this._createElement("text", {
                        text: text || "",
                        x: x || 0,
                        y: y || 0
                    })
            },
            pattern: function(color, hatching) {
                hatching = hatching || {};
                var that = this,
                    id,
                    d,
                    pattern,
                    rect,
                    path,
                    step = hatching.step || 6,
                    stepTo2 = step / 2,
                    stepBy15 = step * 1.5,
                    direction = (hatching.direction || "").toLowerCase();
                if (direction !== "right" && direction !== "left")
                    return {
                            id: color,
                            append: function() {
                                return this
                            },
                            clear: function(){},
                            dispose: function(){}
                        };
                id = getNextDefsSvgId();
                d = direction === "right" ? "M " + stepTo2 + " " + -stepTo2 + " L " + -stepTo2 + " " + stepTo2 + " M 0 " + step + " L " + step + " 0 M " + stepBy15 + " " + stepTo2 + " L " + stepTo2 + " " + stepBy15 : "M 0 0 L " + step + " " + step + " M " + -stepTo2 + " " + stepTo2 + " L " + stepTo2 + " " + stepBy15 + " M " + stepTo2 + " " + -stepTo2 + " L " + stepBy15 + " " + stepTo2;
                pattern = that._createElement("pattern", {
                    id: id,
                    width: step,
                    height: step,
                    patternUnits: "userSpaceOnUse"
                }).append(that.defs);
                pattern.id = getPatternUrl(id, that.pathModified);
                rect = that.rect(0, 0, step, step).attr({
                    fill: color,
                    opacity: hatching.opacity
                }).append(pattern);
                path = that._createElement("path", {
                    d: d,
                    "stroke-width": hatching.width || 1,
                    stroke: color
                }).append(pattern);
                pattern.rect = rect;
                pattern.path = path;
                return pattern
            },
            clipRect: function(x, y, width, height) {
                var that = this,
                    id = getNextDefsSvgId(),
                    clipPath = that._createElement("clipPath", {id: id}).append(that.defs),
                    rect = that.rect(x, y, width, height).append(clipPath);
                rect.id = id;
                rect.clipPath = clipPath;
                return rect
            },
            shadowFilter: function(x, y, width, height, dx, dy, blur, color, opacity) {
                var that = this,
                    id = getNextDefsSvgId(),
                    filter = that._createElement("filter", {
                        id: id,
                        x: x || 0,
                        y: y || 0,
                        width: width || 0,
                        height: height || 0
                    }).append(that.defs),
                    gaussianBlur = that._createElement("feGaussianBlur", {
                        "in": "SourceGraphic",
                        result: "gaussianBlurResult",
                        stdDeviation: blur || 0
                    }).append(filter),
                    offset = that._createElement("feOffset", {
                        "in": "gaussianBlurResult",
                        result: "offsetResult",
                        dx: dx || 0,
                        dy: dy || 0
                    }).append(filter),
                    flood = that._createElement("feFlood", {
                        result: "floodResult",
                        "flood-color": color || "",
                        "flood-opacity": opacity
                    }).append(filter),
                    composite = that._createElement("feComposite", {
                        "in": "floodResult",
                        in2: "offsetResult",
                        operator: "in",
                        result: "compositeResult"
                    }).append(filter),
                    finalComposite = that._createElement("feComposite", {
                        "in": "SourceGraphic",
                        in2: "compositeResult",
                        operator: "over"
                    }).append(filter);
                filter.ref = getPatternUrl(id, that.pathModified);
                filter.gaussianBlur = gaussianBlur;
                filter.offset = offset;
                filter.flood = flood;
                filter.composite = composite;
                filter.finalComposite = finalComposite;
                filter.attr = function(attrs) {
                    var that = this,
                        filterAttrs = {},
                        offsetAttrs = {},
                        floodAttrs = {};
                    "x" in attrs && (filterAttrs.x = attrs.x);
                    "y" in attrs && (filterAttrs.y = attrs.y);
                    "width" in attrs && (filterAttrs.width = attrs.width);
                    "height" in attrs && (filterAttrs.height = attrs.height);
                    baseAttr.call(that, filterAttrs);
                    "blur" in attrs && that.gaussianBlur.attr({stdDeviation: attrs.blur});
                    "dx" in attrs && (offsetAttrs.dx = attrs.dx);
                    "dy" in attrs && (offsetAttrs.dy = attrs.dy);
                    that.offset.attr(offsetAttrs);
                    "color" in attrs && (floodAttrs["flood-color"] = attrs.color);
                    "opacity" in attrs && (floodAttrs["flood-opacity"] = attrs.opacity);
                    that.flood.attr(floodAttrs);
                    return that
                };
                return filter
            }
        };
        function processCircleSettings(x, y, size, borderWidth) {
            var correct = size + ~~borderWidth & 1;
            return {
                    cx: correct ? x + 0.5 : x,
                    cy: correct ? y + 0.5 : y,
                    r: size / 2
                }
        }
        rendererNS._svgProcessCircleSettings = processCircleSettings;
        rendererNS._svgBuildPath = buildPath;
        rendererNS._createArcAttr = createArcAttr;
        rendererNS._createPathAttr = createPathAttr;
        rendererNS._createRectAttr = createRectAttr
    })(DevExpress, document);
    /*! Module viz-core, file vmlRenderer.js */
    (function(DX, doc) {
        DX.viz.renderers = DX.viz.renderers || {};
        var rendererNS = DX.viz.renderers,
            math = Math,
            mathMin = math.min,
            mathMax = math.max,
            mathCeil = math.ceil,
            mathFloor = math.floor,
            mathRound = math.round,
            mathSin = math.sin,
            mathCos = math.cos,
            mathAbs = math.abs,
            mathPI = math.PI,
            MAX_PIXEL_COUNT = 10000000000,
            baseElementPrototype = rendererNS.SvgElement.prototype,
            documentFragment = doc.createDocumentFragment(),
            DEFAULT_STYLE = {
                behavior: "url(#default#VML)",
                display: "inline-block",
                position: "absolute"
            },
            DEFAULT_ATTRS = {xmlns: 'urn:schemas-microsoft-com:vml'},
            INHERITABLE_PROPERTIES = {
                stroke: true,
                fill: true,
                opacity: true,
                'stroke-width': true,
                align: true,
                dashStyle: true,
                "stroke-opacity": true,
                'fill-opacity': true,
                rotate: true,
                rotateX: true,
                rotateY: true
            },
            stub = function(){},
            stubReturnedThis = function() {
                return this
            },
            svgToVmlConv = {
                circle: "oval",
                g: "div",
                path: "shape",
                text: "span"
            },
            FONT_HEIGHT_OFFSET_K = 0.55 + 0.45 / 2,
            DEFAULTS = {
                scaleX: 1,
                scaleY: 1
            },
            pathAttr = rendererNS._createPathAttr(vmlAttr),
            arcAttr = rendererNS._createArcAttr(vmlAttr, buildArcPath),
            rectAttr = rendererNS._createRectAttr(vmlAttr);
        function isDefined(value) {
            return value !== null && value !== undefined
        }
        function extend(a, b) {
            for (var key in b)
                a[key] = b[key];
            return a
        }
        function inArray(array, elem) {
            var i = 0;
            for (; i < array.length; i++)
                if (elem === array[i])
                    return i;
            return -1
        }
        function buildArcPath(x, y, innerR, outerR, startAngleCos, startAngleSin, endAngleCos, endAngleSin, isCircle, longFlag, noArc) {
            var xOuterStart = x + outerR * startAngleCos,
                yOuterStart = y - outerR * startAngleSin,
                xOuterEnd = x + outerR * endAngleCos,
                yOuterEnd = y - outerR * endAngleSin,
                xInnerStart = x + innerR * endAngleCos,
                yInnerStart = y - innerR * endAngleSin,
                xInnerEnd = x + innerR * startAngleCos,
                yInnerEnd = y - innerR * startAngleSin;
            return !noArc ? ['wr', mathFloor(x - innerR), mathFloor(y - innerR), mathFloor(x + innerR), mathFloor(y + innerR), mathFloor(xInnerStart), mathFloor(yInnerStart), mathFloor(xInnerEnd), mathFloor(yInnerEnd), isCircle ? 'wr ' : 'at ', mathFloor(x - outerR), mathFloor(y - outerR), mathFloor(x + outerR), mathFloor(y + outerR), mathFloor(xOuterStart), mathFloor(yOuterStart), mathFloor(xOuterEnd), mathFloor(yOuterEnd), 'x e'].join(" ") : "m 0 0 x e"
        }
        function getInheritSettings(settings) {
            var result = {},
                prop,
                value;
            for (prop in INHERITABLE_PROPERTIES) {
                value = settings[prop];
                value !== undefined && (result[prop] = value)
            }
            return result
        }
        function correctBoundingRectWithStrokeWidth(rect, strokeWidth) {
            strokeWidth = Math.ceil(parseInt(strokeWidth) / 2);
            if (strokeWidth && strokeWidth > 1) {
                rect.left -= strokeWidth;
                rect.top -= strokeWidth;
                rect.right += strokeWidth;
                rect.bottom += strokeWidth
            }
            return rect
        }
        function shapeBBox() {
            var element = this.element,
                points = (element.path.value || element.path).match(/[-0-9]+/g),
                i,
                value,
                resultRect = {};
            for (i = 0; i < points.length; i++) {
                value = parseInt(points[i]);
                if (i % 2) {
                    resultRect.top = resultRect.top === undefined || value < resultRect.top ? value : resultRect.top;
                    resultRect.bottom = resultRect.bottom === undefined || value > resultRect.bottom ? value : resultRect.bottom
                }
                else {
                    resultRect.left = resultRect.left === undefined || value < resultRect.left ? value : resultRect.left;
                    resultRect.right = resultRect.right === undefined || value > resultRect.right ? value : resultRect.right
                }
            }
            resultRect.left = resultRect.left || 0;
            resultRect.top = resultRect.top || 0;
            resultRect.right = resultRect.right || 0;
            resultRect.bottom = resultRect.bottom || 0;
            return correctBoundingRectWithStrokeWidth(resultRect, this._fullSettings["stroke-width"])
        }
        function baseAttr(attrs, inh) {
            var elem = this.element,
                settings = this._settings,
                fullSettings = this._fullSettings,
                value,
                key,
                params = {style: {}},
                appliedAttr;
            if (typeof attrs == "string") {
                if (attrs in settings)
                    return settings[attrs];
                if (attrs in DEFAULTS)
                    return DEFAULTS[attrs];
                return 0
            }
            for (key in attrs) {
                value = attrs[key];
                if (value === undefined)
                    continue;
                appliedAttr = fullSettings[key];
                !inh && (settings[key] = value);
                fullSettings[key] = value;
                if (INHERITABLE_PROPERTIES[key])
                    value = value === null ? this._parent && this._parent._fullSettings[key] || value : value;
                appliedAttr !== value && this.processAttr(elem, key, value, params)
            }
            this._applyTransformation(params);
            this.css(params.style);
            for (var i = 0; i < this._children.length; i++) {
                var elem = this._children[i];
                elem !== this._clipRect && elem.attr(extend(getInheritSettings(this._fullSettings), elem._settings), true);
                elem._applyStyleSheet()
            }
            !inh && this._applyStyleSheet();
            return this
        }
        function vmlAttr(attrs) {
            var elem = this.element,
                result = baseAttr.apply(this, arguments);
            for (var i = 0; i < elem.childNodes.length; i++) {
                elem.childNodes[i].xmlns = 'urn:schemas-microsoft-com:vml';
                elem.childNodes[i].style.behavior = "url(#default#VML)";
                elem.childNodes[i].style.display = "inline-block"
            }
            return result
        }
        function processVmlAttr(element, attr, value, params) {
            switch (attr) {
                case"stroke":
                    value = value || "none";
                    element.stroked = value === 'none' ? 'f' : 't';
                    attr += "color";
                    break;
                case"fill":
                    value = value || "none";
                    element.filled = value === 'none' ? 'f' : 't';
                    attr += "color";
                    break;
                case"stroke-width":
                    attr = "strokeweight";
                    value = value + 'px';
                    break;
                case"stroke-linejoin":
                    element.stroke.joinstyle = value;
                    return;
                case"stroke-linecap":
                    element.stroke.endcap = value === "butt" ? "flat" : value;
                    return;
                case"opacity":
                    value = adjustOpacityValue(value);
                    element.fill.opacity = value;
                    element.stroke.opacity = value;
                    return;
                case"fill-opacity":
                    element.fill.opacity = adjustOpacityValue(value);
                    return;
                case"stroke-opacity":
                    element.stroke.opacity = adjustOpacityValue(value);
                    return;
                case"dashStyle":
                    if (value === null)
                        element.stroke[attr] = "";
                    else {
                        value = value.toLowerCase();
                        if (value === "solid" || value === "none")
                            value = "";
                        else
                            value = value.replace(/longdash/g, "8,3,").replace(/dash/g, "4,3,").replace(/dot/g, "1,3,").replace(/,$/, "");
                        element.stroke[attr] = value
                    }
                    return;
                case"d":
                    attr = "path";
                    value = (value + '').toLowerCase().replace("z", "x e").replace(/([.]\d+)/g, "");
                    break;
                case"href":
                    attr = "src";
                    break;
                case"width":
                case"height":
                case"visibility":
                    params.style[attr] = isDefined(value) ? value : "";
                    return;
                case"class":
                    attr += "Name";
                    break;
                case"translateX":
                case"translateY":
                case"rotate":
                case"rotateX":
                case"rotateY":
                case"scale":
                case"scaleX":
                case"scaleY":
                case"x":
                case"y":
                    return
            }
            element[attr] = value
        }
        function adjustOpacityValue(value) {
            return value >= 0.002 ? value : value === null ? 1 : 0.002
        }
        function createElement(tagName) {
            var element = document.createElement(tagName);
            return documentFragment.appendChild(element)
        }
        var VmlElement = function() {
                this.ctor.apply(this, arguments)
            };
        function processAttr(element, attr, value, params) {
            if (!INHERITABLE_PROPERTIES[attr])
                if (attr === "visibility")
                    params.style[attr] = isDefined(value) ? value : "";
                else if (attr === "width" || attr === "height")
                    params.style[attr] = value;
                else if (attr === "clipId")
                    this.applyClipID(value);
                else if (attr === "translateX" || attr === "translateY" || attr === "x" || attr === "y")
                    return;
                else if (attr === "class")
                    element.className = value;
                else
                    element[attr] = value
        }
        var elementMixin = {
                div: {
                    processAttr: processAttr,
                    attr: baseAttr,
                    _applyTransformation: function(params) {
                        var style = params.style,
                            settings = this._settings,
                            fullSettings = this._fullSettings;
                        if (fullSettings.rotate) {
                            fullSettings.rotateX = fullSettings.rotateX || 0;
                            fullSettings.rotateY = fullSettings.rotateY || 0
                        }
                        style.left = (settings.x || 0) + (settings.translateX || 0);
                        style.top = (settings.y || 0) + (settings.translateY || 0)
                    },
                    _getBBox: function() {
                        var left = Infinity,
                            top = Infinity,
                            right = -Infinity,
                            bottom = -Infinity,
                            i = 0,
                            child,
                            children = this._children,
                            translateX,
                            translateY,
                            childBBox,
                            childSettings;
                        if (!children.length)
                            left = top = bottom = right = 0;
                        else
                            for (; i < children.length; i++) {
                                child = children[i];
                                if (child === this._clipRect)
                                    continue;
                                translateX = child._fullSettings.translateX || 0;
                                translateY = child._fullSettings.translateY || 0;
                                childSettings = child._fullSettings;
                                childBBox = child._getBBox();
                                left = mathMin(left, childBBox.left + translateX);
                                right = mathMax(right, childBBox.right + translateX);
                                top = mathMin(top, childBBox.top + translateY);
                                bottom = mathMax(bottom, childBBox.bottom + translateY)
                            }
                        return {
                                left: left,
                                right: right,
                                top: top,
                                bottom: bottom
                            }
                    },
                    defaultAttrs: {},
                    defaultStyle: {position: "absolute"}
                },
                shape: {
                    defaultAttrs: extend({
                        coordsize: "1,1",
                        "stroke-linejoin": "miter"
                    }, DEFAULT_ATTRS),
                    defaultStyle: extend({
                        width: 1,
                        height: 1
                    }, DEFAULT_STYLE),
                    _getBBox: shapeBBox
                },
                image: {processAttr: function(element, attr, value, params) {
                        if (attr === "fill" || attr == "stroke")
                            return;
                        processVmlAttr.call(this, element, attr, value, params)
                    }},
                oval: {
                    processAttr: function(element, attr, value, params) {
                        if (attr === "cx" || attr === "cy")
                            attr = attr[1];
                        else if (attr === "r") {
                            value *= 2;
                            processVmlAttr.call(this, element, "width", value, params);
                            attr = "height"
                        }
                        else if (attr == "x" || attr === "y")
                            return;
                        processVmlAttr.call(this, element, attr, value, params)
                    },
                    _getBBox: function() {
                        var element = this.element,
                            settings = this._fullSettings,
                            x = settings.cx || 0,
                            y = settings.cy || 0,
                            r = settings.r || 0;
                        return correctBoundingRectWithStrokeWidth({
                                left: x - r,
                                top: y - r,
                                right: x + r,
                                bottom: y + r
                            }, settings["stroke-width"] || 1)
                    }
                },
                span: {
                    defaultAttrs: {},
                    defaultStyle: {
                        position: 'absolute',
                        whiteSpace: 'nowrap'
                    },
                    processAttr: function(element, attr, value, params) {
                        if (attr === "text") {
                            value = isDefined(value) ? value.toString().replace(/\r/g, "").replace(/\n/g, "<br/>") : '';
                            element.innerHTML = value;
                            this.css({filter: ""});
                            this._bbox = null
                        }
                        else
                            processAttr.apply(this, arguments)
                    },
                    attr: baseAttr,
                    _applyTransformation: function(params) {
                        var that = this,
                            style = params.style,
                            settings = that._fullSettings,
                            x = isDefined(settings.x) ? settings.x : 0,
                            y = isDefined(settings.y) ? settings.y : 0,
                            textHeight = that.element.offsetHeight,
                            bbox = that._bbox || that.element.getBoundingClientRect(),
                            textWidth = bbox.right - bbox.left,
                            textHeight = bbox.bottom - bbox.top,
                            rotateAngle = settings.rotate,
                            cos = 1,
                            sin = 0,
                            rotateX = isDefined(settings.rotateX) ? settings.rotateX : x,
                            rotateY = isDefined(settings.rotateY) ? settings.rotateY : y,
                            radianAngle,
                            marginLeft = 0,
                            marginTop = 0,
                            fontHeightOffset = textHeight * FONT_HEIGHT_OFFSET_K,
                            filter = "",
                            alignMultiplier = {
                                center: 0.5,
                                right: 1
                            }[settings.align],
                            opacity = this._styles.opacity || settings.opacity || settings["fill-opacity"];
                        if (textHeight && textWidth) {
                            if (rotateAngle) {
                                radianAngle = rotateAngle * Math.PI / 180.0;
                                cos = mathCos(radianAngle);
                                sin = mathSin(radianAngle);
                                marginLeft = (x - rotateX) * cos - (y - rotateY) * sin + rotateX - x;
                                marginTop = (x - rotateX) * sin + (y - rotateY) * cos + rotateY - y;
                                filter = 'progid:DXImageTransform.Microsoft.Matrix(sizingMethod="auto expand", M11 = ' + cos.toFixed(5) + ', M12 = ' + (-sin).toFixed(5) + ', M21 = ' + sin.toFixed(5) + ', M22 = ' + cos.toFixed(5) + ')'
                            }
                            if (rotateAngle < 90) {
                                marginTop -= fontHeightOffset * cos;
                                marginLeft -= (textHeight - fontHeightOffset) * sin
                            }
                            else if (rotateAngle < 180) {
                                marginTop += (textHeight - fontHeightOffset) * cos;
                                marginLeft += textWidth * cos - (textHeight - fontHeightOffset) * sin
                            }
                            else if (rotateAngle < 270) {
                                marginTop += (textHeight - fontHeightOffset) * cos + textWidth * sin;
                                marginLeft += textWidth * cos + fontHeightOffset * sin
                            }
                            else {
                                marginTop += textWidth * sin - fontHeightOffset * cos;
                                marginLeft += fontHeightOffset * sin
                            }
                            if (rotateAngle && this.renderer.rtl)
                                marginLeft -= textWidth - (textHeight * Math.abs(sin) + textWidth * Math.abs(cos));
                            if (alignMultiplier) {
                                marginLeft -= textWidth * alignMultiplier * cos;
                                marginTop -= textWidth * alignMultiplier * sin
                            }
                            if (isDefined(opacity))
                                filter += " progid:DXImageTransform.Microsoft.Alpha(Opacity=" + opacity * 100 + ")";
                            x += marginLeft;
                            y += marginTop;
                            this._bbox = bbox;
                            style.filter = (style.filter || "") + filter;
                            style.left = x + (settings.translateX || 0);
                            style.top = y + (settings.translateY || 0)
                        }
                    },
                    _getBBox: function textBBox() {
                        var element = this.element,
                            settings = this._fullSettings,
                            parentRect = (element.parentNode && element.parentNode.getBoundingClientRect ? element.parentNode : this.renderer.root.element).getBoundingClientRect(),
                            boundingRect = element.getBoundingClientRect(),
                            left = boundingRect.left - (settings.translateX || 0) - parentRect.left,
                            top = boundingRect.top - (settings.translateY || 0) - parentRect.top;
                        return {
                                left: left,
                                top: top,
                                right: left + element.offsetWidth,
                                bottom: top + element.offsetHeight
                            }
                    }
                }
            };
        extend(VmlElement.prototype, baseElementPrototype);
        extend(VmlElement.prototype, {
            defaultStyle: DEFAULT_STYLE,
            defaultAttrs: DEFAULT_ATTRS,
            ctor: function(renderer, tagName, type) {
                var that = this,
                    tagPrefix = '<';
                that.renderer = renderer;
                that.type = type;
                that._children = [];
                that._settings = {};
                that._fullSettings = {};
                that._styles = {};
                if (tagName !== "div" && tagName !== "span")
                    tagPrefix = "<vml:";
                if (tagName === "shape")
                    if (that.type === "arc")
                        that.attr = arcAttr;
                    else
                        that.attr = pathAttr;
                else if (tagName === "rect")
                    that.attr = rectAttr;
                extend(that, elementMixin[tagName]);
                that.element = createElement(tagPrefix + tagName + "/>");
                that.css(that.defaultStyle).attr(that.defaultAttrs)
            },
            dispose: function() {
                this.element && this.remove();
                return null
            },
            attr: vmlAttr,
            processAttr: processVmlAttr,
            css: function(css) {
                var elem = this.element,
                    value,
                    appliedValue,
                    key;
                for (key in css) {
                    appliedValue = this._styles[key];
                    value = css[key];
                    if (!isDefined(value))
                        continue;
                    this._styles[key] = value;
                    if (appliedValue === value)
                        continue;
                    if (key === "fill")
                        key = "color";
                    else if (key === "font-size") {
                        key = "fontSize";
                        if (typeof value === "number")
                            value += "px"
                    }
                    else if (key === "font-weight")
                        key = "fontWeight";
                    else if (key === "opacity")
                        continue;
                    try {
                        elem.style[key] = value
                    }
                    catch(_) {
                        continue
                    }
                }
                return this
            },
            applyClipID: function(id) {
                var clipRect,
                    cssValue,
                    renderer = this.renderer;
                clipRect = renderer.getClipRect(id);
                if (clipRect) {
                    cssValue = clipRect.getValue();
                    clipRect.addElement(this)
                }
                else
                    cssValue = "rect(-9999px 9999px 9999px -9999px)";
                this._clipRect = this._clipRect || renderer.rect(0, 0, 0, 0).attr({
                    "class": "dxc-vml-clip",
                    fill: "none",
                    opacity: 0.001
                });
                this._clipRect.attr({
                    width: renderer.root.attr("width"),
                    height: renderer.root.attr("height")
                });
                this.css({
                    clip: cssValue,
                    width: renderer.root.attr("width"),
                    height: renderer.root.attr("height")
                })
            },
            append: function(parent) {
                parent = parent || this.renderer.root;
                (parent.element || parent).appendChild(this.element);
                if (parent._children) {
                    this._parent = parent;
                    if (inArray(parent._children, this) === -1)
                        parent._children.push(this);
                    this.attr(extend(getInheritSettings(parent._fullSettings), this._settings), true)
                }
                this._applyStyleSheet();
                if (parent._clipRect && this !== parent._clipRect)
                    parent._clipRect.append(parent);
                return this
            },
            _applyTransformation: function(params) {
                var that = this,
                    style = params.style,
                    element = that.element,
                    settings = that._fullSettings,
                    x = that.type !== "arc" ? settings.x || settings.cx - settings.r || 0 : 0,
                    y = that.type !== "arc" ? settings.y || settings.cy - settings.r || 0 : 0,
                    width = settings.width || 0,
                    height = settings.height || 0,
                    rotateAngle = settings.rotate;
                if (settings.rotate) {
                    var radianAngle = settings.rotate * Math.PI / 180.0,
                        rotateX = isDefined(settings.rotateX) ? settings.rotateX : x,
                        rotateY = isDefined(settings.rotateY) ? settings.rotateY : y,
                        rx = x + (settings.width || 0 || parseInt(element.style.width || 0)) / 2,
                        ry = y + (settings.height || 0 || parseInt(element.style.height || 0)) / 2,
                        cos = mathCos(radianAngle),
                        sin = mathSin(radianAngle),
                        marginLeft = (rx - rotateX) * cos - (ry - rotateY) * sin + rotateX - rx,
                        marginTop = (rx - rotateX) * sin + (ry - rotateY) * cos + rotateY - ry;
                    x += marginLeft;
                    y += marginTop;
                    style.rotation = settings.rotate
                }
                style.left = x + (settings.translateX || 0);
                style.top = y + (settings.translateY || 0)
            },
            remove: function() {
                var that = this,
                    parent = that._parent;
                if (parent)
                    parent._children.splice(inArray(parent._children, that), 1);
                that._parent = null;
                return baseElementPrototype.remove.call(that)
            },
            clear: function() {
                this._children = [];
                return baseElementPrototype.clear.call(this)
            },
            getBBox: function() {
                var clientRect = this._getBBox(),
                    x = clientRect.left,
                    y = clientRect.top,
                    width = clientRect.right - x,
                    height = clientRect.bottom - y;
                return {
                        x: x,
                        y: y,
                        width: width,
                        height: height,
                        isEmpty: !x && !y && !width && !height
                    }
            },
            _getBBox: function() {
                var element = this.element,
                    settings = this._fullSettings,
                    x = settings.x || 0,
                    y = settings.y || 0,
                    width = parseInt(element.style.width || 0),
                    height = parseInt(element.style.height || 0);
                return correctBoundingRectWithStrokeWidth({
                        left: x,
                        top: y,
                        right: x + width,
                        bottom: y + height
                    }, settings["stroke-width"] || 1)
            },
            _applyStyleSheet: function() {
                if (this._useCSSTheme)
                    this.attr(getInheritSettings(this.element.currentStyle), true)
            },
            setTitle: function(text) {
                this.element.setAttribute('title', text)
            }
        });
        var ClipRect = function(renderer, id) {
                this.ctor.apply(this, arguments)
            };
        extend(ClipRect.prototype, VmlElement.prototype);
        extend(ClipRect.prototype, {
            ctor: function(renderer, id) {
                this._settings = this._fullSettings = {};
                this.renderer = renderer;
                this._children = [];
                this._elements = [];
                this.id = id
            },
            attr: function() {
                var result = baseAttr.apply(this, arguments),
                    elements = this._elements.slice(),
                    element,
                    i;
                if (result === this)
                    for (i = 0; i < elements.length; i++) {
                        element = elements[i];
                        if (element._fullSettings.clipId === this.id)
                            elements[i].applyClipID(this.id);
                        else
                            this.removeElement(element)
                    }
                return result
            },
            processAttr: stub,
            _applyTransformation: stub,
            append: stubReturnedThis,
            dispose: function() {
                this._elements = null;
                this.renderer.removeClipRect(this.id);
                return this
            },
            addElement: function(element) {
                var hasElement = false,
                    elements = this._elements;
                if (inArray(elements, element) == -1)
                    elements.push(element)
            },
            removeElement: function(element) {
                var elements = this._elements,
                    index = inArray(this._elements, element);
                index > -1 && this._elements.splice(index, 1)
            },
            getValue: function() {
                var settings = this._settings,
                    left = (settings.x || 0) + (settings.translateX || 0),
                    top = (settings.y || 0) + (settings.translateY || 0);
                return "rect(" + top + "px, " + (left + (settings.width || 0)) + "px, " + (top + (settings.height || 0)) + "px, " + left + "px)"
            },
            css: stubReturnedThis,
            remove: stubReturnedThis
        });
        var VmlRenderer = function() {
                this.ctor.apply(this, arguments)
            };
        extend(VmlRenderer.prototype, rendererNS.SvgRenderer.prototype);
        extend(VmlRenderer.prototype, {
            _createRoot: function() {
                return this._createElement("div", {
                        "class": this.cssClass,
                        fill: "none",
                        stroke: "none",
                        "stroke-width": 0
                    }).css({
                        position: "relative",
                        display: "inline-block",
                        overflow: "hidden",
                        direction: this.rtl ? "rtl" : "ltr"
                    })
            },
            _init: function(options) {
                this._clipRects = [];
                this.animOptions = {enabled: false};
                this.defs = {
                    clear: stubReturnedThis,
                    remove: stubReturnedThis,
                    append: stubReturnedThis,
                    dispose: stubReturnedThis
                }
            },
            _createElement: function(tagName, attr, type) {
                tagName = svgToVmlConv[tagName] || tagName;
                var elem = new rendererNS.VmlElement(this, tagName, type);
                attr && elem.attr(attr);
                return elem
            },
            dispose: function() {
                this.root.dispose();
                return null
            },
            shadowFilter: function() {
                return {
                        ref: null,
                        append: stubReturnedThis,
                        dispose: stubReturnedThis,
                        attr: stubReturnedThis,
                        css: stubReturnedThis
                    }
            },
            clipRect: function(x, y, width, height) {
                var clipRects = this._clipRects,
                    id = clipRects.length,
                    clipRect = new ClipRect(this, id).attr({
                        x: x || 0,
                        y: y || 0,
                        width: width || 0,
                        height: height || 0
                    });
                clipRects.push(clipRect);
                return clipRect
            },
            getClipRect: function(id) {
                return this._clipRects[id]
            },
            removeClipRect: function(id) {
                delete this._clipRects[id]
            },
            pattern: function(color) {
                return {
                        id: color,
                        append: stubReturnedThis,
                        remove: stubReturnedThis,
                        dispose: stubReturnedThis
                    }
            },
            image: function(x, y, w, h, href, location) {
                var image = this._createElement("image", {
                        x: x || 0,
                        y: y || 0,
                        width: w || 0,
                        height: h || 0,
                        location: location,
                        href: href
                    });
                return image
            },
            updateAnimationOptions: stubReturnedThis,
            stopAllAnimations: stubReturnedThis,
            svg: function() {
                return ""
            }
        });
        rendererNS.VmlRenderer = VmlRenderer;
        rendererNS.VmlElement = VmlElement;
        function buildPath(points) {
            var i = 0,
                ii = points.length,
                list = [];
            for (; i < ii; )
                list.push('l', points[i++].toFixed(0), points[i++].toFixed(0));
            if (ii) {
                list[0] = 'm';
                list.push('x e');
                list = list.join(' ')
            }
            else
                list = '';
            return list
        }
        function processCircleSettings(x, y, size) {
            return {
                    cx: x,
                    cy: y,
                    r: size / 2
                }
        }
        rendererNS._vmlBuildPath = buildPath;
        rendererNS._vmlProcessCircleSettings = processCircleSettings;
        rendererNS._VmlClipRect = ClipRect
    })(DevExpress, document);
    /*! Module viz-core, file animation.js */
    (function(DX) {
        var rendererNS = DX.viz.renderers,
            noop = function(){},
            easingFunctions = {
                easeOutCubic: function(pos, start, end) {
                    return pos === 1 ? end : (1 - Math.pow(1 - pos, 3)) * (end - start) + +start
                },
                linear: function(pos, start, end) {
                    return pos === 1 ? end : pos * (end - start) + +start
                }
            },
            FPS = 1000 / 60,
            requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
                setTimeout(callback, FPS)
            };
        rendererNS.easingFunctions = easingFunctions;
        rendererNS.animationSvgStep = {
            segments: function(elem, params, progress, easing, currentParams) {
                var from = params.from,
                    to = params.to,
                    curSeg,
                    seg,
                    i,
                    j,
                    segments = [];
                for (i = 0; i < from.length; i++) {
                    curSeg = from[i];
                    seg = [curSeg[0]];
                    if (curSeg.length > 1)
                        for (j = 1; j < curSeg.length; j++)
                            seg.push(easing(progress, curSeg[j], to[i][j]));
                    segments.push(seg)
                }
                currentParams.segments = params.end && progress === 1 ? params.end : segments;
                elem.attr({segments: segments})
            },
            arc: function(elem, params, progress, easing) {
                var from = params.from,
                    to = params.to,
                    current = {};
                for (var i in from)
                    current[i] = easing(progress, from[i], to[i]);
                elem.attr(current)
            },
            transform: function(elem, params, progress, easing, currentParams) {
                var from = params.from,
                    to = params.to,
                    current = {};
                for (var i in from)
                    current[i] = currentParams[i] = easing(progress, from[i], to[i]);
                elem.attr(current)
            },
            base: function(elem, params, progress, easing, currentParams, attributeName) {
                var obj = {};
                obj[attributeName] = currentParams[attributeName] = easing(progress, params.from, params.to);
                elem.attr(obj)
            },
            _: noop,
            complete: function(element, currentSettings) {
                element.attr(currentSettings)
            }
        };
        function Animation(element, params, options) {
            this.ctor.apply(this, arguments)
        }
        Animation.prototype = {
            ctor: function(element, params, options) {
                var that = this;
                that._progress = 0;
                that.element = element;
                that.params = params;
                that.options = options;
                that.duration = options.partitionDuration ? options.duration * options.partitionDuration : options.duration;
                that._animateStep = options.animateStep || rendererNS.animationSvgStep;
                that._easing = easingFunctions[options.easing] || easingFunctions["easeOutCubic"];
                that._currentParams = {};
                that.tick = that._start
            },
            _calcProgress: function(now) {
                return Math.min(1, (now - this._startTime) / this.duration)
            },
            _step: function(now) {
                var that = this,
                    animateStep = that._animateStep,
                    attrName;
                that._progress = that._calcProgress(now);
                for (attrName in that.params) {
                    var anim = animateStep[attrName] || animateStep.base;
                    anim(that.element, that.params[attrName], that._progress, that._easing, that._currentParams, attrName)
                }
                that.options.step && that.options.step(that._easing(that._progress, 0, 1), that._progress);
                if (that._progress === 1)
                    return that.stop();
                return true
            },
            _start: function(now) {
                this._startTime = now;
                this.tick = this._step;
                return true
            },
            _end: function(disableComplete) {
                var that = this;
                that.stop = noop;
                that.tick = noop;
                that._animateStep.complete && that._animateStep.complete(that.element, that._currentParams);
                that.options.complete && !disableComplete && that.options.complete()
            },
            tick: function(now) {
                return true
            },
            stop: function(breakAnimation, disableComplete) {
                var that = this,
                    options = that.options;
                if (!breakAnimation && options.repeatCount && --options.repeatCount > 0) {
                    that.tick = that._start;
                    return true
                }
                else
                    that._end(disableComplete)
            }
        };
        function AnimationController() {
            this.ctor.apply(this, arguments)
        }
        rendererNS.AnimationController = AnimationController;
        AnimationController.prototype = {
            ctor: function(element) {
                var that = this;
                that.requestAnimationFrame = requestAnimationFrame;
                that._animationCount = 0;
                that._timerId = null;
                that._animations = {};
                that.element = element
            },
            _loop: function() {
                var that = this,
                    animations = that._animations,
                    activeAnimation = 0,
                    now = (new Date).getTime(),
                    an;
                for (an in animations) {
                    if (!animations[an].tick(now))
                        delete animations[an];
                    activeAnimation++
                }
                if (activeAnimation === 0) {
                    that.stop();
                    return
                }
                that._timerId = that.requestAnimationFrame.call(null, function() {
                    that._loop()
                }, that.element)
            },
            addAnimation: function(animation) {
                var that = this;
                that._animations[that._animationCount++] = animation;
                if (!that._timerId) {
                    clearTimeout(that._startDelay);
                    that._startDelay = setTimeout(function() {
                        that._timerId = 1;
                        that._loop()
                    }, 0)
                }
            },
            animateElement: function(elem, params, options) {
                if (elem && params && options) {
                    elem.animation && elem.animation.stop(true);
                    this.addAnimation(elem.animation = new Animation(elem, params, options))
                }
            },
            dispose: function() {
                this.stop();
                this.element = null
            },
            stop: function() {
                var that = this;
                that._animations = {};
                that._animationCount = 0;
                clearTimeout(that._startDelay);
                that._timerId = null
            },
            lock: function() {
                var an,
                    animations = this._animations;
                for (an in animations)
                    animations[an].stop(true, true);
                this.stop()
            }
        };
        rendererNS.Animation = Animation;
        rendererNS.noop = noop
    })(DevExpress);
    /*! Module viz-core, file renderer.js */
    (function($, DX, document) {
        var renderers = DX.viz.renderers,
            browser = DX.browser;
        function isSvg() {
            return !(browser.msie && browser.version < 9) || !!document.createElementNS && !!document.createElementNS('http://www.w3.org/2000/svg', "svg").createSVGRect
        }
        if (!isSvg()) {
            if (document.namespaces && !document.namespaces.vml) {
                document.namespaces.add('vml', 'urn:schemas-microsoft-com:vml');
                document.createStyleSheet().cssText = 'vml\\:* { behavior:url(#default#VML); display: inline-block; } '
            }
            renderers.Renderer = renderers.VmlRenderer;
            renderers.buildPath = renderers._vmlBuildPath;
            renderers.processCircleSettings = renderers._vmlProcessCircleSettings
        }
        else {
            renderers.Renderer = renderers.SvgRenderer;
            renderers.buildPath = renderers._svgBuildPath;
            renderers.processCircleSettings = renderers._svgProcessCircleSettings
        }
        renderers.isSvg = isSvg
    })(jQuery, DevExpress, document);
    /*! Module viz-core, file seriesConsts.js */
    (function(DX) {
        DX.viz.core.series = DX.viz.core.series || {};
        DX.viz.core.series.helpers = DX.viz.core.series.helpers || {};
        DX.viz.core.series.helpers.consts = {
            events: {
                mouseover: "mouseover",
                mouseout: "mouseout",
                mousemove: "mousemove",
                touchstart: "touchstart",
                touchmove: "touchmove",
                touchend: "touchend",
                mousedown: "mousedown",
                mouseup: "mouseup",
                click: "click",
                selectSeries: "selectseries",
                deselectSeries: "deselectseries",
                selectPoint: "selectpoint",
                deselectPoint: "deselectpoint",
                showPointTooltip: "showpointtooltip",
                hidePointTooltip: "hidepointtooltip"
            },
            states: {
                hover: "hover",
                normal: "normal",
                selected: "selected",
                normalMark: 0,
                hoverMark: 1,
                selectedMark: 2
            },
            animations: {
                showDuration: {duration: 400},
                hideGroup: {opacity: 0.0001},
                showGroup: {opacity: 1}
            },
            pieLabelIndent: 30
        }
    })(DevExpress);
    /*! Module viz-core, file seriesFamily.js */
    (function($, DX, undefined) {
        var utils = DX.utils,
            _round = Math.round,
            _abs = Math.abs,
            _pow = Math.pow;
        DX.viz.core.series.helpers.SeriesFamily = DX.Class.inherit(function() {
            var ctor = function(options) {
                    var debug = DX.utils.debug;
                    debug.assert(options.type, "type was not passed or empty");
                    var that = this,
                        stubFunction = $.noop;
                    $.extend(that, options);
                    that.type = that.type.toLowerCase();
                    that.series = [];
                    switch (that.type) {
                        case"bar":
                            that.adjustSeriesDimensions = adjustBarSeriesDimensions;
                            that.adjustSeriesValues = stubFunction;
                            that.updateSeriesValues = updateBarSeriesValues;
                            break;
                        case"rangebar":
                            that.adjustSeriesDimensions = adjustBarSeriesDimensions;
                            that.adjustSeriesValues = stubFunction;
                            that.updateSeriesValues = stubFunction;
                            break;
                        case"fullstackedbar":
                            that.fullStacked = true;
                            that.adjustSeriesDimensions = adjustStackedBarSeriesDimensions;
                            that.adjustSeriesValues = adjustStackedSeriesValues;
                            that.updateSeriesValues = updateStackedSeriesValues;
                            break;
                        case"stackedbar":
                            that.adjustSeriesDimensions = adjustStackedBarSeriesDimensions;
                            that.adjustSeriesValues = adjustStackedSeriesValues;
                            that.updateSeriesValues = updateStackedSeriesValues;
                            break;
                        case"fullstackedarea":
                        case"fullstackedline":
                        case"fullstackedspline":
                        case"fullstackedsplinearea":
                            that.fullStacked = true;
                            that.adjustSeriesDimensions = stubFunction;
                            that.adjustSeriesValues = adjustStackedSeriesValues;
                            that.updateSeriesValues = stubFunction;
                            break;
                        case"stackedarea":
                        case"stackedsplinearea":
                        case"stackedline":
                        case"stackedspline":
                            that.adjustSeriesDimensions = stubFunction;
                            that.adjustSeriesValues = adjustStackedSeriesValues;
                            that.updateSeriesValues = stubFunction;
                            break;
                        case"candlestick":
                        case"stock":
                            that.adjustSeriesDimensions = adjustCandlestickSeriesDimensions;
                            that.adjustSeriesValues = stubFunction;
                            that.updateSeriesValues = stubFunction;
                            break;
                        case"bubble":
                            that.adjustSeriesDimensions = adjustBubbleSeriesDimensions;
                            that.adjustSeriesValues = stubFunction;
                            that.updateSeriesValues = stubFunction;
                            break;
                        default:
                            that.adjustSeriesDimensions = stubFunction;
                            that.adjustSeriesValues = stubFunction;
                            that.updateSeriesValues = stubFunction;
                            break
                    }
                };
            var dispose = function() {
                    this.series = null;
                    this.translators = null
                };
            var add = function(series) {
                    var that = this,
                        singleSeries,
                        i;
                    if (!$.isArray(series))
                        series = [series];
                    for (i = 0; i < series.length; i++) {
                        singleSeries = series[i];
                        if (singleSeries.type.toLowerCase() === that.type)
                            that.series.push(singleSeries)
                    }
                };
            var adjustBarSeriesDimensionsCore = function(series, interval, stackCount, equalBarWidth, seriesStackIndexCallback) {
                    var spacing,
                        width,
                        maxWidth,
                        middleIndex,
                        stackIndex,
                        i,
                        point,
                        points,
                        seriesOffset,
                        stackName,
                        argumentsKeeper = {},
                        stackKeepers = {},
                        stacksWithArgument,
                        count;
                    if (equalBarWidth) {
                        width = equalBarWidth.width && equalBarWidth.width < 0 ? 0 : equalBarWidth.width;
                        spacing = equalBarWidth.spacing && equalBarWidth.spacing < 0 ? 0 : equalBarWidth.spacing;
                        if (width && !spacing)
                            if (stackCount > 1) {
                                spacing = _round((interval * 0.7 - width * stackCount) / (stackCount - 1));
                                if (spacing < 1)
                                    spacing = 1
                            }
                            else
                                spacing = 0;
                        else if (spacing && !width) {
                            width = _round((interval * 0.7 - spacing * (stackCount - 1)) / stackCount);
                            if (width < 2)
                                width = 2
                        }
                        else if (!spacing && !width) {
                            if (stackCount > 1) {
                                spacing = _round(interval * 0.7 / stackCount * 0.2);
                                if (spacing < 1)
                                    spacing = 1
                            }
                            else
                                spacing = 0;
                            width = _round((interval * 0.7 - spacing * (stackCount - 1)) / stackCount);
                            if (width < 2)
                                width = 2
                        }
                        if (width * stackCount + spacing * (stackCount - 1) > interval) {
                            spacing = _round((interval * 0.7 - width * stackCount) / (stackCount - 1));
                            if (spacing < 1) {
                                spacing = 1;
                                maxWidth = _round((interval * 0.7 - spacing * (stackCount - 1)) / stackCount)
                            }
                        }
                        middleIndex = stackCount / 2;
                        for (i = 0; i < series.length; i++) {
                            stackIndex = seriesStackIndexCallback(i);
                            points = series[i].getPoints();
                            seriesOffset = (stackIndex - middleIndex + 0.5) * (maxWidth || width) - (middleIndex - stackIndex - 0.5) * spacing;
                            $.each(points, function(_, point) {
                                point.correctCoordinates({
                                    width: width,
                                    offset: seriesOffset
                                })
                            })
                        }
                    }
                    else {
                        $.each(series, function(i, singleSeries) {
                            stackName = singleSeries.getStackName && singleSeries.getStackName();
                            stackName = stackName || i.toString();
                            if (!stackKeepers[stackName])
                                stackKeepers[stackName] = [];
                            stackKeepers[stackName].push(singleSeries)
                        });
                        $.each(series, function(i, singleSeries) {
                            $.each(singleSeries.getPoints(), function(_, point) {
                                var argument = point.argument;
                                if (!argumentsKeeper.hasOwnProperty(argument))
                                    argumentsKeeper[argument.valueOf()] = 1
                            })
                        });
                        for (var argument in argumentsKeeper) {
                            if (!argumentsKeeper.hasOwnProperty(argument))
                                continue;
                            stacksWithArgument = [];
                            $.each(stackKeepers, function(stackName, seriesInStack) {
                                $.each(seriesInStack, function(i, singleSeries) {
                                    point = singleSeries.getPointByArg(argument);
                                    if (point && point.value) {
                                        stacksWithArgument.push(stackName);
                                        return false
                                    }
                                })
                            });
                            count = stacksWithArgument.length;
                            spacing = _round(interval * 0.7 / count * 0.2);
                            if (spacing < 1)
                                spacing = 1;
                            width = _round((interval * 0.7 - spacing * (count - 1)) / count);
                            if (width < 2)
                                width = 2;
                            middleIndex = count / 2;
                            $.each(stackKeepers, function(stackName, seriesInStack) {
                                stackIndex = $.inArray(stackName, stacksWithArgument);
                                if (stackIndex === -1)
                                    return;
                                seriesOffset = (stackIndex - middleIndex + 0.5) * width - (middleIndex - stackIndex - 0.5) * spacing;
                                $.each(seriesInStack, function(i, singleSeries) {
                                    var point = singleSeries.getPointByArg(argument);
                                    if (point && point.value)
                                        point.correctCoordinates({
                                            width: width,
                                            offset: seriesOffset
                                        })
                                })
                            })
                        }
                    }
                };
            var getVisibleSeries = function(that) {
                    return $.map(that.series, function(s) {
                            return s.isVisible() ? s : null
                        })
                };
            var adjustBarSeriesDimensions = function(translators) {
                    var debug = DX.utils.debug;
                    debug.assert(translators, "translator was not passed or empty");
                    var that = this,
                        equalBarWidth = that.equalBarWidth,
                        series = getVisibleSeries(that);
                    adjustBarSeriesDimensionsCore(series, getInterval(that, translators), series.length, equalBarWidth, function(seriesIndex) {
                        return seriesIndex
                    })
                };
            var adjustStackedBarSeriesDimensions = function(translators) {
                    var debug = DX.utils.debug;
                    debug.assert(translators, "translators was not passed or empty");
                    var that = this,
                        interval,
                        series = getVisibleSeries(that),
                        stackIndexes = {},
                        stackCount = 0,
                        equalBarWidth = that.equalBarWidth;
                    $.each(series, function() {
                        var stackName = this.getStackName();
                        if (!stackIndexes.hasOwnProperty(stackName))
                            stackIndexes[stackName] = stackCount++
                    });
                    adjustBarSeriesDimensionsCore(series, getInterval(that, translators), stackCount, equalBarWidth, function(seriesIndex) {
                        return stackIndexes[series[seriesIndex].getStackName()]
                    })
                };
            var adjustStackedSeriesValues = function() {
                    var that = this,
                        series = getVisibleSeries(that),
                        stackKeepers = {
                            positive: {},
                            negative: {}
                        },
                        holesStack = {
                            left: {},
                            right: {}
                        };
                    $.each(series, function(seriesIndex, singleSeries) {
                        var points = singleSeries.getPoints(),
                            hole = false;
                        singleSeries._prevSeries = series[seriesIndex - 1],
                        singleSeries.holes = $.extend(true, {}, holesStack);
                        $.each(points, function(index, point) {
                            var value = point.initialValue,
                                argument = point.argument.valueOf(),
                                stackName = singleSeries.getStackName(),
                                stacks = value >= 0 ? stackKeepers.positive : stackKeepers.negative,
                                currentStack;
                            stacks[stackName] = stacks[stackName] || {};
                            currentStack = stacks[stackName];
                            if (currentStack[argument]) {
                                point.correctValue(currentStack[argument]);
                                currentStack[argument] += value
                            }
                            else {
                                currentStack[argument] = value;
                                point.resetCorrection()
                            }
                            if (!point.hasValue()) {
                                var prevPoint = points[index - 1];
                                if (!hole && prevPoint && prevPoint.hasValue()) {
                                    argument = prevPoint.argument.valueOf();
                                    prevPoint._skipSetRightHole = true;
                                    holesStack.right[argument] = (holesStack.right[argument] || 0) + (prevPoint.value - (isFinite(prevPoint.minValue) ? prevPoint.minValue : 0))
                                }
                                hole = true
                            }
                            else if (hole) {
                                hole = false;
                                holesStack.left[argument] = (holesStack.left[argument] || 0) + (point.value - (isFinite(point.minValue) ? point.minValue : 0));
                                point._skipSetLeftHole = true
                            }
                        })
                    });
                    $.each(series, function(seriesIndex, singleSeries) {
                        var points = singleSeries.getPoints(),
                            holes = singleSeries.holes;
                        $.each(points, function(index, point) {
                            var argument = point.argument.valueOf(),
                                holeValue;
                            !point._skipSetLeftHole && point.setHole(holes.left[argument] || holesStack.left[argument] && 0, "left");
                            !point._skipSetRightHole && point.setHole(holes.right[argument] || holesStack.right[argument] && 0, "right");
                            point._skipSetLeftHole = null;
                            point._skipSetRightHole = null
                        })
                    });
                    setPercentStackedValues(series, stackKeepers, that.fullStacked, holesStack)
                };
            var setPercentStackedValues = function(series, stackKeepers, fullStacked, holeStack) {
                    $.each(series, function(_, singleSeries) {
                        var points = singleSeries.getPoints();
                        $.each(points, function(_, point) {
                            var argument = point.argument.valueOf(),
                                stackName = singleSeries.getStackName(),
                                valueType = point.value >= 0 ? "positive" : "negative",
                                currentStack;
                            stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};
                            currentStack = stackKeepers[valueType][stackName];
                            point.setPercentValue(currentStack[argument], fullStacked, holeStack.left[argument], holeStack.right[argument])
                        })
                    })
                };
            var updateStackedSeriesValues = function(translators) {
                    var that = this,
                        series = getVisibleSeries(that),
                        stackKeepers = {
                            positive: {},
                            negative: {}
                        };
                    $.each(series, function(_, singleSeries) {
                        var points = singleSeries.getPoints(),
                            minBarSize = singleSeries.getOptions().minBarSize,
                            minShownBusinessValue = minBarSize && translators.val.getMinBarSize(minBarSize);
                        $.each(points, function(index, point) {
                            var value = point.value,
                                minValue = point.minValue,
                                argument = point.argument,
                                updateValue,
                                pointSize,
                                stackName = singleSeries.getStackName ? singleSeries.getStackName() : "default",
                                valueType = value >= 0 ? "positive" : "negative",
                                currentStack;
                            currentStack = stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};
                            if (currentStack[argument.valueOf()]) {
                                minValue = utils.isNumber(minValue) ? minValue : 0,
                                pointSize = _abs(minValue - value);
                                if (minShownBusinessValue && pointSize < minShownBusinessValue)
                                    updateValue = minShownBusinessValue;
                                else
                                    updateValue = value - minValue;
                                points[index].minValue = currentStack[argument.valueOf()];
                                points[index].value = currentStack[argument.valueOf()] + updateValue;
                                currentStack[argument.valueOf()] += updateValue
                            }
                            else {
                                pointSize = value;
                                if (minShownBusinessValue && pointSize < minShownBusinessValue)
                                    updateValue = minShownBusinessValue;
                                else
                                    updateValue = value;
                                points[index].value = updateValue;
                                currentStack[argument.valueOf()] = updateValue
                            }
                        })
                    });
                    if (that.fullStacked)
                        updateFullStackedSeriesValues(series, stackKeepers)
                };
            var updateFullStackedSeriesValues = function(series, stackKeepers) {
                    $.each(series, function(_, singleSeries) {
                        var stackName = singleSeries.getStackName ? singleSeries.getStackName() : "default",
                            points = singleSeries.getPoints();
                        $.each(points, function(index, point) {
                            var value = point.value,
                                argument = point.argument,
                                valueType = value >= 0 ? "positive" : "negative",
                                currentStack;
                            stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};
                            currentStack = stackKeepers[valueType][stackName];
                            points[index].value = points[index].value / currentStack[argument.valueOf()] || 0;
                            if (DX.utils.isNumber(points[index].minValue))
                                points[index].minValue = points[index].minValue / currentStack[argument.valueOf()] || 0
                        })
                    })
                };
            var updateBarSeriesValues = function(translators) {
                    var that = this;
                    $.each(that.series, function(_, singleSeries) {
                        var points = singleSeries.getPoints(),
                            minBarSize = singleSeries.getOptions().minBarSize,
                            minShownBusinessValue = minBarSize && translators.val.getMinBarSize(minBarSize);
                        $.each(points, function(index, point) {
                            var value = point.value,
                                updateValue,
                                pointSize = _abs(value);
                            if (minShownBusinessValue && pointSize < minShownBusinessValue)
                                updateValue = value >= 0 ? minShownBusinessValue : -minShownBusinessValue;
                            else
                                updateValue = value;
                            points[index].value = updateValue
                        })
                    })
                };
            var adjustCandlestickSeriesDimensions = function(translators) {
                    var debug = DX.utils.debug;
                    debug.assert(translators, "translator was not passed or empty");
                    var that = this,
                        series = getVisibleSeries(that);
                    adjustBarSeriesDimensionsCore(series, getInterval(that, translators), series.length, true, function(seriesIndex) {
                        return seriesIndex
                    })
                };
            var getInterval = function(that, translators) {
                    var argTranslator = translators.arg;
                    return that.interval = argTranslator.getInterval()
                };
            var adjustBubbleSeriesDimensions = function(translators) {
                    var debug = DX.utils.debug;
                    debug.assert(translators, "translator was not passed or empty");
                    var that = this,
                        series = getVisibleSeries(that),
                        points,
                        i,
                        visibleAreaX = translators.arg.getCanvasVisibleArea(),
                        visibleAreaY = translators.val.getCanvasVisibleArea(),
                        min = Math.min(visibleAreaX.max - visibleAreaX.min, visibleAreaY.max - visibleAreaY.min),
                        minBubbleArea = _pow(that.minBubbleSize, 2),
                        maxBubbleArea = _pow(min * that.maxBubbleSize, 2),
                        equalBubbleSize = (min * that.maxBubbleSize + that.minBubbleSize) / 2,
                        minPointSize = Infinity,
                        maxPointSize = 0,
                        pointSize,
                        bubbleArea,
                        sizeProportion,
                        sizeDispersion,
                        areaDispersion;
                    for (i = 0; i < series.length; i++) {
                        points = series[i].getPoints();
                        $.each(points, function(_, point) {
                            maxPointSize = maxPointSize > point.size ? maxPointSize : point.size;
                            minPointSize = minPointSize < point.size ? minPointSize : point.size
                        })
                    }
                    sizeDispersion = maxPointSize - minPointSize;
                    areaDispersion = _abs(maxBubbleArea - minBubbleArea);
                    minPointSize = minPointSize < 0 ? 0 : minPointSize;
                    for (i = 0; i < series.length; i++) {
                        points = series[i].getPoints();
                        $.each(points, function(_, point) {
                            if (maxPointSize === minPointSize)
                                pointSize = _round(equalBubbleSize);
                            else {
                                sizeProportion = _abs(point.size - minPointSize) / sizeDispersion;
                                bubbleArea = areaDispersion * sizeProportion + minBubbleArea;
                                pointSize = _round(Math.sqrt(bubbleArea))
                            }
                            point.correctCoordinates(pointSize)
                        })
                    }
                };
            return {
                    ctor: ctor,
                    dispose: dispose,
                    add: add
                }
        }())
    })(jQuery, DevExpress);
    /*! Module viz-core, file baseSeries.js */
    (function($, DX) {
        var viz = DX.viz,
            core = viz.core,
            seriesNS = core.series,
            utils = DX.utils,
            _isDefined = utils.isDefined,
            _each = $.each,
            _extend = $.extend,
            _isEmptyObject = $.isEmptyObject,
            _Event = $.Event,
            _noop = $.noop,
            SELECTED_STATE = 2,
            HOVER_STATE = 1,
            NONE_MODE = "none",
            INCLUDE_POINTS = "includepoints",
            EXLUDE_POINTS = "excludepoints",
            ALL_SERIES_POINTS_MODE = "allseriespoints",
            APPLY_SELECTED = "applySelected",
            APPLY_HOVER = "applyHover",
            SYMBOL_POINT = "symbolPoint",
            POLAR_SYMBOL_POINT = "polarSymbolPoint",
            BAR_POINT = "barPoint",
            POLAR_BAR_POINT = "polarBarPoint",
            PIE_POINT = "piePoint",
            getEmptyBusinessRange = function() {
                return {
                        arg: {},
                        val: {}
                    }
            };
        seriesNS.mixins = {
            chart: {pointTypes: {
                    scatter: SYMBOL_POINT,
                    line: SYMBOL_POINT,
                    spline: SYMBOL_POINT,
                    stepline: SYMBOL_POINT,
                    stackedline: SYMBOL_POINT,
                    fullstackedline: SYMBOL_POINT,
                    stackedspline: SYMBOL_POINT,
                    fullstackedspline: SYMBOL_POINT,
                    stackedsplinearea: SYMBOL_POINT,
                    fullstackedsplinearea: SYMBOL_POINT,
                    area: SYMBOL_POINT,
                    splinearea: SYMBOL_POINT,
                    steparea: SYMBOL_POINT,
                    stackedarea: SYMBOL_POINT,
                    fullstackedarea: SYMBOL_POINT,
                    rangearea: "rangeSymbolPoint",
                    bar: BAR_POINT,
                    stackedbar: BAR_POINT,
                    fullstackedbar: BAR_POINT,
                    rangebar: "rangeBarPoint",
                    bubble: "bubblePoint",
                    stock: "stockPoint",
                    candlestick: "candlestickPoint"
                }},
            pie: {pointTypes: {
                    pie: PIE_POINT,
                    doughnut: PIE_POINT,
                    donut: PIE_POINT
                }},
            polar: {pointTypes: {
                    scatter: POLAR_SYMBOL_POINT,
                    line: POLAR_SYMBOL_POINT,
                    stackedline: POLAR_SYMBOL_POINT,
                    area: POLAR_SYMBOL_POINT,
                    bar: POLAR_BAR_POINT,
                    stackedbar: POLAR_BAR_POINT,
                    fullstackedbar: POLAR_BAR_POINT
                }}
        };
        function Series() {
            this.ctor.apply(this, arguments)
        }
        seriesNS.Series = Series;
        Series.prototype = {
            ctor: function(renderSettings, options) {
                var that = this;
                that.fullState = 0;
                that._extGroups = renderSettings;
                that._renderer = renderSettings.renderer;
                that._group = renderSettings.renderer.g().attr({"class": "dxc-series"});
                that.updateOptions(options)
            },
            update: function(data, options) {
                this.updateOptions(options);
                this.updateData(data)
            },
            _createLegendState: _noop,
            getLegendStyles: function() {
                return this._styles.legendStyles
            },
            _createStyles: function(options) {
                var that = this,
                    mainSeriesColor = options.mainSeriesColor,
                    specialMainColor = that._getSpecialColor(mainSeriesColor);
                that._styles = {
                    normal: that._parseStyle(options, mainSeriesColor, mainSeriesColor),
                    hover: that._parseStyle(options.hoverStyle || {}, specialMainColor, mainSeriesColor),
                    selection: that._parseStyle(options.selectionStyle || {}, specialMainColor, mainSeriesColor),
                    legendStyles: {
                        normal: that._createLegendState(options, mainSeriesColor),
                        hover: that._createLegendState(options.hoverStyle || {}, specialMainColor),
                        selection: that._createLegendState(options.selectionStyle || {}, specialMainColor)
                    }
                }
            },
            setAdjustSeriesLabels: function(adjustSeriesLabels) {
                _each(this._points || [], function(_, point) {
                    point.setAdjustSeriesLabels(adjustSeriesLabels)
                })
            },
            setClippingParams: function(baseId, wideId, forceClipping) {
                this._paneClipRectID = baseId;
                this._widePaneClipRectID = wideId;
                this._forceClipping = forceClipping
            },
            applyClip: function() {
                this._group.attr({clipId: this._paneClipRectID})
            },
            resetClip: function() {
                this._group.attr({clipId: null})
            },
            getTagField: function() {
                return this._options.tagField || "tag"
            },
            getValueFields: _noop,
            getArgumentField: _noop,
            getPoints: function() {
                return this._points
            },
            _createPoint: function(data, pointsArray, index) {
                data.index = index;
                var that = this,
                    point = pointsArray[index],
                    pointsByArgument = that.pointsByArgument,
                    options;
                if (that._checkData(data)) {
                    options = that._customizePoint(data) || that._getCreatingPointOptions();
                    if (point)
                        point.update(data, options);
                    else {
                        point = core.CoreFactory.createPoint(that, data, options);
                        pointsArray.push(point)
                    }
                    pointsByArgument[point.argument.valueOf()] = pointsByArgument[point.argument.valueOf()] || point;
                    return true
                }
            },
            getRangeData: function(zoomArgs, calcIntervalFunction) {
                return this._visible ? _extend(true, {}, this._getRangeData(zoomArgs, calcIntervalFunction)) : getEmptyBusinessRange()
            },
            _deleteGroup: function(groupName) {
                var group = this[groupName];
                if (group) {
                    group.remove();
                    this[groupName] = null
                }
            },
            _saveOldAnimationMethods: function() {
                var that = this;
                that._oldClearingAnimation = that._clearingAnimation;
                that._oldUpdateElement = that._updateElement;
                that._oldgetAffineCoordOptions = that._getAffineCoordOptions
            },
            _deleteOldAnimationMethods: function() {
                this._oldClearingAnimation = null;
                this._oldUpdateElement = null;
                this._oldgetAffineCoordOptions = null
            },
            updateOptions: function(newOptions) {
                var that = this,
                    widgetType = newOptions.widgetType,
                    oldType = that.type,
                    newType = newOptions.type;
                that.type = newType && newType.toString().toLowerCase();
                if (!that._checkType(widgetType)) {
                    that.dispose();
                    that.isUpdated = false;
                    return
                }
                if (oldType !== that.type) {
                    that._firstDrawing = true;
                    that._saveOldAnimationMethods();
                    that._resetType(oldType, widgetType);
                    that._setType(that.type, widgetType)
                }
                that._options = newOptions;
                that._pointOptions = null;
                that._deletePatterns();
                that._patterns = [];
                that.name = newOptions.name;
                that.pane = newOptions.pane;
                that.axis = newOptions.axis;
                that.tag = newOptions.tag;
                that._createStyles(newOptions);
                that._updateOptions(newOptions);
                that._visible = newOptions.visible;
                that.isUpdated = true
            },
            _disposePoints: function(points) {
                _each(points || [], function(_, p) {
                    p.dispose()
                })
            },
            _correctPointsLength: function(length, points) {
                this._disposePoints(this._oldPoints);
                this._oldPoints = points.splice(length, points.length)
            },
            _getTicksForAggregation: function(min, max, screenDelta, pointSize) {
                var tickManager = new viz.core.tickManager.TickManager({
                        axisType: "continuous",
                        dataType: utils.isDate(min) ? "datetime" : "numeric"
                    }, {
                        min: min,
                        max: max,
                        screenDelta: screenDelta
                    }, {
                        gridSpacingFactor: pointSize,
                        labelOptions: {},
                        stick: true
                    });
                return {
                        ticks: tickManager.getTicks(true),
                        tickInterval: tickManager.getTickInterval()
                    }
            },
            _getRangeCorrector: _noop,
            updateDataType: function(settings) {
                var that = this;
                that.argumentType = settings.argumentType;
                that.valueType = settings.valueType;
                that.argumentAxisType = settings.argumentAxisType;
                that.valueAxisType = settings.valueAxisType
            },
            getValueCategories: function() {
                return this._options.valueCategories || []
            },
            getOptions: function() {
                return this._options
            },
            getArgumentCategories: function() {
                return this._options.argumentCategories || []
            },
            _resetRangeData: function() {
                this._rangeData = getEmptyBusinessRange()
            },
            updateData: function(data) {
                var that = this,
                    points = that._originalPoints || [],
                    lastPointIndex = 0,
                    options = that._options,
                    pointData,
                    rangeCorrector = that._getRangeCorrector();
                that.pointsByArgument = {};
                that._resetRangeData();
                if (data && data.length)
                    that._canRenderCompleteHandle = true;
                that._beginUpdateData(data);
                _each(data, function(index, dataItem) {
                    pointData = that._getPointData(dataItem, options);
                    if (that._createPoint(pointData, points, lastPointIndex)) {
                        that._processRange(points[lastPointIndex], lastPointIndex > 0 ? points[lastPointIndex - 1] : null, rangeCorrector);
                        lastPointIndex++
                    }
                });
                that._points = that._originalPoints = points;
                that._correctPointsLength(lastPointIndex, points);
                that._endUpdateData()
            },
            getTeamplatedFields: function() {
                var that = this,
                    fields = that.getValueFields(),
                    teampleteFields = [];
                fields.push(that.getTagField());
                _each(fields, function(_, field) {
                    var fieldsObject = {};
                    fieldsObject.teamplateField = field + that.name;
                    fieldsObject.originalField = field;
                    teampleteFields.push(fieldsObject)
                });
                return teampleteFields
            },
            resamplePoints: function(translators, min, max) {
                var that = this,
                    originalPoints = that.getAllPoints(),
                    argTranslator = that._options.rotated ? translators.y : translators.x,
                    minI,
                    maxI,
                    sizePoint,
                    tickObject,
                    ticks,
                    tickInterval;
                if (originalPoints.length) {
                    _each(originalPoints, function(i, point) {
                        minI = point.argument - min <= 0 ? i : minI;
                        if (!maxI)
                            maxI = point.argument - max > 0 ? i : null
                    });
                    minI = minI ? minI : 1;
                    maxI = _isDefined(maxI) ? maxI : originalPoints.length - 1;
                    min = originalPoints[minI - 1].argument;
                    max = originalPoints[maxI].argument;
                    sizePoint = that._getPointSize();
                    if (that.argumentAxisType !== "discrete" && that.valueAxisType !== "discrete") {
                        tickObject = that._getTicksForAggregation(min, max, argTranslator.canvasLength, sizePoint);
                        ticks = tickObject.ticks;
                        tickInterval = tickObject.tickInterval
                    }
                    else
                        ticks = argTranslator.canvasLength / sizePoint;
                    that._points = that._resample(ticks, tickInterval)
                }
            },
            _removeOldSegments: function(startIndex) {
                var that = this;
                _each(that._graphics.splice(startIndex, that._graphics.length) || [], function(_, elem) {
                    that._removeElement(elem)
                });
                if (that._trackers)
                    _each(that._trackers.splice(startIndex, that._trackers.length) || [], function(_, elem) {
                        elem.remove()
                    })
            },
            draw: function(translators, animationEnabled, hideLayoutLabels, legendCallback) {
                var that = this;
                if (that._oldClearingAnimation && animationEnabled && that._firstDrawing) {
                    var drawComplete = function() {
                            that._draw(translators, true, hideLayoutLabels)
                        };
                    that._oldClearingAnimation(translators, drawComplete)
                }
                else
                    that._draw(translators, animationEnabled, hideLayoutLabels, legendCallback)
            },
            _clearSeries: function() {
                var that = this;
                that._deleteGroup("_elementsGroup");
                that._deleteGroup("_bordersGroup");
                that._deleteTrackers();
                that._graphics = [];
                that._trackers = []
            },
            _draw: function(translators, animationEnabled, hideLayoutLabels, legendCallback) {
                var that = this,
                    points = that._points || [],
                    segment = [],
                    segmentCount = 0,
                    firstDrawing = that._firstDrawing,
                    closeSegment = points[0] && points[0].hasValue() && that._options.closed;
                that._graphics = that._graphics || [];
                that._prepareSeriesToDrawing();
                if (!that._visible) {
                    animationEnabled = false;
                    that._group.remove();
                    return
                }
                else
                    that._group.append(that._extGroups.seriesGroup);
                that.translators = translators;
                that._createGroups(animationEnabled, undefined, firstDrawing);
                that._segments = [];
                that._drawedPoints = [];
                that._firstDrawing = points.length ? false : true;
                _each(points, function(i, p) {
                    p.translate(translators);
                    if (p.hasValue()) {
                        that._drawPoint(p, that._markersGroup, that._labelsGroup, animationEnabled, firstDrawing);
                        segment.push(p)
                    }
                    else if (segment.length) {
                        that._drawSegment(segment, animationEnabled, segmentCount++);
                        segment = []
                    }
                });
                segment.length && that._drawSegment(segment, animationEnabled, segmentCount++, closeSegment);
                that._removeOldSegments(segmentCount);
                that._defaultSegments = that._generateDefaultSegments();
                that._adjustLabels();
                hideLayoutLabels && that.hideLabels();
                animationEnabled && that._animate(firstDrawing);
                if (that.isSelected())
                    that._changeStyle(legendCallback, APPLY_SELECTED);
                else if (that.isHovered())
                    that._changeStyle(legendCallback, APPLY_HOVER)
            },
            _checkType: function(widgetType) {
                return !!seriesNS.mixins[widgetType][this.type]
            },
            _resetType: function(seriesType, widgetType) {
                var that = this;
                if (seriesType)
                    _each(seriesNS.mixins[widgetType][seriesType], function(methodName) {
                        delete that[methodName]
                    })
            },
            _setType: function(seriesType, widgetType) {
                var that = this;
                _each(seriesNS.mixins[widgetType][seriesType], function(methodName, method) {
                    that[methodName] = method
                })
            },
            setSelectedState: function(state, mode, legendCallback) {
                var that = this;
                that.lastSelectionMode = (mode || that._options.selectionMode).toLowerCase();
                if (state && !that.isSelected()) {
                    that.fullState = that.fullState | SELECTED_STATE;
                    that._changeStyle(legendCallback, APPLY_SELECTED)
                }
                else if (!state && that.isSelected()) {
                    that.fullState = that.fullState & ~SELECTED_STATE;
                    if (that.isHovered())
                        that._changeStyle(legendCallback, APPLY_HOVER);
                    else
                        that._changeStyle(legendCallback, "resetItem")
                }
            },
            setHoverState: function(state, mode, legendCallback) {
                var that = this;
                that.lastHoverMode = (mode || that._options.hoverMode).toLowerCase();
                if (state && !that.isHovered()) {
                    that.fullState = that.fullState | HOVER_STATE;
                    !that.isSelected() && that._changeStyle(legendCallback, APPLY_HOVER)
                }
                else if (!state && that.isHovered()) {
                    that.fullState = that.fullState & ~HOVER_STATE;
                    !that.isSelected() && that._changeStyle(legendCallback, "resetItem")
                }
            },
            isFullStackedSeries: function() {
                return this.type.indexOf("fullstacked") === 0
            },
            isStackedSeries: function() {
                return this.type.indexOf("stacked") === 0
            },
            isFinancialSeries: function() {
                return this.type === "stock" || this.type === "candlestick"
            },
            _changeStyle: function(legendCallBack, legendAction) {
                var that = this,
                    style = that._calcStyle(),
                    pointStyle;
                if (style.mode === NONE_MODE)
                    return;
                legendCallBack && legendCallBack(legendAction);
                if (style.mode === INCLUDE_POINTS || style.mode === ALL_SERIES_POINTS_MODE) {
                    pointStyle = style.pointStyle;
                    _each(that._points || [], function(_, p) {
                        !p.isSelected() && p.applyStyle(pointStyle)
                    })
                }
                that._applyStyle(style.series)
            },
            _calcStyle: function() {
                var that = this,
                    styles = that._styles,
                    isHoverIncludeModeAndSeriesExcludeMode = false,
                    result;
                switch (that.fullState & 3) {
                    case 0:
                        result = {
                            pointStyle: "normal",
                            mode: INCLUDE_POINTS,
                            series: styles.normal
                        };
                        break;
                    case 1:
                        result = {
                            pointStyle: "hover",
                            mode: that.lastHoverMode,
                            series: styles.hover
                        };
                        break;
                    case 2:
                        result = {
                            pointStyle: "selection",
                            mode: that.lastSelectionMode,
                            series: styles.selection
                        };
                        break;
                    case 3:
                        isHoverIncludeModeAndSeriesExcludeMode = that.lastSelectionMode === EXLUDE_POINTS && (that.lastHoverMode === INCLUDE_POINTS || that.lastHoverMode === ALL_SERIES_POINTS_MODE);
                        result = {
                            pointStyle: isHoverIncludeModeAndSeriesExcludeMode ? "normal" : "selection",
                            mode: isHoverIncludeModeAndSeriesExcludeMode ? INCLUDE_POINTS : that.lastSelectionMode,
                            series: styles.selection
                        }
                }
                return result
            },
            _getMainAxisName: function() {
                return this._options.rotated ? "X" : "Y"
            },
            areLabelsVisible: function() {
                return !_isDefined(this._options.maxLabelCount) || this._points.length <= this._options.maxLabelCount
            },
            getLabelVisibility: function() {
                return this.areLabelsVisible() && this._options.label && this._options.label.visible
            },
            _customizePoint: function(pointData) {
                var that = this,
                    options = that._options,
                    customizePoint = options.customizePoint,
                    customizeObject,
                    pointOptions,
                    customLabelOptions,
                    customOptions,
                    customizeLabel = options.customizeLabel,
                    useLabelCustomOptions,
                    usePointCustomOptions;
                if (customizeLabel && customizeLabel.call) {
                    customizeObject = _extend({seriesName: that.name}, pointData);
                    customizeObject.series = that;
                    customLabelOptions = customizeLabel.call(customizeObject, customizeObject);
                    useLabelCustomOptions = customLabelOptions && !_isEmptyObject(customLabelOptions);
                    customLabelOptions = useLabelCustomOptions ? _extend(true, {}, options.label, customLabelOptions) : null
                }
                if (customizePoint && customizePoint.call) {
                    customizeObject = customizeObject || _extend({seriesName: that.name}, pointData);
                    customizeObject.series = that;
                    customOptions = customizePoint.call(customizeObject, customizeObject);
                    usePointCustomOptions = customOptions && !_isEmptyObject(customOptions)
                }
                if (useLabelCustomOptions || usePointCustomOptions) {
                    pointOptions = that._parsePointOptions(that._preparePointOptions(customOptions), customLabelOptions || options.label);
                    pointOptions.styles.useLabelCustomOptions = useLabelCustomOptions;
                    pointOptions.styles.usePointCustomOptions = usePointCustomOptions
                }
                return pointOptions
            },
            _getLabelOptions: function(labelOptions, defaultColor) {
                var opt = labelOptions || {},
                    labelFont = opt.font || {},
                    labelBorder = opt.border || {},
                    labelConnector = opt.connector || {},
                    labelAttributes = {font: {
                            color: opt.backgroundColor === "none" && labelFont.color.toLowerCase() === "#ffffff" && opt.position !== "inside" ? defaultColor : labelFont.color,
                            family: labelFont.family,
                            weight: labelFont.weight,
                            size: labelFont.size,
                            opacity: labelFont.opacity
                        }},
                    backgroundAttr = {
                        fill: opt.backgroundColor || defaultColor,
                        "stroke-width": labelBorder.visible ? labelBorder.width || 0 : 0,
                        stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : "none",
                        dashStyle: labelBorder.dashStyle
                    },
                    connectorAttr = {
                        stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : "none",
                        "stroke-width": labelConnector.visible ? labelConnector.width || 0 : 0
                    };
                return {
                        alignment: opt.alignment,
                        format: opt.format,
                        argumentFormat: opt.argumentFormat,
                        precision: opt.precision,
                        argumentPrecision: opt.argumentPrecision,
                        percentPrecision: opt.percentPrecision,
                        customizeText: $.isFunction(opt.customizeText) ? opt.customizeText : undefined,
                        attributes: labelAttributes,
                        visible: labelFont.size !== 0 ? opt.visible : false,
                        showForZeroValues: opt.showForZeroValues,
                        horizontalOffset: opt.horizontalOffset,
                        verticalOffset: opt.verticalOffset,
                        radialOffset: opt.radialOffset,
                        background: backgroundAttr,
                        position: opt.position,
                        connector: connectorAttr,
                        rotationAngle: opt.rotationAngle
                    }
            },
            show: function() {
                var that = this;
                if (!that._visible) {
                    that._visible = true;
                    that.hidePointTooltip();
                    that._options.visibilityChanged()
                }
            },
            hide: function() {
                var that = this;
                if (that._visible) {
                    that._visible = false;
                    that.hidePointTooltip();
                    that._options.visibilityChanged()
                }
            },
            hideLabels: function() {
                _each(this._points, function(_, point) {
                    point._label.hide()
                })
            },
            _parsePointOptions: function(pointOptions, labelOptions) {
                var that = this,
                    options = that._options,
                    styles = that._createPointStyles(pointOptions),
                    parsedOptions = _extend(true, {}, pointOptions, {
                        type: options.type,
                        tag: that.tag,
                        rotated: options.rotated,
                        styles: styles,
                        widgetType: options.widgetType,
                        visibilityChanged: options.visibilityChanged
                    });
                parsedOptions.label = that._getLabelOptions(labelOptions, styles.normal.fill);
                parsedOptions.errorBars = options.valueErrorBar;
                return parsedOptions
            },
            _resample: function(ticks, ticksInterval) {
                var that = this,
                    fusPoints = [],
                    arrayFusPoints,
                    nowIndexTicks = 0,
                    lastPointIndex = 0,
                    originalPoints = that.getAllPoints();
                if (that.argumentAxisType === "discrete" || that.valueAxisType === "discrete") {
                    ticksInterval = originalPoints.length / ticks;
                    arrayFusPoints = $.map(originalPoints, function(point, index) {
                        if (Math.floor(nowIndexTicks) <= index) {
                            nowIndexTicks += ticksInterval;
                            return point
                        }
                        point.setInvisibility();
                        return null
                    });
                    return arrayFusPoints
                }
                that._aggregatedPoints = that._aggregatedPoints || [];
                _each(originalPoints, function(_, point) {
                    switch (that._isInInterval(point.argument, ticks, nowIndexTicks, ticksInterval)) {
                        case true:
                            fusPoints.push(point);
                            break;
                        case"nextInterval":
                            var pointData = that._fusionPoints(fusPoints, ticks[nowIndexTicks], nowIndexTicks);
                            while (that._isInInterval(point.argument, ticks, nowIndexTicks, ticksInterval) === "nextInterval")
                                nowIndexTicks++;
                            fusPoints = [];
                            that._isInInterval(point.argument, ticks, nowIndexTicks, ticksInterval) === true && fusPoints.push(point);
                            if (that._createPoint(pointData, that._aggregatedPoints, lastPointIndex))
                                lastPointIndex++
                    }
                });
                if (fusPoints.length) {
                    var pointData = that._fusionPoints(fusPoints, ticks[nowIndexTicks], nowIndexTicks);
                    if (that._createPoint(pointData, that._aggregatedPoints, lastPointIndex))
                        lastPointIndex++
                }
                that._correctPointsLength(lastPointIndex, that._aggregatedPoints);
                that._endUpdateData();
                return that._aggregatedPoints
            },
            _isInInterval: function(argument, ticks, nowIndexTicks, ticksInterval) {
                var minTick = ticks[nowIndexTicks],
                    maxTick = ticks[nowIndexTicks + 1],
                    sumMinTickTicksInterval;
                ticksInterval = $.isNumeric(ticksInterval) ? ticksInterval : utils.convertDateTickIntervalToMilliseconds(ticksInterval);
                sumMinTickTicksInterval = utils.isDate(minTick) ? new Date(minTick.getTime() + ticksInterval) : minTick + ticksInterval;
                if (argument >= minTick && argument < sumMinTickTicksInterval)
                    return true;
                if (argument < minTick || maxTick === undefined)
                    return false;
                return "nextInterval"
            },
            canRenderCompleteHandle: function() {
                var result = this._canRenderCompleteHandle;
                delete this._canRenderCompleteHandle;
                return !!result
            },
            isHovered: function() {
                return !!(this.fullState & 1)
            },
            isSelected: function() {
                return !!(this.fullState & 2)
            },
            isVisible: function() {
                return this._visible
            },
            getAllPoints: function() {
                return (this._originalPoints || []).slice()
            },
            getPointByPos: function(pos) {
                return (this._points || [])[pos]
            },
            getVisiblePoints: function() {
                return (this._drawedPoints || []).slice()
            },
            setPointHoverState: function(point, legendCallback) {
                point.fullState = point.fullState | HOVER_STATE;
                if (!(this.isSelected() && (this.lastSelectionMode === ALL_SERIES_POINTS_MODE || this.lastSelectionMode === INCLUDE_POINTS)) && !point.isSelected()) {
                    point.applyStyle("hover");
                    legendCallback && legendCallback("applyHover")
                }
            },
            releasePointHoverState: function(point, legendCallback) {
                var that = this;
                point.fullState = point.fullState & ~HOVER_STATE;
                if (!(that.isSelected() && (that.lastSelectionMode === ALL_SERIES_POINTS_MODE || that.lastSelectionMode === INCLUDE_POINTS)) && !point.isSelected())
                    if (!(that.isHovered() && (that.lastHoverMode === ALL_SERIES_POINTS_MODE || that.lastHoverMode === INCLUDE_POINTS))) {
                        point.applyStyle("normal");
                        legendCallback && legendCallback("resetItem")
                    }
            },
            setPointSelectedState: function(point, legendCallback) {
                point.fullState = point.fullState | SELECTED_STATE;
                point.applyStyle("selection");
                legendCallback && legendCallback("applySelected")
            },
            releasePointSelectedState: function(point, legendCallback) {
                var that = this;
                point.fullState = point.fullState & ~SELECTED_STATE;
                if (that.isHovered() && (that.lastHoverMode === ALL_SERIES_POINTS_MODE || that.lastHoverMode === INCLUDE_POINTS) || point.isHovered()) {
                    point.applyStyle("hover");
                    legendCallback && legendCallback("applyHover")
                }
                else if (that.isSelected() && (that.lastSelectionMode === ALL_SERIES_POINTS_MODE || that.lastSelectionMode === INCLUDE_POINTS)) {
                    point.applyStyle("selection");
                    legendCallback && legendCallback("applySelected")
                }
                else {
                    point.applyStyle("normal");
                    legendCallback && legendCallback("resetItem")
                }
            },
            selectPoint: function(point) {
                this._extGroups.seriesGroup && $(this._extGroups.seriesGroup.element).trigger(new _Event("selectpoint"), point)
            },
            deselectPoint: function(point) {
                this._extGroups.seriesGroup && $(this._extGroups.seriesGroup.element).trigger(new _Event("deselectpoint"), point)
            },
            showPointTooltip: function(point) {
                this._extGroups.seriesGroup && $(this._extGroups.seriesGroup.element).trigger(new _Event("showpointtooltip"), point)
            },
            hidePointTooltip: function(point) {
                this._extGroups.seriesGroup && $(this._extGroups.seriesGroup.element).trigger(new _Event("hidepointtooltip"), point)
            },
            select: function() {
                var that = this,
                    trackersGroup = that._trackersGroup;
                that._extGroups.seriesGroup && $(that._extGroups.seriesGroup.element).trigger(new _Event("selectseries", {target: that}), that._options.selectionMode);
                that._group.toForeground()
            },
            clearSelection: function clearSelection() {
                var that = this;
                that._extGroups.seriesGroup && $(that._extGroups.seriesGroup.element).trigger(new _Event("deselectseries", {target: that}), that._options.selectionMode)
            },
            getPointByArg: function(arg) {
                return this.pointsByArgument[arg.valueOf()] || null
            },
            _deletePoints: function() {
                var that = this;
                that._disposePoints(that._originalPoints);
                that._disposePoints(that._aggregatedPoints);
                that._disposePoints(that._oldPoints);
                that._points = null;
                that._oldPoints = null;
                that._aggregatedPoints = null;
                that._originalPoints = null;
                that._drawedPoint = null
            },
            _deletePatterns: function() {
                _each(this._patterns || [], function(_, pattern) {
                    pattern && pattern.dispose()
                });
                this._patterns = null
            },
            _deleteTrackers: function() {
                var that = this;
                _each(that._trackers || [], function(_, tracker) {
                    tracker.remove()
                });
                that._trackersGroup && that._trackersGroup.remove();
                that._trackers = that._trackersGroup = null
            },
            dispose: function() {
                var that = this;
                that._deletePoints();
                that._group.remove();
                that._labelsGroup && that._labelsGroup.remove();
                that._deletePatterns();
                that._deleteTrackers();
                that._group = null;
                that._markersGroup = null;
                that._elementsGroup = null;
                that._bordersGroup = null;
                that._labelsGroup = null;
                that._graphics = null;
                that._rangeData = null;
                that._renderer = null;
                that.translators = null;
                that._styles = null;
                that._options = null;
                that._pointOptions = null;
                that._drawedPoints = null;
                that._aggregatedPoints = null;
                that.pointsByArgument = null;
                that._segments = null;
                that._prevSeries = null
            },
            correctPosition: _noop,
            drawTrackers: _noop,
            getNeighborPoint: _noop,
            _adjustLabels: _noop,
            getColor: function() {
                return this.getLegendStyles().normal.fill
            },
            getStackName: function() {
                return this.type === "stackedbar" || this.type === "fullstackedbar" ? this._stackName : null
            },
            getPointByCoord: function(x, y) {
                var point = this.getNeighborPoint(x, y);
                return point && point.coordsIn(x, y) ? point : null
            }
        }
    })(jQuery, DevExpress);
    /*! Module viz-core, file rangeDataCalculator.js */
    (function($, DX, undefined) {
        var _math = Math,
            _abs = _math.abs,
            _min = _math.min,
            _max = _math.max,
            _each = $.each,
            _isEmptyObject = $.isEmptyObject,
            _isDefined = DX.utils.isDefined,
            _isFinite = isFinite,
            FULLSTACKED_SERIES_VALUE_MARGIN_PRIORITY = 15,
            BAR_ZERO_VALUE_MARGIN_PRIORITY = 20,
            SERIES_VALUE_MARGIN_PRIORITY = 20,
            SERIES_LABEL_VALUE_MARGIN = 0.3,
            MIN_VISIBLE = "minVisible",
            MAX_VISIBLE = "maxVisible",
            DISCRETE = "discrete";
        function _truncateValue(data, value) {
            var min = data.min,
                max = data.max;
            data.min = value < min || !_isDefined(min) ? value : min;
            data.max = value > max || !_isDefined(max) ? value : max
        }
        function _processValue(series, type, value, prevValue, calcInterval) {
            var axis = type === "arg" ? "argument" : "value",
                data = series._rangeData[type],
                minInterval = data.interval,
                interval;
            if (series[axis + "AxisType"] === DISCRETE) {
                data.categories = data.categories || [];
                data.categories.push(value)
            }
            else {
                _truncateValue(data, value);
                if (type === "arg") {
                    interval = (_isDefined(prevValue) ? _abs(calcInterval ? calcInterval(value, prevValue) : value - prevValue) : interval) || minInterval;
                    data.interval = _isDefined(interval) && (interval < minInterval || !_isDefined(minInterval)) ? interval : minInterval
                }
            }
        }
        function _addToVisibleRange(series, value) {
            var data = series._rangeData.val,
                isDiscrete = series.valueAxisType === DISCRETE;
            if (!isDiscrete) {
                if (value < data.minVisible || !_isDefined(data.minVisible))
                    data.minVisible = value;
                if (value > data.maxVisible || !_isDefined(data.maxVisible))
                    data.maxVisible = value
            }
        }
        function _processRangeValue(series, val, minVal, prevVal, prevMinVal) {
            var data = series._rangeData.val,
                interval,
                currentInterval = data.interval;
            if (series.valueAxisType === DISCRETE) {
                data.categories = data.categories || [];
                data.categories.push(val, minVal)
            }
            else {
                _truncateValue(data, val);
                _truncateValue(data, minVal)
            }
        }
        function _unique(array) {
            var values = {};
            return $.map(array, function(item) {
                    var result = !values[item] ? item : null;
                    values[item] = true;
                    return result
                })
        }
        function _processZoomArgument(series, zoomArgs, isDiscrete) {
            var data = series._rangeData.arg,
                minArg,
                maxArg;
            if (isDiscrete) {
                data.startCategories = zoomArgs.minArg;
                data.endCategories = zoomArgs.maxArg;
                return
            }
            minArg = zoomArgs.minArg < zoomArgs.maxArg ? zoomArgs.minArg : zoomArgs.maxArg;
            maxArg = zoomArgs.maxArg > zoomArgs.minArg ? zoomArgs.maxArg : zoomArgs.minArg;
            data.min = minArg < data.min ? minArg : data.min;
            data.max = maxArg > data.max ? maxArg : data.max;
            data.minVisible = minArg;
            data.maxVisible = maxArg
        }
        function _correctZoomValue(series, zoomArgs) {
            var minVal,
                maxVal;
            if (_isDefined(zoomArgs.minVal) && _isDefined(zoomArgs.maxVal)) {
                minVal = zoomArgs.minVal < zoomArgs.maxVal ? zoomArgs.minVal : zoomArgs.maxVal;
                maxVal = zoomArgs.maxVal > zoomArgs.minVal ? zoomArgs.maxVal : zoomArgs.minVal
            }
            if (_isDefined(zoomArgs.minVal)) {
                series._rangeData.val.min = minVal < series._rangeData.val.min ? minVal : series._rangeData.val.min;
                series._rangeData.val.minVisible = minVal
            }
            if (_isDefined(zoomArgs.maxVal)) {
                series._rangeData.val.max = maxVal > series._rangeData.val.max ? maxVal : series._rangeData.val.max;
                series._rangeData.val.maxVisible = maxVal
            }
        }
        function _processZoomValue(series, zoomArgs) {
            var adjustOnZoom = zoomArgs.adjustOnZoom,
                points = series._points || [],
                lastVisibleIndex,
                prevPointAdded = false;
            _each(points, function(index, point) {
                var arg = point.argument,
                    prevPoint = index > 0 ? points[index - 1] : null;
                if (adjustOnZoom && arg >= series._rangeData.arg.minVisible && arg <= series._rangeData.arg.maxVisible) {
                    if (!prevPointAdded) {
                        prevPoint && prevPoint.hasValue() && _addToVisibleRange(series, prevPoint.value);
                        prevPointAdded = true
                    }
                    point.hasValue() && _addToVisibleRange(series, point.value);
                    lastVisibleIndex = index
                }
            });
            if (_isDefined(lastVisibleIndex) && lastVisibleIndex < points.length - 1 && points[lastVisibleIndex + 1].hasValue())
                _addToVisibleRange(series, points[lastVisibleIndex + 1].value);
            _correctZoomValue(series, zoomArgs)
        }
        function _processZoomRangeValue(series, zoomArgs, maxValueName, minValueName) {
            var adjustOnZoom = zoomArgs.adjustOnZoom,
                points = series._points || [],
                lastVisibleIndex,
                prevPointAdded = false;
            _each(points, function(index, point) {
                var arg = point.argument,
                    prevPoint = index > 0 ? points[index - 1] : null;
                if (adjustOnZoom && arg >= series._rangeData.arg.minVisible && arg <= series._rangeData.arg.maxVisible) {
                    if (!prevPointAdded) {
                        if (prevPoint && prevPoint.hasValue()) {
                            _addToVisibleRange(series, prevPoint[maxValueName]);
                            _addToVisibleRange(series, prevPoint[minValueName])
                        }
                        prevPointAdded = true
                    }
                    if (point.hasValue()) {
                        _addToVisibleRange(series, point[maxValueName]);
                        _addToVisibleRange(series, point[minValueName])
                    }
                    lastVisibleIndex = index
                }
            });
            if (_isDefined(lastVisibleIndex) && lastVisibleIndex < points.length - 1 && points[lastVisibleIndex + 1].hasValue())
                _addToVisibleRange(series, points[lastVisibleIndex + 1].value);
            _correctZoomValue(series, zoomArgs)
        }
        function _processNewInterval(series, calcInterval) {
            var data = series._rangeData,
                points = series._points || [],
                isArgumentAxisDiscrete = series.argumentAxisType === DISCRETE;
            delete data.arg.interval;
            _each(points, function(index, point) {
                var arg = point.argument,
                    prevPoint = index > 0 ? points[index - 1] : null,
                    prevArg = prevPoint && prevPoint.argument;
                !isArgumentAxisDiscrete && _processValue(series, "arg", arg, prevArg, calcInterval)
            })
        }
        function _fillRangeData(series) {
            var data = series._rangeData,
                mainAxis = series._getMainAxisName(),
                axis = mainAxis === "X" ? "Y" : "X";
            data.arg.categories && (data.arg.categories = _unique(data.arg.categories));
            data.val.categories && (data.val.categories = _unique(data.val.categories));
            data.arg.axisType = series.argumentAxisType;
            data.arg.dataType = series.argumentType;
            data.val.axisType = series.valueAxisType;
            data.val.dataType = series.valueType;
            data.val.isValueRange = true
        }
        function processTwoValues(series, point, prevPoint, highValueName, lowValueName) {
            var val = point[highValueName],
                minVal = point[lowValueName],
                arg = point.argument,
                prevVal = prevPoint && prevPoint[highValueName],
                prevMinVal = prevPoint && prevPoint[lowValueName],
                prevArg = prevPoint && prevPoint.argument;
            point.hasValue() && _processRangeValue(series, val, minVal, prevVal, prevMinVal);
            _processValue(series, "arg", arg, prevArg)
        }
        function calculateRangeMinValue(series, zoomArgs) {
            var data = series._rangeData.val,
                minVisible = data[MIN_VISIBLE],
                maxVisible = data[MAX_VISIBLE];
            zoomArgs = zoomArgs || {};
            if (data)
                if (series.valueAxisType !== "logarithmic" && series.valueType !== "datetime" && series.getOptions().showZero !== false) {
                    data[MIN_VISIBLE] = minVisible > (zoomArgs.minVal || 0) ? zoomArgs.minVal || 0 : minVisible;
                    data[MAX_VISIBLE] = maxVisible < (zoomArgs.maxVal || 0) ? zoomArgs.maxVal || 0 : maxVisible;
                    data.min = data.min > 0 ? 0 : data.min;
                    data.max = data.max < 0 ? 0 : data.max
                }
        }
        function processFullStackedRange(series) {
            var data = series._rangeData.val,
                isRangeEmpty = _isEmptyObject(data);
            data.percentStick = true;
            !isRangeEmpty && (data.min = 0)
        }
        function _correctMinMaxByErrorBar(data, point, getMinMaxCorrectionData) {
            if (!getMinMaxCorrectionData)
                return;
            var correctionData = getMinMaxCorrectionData(point),
                minError = _min.apply(undefined, correctionData),
                maxError = _max.apply(undefined, correctionData);
            if (_isFinite(minError) && data.min > minError)
                data.min = minError;
            if (_isFinite(maxError) && data.max < maxError)
                data.max = maxError
        }
        function processRange(series, point, prevPoint, getMinMaxCorrectionData) {
            var val = point.value,
                arg = point.argument,
                prevVal = prevPoint && prevPoint.value,
                prevArg = prevPoint && prevPoint.argument;
            point.hasValue() && _processValue(series, "val", val, prevVal);
            _processValue(series, "arg", arg, prevArg);
            _correctMinMaxByErrorBar(series._rangeData.val, point, getMinMaxCorrectionData)
        }
        function addLabelPaddings(series) {
            var labelOptions = series.getOptions().label,
                valueData;
            if (series.areLabelsVisible() && labelOptions && labelOptions.visible && labelOptions.position !== "inside") {
                valueData = series._rangeData.val;
                if (valueData.min < 0)
                    valueData.minSpaceCorrection = true;
                if (valueData.max > 0)
                    valueData.maxSpaceCorrection = true
            }
        }
        function addRangeSeriesLabelPaddings(series) {
            var data = series._rangeData.val;
            if (series.areLabelsVisible() && series._options.label.visible && series._options.label.position !== "inside")
                data.minSpaceCorrection = data.maxSpaceCorrection = true
        }
        function calculateRangeData(series, zoomArgs, calcIntervalFunction, maxValueName, minValueName) {
            var valueData = series._rangeData.val,
                isRangeSeries = !!maxValueName && !!minValueName,
                isDiscrete = series.argumentAxisType === DISCRETE;
            if (zoomArgs && _isDefined(zoomArgs.minArg) && _isDefined(zoomArgs.maxArg)) {
                if (!isDiscrete) {
                    valueData[MIN_VISIBLE] = zoomArgs.minVal;
                    valueData[MAX_VISIBLE] = zoomArgs.maxVal
                }
                _processZoomArgument(series, zoomArgs, isDiscrete);
                if (isRangeSeries)
                    _processZoomRangeValue(series, zoomArgs, maxValueName, minValueName);
                else
                    _processZoomValue(series, zoomArgs)
            }
            else if (!zoomArgs && calcIntervalFunction)
                _processNewInterval(series, calcIntervalFunction);
            _fillRangeData(series)
        }
        DX.viz.core.series.helpers.rangeDataCalculator = {
            processRange: processRange,
            calculateRangeData: calculateRangeData,
            addLabelPaddings: addLabelPaddings,
            addRangeSeriesLabelPaddings: addRangeSeriesLabelPaddings,
            processFullStackedRange: processFullStackedRange,
            calculateRangeMinValue: calculateRangeMinValue,
            processTwoValues: processTwoValues
        }
    })(jQuery, DevExpress);
    /*! Module viz-core, file scatterSeries.js */
    (function($, DX) {
        var series = DX.viz.core.series,
            rangeCalculator = series.helpers.rangeDataCalculator,
            chartSeries = series.mixins.chart,
            _each = $.each,
            _extend = $.extend,
            _map = $.map,
            _noop = $.noop,
            _utils = DX.utils,
            _isDefined = _utils.isDefined,
            _isString = _utils.isString,
            math = Math,
            _floor = math.floor,
            _abs = math.abs,
            _sqrt = math.sqrt,
            _min = math.min,
            _max = math.max,
            LABEL_OFFSET = 10,
            DEFAULT_SYMBOL_POINT_SIZE = 2,
            DEFAULT_TRACKER_WIDTH = 20,
            DEFAULT_DURATION = 400,
            HIGH_ERROR = "highError",
            LOW_ERROR = "lowError",
            VARIANCE = "variance",
            STANDARD_DEVIATION = "stddeviation",
            STANDARD_ERROR = "stderror",
            PERCENT = "percent",
            FIXED = "fixed",
            DISCRETE = "discrete",
            LOGARITHMIC = "logarithmic",
            DATETIME = "datetime";
        function sum(array) {
            var sum = 0;
            _each(array, function(_, value) {
                sum += value
            });
            return sum
        }
        function toLowerCase(value) {
            return value.toLowerCase()
        }
        function variance(array, expectedValue) {
            return sum($.map(array, function(value) {
                    return (value - expectedValue) * (value - expectedValue)
                })) / array.length
        }
        var baseScatterMethods = {
                _defaultDuration: DEFAULT_DURATION,
                _defaultTrackerWidth: DEFAULT_TRACKER_WIDTH,
                _applyStyle: _noop,
                _updateOptions: _noop,
                _parseStyle: _noop,
                _prepareSegment: _noop,
                _drawSegment: _noop,
                _generateDefaultSegments: _noop,
                _prepareSeriesToDrawing: function() {
                    var that = this;
                    that._deleteOldAnimationMethods();
                    that._firstDrawing && that._clearSeries();
                    that._disposePoints(that._oldPoints);
                    that._oldPoints = null
                },
                _createLegendState: function(styleOptions, defaultColor) {
                    return {
                            fill: styleOptions.color || defaultColor,
                            hatching: styleOptions.hatching
                        }
                },
                updateTeamplateFieldNames: function() {
                    var that = this,
                        options = that._options;
                    options.valueField = that.getValueFields()[0] + that.name;
                    options.tagField = that.getTagField() + that.name
                },
                _applyElementsClipRect: function(settings) {
                    settings.clipId = this._paneClipRectID
                },
                _applyMarkerClipRect: function(settings) {
                    settings.clipId = this._forceClipping ? this._paneClipRectID : null
                },
                _createGroup: function(groupName, parent, target, settings) {
                    var group = parent[groupName] = parent[groupName] || this._renderer.g();
                    group.attr(settings).append(target)
                },
                _applyClearingSettings: function(settings) {
                    settings.opacity = null;
                    settings.scale = null;
                    if (this._options.rotated)
                        settings.translateX = null;
                    else
                        settings.translateY = null
                },
                _createMarkerGroup: function() {
                    var that = this,
                        settings = that._getPointOptions().styles.normal;
                    settings["class"] = "dxc-markers";
                    settings.opacity = 1;
                    that._applyMarkerClipRect(settings);
                    that._createGroup("_markersGroup", that, that._group, settings)
                },
                _createLabelGroup: function() {
                    var that = this,
                        settings = {
                            "class": "dxc-labels",
                            visibility: that.getLabelVisibility() ? "visible" : "hidden"
                        };
                    that._applyElementsClipRect(settings);
                    that._applyClearingSettings(settings);
                    that._createGroup("_labelsGroup", that, that._extGroups.labelsGroup, settings)
                },
                _createGroups: function(animationEnabled) {
                    var that = this;
                    that._createMarkerGroup();
                    that._createLabelGroup();
                    animationEnabled && that._labelsGroup && that._labelsGroup.attr({opacity: 0.001})
                },
                _getCreatingPointOptions: function() {
                    var that = this,
                        defaultPointOptions,
                        creatingPointOptions = that._predefinedPointOptions,
                        normalStyle;
                    if (!creatingPointOptions) {
                        defaultPointOptions = that._getPointOptions();
                        that._predefinedPointOptions = creatingPointOptions = _extend(true, {styles: {}}, defaultPointOptions);
                        normalStyle = defaultPointOptions.styles && defaultPointOptions.styles.normal || {};
                        creatingPointOptions.styles = creatingPointOptions.styles || {};
                        creatingPointOptions.styles.normal = {
                            "stroke-width": normalStyle["stroke-width"],
                            r: normalStyle.r,
                            opacity: normalStyle.opacity
                        }
                    }
                    return creatingPointOptions
                },
                _getSpecialColor: function(mainSeriesColor) {
                    return mainSeriesColor
                },
                _getPointOptions: function() {
                    var that = this;
                    return that._pointOptions || (that._pointOptions = that._parsePointOptions(that._preparePointOptions(), that._options.label))
                },
                _preparePointOptions: function(customOptions) {
                    var point = this._options.point;
                    return customOptions ? _extend(true, {}, point, customOptions) : point
                },
                _parsePointStyle: function(style, defaultColor, defaultBorderColor) {
                    var border = style.border || {};
                    return {
                            fill: style.color || defaultColor,
                            stroke: border.color || defaultBorderColor,
                            "stroke-width": border.visible ? border.width : 0,
                            r: style.size / 2 + (border.visible && style.size !== 0 ? ~~(border.width / 2) || 0 : 0)
                        }
                },
                _createPointStyles: function(pointOptions) {
                    var that = this,
                        mainPointColor = pointOptions.color || that._options.mainSeriesColor,
                        containerColor = that._options.containerBackgroundColor,
                        normalStyle = that._parsePointStyle(pointOptions, mainPointColor, mainPointColor);
                    normalStyle.visibility = pointOptions.visible ? "visible" : "hidden";
                    return {
                            normal: normalStyle,
                            hover: that._parsePointStyle(pointOptions.hoverStyle, containerColor, mainPointColor),
                            selection: that._parsePointStyle(pointOptions.selectionStyle, containerColor, mainPointColor)
                        }
                },
                _checkData: function(data) {
                    return _isDefined(data.argument) && data.value !== undefined
                },
                _getRangeCorrector: function() {
                    var errorBars = this._options.valueErrorBar || {},
                        mode = toLowerCase(errorBars.displayMode + ""),
                        minMaxRangeCorrection = errorBars ? function(point) {
                            var lowError = point.lowError,
                                highError = point.highError;
                            switch (mode) {
                                case"low":
                                    return [lowError];
                                case"high":
                                    return [highError];
                                case"none":
                                    return [];
                                default:
                                    return [lowError, highError]
                            }
                        } : undefined;
                    return minMaxRangeCorrection
                },
                _processRange: function(point, prevPoint, rangeCorrection) {
                    rangeCalculator.processRange(this, point, prevPoint, rangeCorrection)
                },
                _getRangeData: function(zoomArgs, calcIntervalFunction) {
                    rangeCalculator.calculateRangeData(this, zoomArgs, calcIntervalFunction);
                    rangeCalculator.addLabelPaddings(this);
                    return this._rangeData
                },
                _getPointData: function(data, options) {
                    var pointData = {
                            value: data[options.valueField || "val"],
                            argument: data[options.argumentField || "arg"],
                            tag: data[options.tagField || "tag"]
                        };
                    this._fillErrorBars(data, pointData, options);
                    return pointData
                },
                _errorBarsEnabled: function() {
                    return this.valueAxisType !== DISCRETE && this.valueAxisType !== LOGARITHMIC && this.valueType !== DATETIME
                },
                _fillErrorBars: function(data, pointData, options) {
                    var errorBars = options.valueErrorBar || {};
                    this._errorBarsEnabled() && (pointData.lowError = data[errorBars.lowValueField || LOW_ERROR], pointData.highError = data[errorBars.highValueField || HIGH_ERROR])
                },
                _drawPoint: function(point, markersGroup, labelsGroup, animationEnabled, firstDrawing) {
                    if (point.isInVisibleArea()) {
                        point.clearVisibility();
                        point.draw(this._renderer, markersGroup, labelsGroup, animationEnabled, firstDrawing);
                        this._drawedPoints.push(point)
                    }
                    else
                        point.setInvisibility()
                },
                _clearingAnimation: function(translators, drawComplete) {
                    var that = this,
                        params = {opacity: 0.001},
                        options = {
                            duration: that._defaultDuration,
                            partitionDuration: 0.5
                        };
                    that._labelsGroup && that._labelsGroup.animate(params, options, function() {
                        that._markersGroup && that._markersGroup.animate(params, options, drawComplete)
                    })
                },
                _animate: function(complete) {
                    var that = this,
                        lastPointIndex = that._drawedPoints.length - 1,
                        labelAnimFunc = function() {
                            that._labelsGroup && that._labelsGroup.animate({opacity: 1}, {duration: that._defaultDuration})
                        };
                    _each(that._drawedPoints || [], function(i, p) {
                        p.animate(i === lastPointIndex ? labelAnimFunc : undefined, {
                            translateX: p.x,
                            translateY: p.y
                        })
                    })
                },
                _getPointSize: function() {
                    return this._options.point.visible ? this._options.point.size : DEFAULT_SYMBOL_POINT_SIZE
                },
                _calcMedianValue: function(fusionPoints, valueField) {
                    var result,
                        allValue = _map(fusionPoints, function(point) {
                            return point[valueField]
                        });
                    allValue.sort(function(a, b) {
                        return a - b
                    });
                    result = allValue[_floor(allValue.length / 2)];
                    return _isDefined(result) ? result : null
                },
                _calcErrorBarValues: function(fusionPoints) {
                    if (!fusionPoints.length)
                        return {};
                    var lowValue = fusionPoints[0].lowError,
                        highValue = fusionPoints[0].highError,
                        i = 1,
                        length = fusionPoints.length,
                        lowError,
                        highError;
                    for (i; i < length; i++) {
                        lowError = fusionPoints[i].lowError;
                        highError = fusionPoints[i].highError;
                        if (_isDefined(lowError) && _isDefined(highError)) {
                            lowValue = _min(lowError, lowValue);
                            highValue = _max(highError, highValue)
                        }
                    }
                    return {
                            low: lowValue,
                            high: highValue
                        }
                },
                _fusionPoints: function(fusionPoints, tick, index) {
                    var errorBarValues = this._calcErrorBarValues(fusionPoints);
                    return {
                            value: this._calcMedianValue(fusionPoints, "value"),
                            argument: tick,
                            tag: null,
                            index: index,
                            seriesName: this.name,
                            lowError: errorBarValues.low,
                            highError: errorBarValues.high
                        }
                },
                _endUpdateData: function() {
                    delete this._predefinedPointOptions
                },
                getArgumentField: function() {
                    return this._options.argumentField || "arg"
                },
                getValueFields: function() {
                    var options = this._options,
                        errorBarsOptions = options.valueErrorBar || {},
                        valueFields = [options.valueField || "val"],
                        lowValueField = errorBarsOptions.lowValueField,
                        highValueField = errorBarsOptions.highValueField;
                    _isString(lowValueField) && valueFields.push(lowValueField);
                    _isString(highValueField) && valueFields.push(highValueField);
                    return valueFields
                },
                _calculateErrorBars: function(data) {
                    var that = this,
                        options = that._options,
                        errorBarsOptions = options.valueErrorBar || {},
                        errorBarType = toLowerCase(errorBarsOptions.type + ""),
                        floatErrorValue = parseFloat(errorBarsOptions.value),
                        valueField = that.getValueFields()[0],
                        value,
                        lowValueField = errorBarsOptions.lowValueField || LOW_ERROR,
                        highValueField = errorBarsOptions.highValueField || HIGH_ERROR,
                        valueArray,
                        valueArrayLength,
                        meanValue,
                        processDataItem,
                        addSubError = function(_i, item) {
                            value = item[valueField];
                            item[lowValueField] = value - floatErrorValue;
                            item[highValueField] = value + floatErrorValue
                        };
                    if (!that._errorBarsEnabled() || $.inArray(errorBarType, [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR]) === -1)
                        return;
                    switch (errorBarType) {
                        case FIXED:
                            processDataItem = addSubError;
                            break;
                        case PERCENT:
                            processDataItem = function(_, item) {
                                value = item[valueField];
                                var error = value * floatErrorValue / 100;
                                item[lowValueField] = value - error;
                                item[highValueField] = value + error
                            };
                            break;
                        default:
                            valueArray = $.map(data, function(item) {
                                return item[valueField]
                            });
                            valueArrayLength = valueArray.length;
                            floatErrorValue = floatErrorValue || 1;
                            switch (errorBarType) {
                                case VARIANCE:
                                    floatErrorValue = variance(valueArray, sum(valueArray) / valueArrayLength) * floatErrorValue;
                                    processDataItem = addSubError;
                                    break;
                                case STANDARD_DEVIATION:
                                    meanValue = sum(valueArray) / valueArrayLength,
                                    floatErrorValue = _sqrt(variance(valueArray, meanValue)) * floatErrorValue;
                                    processDataItem = function(_, item) {
                                        item[lowValueField] = meanValue - floatErrorValue;
                                        item[highValueField] = meanValue + floatErrorValue
                                    };
                                    break;
                                case STANDARD_ERROR:
                                    floatErrorValue = _sqrt(variance(valueArray, sum(valueArray) / valueArrayLength) / valueArrayLength) * floatErrorValue;
                                    processDataItem = addSubError;
                                    break
                            }
                    }
                    processDataItem && _each(data, processDataItem)
                },
                _beginUpdateData: function(data) {
                    this._calculateErrorBars(data)
                }
            };
        chartSeries.scatter = _extend({}, baseScatterMethods, {
            drawTrackers: function() {
                var that = this,
                    trackers,
                    trackersGroup,
                    segments = that._segments || [],
                    rotated = that._options.rotated,
                    cat = [];
                if (!that.isVisible())
                    return;
                if (segments.length) {
                    trackers = that._trackers = that._trackers || [];
                    trackersGroup = that._trackersGroup = (that._trackersGroup || that._renderer.g().attr({
                        fill: "gray",
                        opacity: 0.001,
                        stroke: "gray",
                        "class": "dxc-trackers"
                    })).attr({clipId: this._paneClipRectID || null}).append(that._group);
                    _each(segments, function(i, segment) {
                        if (!trackers[i]) {
                            trackers[i] = that._drawTrackerElement(segment).append(trackersGroup);
                            $(trackers[i].element).data({series: that})
                        }
                        else
                            that._updateTrackerElement(segment, trackers[i])
                    })
                }
                that._trackersTranslator = cat;
                _each(that.getVisiblePoints(), function(_, p) {
                    var pointCoord = parseInt(rotated ? p.vy : p.vx);
                    if (!cat[pointCoord])
                        cat[pointCoord] = p;
                    else
                        $.isArray(cat[pointCoord]) ? cat[pointCoord].push(p) : cat[pointCoord] = [cat[pointCoord], p]
                })
            },
            getNeighborPoint: function(x, y) {
                var pCoord = this._options.rotated ? y : x,
                    nCoord = pCoord,
                    cat = this._trackersTranslator,
                    point = null,
                    minDistance,
                    oppositeCoord = this._options.rotated ? x : y,
                    opositeCoordName = this._options.rotated ? "vx" : "vy";
                if (cat) {
                    point = cat[pCoord];
                    do {
                        point = cat[nCoord] || cat[pCoord];
                        pCoord--;
                        nCoord++
                    } while ((pCoord >= 0 || nCoord < cat.length) && !point);
                    if ($.isArray(point)) {
                        minDistance = _abs(point[0][opositeCoordName] - oppositeCoord);
                        _each(point, function(i, p) {
                            var distance = _abs(p[opositeCoordName] - oppositeCoord);
                            if (minDistance >= distance) {
                                minDistance = distance;
                                point = p
                            }
                        })
                    }
                }
                return point
            }
        });
        series.mixins.polar.scatter = _extend({}, baseScatterMethods, {
            drawTrackers: function() {
                chartSeries.scatter.drawTrackers.call(this);
                var cat = this._trackersTranslator,
                    index;
                if (!this.isVisible())
                    return;
                _each(cat, function(i, category) {
                    if (category) {
                        index = i;
                        return false
                    }
                });
                cat[index + 360] = cat[index]
            },
            getNeighborPoint: function(x, y) {
                var pos = this.translators.untranslate(x, y);
                return chartSeries.scatter.getNeighborPoint.call(this, pos.phi, pos.r)
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file lineSeries.js */
    (function($, DX) {
        var core = DX.viz.core,
            series = core.series,
            chartSeries = series.mixins.chart,
            polarSeries = series.mixins.polar,
            utils = DX.utils,
            scatterSeries = chartSeries.scatter,
            rangeCalculator = core.series.helpers.rangeDataCalculator,
            CANVAS_POSITION_START = "canvas_position_start",
            CANVAS_POSITION_TOP = "canvas_position_top",
            DISCRETE = "discrete",
            _extend = $.extend,
            _map = $.map,
            _abs = Math.abs,
            _each = $.each;
        function clonePoint(point, newX, newY, newAngle) {
            var p = utils.clone(point);
            p.x = newX;
            p.y = newY;
            p.angle = newAngle;
            return p
        }
        function getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {
            var currectAngle = point.angle + nextStepAngle,
                cossin = utils.getCosAndSin(currectAngle),
                x = centerPoint.x + (point.radius + tan * nextStepAngle) * cossin.cos,
                y = centerPoint.y - (point.radius + tan * nextStepAngle) * cossin.sin;
            return clonePoint(prevPoint, x, y, currectAngle)
        }
        var lineMethods = {
                _createElementsGroup: function(elementsStyle) {
                    var that = this,
                        settings = _extend({"class": "dxc-elements"}, elementsStyle);
                    that._applyElementsClipRect(settings);
                    that._createGroup("_elementsGroup", that, that._group, settings)
                },
                _createBordersGroup: function(borderStyle) {
                    var that = this,
                        settings = _extend({"class": "dxc-borders"}, borderStyle);
                    that._applyElementsClipRect(settings);
                    that._createGroup("_bordersGroup", that, that._group, settings)
                },
                _createGroups: function(animationEnabled, style) {
                    var that = this,
                        style = style || that._styles.normal;
                    that._createElementsGroup(style.elements);
                    that._areBordersVisible() && that._createBordersGroup(style.border);
                    scatterSeries._createGroups.call(that, animationEnabled, {});
                    animationEnabled && that._markersGroup && that._markersGroup.attr({opacity: 0.001})
                },
                _areBordersVisible: function() {
                    return false
                },
                _getDefaultSegment: function(segment) {
                    return {line: _map(segment.line || [], function(pt) {
                                return pt.getDefaultCoords()
                            })}
                },
                _prepareSegment: function(points) {
                    return {line: points}
                },
                _parseLineOptions: function(options, defaultColor) {
                    return {
                            stroke: options.color || defaultColor,
                            "stroke-width": options.width,
                            dashStyle: options.dashStyle || 'solid'
                        }
                },
                _parseStyle: function(options, defaultColor) {
                    return {elements: this._parseLineOptions(options, defaultColor)}
                },
                _applyStyle: function(style) {
                    var that = this;
                    that._elementsGroup && that._elementsGroup.attr(style.elements);
                    _each(that._graphics || [], function(_, graphic) {
                        graphic.line && graphic.line.attr({'stroke-width': style.elements["stroke-width"]}).sharp()
                    })
                },
                _drawElement: function(segment, group) {
                    return {line: this._createMainElement(segment.line, {"stroke-width": this._styles.normal.elements["stroke-width"]}).append(group)}
                },
                _removeElement: function(element) {
                    element.line.remove()
                },
                _generateDefaultSegments: function() {
                    var that = this;
                    return _map(that._segments || [], function(segment) {
                            return that._getDefaultSegment(segment)
                        })
                },
                _updateElement: function(element, segment, animate, animateParams, complete) {
                    var params = {points: segment.line},
                        lineElement = element.line;
                    animate ? lineElement.animate(params, animateParams, complete) : lineElement.attr(params)
                },
                _clearingAnimation: function(translator, drawComplete) {
                    var that = this,
                        lastIndex = that._graphics.length - 1,
                        settings = {opacity: 0.001},
                        options = {
                            duration: that._defaultDuration,
                            partitionDuration: 0.5
                        };
                    that._labelsGroup && that._labelsGroup.animate(settings, options, function() {
                        that._markersGroup && that._markersGroup.animate(settings, options, function() {
                            _each(that._defaultSegments || [], function(i, segment) {
                                that._oldUpdateElement(that._graphics[i], segment, true, {partitionDuration: 0.5}, i === lastIndex ? drawComplete : undefined)
                            })
                        })
                    })
                },
                _animate: function() {
                    var that = this,
                        lastIndex = that._graphics.length - 1;
                    _each(that._graphics || [], function(i, elem) {
                        that._updateElement(elem, that._segments[i], true, {complete: i === lastIndex ? function() {
                                that._labelsGroup && that._labelsGroup.animate({opacity: 1}, {duration: that._defaultDuration});
                                that._markersGroup && that._markersGroup.animate({opacity: 1}, {duration: that._defaultDuration})
                            } : undefined})
                    })
                },
                _drawPoint: function(point, group, labelsGroup) {
                    scatterSeries._drawPoint.call(this, point, group, labelsGroup)
                },
                _createMainElement: function(points, settings) {
                    return this._renderer.path(points, "line").attr(settings).sharp()
                },
                _drawSegment: function(points, animationEnabled, segmentCount, lastSegment) {
                    var that = this,
                        segment = that._prepareSegment(points, that._options.rotated, lastSegment);
                    that._segments.push(segment);
                    if (!that._graphics[segmentCount])
                        that._graphics[segmentCount] = that._drawElement(animationEnabled ? that._getDefaultSegment(segment) : segment, that._elementsGroup);
                    else if (!animationEnabled)
                        that._updateElement(that._graphics[segmentCount], segment)
                },
                _getTrackerSettings: function() {
                    var that = this,
                        elements = that._styles.normal.elements;
                    return {
                            "stroke-width": elements["stroke-width"] > that._defaultTrackerWidth ? elements["stroke-width"] : that._defaultTrackerWidth,
                            fill: "none"
                        }
                },
                _getMainPointsFromSegment: function(segment) {
                    return segment.line
                },
                _drawTrackerElement: function(segment) {
                    return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment))
                },
                _updateTrackerElement: function(segment, element) {
                    var settings = this._getTrackerSettings(segment);
                    settings.points = this._getMainPointsFromSegment(segment);
                    element.attr(settings)
                }
            };
        chartSeries.line = _extend({}, scatterSeries, lineMethods);
        chartSeries.stepline = _extend({}, chartSeries.line, {
            _calculateStepLinePoints: function(points) {
                var segment = [];
                _each(points, function(i, pt) {
                    var stepY;
                    if (!i) {
                        segment.push(pt);
                        return
                    }
                    stepY = segment[segment.length - 1].y;
                    if (stepY !== pt.y) {
                        var point = utils.clone(pt);
                        point.y = stepY;
                        segment.push(point)
                    }
                    segment.push(pt)
                });
                return segment
            },
            _prepareSegment: function(points) {
                return chartSeries.line._prepareSegment(this._calculateStepLinePoints(points))
            }
        });
        chartSeries.stackedline = _extend({}, chartSeries.line, {});
        chartSeries.fullstackedline = _extend({}, chartSeries.line, {_getRangeData: function(zoomArgs, calcIntervalFunction) {
                var that = this;
                rangeCalculator.calculateRangeData(that, zoomArgs, calcIntervalFunction);
                rangeCalculator.addLabelPaddings(that);
                rangeCalculator.processFullStackedRange(that);
                return that._rangeData
            }});
        chartSeries.spline = _extend({}, chartSeries.line, {
            _calculateBezierPoints: function(src, rotated) {
                var bezierPoints = [],
                    pointsCopy = src;
                var checkExtr = function(otherPointCoord, pointCoord, controlCoord) {
                        return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord
                    };
                if (pointsCopy.length !== 1)
                    _each(pointsCopy, function(i, curPoint) {
                        var leftControlX,
                            leftControlY,
                            rightControlX,
                            rightControlY,
                            prevPoint,
                            nextPoint,
                            xCur,
                            yCur,
                            x1,
                            x2,
                            y1,
                            y2,
                            delta,
                            lambda = 0.5,
                            curIsExtremum,
                            leftPoint,
                            rightPoint,
                            a,
                            b,
                            c,
                            xc,
                            yc,
                            shift;
                        if (!i) {
                            bezierPoints.push(curPoint);
                            bezierPoints.push(curPoint);
                            return
                        }
                        prevPoint = pointsCopy[i - 1];
                        if (i < pointsCopy.length - 1) {
                            nextPoint = pointsCopy[i + 1];
                            xCur = curPoint.x;
                            yCur = curPoint.y;
                            x1 = prevPoint.x;
                            x2 = nextPoint.x;
                            y1 = prevPoint.y;
                            y2 = nextPoint.y;
                            curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));
                            if (curIsExtremum)
                                if (!rotated) {
                                    rightControlY = leftControlY = yCur;
                                    rightControlX = (xCur + nextPoint.x) / 2;
                                    leftControlX = (xCur + prevPoint.x) / 2
                                }
                                else {
                                    rightControlX = leftControlX = xCur;
                                    rightControlY = (yCur + nextPoint.y) / 2;
                                    leftControlY = (yCur + prevPoint.y) / 2
                                }
                            else {
                                a = y2 - y1;
                                b = x1 - x2;
                                c = y1 * x2 - x1 * y2;
                                if (!rotated) {
                                    xc = xCur;
                                    yc = -1 * (a * xc + c) / b;
                                    shift = yc - yCur || 0;
                                    y1 -= shift;
                                    y2 -= shift
                                }
                                else {
                                    yc = yCur;
                                    xc = -1 * (b * yc + c) / a;
                                    shift = xc - xCur || 0;
                                    x1 -= shift;
                                    x2 -= shift
                                }
                                rightControlX = (xCur + lambda * x2) / (1 + lambda);
                                rightControlY = (yCur + lambda * y2) / (1 + lambda);
                                leftControlX = (xCur + lambda * x1) / (1 + lambda);
                                leftControlY = (yCur + lambda * y1) / (1 + lambda)
                            }
                            if (!rotated) {
                                leftControlY = checkExtr(prevPoint.y, yCur, leftControlY);
                                rightControlY = checkExtr(nextPoint.y, yCur, rightControlY)
                            }
                            else {
                                leftControlX = checkExtr(prevPoint.x, xCur, leftControlX);
                                rightControlX = checkExtr(nextPoint.x, xCur, rightControlX)
                            }
                            leftPoint = clonePoint(curPoint, leftControlX, leftControlY);
                            rightPoint = clonePoint(curPoint, rightControlX, rightControlY);
                            bezierPoints.push(leftPoint, curPoint, rightPoint)
                        }
                        else {
                            bezierPoints.push(curPoint, curPoint);
                            return
                        }
                    });
                else
                    bezierPoints.push(pointsCopy[0]);
                return bezierPoints
            },
            _prepareSegment: function(points, rotated) {
                return chartSeries.line._prepareSegment(this._calculateBezierPoints(points, rotated))
            },
            _createMainElement: function(points, settings) {
                return this._renderer.path(points, "bezier").attr(settings).sharp()
            }
        });
        polarSeries.line = _extend({}, polarSeries.scatter, lineMethods, {
            _prepareSegment: function(points, rotated, lastSegment) {
                var preparedPoints = [],
                    centerPoint = this.translators.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP),
                    i;
                lastSegment && this._closeSegment(points);
                if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {
                    for (i = 1; i < points.length; i++)
                        preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint));
                    if (!preparedPoints.length)
                        preparedPoints = points
                }
                else
                    return chartSeries.line._prepareSegment.apply(this, arguments);
                return {line: preparedPoints}
            },
            _closeSegment: function(points) {
                var point;
                if (this._segments.length)
                    point = this._segments[0].line[0];
                else
                    point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);
                if (points[points.length - 1].angle !== point.angle) {
                    point.angle = points[points.length - 1].angle - utils.normalizeAngle(points[points.length - 1].angle) + utils.normalizeAngle(point.angle);
                    points.push(point)
                }
            },
            _getTangentPoints: function(point, prevPoint, centerPoint) {
                var tangentPoints = [],
                    betweenAngle = prevPoint.angle - point.angle,
                    tan = (prevPoint.radius - point.radius) / betweenAngle,
                    i;
                if (betweenAngle === 0)
                    tangentPoints = [prevPoint, point];
                else if (betweenAngle > 0)
                    for (i = betweenAngle; i >= 0; i--)
                        tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i));
                else
                    for (i = 0; i >= betweenAngle; i--)
                        tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i));
                return tangentPoints
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file areaSeries.js */
    (function($, DX) {
        var core = DX.viz.core,
            utils = DX.utils,
            series = core.series,
            chartSeries = series.mixins.chart,
            polarSeries = series.mixins.polar,
            lineSeries = chartSeries.line,
            rangeCalculator = core.series.helpers.rangeDataCalculator,
            _map = $.map,
            _extend = $.extend,
            HOVER_COLOR_HIGHLIGHTING = 20;
        var baseAreaMethods = {
                _createBorderElement: lineSeries._createMainElement,
                _createLegendState: function(styleOptions, defaultColor) {
                    var legendState = chartSeries.scatter._createLegendState.call(this, styleOptions, defaultColor);
                    legendState.opacity = styleOptions.opacity;
                    return legendState
                },
                _getSpecialColor: function(color) {
                    return this._options._IE8 ? new DX.Color(color).highlight(HOVER_COLOR_HIGHLIGHTING) : color
                },
                _getRangeData: function(zoomArgs, calcIntervalFunction) {
                    rangeCalculator.calculateRangeData(this, zoomArgs, calcIntervalFunction);
                    rangeCalculator.addLabelPaddings(this);
                    rangeCalculator.calculateRangeMinValue(this, zoomArgs);
                    return this._rangeData
                },
                _getDefaultSegment: function(segment) {
                    var defaultSegment = lineSeries._getDefaultSegment(segment);
                    defaultSegment.area = defaultSegment.line.concat(defaultSegment.line.slice().reverse());
                    return defaultSegment
                },
                _updateElement: function(element, segment, animate, animateParams, complete) {
                    var lineParams = {points: segment.line},
                        areaParams = {points: segment.area},
                        borderElement = element.line;
                    if (animate) {
                        borderElement && borderElement.animate(lineParams, animateParams);
                        element.area.animate(areaParams, animateParams, complete)
                    }
                    else {
                        borderElement && borderElement.attr(lineParams);
                        element.area.attr(areaParams)
                    }
                },
                _removeElement: function(element) {
                    element.line && element.line.remove();
                    element.area.remove()
                },
                _drawElement: function(segment, group) {
                    return {
                            line: this._bordersGroup && this._createBorderElement(segment.line, {"stroke-width": this._styles.normal.border["stroke-width"]}).append(this._bordersGroup),
                            area: this._createMainElement(segment.area).append(this._elementsGroup)
                        }
                },
                _applyStyle: function(style) {
                    var that = this;
                    that._elementsGroup && that._elementsGroup.attr(style.elements);
                    that._bordersGroup && that._bordersGroup.attr(style.border);
                    $.each(that._graphics || [], function(_, graphic) {
                        graphic.line && graphic.line.attr({'stroke-width': style.border["stroke-width"]}).sharp()
                    })
                },
                _createPattern: function(color, hatching) {
                    if (hatching && utils.isObject(hatching)) {
                        var pattern = this._renderer.pattern(color, hatching);
                        this._patterns.push(pattern);
                        return pattern.id
                    }
                    return color
                },
                _parseStyle: function(options, defaultColor, defaultBorderColor) {
                    var borderOptions = options.border || {},
                        borderStyle = lineSeries._parseLineOptions(borderOptions, defaultBorderColor);
                    borderStyle["stroke-width"] = borderOptions.visible ? borderStyle["stroke-width"] : 0;
                    return {
                            border: borderStyle,
                            elements: {
                                stroke: "none",
                                fill: this._createPattern(options.color || defaultColor, options.hatching),
                                opacity: options.opacity
                            }
                        }
                },
                _areBordersVisible: function() {
                    var options = this._options;
                    return options.border.visible || options.hoverStyle.border.visible || options.selectionStyle.border.visible
                },
                _createMainElement: function(points, settings) {
                    return this._renderer.path(points, "area").attr(settings)
                },
                _getTrackerSettings: function(segment) {
                    return {"stroke-width": segment.singlePointSegment ? this._defaultTrackerWidth : 0}
                },
                _getMainPointsFromSegment: function(segment) {
                    return segment.area
                }
            };
        chartSeries.area = _extend({}, lineSeries, baseAreaMethods, {
            _prepareSegment: function(points, rotated) {
                var processedPoints = this._processSinglePointsAreaSegment(points, rotated);
                return {
                        line: processedPoints,
                        area: _map(processedPoints, function(pt) {
                            return pt.getCoords()
                        }).concat(_map(processedPoints.slice().reverse(), function(pt) {
                            return pt.getCoords(true)
                        })),
                        singlePointSegment: processedPoints !== points
                    }
            },
            _processSinglePointsAreaSegment: function(points, rotated) {
                if (points.length == 1) {
                    var p = points[0],
                        p1 = utils.clone(p);
                    p1[rotated ? "y" : "x"] += 1;
                    p1.argument = null;
                    return [p, p1]
                }
                return points
            }
        });
        polarSeries.area = _extend({}, polarSeries.line, baseAreaMethods, {
            _prepareSegment: function(points, rotated, lastSegment) {
                lastSegment && polarSeries.line._closeSegment.call(this, points);
                var preparedPoints = chartSeries.area._prepareSegment.call(this, points);
                return preparedPoints
            },
            _processSinglePointsAreaSegment: function(points) {
                return polarSeries.line._prepareSegment.call(this, points).line
            }
        });
        chartSeries.steparea = _extend({}, chartSeries.area, {_prepareSegment: function(points, rotated) {
                points = chartSeries.area._processSinglePointsAreaSegment(points, rotated);
                return chartSeries.area._prepareSegment.call(this, chartSeries.stepline._calculateStepLinePoints(points))
            }});
        chartSeries.splinearea = _extend({}, chartSeries.area, {
            _areaPointsToSplineAreaPoints: function(areaPoints) {
                var lastFwPoint = areaPoints[areaPoints.length / 2 - 1],
                    firstBwPoint = areaPoints[areaPoints.length / 2];
                areaPoints.splice(areaPoints.length / 2, 0, {
                    x: lastFwPoint.x,
                    y: lastFwPoint.y
                }, {
                    x: firstBwPoint.x,
                    y: firstBwPoint.y
                });
                if (lastFwPoint.defaultCoords)
                    areaPoints[areaPoints.length / 2].defaultCoords = true;
                if (firstBwPoint.defaultCoords)
                    areaPoints[areaPoints.length / 2 - 1].defaultCoords = true
            },
            _prepareSegment: function(points, rotated) {
                var areaSeries = chartSeries.area,
                    processedPoints = areaSeries._processSinglePointsAreaSegment(points, rotated),
                    areaSegment = areaSeries._prepareSegment.call(this, chartSeries.spline._calculateBezierPoints(processedPoints, rotated));
                this._areaPointsToSplineAreaPoints(areaSegment.area);
                areaSegment.singlePointSegment = processedPoints !== points;
                return areaSegment
            },
            _getDefaultSegment: function(segment) {
                var areaDefaultSegment = chartSeries.area._getDefaultSegment(segment);
                this._areaPointsToSplineAreaPoints(areaDefaultSegment.area);
                return areaDefaultSegment
            },
            _createMainElement: function(points, settings) {
                return this._renderer.path(points, "bezierarea").attr(settings)
            },
            _createBorderElement: chartSeries.spline._createMainElement
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file barSeries.js */
    (function($, DX) {
        var viz = DX.viz,
            series = viz.core.series,
            chartSeries = series.mixins.chart,
            polarSeries = series.mixins.polar,
            scatterSeries = chartSeries.scatter,
            areaSeries = chartSeries.area,
            _extend = $.extend,
            _each = $.each,
            CANVAS_POSITION_START = "canvas_position_start",
            DEFAULT_BAR_POINT_SIZE = 3;
        var baseBarSeriesMethods = {
                _getSpecialColor: areaSeries._getSpecialColor,
                _createPattern: areaSeries._createPattern,
                _updateOptions: function(options) {
                    this._stackName = "axis_" + (options.axis || "default") + "_stack_" + (options.stack || "default")
                },
                _parsePointStyle: function(style, defaultColor, defaultBorderColor) {
                    var color = this._createPattern(style.color || defaultColor, style.hatching),
                        base = scatterSeries._parsePointStyle.call(this, style, color, defaultBorderColor);
                    base.fill = color;
                    base.dashStyle = style.border && style.border.dashStyle || "solid";
                    delete base.r;
                    return base
                },
                _applyMarkerClipRect: function(settings) {
                    settings.clipId = null
                },
                _getAffineCoordOptions: function(translators, grounded) {
                    var rotated = this._options.rotated,
                        settings = that._oldgetAffineCoordOptions(translators) || that._getAffineCoordOptions(translators),
                        direction = rotated ? "x" : "y",
                        y = rotated ? 1 : 0.001,
                        x = rotated ? 0.001 : 1,
                        settings = {
                            scaleX: x,
                            scaleY: y
                        };
                    settings["translate" + direction.toUpperCase()] = translators[direction].translate("canvas_position_default");
                    return settings
                },
                _clearingAnimation: function(translators, drawComplete) {
                    var that = this,
                        settings = that._oldgetAffineCoordOptions(translators) || that._getAffineCoordOptions(translators);
                    that._labelsGroup && that._labelsGroup.animate({opacity: 0.001}, {
                        duration: that._defaultDuration,
                        partitionDuration: 0.5
                    }, function() {
                        that._markersGroup.animate(settings, {partitionDuration: 0.5}, function() {
                            that._markersGroup.attr({
                                scaleX: null,
                                scaleY: null,
                                translateX: 0,
                                translateY: 0
                            });
                            drawComplete()
                        })
                    })
                },
                _createGroups: function(animationEnabled, style, firstDrawing) {
                    var that = this,
                        settings = {};
                    scatterSeries._createGroups.apply(that, arguments);
                    if (animationEnabled && firstDrawing)
                        settings = this._getAffineCoordOptions(that.translators, true);
                    else if (!animationEnabled)
                        settings = {
                            scaleX: 1,
                            scaleY: 1,
                            translateX: 0,
                            translateY: 0
                        };
                    that._markersGroup.attr(settings)
                },
                _drawPoint: function(point, markersGroup, labelsGroup, animationEnabled, firstDrawing) {
                    scatterSeries._drawPoint.call(this, point, markersGroup, labelsGroup, animationEnabled && !firstDrawing)
                },
                _getMainColor: function() {
                    return this._options.mainSeriesColor
                },
                _createPointStyles: function(pointOptions) {
                    var that = this,
                        mainColor = pointOptions.color || that._getMainColor(),
                        specialMainColor = that._getSpecialColor(mainColor);
                    return {
                            normal: that._parsePointStyle(pointOptions, mainColor, mainColor),
                            hover: that._parsePointStyle(pointOptions.hoverStyle || {}, specialMainColor, mainColor),
                            selection: that._parsePointStyle(pointOptions.selectionStyle || {}, specialMainColor, mainColor)
                        }
                },
                _preparePointOptions: function(customOptions) {
                    var options = this._options;
                    return customOptions ? _extend(true, {}, options, customOptions) : options
                },
                _animate: function(firstDrawing) {
                    var that = this,
                        labelsGroup = that._labelsGroup,
                        labelAnimFunc = function() {
                            labelsGroup && labelsGroup.animate({opacity: 1}, {duration: that._defaultDuration})
                        },
                        lastPointIndex;
                    that._markersGroup.animate({
                        scaleX: 1,
                        scaleY: 1,
                        translateY: 0,
                        translateX: 0
                    }, undefined, labelAnimFunc);
                    if (!firstDrawing) {
                        lastPointIndex = that._drawedPoints.length - 1;
                        _each(that._drawedPoints || [], function(i, point) {
                            point.animate(i === lastPointIndex ? labelAnimFunc : undefined, point.getMarkerCoords())
                        })
                    }
                },
                _getPointSize: function() {
                    return DEFAULT_BAR_POINT_SIZE
                }
            };
        chartSeries.bar = _extend({}, scatterSeries, baseBarSeriesMethods, {
            _getAffineCoordOptions: function(translators, grounded) {
                var rotated = this._options.rotated,
                    direction = rotated ? "x" : "y",
                    y = rotated ? 1 : 0.001,
                    x = rotated ? 0.001 : 1,
                    settings = {
                        scaleX: x,
                        scaleY: y
                    };
                if (grounded)
                    settings["translate" + direction.toUpperCase()] = translators[direction].translate("canvas_position_default");
                else
                    settings["translate" + direction.toUpperCase()] = translators[direction].translate("canvas_position_default");
                return settings
            },
            _getRangeData: function(zoomArgs, calcIntervalFunction) {
                var rangeData = areaSeries._getRangeData.apply(this, arguments);
                rangeData.arg.stick = false;
                return rangeData
            }
        });
        polarSeries.bar = _extend({}, polarSeries.scatter, baseBarSeriesMethods, {
            _getAffineCoordOptions: function(translators, grounded) {
                var center = translators.translate(CANVAS_POSITION_START, CANVAS_POSITION_START),
                    settings = {
                        scaleX: .001,
                        scaleY: .001
                    };
                if (grounded) {
                    settings.translateX = center.x;
                    settings.translateY = center.y
                }
                else {
                    settings.translateX = center.x;
                    settings.translateY = center.y
                }
                return settings
            },
            _parsePointStyle: function(style, defaultColor, defaultBorderColor) {
                var base = chartSeries.bar._parsePointStyle.call(this, style, defaultColor, defaultBorderColor);
                base.opacity = style.opacity;
                return base
            },
            _createMarkerGroup: function() {
                var that = this,
                    markersSettings = that._getPointOptions().styles.normal,
                    groupSettings;
                markersSettings["class"] = "dxc-markers";
                that._applyMarkerClipRect(markersSettings);
                groupSettings = _extend({}, markersSettings);
                delete groupSettings.opacity;
                that._createGroup("_markersGroup", that, that._group, groupSettings)
            },
            _createLegendState: areaSeries._createLegendState,
            _getRangeData: areaSeries._getRangeData
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file rangeSeries.js */
    (function($, DX) {
        var core = DX.viz.core,
            series = core.series.mixins.chart,
            _extend = $.extend,
            _isDefined = DX.utils.isDefined,
            _map = $.map,
            rangeCalculator = core.series.helpers.rangeDataCalculator,
            areaSeries = series.area;
        var baseRangeSeries = {
                _beginUpdateData: $.noop,
                _checkData: function(data) {
                    return _isDefined(data.argument) && data.value !== undefined && data.minValue !== undefined
                },
                updateTeamplateFieldNames: function() {
                    var that = this,
                        options = that._options,
                        valueFields = that.getValueFields(),
                        name = that.name;
                    options.rangeValue1Field = valueFields[0] + name;
                    options.rangeValue2Field = valueFields[1] + name;
                    options.tagField = that.getTagField() + name
                },
                _processRange: function(point, prevPoint) {
                    rangeCalculator.processTwoValues(this, point, prevPoint, "value", "minValue")
                },
                _getRangeData: function(zoomArgs, calcIntervalFunction) {
                    rangeCalculator.calculateRangeData(this, zoomArgs, calcIntervalFunction, "value", "minValue");
                    rangeCalculator.addRangeSeriesLabelPaddings(this);
                    return this._rangeData
                },
                _getPointData: function(data, options) {
                    return {
                            tag: data[options.tagField || "tag"],
                            minValue: data[options.rangeValue1Field || "val1"],
                            value: data[options.rangeValue2Field || "val2"],
                            argument: data[options.argumentField || "arg"]
                        }
                },
                _fusionPoints: function(fusionPoints, tick, index) {
                    var calcMedianValue = series.scatter._calcMedianValue,
                        value = calcMedianValue.call(this, fusionPoints, "value"),
                        minValue = calcMedianValue.call(this, fusionPoints, "minValue");
                    if (value === null || minValue === null)
                        value = minValue = null;
                    return {
                            minValue: minValue,
                            value: value,
                            argument: tick,
                            tag: null
                        }
                },
                getValueFields: function() {
                    return [this._options.rangeValue1Field || "val1", this._options.rangeValue2Field || "val2"]
                }
            };
        series.rangebar = _extend({}, series.bar, baseRangeSeries);
        series.rangearea = _extend({}, areaSeries, {
            _drawPoint: function(point, markersGroup, labelsGroup, animationEnabled) {
                if (point.isInVisibleArea()) {
                    point.clearVisibility();
                    point.draw(this._renderer, markersGroup, labelsGroup, animationEnabled);
                    this._drawedPoints.push(point);
                    if (!point.visibleTopMarker)
                        point.hideMarker("top");
                    if (!point.visibleBottomMarker)
                        point.hideMarker("bottom")
                }
                else
                    point.setInvisibility()
            },
            _prepareSegment: function(points, rotated) {
                var processedPoints = this._processSinglePointsAreaSegment(points, rotated),
                    processedMinPointsCoords = $.map(processedPoints, function(pt) {
                        return pt.getCoords(true)
                    });
                return {
                        line: processedPoints,
                        bottomLine: processedMinPointsCoords,
                        area: $.map(processedPoints, function(pt) {
                            return pt.getCoords()
                        }).concat(processedMinPointsCoords.slice().reverse()),
                        singlePointSegment: processedPoints !== points
                    }
            },
            _getDefaultSegment: function(segment) {
                var defaultSegment = areaSeries._getDefaultSegment.call(this, segment);
                defaultSegment.bottomLine = defaultSegment.line;
                return defaultSegment
            },
            _removeElement: function(element) {
                areaSeries._removeElement.call(this, element);
                element.bottomLine && element.bottomLine.remove()
            },
            _drawElement: function(segment, group) {
                var that = this,
                    drawnElement = areaSeries._drawElement.call(that, segment, group);
                drawnElement.bottomLine = that._bordersGroup && that._createBorderElement(segment.bottomLine, {"stroke-width": that._styles.normal.border["stroke-width"]}).append(that._bordersGroup);
                return drawnElement
            },
            _applyStyle: function(style) {
                var that = this,
                    elementsGroup = that._elementsGroup,
                    bordersGroup = that._bordersGroup;
                elementsGroup && elementsGroup.attr(style.elements);
                bordersGroup && bordersGroup.attr(style.border);
                $.each(that._graphics || [], function(_, graphic) {
                    graphic.line && graphic.line.attr({"stroke-width": style.border["stroke-width"]});
                    graphic.bottomLine && graphic.bottomLine.attr({"stroke-width": style.border["stroke-width"]})
                })
            },
            _updateElement: function(element, segment, animate, animateParams, complete) {
                areaSeries._updateElement.call(this, element, segment, animate, animateParams, complete);
                var bottomLineParams = {points: segment.bottomLine},
                    bottomBorderElement = element.bottomLine;
                if (bottomBorderElement)
                    animate ? bottomBorderElement.animate(bottomLineParams, animateParams) : bottomBorderElement.attr(bottomLineParams)
            }
        }, baseRangeSeries)
    })(jQuery, DevExpress);
    /*! Module viz-core, file bubbleSeries.js */
    (function($, DX) {
        var mixins = DX.viz.core.series.mixins,
            series = mixins.chart,
            scatterSeries = series.scatter,
            barSeries = series.bar,
            _isDefined = DX.utils.isDefined,
            _extend = $.extend,
            _each = $.each,
            _noop = $.noop;
        series.bubble = _extend({}, scatterSeries, {
            _fillErrorBars: _noop,
            _getRangeCorrector: _noop,
            _calculateErrorBars: _noop,
            _getMainColor: barSeries._getMainColor,
            _createPointStyles: barSeries._createPointStyles,
            _createPattern: barSeries._createPattern,
            _preparePointOptions: barSeries._preparePointOptions,
            _getSpecialColor: barSeries._getSpecialColor,
            _applyMarkerClipRect: series.line._applyElementsClipRect,
            _parsePointStyle: mixins.polar.bar._parsePointStyle,
            _createLegendState: series.area._createLegendState,
            _createMarkerGroup: mixins.polar.bar._createMarkerGroup,
            _checkData: function(data) {
                return _isDefined(data.argument) && _isDefined(data.size) && data.value !== undefined
            },
            _getPointData: function(data, options) {
                var pointData = scatterSeries._getPointData.call(this, data, options);
                pointData.size = data[options.sizeField || "size"];
                return pointData
            },
            _fusionPoints: function(fusionPoints, tick, index) {
                var calcMedianValue = scatterSeries._calcMedianValue;
                return {
                        size: calcMedianValue.call(this, fusionPoints, "size"),
                        value: calcMedianValue.call(this, fusionPoints, "value"),
                        argument: tick,
                        tag: null
                    }
            },
            getValueFields: function() {
                var options = this._options;
                return [options.valueField || "val", options.sizeField || "size"]
            },
            updateTeamplateFieldNames: function() {
                var that = this,
                    options = that._options,
                    valueFields = that.getValueFields(),
                    name = that.name;
                options.valueField = valueFields[0] + name;
                options.sizeField = valueFields[1] + name;
                options.tagField = that.getTagField() + name
            },
            _clearingAnimation: function(translators, drawComplete) {
                var that = this,
                    partitionDuration = 0.5,
                    lastPointIndex = that._drawedPoints.length - 1,
                    labelsGroup = that._labelsGroup;
                labelsGroup && labelsGroup.animate({opacity: 0.001}, {
                    duration: that._defaultDuration,
                    partitionDuration: partitionDuration
                }, function() {
                    _each(that._drawedPoints || [], function(i, p) {
                        p.animate(i === lastPointIndex ? drawComplete : undefined, {r: 0}, partitionDuration)
                    })
                })
            },
            _animate: function(firstDrawing) {
                var that = this,
                    lastPointIndex = that._drawedPoints.length - 1,
                    labelsGroup = that._labelsGroup,
                    labelAnimFunc = function() {
                        labelsGroup && labelsGroup.animate({opacity: 1}, {duration: that._defaultDuration})
                    };
                _each(that._drawedPoints || [], function(i, p) {
                    p.animate(i === lastPointIndex ? labelAnimFunc : undefined, {
                        r: p.bubbleSize,
                        translateX: p.x,
                        translateY: p.y
                    })
                })
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file pieSeries.js */
    (function($, DX) {
        var mixins = DX.viz.core.series.mixins,
            pieSeries = mixins.pie,
            _utils = DX.utils,
            scatterSeries = mixins.chart.scatter,
            barSeries = mixins.chart.bar,
            _extend = $.extend,
            _each = $.each,
            _noop = $.noop,
            _map = $.map,
            _isFinite = isFinite,
            _max = Math.max,
            _sqrt = Math.sqrt,
            _pow = Math.pow,
            _round = Math.round;
        pieSeries.pie = _extend({}, barSeries, {
            _createLabelGroup: scatterSeries._createLabelGroup,
            _createGroups: scatterSeries._createGroups,
            _drawPoint: function(point) {
                scatterSeries._drawPoint.apply(this, arguments);
                !point.isVisible() && point.setInvisibility()
            },
            _adjustLabels: function() {
                var that = this,
                    points = that._points || [],
                    maxLabelLength,
                    labelsBBoxes = [];
                _each(points, function(_, point) {
                    if (point._label.hasText() && point._label.getLayoutOptions().position !== "inside") {
                        point.setLabelEllipsis();
                        labelsBBoxes.push(point._label.getBoundingRect().width)
                    }
                });
                if (labelsBBoxes.length)
                    maxLabelLength = _max.apply(null, labelsBBoxes);
                _each(points, function(_, point) {
                    if (point._label.hasText() && point._label.getLayoutOptions().position !== "inside") {
                        point._maxLabelLength = maxLabelLength;
                        point.updateLabelCoord()
                    }
                })
            },
            _processRange: _noop,
            _applyElementsClipRect: _noop,
            getColor: _noop,
            _prepareSeriesToDrawing: _noop,
            _endUpdateData: scatterSeries._prepareSeriesToDrawing,
            resetLabelSetups: function() {
                _each(this._points || [], function(_, point) {
                    point._label.clearVisibility()
                })
            },
            drawLabelsWOPoints: function(translators) {
                var that = this,
                    options = that._options,
                    points = that._points || [],
                    labelsGroup;
                if (options.label.position === "inside")
                    return false;
                that._createGroups();
                labelsGroup = that._labelsGroup;
                _each(points, function(_, point) {
                    point.drawLabel(translators, that._renderer, labelsGroup)
                });
                return true
            },
            _getCreatingPointOptions: function() {
                return this._getPointOptions()
            },
            _updateOptions: function(options) {
                this.labelSpace = 0;
                this.innerRadius = this.type === "pie" ? 0 : options.innerRadius
            },
            _checkData: function(data) {
                var base = barSeries._checkData(data);
                return this._options.paintNullPoints ? base : base && data.value !== null
            },
            _createMarkerGroup: function() {
                var that = this;
                if (!that._markersGroup)
                    that._markersGroup = that._renderer.g().attr({"class": "dxc-markers"}).append(that._group)
            },
            _getMainColor: function() {
                return this._options.mainSeriesColor()
            },
            _getPointOptions: function() {
                return this._parsePointOptions(this._preparePointOptions(), this._options.label)
            },
            _getRangeData: function() {
                return this._rangeData
            },
            _getArrangeTotal: function(points) {
                var total = 0;
                _each(points, function(_, point) {
                    if (point.isVisible())
                        total += point.initialValue
                });
                return total
            },
            _createPointStyles: function(pointOptions) {
                var that = this,
                    mainColor = pointOptions.color || that._getMainColor(),
                    specialMainColor = that._getSpecialColor(mainColor);
                return {
                        normal: that._parsePointStyle(pointOptions, mainColor, mainColor),
                        hover: that._parsePointStyle(pointOptions.hoverStyle, specialMainColor, mainColor),
                        selection: that._parsePointStyle(pointOptions.selectionStyle, specialMainColor, mainColor),
                        legendStyles: {
                            normal: that._createLegendState(pointOptions, mainColor),
                            hover: that._createLegendState(pointOptions.hoverStyle, specialMainColor),
                            selection: that._createLegendState(pointOptions.selectionStyle, specialMainColor)
                        }
                    }
            },
            _getArrangeMinShownValue: function(points, total) {
                var minSegmentSize = this._options.minSegmentSize,
                    totalMinSegmentSize = 0,
                    totalNotMinValues = 0;
                total = total || points.length;
                _each(points, function(_, point) {
                    if (point.isVisible())
                        if (point.initialValue < minSegmentSize * total / 360)
                            totalMinSegmentSize += minSegmentSize;
                        else
                            totalNotMinValues += point.initialValue
                });
                return totalMinSegmentSize < 360 ? minSegmentSize * totalNotMinValues / (360 - totalMinSegmentSize) : 0
            },
            _applyArrangeCorrection: function(points, minShownValue, total) {
                var options = this._options,
                    isClockWise = options.segmentsDirection !== "anticlockwise",
                    shiftedAngle = _isFinite(options.startAngle) ? _utils.normalizeAngle(options.startAngle) : 0,
                    minSegmentSize = options.minSegmentSize,
                    percent,
                    correction = 0,
                    zeroTotalCorrection = 0;
                if (total === 0) {
                    total = points.length;
                    zeroTotalCorrection = 1
                }
                _each(isClockWise ? points : points.concat([]).reverse(), function(_, point) {
                    var val = point.isVisible() ? zeroTotalCorrection || point.initialValue : 0,
                        updatedZeroValue;
                    if (minSegmentSize && point.isVisible() && val < minShownValue)
                        updatedZeroValue = minShownValue;
                    percent = val / total;
                    point.correctValue(correction, percent, zeroTotalCorrection + (updatedZeroValue || 0));
                    point.shiftedAngle = shiftedAngle;
                    correction = correction + (updatedZeroValue || val)
                });
                this._rangeData = {val: {
                        min: 0,
                        max: correction
                    }}
            },
            arrangePoints: function() {
                var that = this,
                    minSegmentSize = that._options.minSegmentSize,
                    minShownValue,
                    pointIndex = 0,
                    total,
                    points = that._originalPoints = that._points = _map(that._originalPoints || [], function(point) {
                        if (point.value === null || point.value < 0 || point.value === 0 && !minSegmentSize) {
                            point.dispose();
                            return null
                        }
                        else {
                            point.index = pointIndex++;
                            return point
                        }
                    });
                total = that._getArrangeTotal(points);
                if (minSegmentSize)
                    minShownValue = this._getArrangeMinShownValue(points, total);
                that._applyArrangeCorrection(points, minShownValue, total)
            },
            correctPosition: function(correction) {
                var debug = DX.utils.debug;
                debug.assert(correction, "correction was not passed");
                debug.assertParam(correction.centerX, "correction.centerX was not passed");
                debug.assertParam(correction.centerY, "correction.centerY was not passed");
                debug.assertParam(correction.radiusInner, "correction.radiusInner was not passed");
                debug.assertParam(correction.radiusOuter, "correction.radiusOuter was not passed");
                _each(this._points, function(_, point) {
                    point.correctPosition(correction)
                });
                this._centerX = correction.centerX;
                this._centerY = correction.centerY;
                this._radiusOuter = correction.radiusOuter
            },
            _animate: function(firstDrawing) {
                var that = this,
                    index = 0,
                    timeThreshold = 0.2,
                    points = that._points,
                    pointsCount = points && points.length,
                    duration = 1 / (timeThreshold * (pointsCount - 1) + 1),
                    animateP = function() {
                        points[index] && points[index++].animate(index === pointsCount ? completeFunc : undefined, duration, stepFunc)
                    },
                    stepFunc = function(_, progress) {
                        if (progress >= timeThreshold) {
                            this.step = null;
                            animateP()
                        }
                    },
                    completeFunc = function() {
                        that._labelsGroup && that._labelsGroup.animate({opacity: 1}, {duration: 400})
                    };
                if (firstDrawing)
                    animateP();
                else
                    $.each(points, function(i, p) {
                        p.animate(i == pointsCount - 1 ? completeFunc : undefined)
                    })
            },
            getVisiblePoints: function() {
                return _map(this._points, function(p) {
                        return p.isVisible() ? p : null
                    })
            },
            getPointByCoord: function(x, y) {
                var points = this._points;
                for (var i = 0; i < points.length; i++)
                    if (points[i].coordsIn(x, y))
                        return points[i]
            },
            _beginUpdateData: function() {
                this._deletePatterns();
                this._patterns = []
            }
        });
        pieSeries.doughnut = pieSeries.donut = pieSeries.pie
    })(jQuery, DevExpress);
    /*! Module viz-core, file financialSeries.js */
    (function($, DX) {
        var viz = DX.viz,
            seriesNS = viz.core.series,
            series = seriesNS.mixins.chart,
            scatterSeries = series.scatter,
            barSeries = series.bar,
            rangeCalculator = seriesNS.helpers.rangeDataCalculator,
            _isDefined = DX.utils.isDefined,
            _extend = $.extend,
            _each = $.each,
            _noop = $.noop,
            DEFAULT_FINANCIAL_POINT_SIZE = 10;
        series.stock = _extend({}, scatterSeries, {
            _animate: _noop,
            _applyMarkerClipRect: function(settings) {
                settings.clipId = this._forceClipping ? this._paneClipRectID : this._widePaneClipRectID
            },
            _createPattern: barSeries._createPattern,
            _preparePointOptions: barSeries._preparePointOptions,
            _getRangeCorrector: _noop,
            _createMarkerGroup: function() {
                var that = this,
                    markersGroup,
                    styles = that._getPointOptions().styles,
                    defaultStyle = styles.normal,
                    defaultPositiveStyle = styles.positive.normal,
                    reductionStyle = styles.reduction.normal,
                    reductionPositiveStyle = styles.reductionPositive.normal,
                    markerSettings = {"class": "dxc-markers"};
                that._applyMarkerClipRect(markerSettings);
                defaultStyle["class"] = "default-markers";
                defaultPositiveStyle["class"] = "default-positive-markers";
                reductionStyle["class"] = "reduction-markers";
                reductionPositiveStyle["class"] = "reduction-positive-markers";
                that._createGroup("_markersGroup", that, that._group, markerSettings);
                markersGroup = that._markersGroup;
                that._createGroup("defaultMarkersGroup", markersGroup, markersGroup, defaultStyle);
                that._createGroup("reductionMarkersGroup", markersGroup, markersGroup, reductionStyle);
                that._createGroup("defaultPositiveMarkersGroup", markersGroup, markersGroup, defaultPositiveStyle);
                that._createGroup("reductionPositiveMarkersGroup", markersGroup, markersGroup, reductionPositiveStyle)
            },
            _createGroups: function() {
                scatterSeries._createGroups.call(this, false)
            },
            _clearingAnimation: function(translators, drawComplete) {
                drawComplete()
            },
            _getCreatingPointOptions: function() {
                var that = this,
                    defaultPointOptions,
                    creatingPointOptions = that._predefinedPointOptions;
                if (!creatingPointOptions) {
                    defaultPointOptions = this._getPointOptions();
                    that._predefinedPointOptions = creatingPointOptions = _extend(true, {styles: {}}, defaultPointOptions);
                    creatingPointOptions.styles.normal = creatingPointOptions.styles.positive.normal = creatingPointOptions.styles.reduction.normal = creatingPointOptions.styles.reductionPositive.normal = {"stroke-width": defaultPointOptions.styles && defaultPointOptions.styles.normal && defaultPointOptions.styles.normal["stroke-width"]}
                }
                return creatingPointOptions
            },
            _checkData: function(data) {
                return _isDefined(data.argument) && data.highValue !== undefined && data.lowValue !== undefined && data.openValue !== undefined && data.closeValue !== undefined
            },
            _processRange: function(point, prevPoint) {
                rangeCalculator.processTwoValues(this, point, prevPoint, "highValue", "lowValue")
            },
            _getRangeData: function(zoomArgs, calcIntervalFunction) {
                rangeCalculator.calculateRangeData(this, zoomArgs, calcIntervalFunction, "highValue", "lowValue");
                rangeCalculator.addRangeSeriesLabelPaddings(this);
                return this._rangeData
            },
            _getPointData: function(data, options) {
                var that = this,
                    level,
                    openValueField = options.openValueField || "open",
                    closeValueField = options.closeValueField || "close",
                    highValueField = options.highValueField || "high",
                    lowValueField = options.lowValueField || "low",
                    reductionValue;
                that.level = options.reduction.level;
                switch ((that.level || "").toLowerCase()) {
                    case"open":
                        level = openValueField;
                        break;
                    case"high":
                        level = highValueField;
                        break;
                    case"low":
                        level = lowValueField;
                        break;
                    default:
                        level = closeValueField;
                        that.level = "close";
                        break
                }
                reductionValue = data[level];
                return {
                        argument: data[options.argumentField || "date"],
                        highValue: data[highValueField],
                        lowValue: data[lowValueField],
                        closeValue: data[closeValueField],
                        openValue: data[openValueField],
                        reductionValue: reductionValue,
                        tag: data[options.tagField || "tag"],
                        isReduction: that._checkReduction(reductionValue)
                    }
            },
            _parsePointStyle: function(style, defaultColor, innerColor) {
                return {
                        stroke: style.color || defaultColor,
                        "stroke-width": style.width,
                        fill: style.color || innerColor
                    }
            },
            updateTeamplateFieldNames: function() {
                var that = this,
                    options = that._options,
                    valueFields = that.getValueFields(),
                    name = that.name;
                options.openValueField = valueFields[0] + name;
                options.highValueField = valueFields[1] + name;
                options.lowValueField = valueFields[2] + name;
                options.closeValueField = valueFields[3] + name;
                options.tagField = that.getTagField() + name
            },
            _getDefaultStyle: function(options) {
                var that = this,
                    mainPointColor = options.color || that._options.mainSeriesColor;
                return {
                        normal: that._parsePointStyle(options, mainPointColor, mainPointColor),
                        hover: that._parsePointStyle(options.hoverStyle, mainPointColor, mainPointColor),
                        selection: that._parsePointStyle(options.selectionStyle, mainPointColor, mainPointColor)
                    }
            },
            _getReductionStyle: function(options) {
                var that = this,
                    reductionColor = options.reduction.color;
                return {
                        normal: that._parsePointStyle({
                            color: reductionColor,
                            width: options.width,
                            hatching: options.hatching
                        }, reductionColor, reductionColor),
                        hover: that._parsePointStyle(options.hoverStyle, reductionColor, reductionColor),
                        selection: that._parsePointStyle(options.selectionStyle, reductionColor, reductionColor)
                    }
            },
            _createPointStyles: function(pointOptions) {
                var that = this,
                    innerColor = that._options.innerColor,
                    styles = that._getDefaultStyle(pointOptions),
                    positiveStyle,
                    reductionStyle,
                    reductionPositiveStyle;
                positiveStyle = _extend(true, {}, styles);
                reductionStyle = that._getReductionStyle(pointOptions);
                reductionPositiveStyle = _extend(true, {}, reductionStyle);
                positiveStyle.normal.fill = positiveStyle.hover.fill = positiveStyle.selection.fill = innerColor;
                reductionPositiveStyle.normal.fill = reductionPositiveStyle.hover.fill = reductionPositiveStyle.selection.fill = innerColor;
                styles.positive = positiveStyle;
                styles.reduction = reductionStyle;
                styles.reductionPositive = reductionPositiveStyle;
                return styles
            },
            _endUpdateData: function() {
                delete this.prevLevelValue;
                delete this._predefinedPointOptions
            },
            _checkReduction: function(value) {
                var that = this,
                    result = false;
                if (value != null) {
                    if (_isDefined(that.prevLevelValue))
                        result = value < that.prevLevelValue;
                    that.prevLevelValue = value
                }
                return result
            },
            _fusionPoints: function(fusionPoints, tick, nowIndexTicks) {
                var fusedPointData = {},
                    reductionLevel,
                    highValue = -Infinity,
                    lowValue = +Infinity,
                    openValue,
                    closeValue;
                if (!fusionPoints.length)
                    return {};
                _each(fusionPoints, function(_, point) {
                    if (!point.hasValue())
                        return;
                    highValue = Math.max(highValue, point.highValue);
                    lowValue = Math.min(lowValue, point.lowValue);
                    openValue = openValue !== undefined ? openValue : point.openValue;
                    closeValue = point.closeValue !== undefined ? point.closeValue : closeValue
                });
                fusedPointData.argument = tick;
                fusedPointData.openValue = openValue;
                fusedPointData.closeValue = closeValue;
                fusedPointData.highValue = highValue;
                fusedPointData.lowValue = lowValue;
                fusedPointData.tag = null;
                switch ((this.level || "").toLowerCase()) {
                    case"open":
                        reductionLevel = openValue;
                        break;
                    case"high":
                        reductionLevel = highValue;
                        break;
                    case"low":
                        reductionLevel = lowValue;
                        break;
                    default:
                        reductionLevel = closeValue;
                        break
                }
                fusedPointData.reductionValue = reductionLevel;
                fusedPointData.isReduction = this._checkReduction(reductionLevel);
                return fusedPointData
            },
            _getPointSize: function() {
                return DEFAULT_FINANCIAL_POINT_SIZE
            },
            getValueFields: function() {
                var options = this._options;
                return [options.openValueField || "open", options.highValueField || "high", options.lowValueField || "low", options.closeValueField || "close"]
            },
            getArgumentField: function() {
                return this._options.argumentField || "date"
            },
            _beginUpdateData: _noop
        });
        series.candlestick = _extend({}, series.stock, {_parsePointStyle: function(style, defaultColor, innerColor) {
                var color = this._createPattern(style.color || innerColor, style.hatching),
                    base = series.stock._parsePointStyle.call(this, style, defaultColor, color);
                base.fill = color;
                return base
            }})
    })(jQuery, DevExpress);
    /*! Module viz-core, file stackedSeries.js */
    (function($, DX) {
        var core = DX.viz.core,
            series = core.series,
            chartSeries = series.mixins.chart,
            polarSeries = series.mixins.polar,
            areaSeries = chartSeries.area,
            barSeries = chartSeries.bar,
            lineSeries = chartSeries.line,
            rangeCalculator = core.series.helpers.rangeDataCalculator,
            _extend = $.extend,
            utils = DX.utils,
            _noop = $.noop,
            baseStackedSeries = {
                _processRange: _noop,
                _getRangeCorrector: _noop,
                _fillErrorBars: _noop,
                _calculateErrorBars: _noop,
                _processStackedRange: function() {
                    var that = this,
                        prevPoint;
                    that._resetRangeData();
                    $.each(that.getAllPoints(), function(i, p) {
                        rangeCalculator.processRange(that, p, prevPoint);
                        prevPoint = p
                    })
                },
                _getRangeData: function() {
                    this._processStackedRange();
                    return areaSeries._getRangeData.apply(this, arguments)
                }
            },
            baseFullStackedSeries = _extend({}, baseStackedSeries, {
                _getRangeData: function(zoomArgs, calcIntervalFunction) {
                    var that = this;
                    that._processStackedRange();
                    rangeCalculator.calculateRangeData(that, zoomArgs, calcIntervalFunction);
                    rangeCalculator.addLabelPaddings(that);
                    rangeCalculator.processFullStackedRange(that);
                    rangeCalculator.calculateRangeMinValue(that, zoomArgs);
                    return that._rangeData
                },
                isFullStackedSeries: function() {
                    return true
                }
            });
        chartSeries.stackedline = _extend({}, lineSeries, baseStackedSeries, {_getRangeData: function() {
                this._processStackedRange();
                return lineSeries._getRangeData.apply(this, arguments)
            }});
        chartSeries.stackedspline = _extend({}, chartSeries.spline, baseStackedSeries, {_getRangeData: chartSeries.stackedline._getRangeData});
        chartSeries.fullstackedline = _extend({}, lineSeries, baseFullStackedSeries, {_getRangeData: function(zoomArgs, calcIntervalFunction) {
                var that = this;
                that._processStackedRange();
                rangeCalculator.calculateRangeData(that, zoomArgs, calcIntervalFunction);
                rangeCalculator.addLabelPaddings(that);
                rangeCalculator.processFullStackedRange(that);
                return that._rangeData
            }});
        chartSeries.fullstackedspline = _extend({}, chartSeries.spline, baseFullStackedSeries, {_getRangeData: chartSeries.fullstackedline._getRangeData});
        chartSeries.stackedbar = _extend({}, barSeries, baseStackedSeries, {_getRangeData: function() {
                this._processStackedRange();
                return barSeries._getRangeData.apply(this, arguments)
            }});
        chartSeries.fullstackedbar = _extend({}, barSeries, baseFullStackedSeries, {_getRangeData: function(zoomArgs, calcIntervalFunction) {
                var rangeData = baseFullStackedSeries._getRangeData.apply(this, arguments);
                rangeData.arg.stick = false;
                return rangeData
            }});
        function clonePoint(point, value, minValue, position) {
            point = utils.clone(point);
            point.value = value;
            point.minValue = minValue;
            point.translate();
            point.argument = point.argument + position;
            return point
        }
        function preparePointsForStackedAreaSegment(points, prevSeries) {
            points = $.map(points, function(p, i) {
                var result = [p];
                if (p.leftHole)
                    result = [clonePoint(p, p.leftHole, p.minLeftHole, "left"), p];
                if (p.rightHole)
                    result.push(clonePoint(p, p.rightHole, p.minRightHole, "right"));
                return result
            });
            return points
        }
        chartSeries.stackedarea = _extend({}, areaSeries, baseStackedSeries, {_prepareSegment: function(points, rotated) {
                return areaSeries._prepareSegment.call(this, preparePointsForStackedAreaSegment(points, this._prevSeries), rotated)
            }});
        function getPointsByArgFromPrevSeries(prevSeries, argument) {
            var result;
            while (prevSeries) {
                result = prevSeries._segmentByArg[argument];
                if (result)
                    break;
                prevSeries = prevSeries._prevSeries
            }
            return result
        }
        chartSeries.stackedsplinearea = _extend({}, chartSeries.splinearea, baseStackedSeries, {_prepareSegment: function(points, rotated) {
                var that = this,
                    areaSegment;
                points = preparePointsForStackedAreaSegment(points, that._prevSeries);
                if (!this._prevSeries || points.length == 1)
                    areaSegment = chartSeries.splinearea._prepareSegment.call(this, points, rotated);
                else {
                    var fwPoints = chartSeries.spline._calculateBezierPoints(points, rotated),
                        bwPoints = $.map(points, function(p) {
                            var point = p.getCoords(true);
                            point.argument = p.argument;
                            return point
                        }),
                        prevSeriesFwPoints = $.map(that._prevSeries._segments, function(seg) {
                            return seg.line
                        }),
                        pointByArg = {};
                    $.each(prevSeriesFwPoints, function(_, p) {
                        if (p.argument !== null) {
                            var argument = p.argument.valueOf();
                            if (!pointByArg[argument])
                                pointByArg[argument] = [p];
                            else
                                pointByArg[argument].push(p)
                        }
                    });
                    that._prevSeries._segmentByArg = pointByArg;
                    bwPoints = chartSeries.spline._calculateBezierPoints(bwPoints, rotated);
                    $.each(bwPoints, function(i, p) {
                        var argument = p.argument.valueOf(),
                            prevSeriesPoints;
                        if (i % 3 === 0) {
                            prevSeriesPoints = pointByArg[argument] || getPointsByArgFromPrevSeries(that._prevSeries, argument);
                            if (prevSeriesPoints) {
                                bwPoints[i - 1] && prevSeriesPoints[0] && (bwPoints[i - 1] = prevSeriesPoints[0]);
                                bwPoints[i + 1] && (bwPoints[i + 1] = prevSeriesPoints[2] || p)
                            }
                        }
                    });
                    areaSegment = {
                        line: fwPoints,
                        area: fwPoints.concat(bwPoints.reverse())
                    };
                    that._areaPointsToSplineAreaPoints(areaSegment.area)
                }
                return areaSegment
            }});
        chartSeries.fullstackedarea = _extend({}, areaSeries, baseFullStackedSeries, {_prepareSegment: chartSeries.stackedarea._prepareSegment});
        chartSeries.fullstackedsplinearea = _extend({}, chartSeries.splinearea, baseFullStackedSeries, {_prepareSegment: chartSeries.stackedsplinearea._prepareSegment});
        polarSeries.stackedbar = _extend({}, polarSeries.bar, baseStackedSeries, {_getRangeData: chartSeries.stackedbar._getRangeData})
    })(jQuery, DevExpress);
    /*! Module viz-core, file basePoint.js */
    (function($, DX) {
        var seriesNS = DX.viz.core.series,
            statesConsts = seriesNS.helpers.consts.states,
            _each = $.each,
            _extend = $.extend,
            _isDefined = DX.utils.isDefined,
            seiresMixins = seriesNS.mixins,
            _noop = $.noop;
        function Point() {
            this.ctor.apply(this, arguments)
        }
        seriesNS.points = {Point: Point};
        Point.prototype = {
            ctor: function(series, dataItem, options) {
                this.series = series;
                this.update(dataItem, options);
                this._emptySettings = {
                    fill: null,
                    stroke: null,
                    dashStyle: null
                }
            },
            getColor: function() {
                return this._styles.normal.fill || this.series.getColor()
            },
            _getStyle: function() {
                var that = this,
                    styles = that._styles,
                    style;
                if (that.isSelected())
                    style = styles.selection;
                else if (that.isHovered())
                    style = styles.hover;
                else {
                    that.fullState = statesConsts.normalMark;
                    style = styles.normal
                }
                return style
            },
            update: function(dataItem, options) {
                this.updateOptions(options);
                this.updateData(dataItem)
            },
            updateData: function(dataItem) {
                var that = this;
                that.argument = that.initialArgument = that.originalArgument = dataItem.argument;
                that.tag = dataItem.tag;
                that.index = dataItem.index;
                that.lowError = dataItem.lowError;
                that.highError = dataItem.highError;
                that._updateData(dataItem);
                if (!that.hasValue())
                    that.setInvisibility();
                else {
                    that._updateLabelData();
                    that._fillStyle()
                }
            },
            deleteMarker: function() {
                var that = this;
                that.graphic && that.graphic.remove();
                that.graphic = null
            },
            deleteTrackerMarker: function() {
                var that = this;
                that.trackerGraphic && that.trackerGraphic.remove();
                that.trackerGraphic = null
            },
            _drawErrorBar: _noop,
            draw: function(renderer, markersGroup, labelsGroup, animationEnabled, firstDrawing) {
                var that = this;
                if (that._needDeletingOnDraw) {
                    that.deleteMarker();
                    that.deleteTrackerMarker();
                    that._needDeletingOnDraw = false
                }
                if (that._needClearingOnDraw) {
                    that.clearMarker();
                    that._needClearingOnDraw = false
                }
                if (!that._hasGraphic())
                    that._options.visible && that._drawMarker(renderer, markersGroup, animationEnabled, firstDrawing);
                else
                    that._updateMarker(animationEnabled, undefined, markersGroup);
                that._drawLabel(renderer, labelsGroup);
                that._drawErrorBar(renderer, markersGroup, animationEnabled)
            },
            applyStyle: function(style) {
                var that = this;
                if (that.graphic) {
                    if (style === "normal")
                        that.clearMarker();
                    else {
                        that.graphic.toForeground();
                        this._errorBar && this._errorBar.toForeground()
                    }
                    that._updateMarker(true, that._styles[style])
                }
            },
            setHoverState: function() {
                this.series.setPointHoverState(this)
            },
            releaseHoverState: function(callback) {
                var that = this;
                that.series.releasePointHoverState(that, callback);
                if (that.graphic)
                    !that.isSelected() && that.graphic.toBackground()
            },
            setSelectedState: function() {
                this.series.setPointSelectedState(this)
            },
            releaseSelectedState: function() {
                this.series.releasePointSelectedState(this)
            },
            select: function() {
                this.series.selectPoint(this)
            },
            clearSelection: function() {
                this.series.deselectPoint(this)
            },
            showTooltip: function() {
                this.series.showPointTooltip(this)
            },
            hideTooltip: function() {
                this.series.hidePointTooltip(this)
            },
            _checkLabelsChanging: function(oldType, newType) {
                if (oldType) {
                    var isNewRange = ~newType.indexOf("range"),
                        isOldRange = ~oldType.indexOf("range");
                    return isOldRange && !isNewRange || !isOldRange && isNewRange
                }
                else
                    return false
            },
            updateOptions: function(newOptions) {
                if (!_isDefined(newOptions))
                    return;
                var that = this,
                    oldOptions = that._options,
                    widgetType = newOptions.widgetType,
                    oldType = oldOptions && oldOptions.type,
                    newType = newOptions.type;
                if (seiresMixins[widgetType].pointTypes[oldType] !== seiresMixins[widgetType].pointTypes[newType]) {
                    that._needDeletingOnDraw = true;
                    that._needClearingOnDraw = false;
                    that._checkLabelsChanging(oldType, newType) && that.deleteLabel();
                    that._resetType(oldType, widgetType);
                    that._setType(newType, widgetType)
                }
                else {
                    that._needDeletingOnDraw = that._checkSymbol(oldOptions, newOptions);
                    that._needClearingOnDraw = that._checkCustomize(oldOptions, newOptions)
                }
                that._options = newOptions;
                that._fillStyle();
                that._updateLabelOptions(seiresMixins[widgetType].pointTypes[newType])
            },
            translate: function(translators) {
                var that = this;
                that.translators = translators || that.translators;
                that.translators && that.hasValue() && that._translate(that.translators)
            },
            drawTracker: function(renderer, group) {
                if (!this.trackerGraphic)
                    this._drawTrackerMarker(renderer, group);
                else
                    this._updateTracker()
            },
            _checkCustomize: function(oldOptions, newOptions) {
                return oldOptions.styles.usePointCustomOptions && !newOptions.styles.usePointCustomOptions
            },
            _getCustomLabelVisibility: function() {
                if (this._styles.useLabelCustomOptions)
                    return this._options.label.visible ? "visible" : "hidden"
            },
            getBoundingRect: function() {
                return this._getGraphicBbox()
            },
            _resetType: function(type, widgetType) {
                var that = this;
                if (type)
                    _each(seriesNS.points.mixins[seiresMixins[widgetType].pointTypes[type]], function(methodName) {
                        delete that[methodName]
                    })
            },
            _setType: function(type, widgetType) {
                var that = this;
                _each(seriesNS.points.mixins[seiresMixins[widgetType].pointTypes[type]], function(methodName, method) {
                    that[methodName] = method
                })
            },
            isInVisibleArea: function() {
                return this.inVisibleArea
            },
            isSelected: function() {
                return !!(this.fullState & statesConsts.selectedMark)
            },
            isHovered: function() {
                return !!(this.fullState & statesConsts.hoverMark)
            },
            getOptions: function() {
                return this._options
            },
            animate: function(complete, settings, partitionDuration) {
                var that = this;
                if (!this.graphic) {
                    complete && complete();
                    return
                }
                this.graphic.animate(settings, {partitionDuration: partitionDuration}, function() {
                    that._errorBar && that._errorBar.animate({opacity: that._options.errorBars.opacity}, {duration: 400});
                    complete && complete()
                })
            },
            getCoords: function(min) {
                var that = this;
                if (!min)
                    return {
                            x: that.x,
                            y: that.y
                        };
                if (!that._options.rotated)
                    return {
                            x: that.x,
                            y: that.minY
                        };
                return {
                        x: that.minX,
                        y: that.y
                    }
            },
            getDefaultCoords: function() {
                var that = this;
                return !that._options.rotated ? {
                        x: that.x,
                        y: that.defaultY
                    } : {
                        x: that.defaultX,
                        y: that.y
                    }
            },
            _calculateVisibility: function(x, y, width, height) {
                var that = this,
                    visibleAreaX,
                    visibleAreaY,
                    rotated = that._options.rotated;
                if (that.translators) {
                    visibleAreaX = that.translators.x.getCanvasVisibleArea();
                    visibleAreaY = that.translators.y.getCanvasVisibleArea();
                    if (visibleAreaX.min > x + (width || 0) || visibleAreaX.max < x || visibleAreaY.min > y + (height || 0) || visibleAreaY.max < y || rotated && _isDefined(width) && width !== 0 && (visibleAreaX.min === x + width || visibleAreaX.max === x) || !rotated && _isDefined(height) && height !== 0 && (visibleAreaY.min === y + height || visibleAreaY.max === y))
                        that.inVisibleArea = false;
                    else
                        that.inVisibleArea = true
                }
            },
            correctPosition: _noop,
            hasValue: function() {
                return this.value !== null && this.minValue !== null
            },
            getBoundaryCoords: function() {
                return this.getBoundingRect()
            },
            getCrosshairCoords: _noop,
            _populatePointShape: _noop,
            _checkSymbol: _noop,
            getMarkerCoords: _noop,
            hide: _noop,
            show: _noop,
            hideMarker: _noop,
            setInvisibility: _noop,
            clearVisibility: _noop,
            isVisible: _noop,
            resetCorrection: _noop,
            correctValue: _noop,
            setPercentValue: _noop,
            correctCoordinates: _noop,
            coordsIn: _noop,
            getTooltipParams: _noop,
            checkLabelPosition: _noop,
            setLabelEllipsis: _noop,
            resolveCollision: _noop,
            getIndentFromPie: _noop,
            updateLabelCoord: _noop,
            getColumnsCoord: _noop,
            drawLabel: _noop,
            dispose: function() {
                var that = this;
                that.deleteMarker();
                that.deleteTrackerMarker();
                that.deleteLabel();
                that._errorBar && this._errorBar.remove();
                that._options = that._styles = that.series = that.translators = that._errorBar = null
            },
            getTooltipFormatObject: function(tooltip) {
                var that = this,
                    tooltipFormatObject = that._getFormatObject(tooltip),
                    sharedTooltipValuesArray = [],
                    tooltipStackPointsFormatObject = [];
                if (that.stackPoints) {
                    _each(that.stackPoints, function(_, point) {
                        if (!point.isVisible())
                            return;
                        var formatObject = point._getFormatObject(tooltip);
                        tooltipStackPointsFormatObject.push(formatObject);
                        sharedTooltipValuesArray.push(formatObject.seriesName + ": " + formatObject.valueText)
                    });
                    _extend(tooltipFormatObject, {
                        points: tooltipStackPointsFormatObject,
                        valueText: sharedTooltipValuesArray.join("\n"),
                        stackName: that.stackPoints.stackName
                    })
                }
                return tooltipFormatObject
            },
            setHole: function(holeValue, position) {
                var that = this,
                    minValue = isFinite(that.minValue) ? that.minValue : 0;
                if (_isDefined(holeValue))
                    if (position === "left") {
                        that.leftHole = that.value - holeValue;
                        that.minLeftHole = minValue - holeValue
                    }
                    else {
                        that.rightHole = that.value - holeValue;
                        that.minRightHole = minValue - holeValue
                    }
            },
            getLabel: function() {
                return this._label
            }
        }
    })(jQuery, DevExpress);
    /*! Module viz-core, file label.js */
    (function($, DX, undefined) {
        var _utils = DX.utils,
            core = DX.viz.core,
            _isDefined = _utils.isDefined,
            _extend = $.extend,
            _round = Math.round,
            _min = Math.min,
            _ceil = Math.ceil,
            _getCosAndSin = DX.utils.getCosAndSin,
            LABEL_BACKGROUND_PADDING_X = 8,
            LABEL_BACKGROUND_PADDING_Y = 4;
        function pointInsideBox(point, box) {
            return point.x >= box.x && point.x <= box.x + box.width && point.y >= box.y && point.y <= box.y + box.height
        }
        function connectorToInner(point, x, y) {
            var normalAngle = _utils.normalizeAngle(point.angle);
            return normalAngle < 180 ? point.y > y : point.y < y
        }
        function getClosestCoord(point, coords) {
            var closerPointsDistase = Infinity,
                closeCoord = {};
            $.each(coords, function(_, coord) {
                var distance = _utils.getDistance(point.x, point.y, coord.x, coord.y);
                if (distance < closerPointsDistase) {
                    closerPointsDistase = distance;
                    closeCoord = coord
                }
            });
            return closeCoord
        }
        function getPointOnBoxFigure(figure, pointOnLabel) {
            return [getClosestCoord(pointOnLabel, [{
                            x: figure.x,
                            y: figure.center.y
                        }, {
                            x: figure.center.x,
                            y: figure.y + figure.height
                        }, {
                            x: figure.x + figure.width,
                            y: figure.center.y
                        }, {
                            x: figure.center.x,
                            y: figure.y
                        }])]
        }
        function getPointOnCircular(figure, pointOnLabel) {
            var angle = Math.atan2(pointOnLabel.y - figure.y, pointOnLabel.x - figure.x),
                cossin = _getCosAndSin(-angle / Math.PI * 180);
            return [{
                        x: figure.x + figure.r * cossin.cos,
                        y: figure.y - figure.r * cossin.sin
                    }]
        }
        function getPointsOnAngle(figure, pointOnLabel) {
            var angle = figure.angle,
                xConnector = _round(figure.x + (pointOnLabel.y - figure.y) / Math.tan(_utils.degreesToRadians(-angle))),
                connectorPoint = {};
            if (connectorToInner(figure, pointOnLabel.x, pointOnLabel.y)) {
                connectorPoint.x = xConnector;
                connectorPoint.y = pointOnLabel.y
            }
            else
                connectorPoint = pointOnLabel;
            return [figure.center, getClosestCoord(figure, [connectorPoint, pointOnLabel])]
        }
        function Label(){}
        Label.prototype = {
            constructor: Label,
            clearVisibility: function() {
                if (this._group && this._group.attr("visibility"))
                    this._group.attr({visibility: null})
            },
            hide: function() {
                if (this._group && this._group.attr("visibility") !== "hidden")
                    this._group.attr({visibility: "hidden"})
            },
            show: function() {
                if (this._group && this._group.attr("visibility") !== "visible")
                    this._group.attr({visibility: "visible"})
            },
            getVisibility: function() {
                return this._group && this._group.attr("visibility")
            },
            updateData: function(data) {
                if (_isDefined(data))
                    this._data = data.formatObject
            },
            updateOptions: function(options) {
                this.setOptions(_extend(true, {}, this._options, options))
            },
            setOptions: function(newOptions) {
                var that = this,
                    oldOptions = that._options;
                newOptions = newOptions || {};
                that._fontStyles = core.utils.patchFontOptions(newOptions.attributes && newOptions.attributes.font);
                that._options = newOptions;
                if (oldOptions) {
                    that._isBackgroundChanged(oldOptions.background, that._options.background) && that._deleteBackground();
                    that._isConnectorChanged(oldOptions.connector, that._options.connector) && that._deleteConnector()
                }
            },
            setDataField: function(fieldName, fieldValue) {
                this._data = this._data || {};
                this._data[fieldName] = fieldValue
            },
            getData: function() {
                return this._data
            },
            setFigureToDrawConnector: function(figure) {
                this.figure = figure;
                this._setFigureOptions(figure)
            },
            _deleteElements: function() {
                this._deleteConnector();
                this._deleteBackground();
                this._deleteText();
                this._deleteGroups()
            },
            dispose: function() {
                this._data = null;
                this._options = null;
                this._positioningFunction = null;
                this._deleteElements()
            },
            _deleteText: function() {
                this._text && this._text.remove();
                this._text = null
            },
            _deleteGroups: function() {
                this._insideGroup = null;
                this._group && this._group.remove();
                this._group = null
            },
            _drawGroups: function(renderer, group) {
                if (!this._group)
                    this._group = renderer.g().append(group);
                if (!this._insideGroup)
                    this._insideGroup = renderer.g().append(this._group)
            },
            _drawText: function(renderer, text) {
                if (!this._text)
                    this._text = renderer.text("", 0, 0).append(this._insideGroup);
                this._text.css(this._fontStyles).attr({text: text})
            },
            _drawBackground: function(renderer) {
                var that = this,
                    options = that._options,
                    background = options.background || {},
                    settings;
                if (that._checkBackground(background)) {
                    settings = _extend(that._getBackgroundSettings(), background);
                    if (!that._background)
                        that._background = renderer.rect().append(that._insideGroup);
                    that._background.attr(settings).toBackground()
                }
            },
            _drawConnector: function(renderer, group) {
                var that = this,
                    connectorOptions = that._options.connector || {},
                    connector = that._connector;
                if (that._checkConnector(connectorOptions)) {
                    if (!connector)
                        that._connector = connector = renderer.path([], "line").append(group);
                    else
                        connector.attr({points: that._getConnectorPoints()});
                    connector.attr(connectorOptions).sharp().toBackground()
                }
            },
            _getConnectorPoints: function() {
                var that = this,
                    figure = that.figure,
                    labelBbox = that.getBoundingRect(),
                    centerX = labelBbox.x + labelBbox.width / 2,
                    centerY = labelBbox.y + labelBbox.height / 2,
                    pointOnLabel;
                if (!figure || pointInsideBox(labelBbox, figure))
                    return [];
                if (!that._background)
                    pointOnLabel = getClosestCoord(that.figure.center, [{
                            x: labelBbox.x,
                            y: centerY
                        }, {
                            x: centerX,
                            y: labelBbox.y + labelBbox.height
                        }, {
                            x: labelBbox.x + labelBbox.width,
                            y: centerY
                        }, {
                            x: centerX,
                            y: labelBbox.y
                        }]);
                else
                    pointOnLabel = {
                        x: centerX,
                        y: centerY
                    };
                return that._getConnectorPointsOnFigure(this.figure, pointOnLabel).concat([pointOnLabel])
            },
            _setFigureOptions: function(figure) {
                var that = this,
                    getConnectorPointsOnFigure;
                if (!figure)
                    return;
                if (_isDefined(figure.r)) {
                    that.figure.center = figure;
                    getConnectorPointsOnFigure = getPointOnCircular
                }
                else if (_isDefined(figure.angle)) {
                    that.figure.center = figure;
                    getConnectorPointsOnFigure = getPointsOnAngle
                }
                else {
                    that.figure.center = {
                        x: figure.x + figure.width / 2,
                        y: figure.y + figure.height / 2
                    };
                    getConnectorPointsOnFigure = getPointOnBoxFigure
                }
                that._getConnectorPointsOnFigure = getConnectorPointsOnFigure
            },
            _setVisibility: function(visibility) {
                this._group && this._group.attr({visibility: visibility})
            },
            draw: function(renderer, group, visibility) {
                var that = this,
                    text = that._format();
                if (_isDefined(text) && text !== "") {
                    that._drawGroups(renderer, group);
                    that._setVisibility(visibility);
                    that._drawText(renderer, text);
                    that._drawBackground(renderer);
                    that._rotateLabel();
                    that._setBoundingRect();
                    that._drawConnector(renderer, that._group)
                }
                else {
                    that._setVisibility("hidden");
                    that._insideGroup = null
                }
                that._formatText = text
            },
            checkEllipsis: function(size) {
                var that = this,
                    lineLength,
                    updateText = "",
                    rotationAngle = that._options.rotationAngle,
                    angleFunction = _getCosAndSin(rotationAngle),
                    text = that._formatText,
                    bbox,
                    lines = [],
                    index,
                    lastIndex,
                    maxLineLength = 0,
                    lengthText,
                    needLengthText;
                function pushLines(text) {
                    lines.push(text.replace(/<[^>]+>/g, ''));
                    if (maxLineLength < lines[lines.length - 1].length)
                        maxLineLength = lines[lines.length - 1].length
                }
                if (!that._text)
                    return;
                bbox = that._text.getBBox();
                lengthText = rotationAngle ? _min(bbox.width / angleFunction.cos, bbox.height / angleFunction.sin) : bbox.width;
                needLengthText = rotationAngle ? _min(size.width / angleFunction.cos, size.height / angleFunction.sin) : size.width;
                if (lengthText <= needLengthText)
                    return;
                index = text.indexOf("<br/>");
                lastIndex = 0;
                while (index !== -1) {
                    pushLines(text.slice(lastIndex, index));
                    lastIndex = index + 5;
                    index = text.indexOf(lastIndex, "<br/>")
                }
                pushLines(text.slice(lastIndex, text.length));
                lineLength = _ceil(maxLineLength * needLengthText / lengthText);
                for (var i = 0; i < lines.length; i++) {
                    if (i > 0)
                        updateText += "<br/>";
                    if (lines[i].length > lineLength)
                        updateText += lines[i].substr(0, lineLength - 1 - 3) + "...";
                    else
                        updateText += lines[i]
                }
                if (text !== updateText) {
                    that._text.attr({text: updateText});
                    that._drawBackground();
                    that._setBoundingRect()
                }
            },
            _deleteBackground: function() {
                this._background && this._background.remove();
                this._background = null
            },
            _isBackgroundChanged: function(oldBackground, newBackground) {
                return this._checkBackground(oldBackground || {}) !== this._checkBackground(newBackground || {})
            },
            _checkBackground: function(background) {
                var hasColor = background.fill && background.fill !== "none",
                    hasBorder = background['stroke-width'] && background.stroke && background.stroke !== "none";
                return hasColor || hasBorder
            },
            _getBackgroundSettings: function() {
                var bbox = this._text.getBBox();
                return {
                        x: bbox.x - LABEL_BACKGROUND_PADDING_X,
                        y: bbox.y - LABEL_BACKGROUND_PADDING_Y,
                        width: bbox.width + 2 * LABEL_BACKGROUND_PADDING_X,
                        height: bbox.height + 2 * LABEL_BACKGROUND_PADDING_Y
                    }
            },
            _deleteConnector: function() {
                this._connector && this._connector.remove();
                this._connector = null
            },
            _isConnectorChanged: function(oldConnector, newConnector) {
                return this._checkConnector(oldConnector || {}) !== this._checkConnector(newConnector || {})
            },
            _checkConnector: function(connector) {
                return connector && connector["stroke-width"]
            },
            _rotateLabel: function() {
                this._insideGroup.rotate(this._options.rotationAngle)
            },
            _format: function() {
                var that = this,
                    data = that._data,
                    options = that._options,
                    formatHelper = DX.formatHelper;
                data.valueText = formatHelper.format(data.value, options.format, options.precision);
                data.argumentText = formatHelper.format(data.argument, options.argumentFormat, options.argumentPrecision);
                if (data.percent !== undefined)
                    data.percentText = formatHelper.format(data.percent, "percent", options.percentPrecision);
                if (data.total !== undefined)
                    data.totalText = formatHelper.format(data.total, options.format, options.precision);
                if (data.openValue !== undefined)
                    data.openValueText = formatHelper.format(data.openValue, options.format, options.precision);
                if (data.closeValue !== undefined)
                    data.closeValueText = formatHelper.format(data.closeValue, options.format, options.precision);
                if (data.lowValue !== undefined)
                    data.lowValueText = formatHelper.format(data.lowValue, options.format, options.precision);
                if (data.highValue !== undefined)
                    data.highValueText = formatHelper.format(data.highValue, options.format, options.precision);
                if (data.reductionValue !== undefined)
                    data.reductionValueText = formatHelper.format(data.reductionValue, options.format, options.precision);
                return options.customizeText ? options.customizeText.call(data, data) : data.valueText
            },
            shift: function(x, y) {
                var that = this;
                if (!that._insideGroup)
                    return;
                that._insideGroup.attr({
                    translateX: _round(x - that.BBox.x),
                    translateY: _round(y - that.BBox.y)
                });
                that._drawConnector()
            },
            _setBoundingRect: function() {
                this.BBox = this._insideGroup && this._insideGroup.getBBox()
            },
            getBoundingRect: function() {
                var coords = {},
                    that = this,
                    insideGroup = this._insideGroup;
                if (insideGroup) {
                    coords.width = that.BBox.width;
                    coords.height = that.BBox.height;
                    coords.x = this.BBox.x + insideGroup.attr("translateX");
                    coords.y = this.BBox.y + insideGroup.attr("translateY")
                }
                return coords
            },
            hasText: function() {
                return !!this._text
            },
            getLayoutOptions: function() {
                var options = this._options;
                return {
                        alignment: options.alignment,
                        background: this._checkBackground(options.background || {}),
                        horizontalOffset: options.horizontalOffset,
                        verticalOffset: options.verticalOffset,
                        radialOffset: options.radialOffset,
                        position: options.position
                    }
            }
        };
        core.series.points.Label = Label
    })(jQuery, DevExpress);
    /*! Module viz-core, file symbolPoint.js */
    (function($, DX) {
        var core = DX.viz.core,
            seriesNS = core.series,
            _extend = $.extend,
            _isNumber = DX.utils.isNumber,
            _isDefined = DX.utils.isDefined,
            _math = Math,
            _round = _math.round,
            _floor = _math.floor,
            _ceil = _math.ceil,
            DEFAULT_IMAGE_WIDTH = 20,
            DEFAULT_IMAGE_HEIGHT = 20,
            LABEL_OFFSET = 10,
            CANVAS_POSITION_DEFAULT = "canvas_position_default",
            ERROR_BAR_WIDTH = 4;
        function getSquareMarkerCoords(radius) {
            return [-radius, -radius, radius, -radius, radius, radius, -radius, radius, -radius, -radius]
        }
        function getPolygonMarkerCoords(radius) {
            var r = _ceil(radius);
            return [-r, 0, 0, -r, r, 0, 0, r, -r, 0]
        }
        function getCrossMarkerCoords(radius) {
            var r = _ceil(radius),
                floorHalfRadius = _floor(r / 2),
                ceilHalfRadius = _ceil(r / 2);
            return [-r, -floorHalfRadius, -floorHalfRadius, -r, 0, -ceilHalfRadius, floorHalfRadius, -r, r, -floorHalfRadius, ceilHalfRadius, 0, r, floorHalfRadius, floorHalfRadius, r, 0, ceilHalfRadius, -floorHalfRadius, r, -r, floorHalfRadius, -ceilHalfRadius, 0]
        }
        function getTriangleMarkerCoords(radius) {
            return [-radius, -radius, radius, -radius, 0, radius, -radius, -radius]
        }
        seriesNS.points.mixins = seriesNS.points.mixins || {};
        seriesNS.points.mixins.symbolPoint = {
            deleteLabel: function() {
                this._label.dispose();
                this._label = null
            },
            _hasGraphic: function() {
                return this.graphic
            },
            _clearTrackerVisibility: function() {
                var trackerGraphic = this.trackerGraphic;
                if (trackerGraphic && trackerGraphic.attr("visibility"))
                    trackerGraphic.attr({visibility: null})
            },
            clearVisibility: function() {
                var that = this,
                    graphic = that.graphic;
                if (graphic && graphic.attr("visibility"))
                    graphic.attr({visibility: null});
                that._clearTrackerVisibility();
                that._label.clearVisibility()
            },
            isVisible: function() {
                return this.inVisibleArea && this.series.isVisible()
            },
            _setTrackerInvisibility: function() {
                var trackerGraphic = this.trackerGraphic;
                if (trackerGraphic && trackerGraphic.attr("visibility") !== "hidden")
                    trackerGraphic.attr({visibility: "hidden"})
            },
            setInvisibility: function() {
                var that = this,
                    graphic = that.graphic;
                if (graphic && graphic.attr("visibility") !== "hidden")
                    graphic.attr({visibility: "hidden"});
                that._errorBar && that._errorBar.attr({visibility: "hidden"});
                that._setTrackerInvisibility();
                that._label.hide()
            },
            clearMarker: function() {
                var graphic = this.graphic;
                graphic && graphic.attr(this._emptySettings)
            },
            setAdjustSeriesLabels: function(adjustSeriesLabels) {
                this.adjustSeriesLabels = adjustSeriesLabels
            },
            _createLabel: function() {
                this._label = core.CoreFactory.createLabel()
            },
            _updateLabelData: function() {
                this._label.updateData({
                    formatObject: this._getLabelFormatObject(),
                    initialValue: this.initialValue
                })
            },
            _updateLabelOptions: function() {
                !this._label && this._createLabel();
                this._label.setOptions(this._options.label)
            },
            _checkImage: function(image) {
                return _isDefined(image) && (typeof image === "string" || _isDefined(image.url))
            },
            _fillStyle: function() {
                this._styles = this._options.styles
            },
            _checkSymbol: function(oldOptions, newOptions) {
                var oldSymbol = oldOptions.symbol,
                    newSymbol = newOptions.symbol,
                    symbolChanged = oldSymbol === "circle" && newSymbol !== "circle" || oldSymbol !== "circle" && newSymbol === "circle",
                    imageChanged = this._checkImage(oldOptions.image) !== this._checkImage(newOptions.image);
                if (symbolChanged || imageChanged)
                    return true;
                return false
            },
            _populatePointShape: function(symbol, radius) {
                switch (symbol) {
                    case"square":
                        return getSquareMarkerCoords(radius);
                    case"polygon":
                        return getPolygonMarkerCoords(radius);
                    case"triangle":
                        return getTriangleMarkerCoords(radius);
                    case"cross":
                        return getCrossMarkerCoords(radius)
                }
            },
            correctValue: function(correction) {
                var that = this;
                if (that.hasValue()) {
                    that.value = that.initialValue + correction;
                    that.minValue = correction;
                    that.translate()
                }
            },
            resetCorrection: function() {
                this.value = this.initialValue;
                this.minValue = CANVAS_POSITION_DEFAULT
            },
            _getTranslates: function(animationEnabled) {
                var translateX = this.x,
                    translateY = this.y;
                if (animationEnabled)
                    if (this._options.rotated)
                        translateX = this.defaultX;
                    else
                        translateY = this.defaultY;
                return {
                        x: translateX,
                        y: translateY
                    }
            },
            _createImageMarker: function(renderer, settings, options) {
                var width = options.width || DEFAULT_IMAGE_WIDTH,
                    height = options.height || DEFAULT_IMAGE_HEIGHT;
                return renderer.image(-_round(width * 0.5), -_round(height * 0.5), width, height, options.url ? options.url.toString() : options.toString(), "center").attr({
                        translateX: settings.translateX,
                        translateY: settings.translateY,
                        visibility: settings.visibility
                    })
            },
            _createSymbolMarker: function(renderer, pointSettings, animationEnabled) {
                var marker,
                    options = this._options;
                switch (options.symbol) {
                    case"circle":
                        delete pointSettings.points;
                        marker = renderer.circle().attr(pointSettings);
                        break;
                    case"square":
                    case"polygon":
                    case"triangle":
                    case"cross":
                        marker = renderer.path([], "area").attr(pointSettings).sharp();
                        break
                }
                return marker
            },
            _createMarker: function(renderer, group, image, settings, animationEnabled) {
                var that = this,
                    marker = that._checkImage(image) ? that._createImageMarker(renderer, settings, image) : that._createSymbolMarker(renderer, settings, animationEnabled);
                marker && (marker.append(group), $(marker.element).data({point: that}));
                return marker
            },
            _getSymbolBbox: function(x, y, r) {
                return {
                        x: x - r,
                        y: y - r,
                        width: r * 2,
                        height: r * 2
                    }
            },
            _getImageBbox: function(x, y) {
                var image = this._options.image,
                    width = image.width || DEFAULT_IMAGE_WIDTH,
                    height = image.height || DEFAULT_IMAGE_HEIGHT;
                return {
                        x: x - _round(width / 2),
                        y: y - _round(height / 2),
                        width: width,
                        height: height
                    }
            },
            _getGraphicBbox: function() {
                var that = this,
                    options = that._options,
                    x = that.x,
                    y = that.y,
                    bbox;
                if (options.visible)
                    bbox = that._checkImage(options.image) ? that._getImageBbox(x, y) : that._getSymbolBbox(x, y, options.styles.normal.r);
                else
                    bbox = {
                        x: x,
                        y: y,
                        width: 0,
                        height: 0
                    };
                return bbox
            },
            _getVisibleArea: function() {
                var translators = this.translators,
                    visibleX,
                    visibleY;
                if (translators) {
                    visibleX = translators.x.getCanvasVisibleArea();
                    visibleY = translators.y.getCanvasVisibleArea();
                    return {
                            minX: visibleX.min,
                            maxX: visibleX.max,
                            minY: visibleY.min,
                            maxY: visibleY.max
                        }
                }
            },
            _drawLabel: function(renderer, group) {
                var that = this,
                    customVisibility = that._getCustomLabelVisibility(),
                    coord,
                    options = that._options;
                if ((that.series.getLabelVisibility() || customVisibility) && that.hasValue() && that._showForZeroValues()) {
                    that._label.draw(renderer, group, customVisibility);
                    coord = that._getLabelCoords(that._label);
                    coord = that._addLabelAlignmentAndOffset(that._label, coord);
                    coord = that.checkLabelPosition(that._label, coord);
                    that._label.setFigureToDrawConnector(that._getLabelConnector(that._label, coord));
                    that._label.shift(_round(coord.x), _round(coord.y))
                }
                else
                    that._label.hide()
            },
            _showForZeroValues: function() {
                return true
            },
            _getLabelConnector: function(label, coord, pointPosition) {
                var coord = this._getPositionFromLocation(pointPosition);
                return this._options.symbol === "circle" ? {
                        x: coord.x,
                        y: coord.y,
                        r: this._options.styles.normal.r
                    } : this._getGraphicBbox(pointPosition)
            },
            _getPositionFromLocation: function() {
                return {
                        x: this.x,
                        y: this.y
                    }
            },
            checkLabelPosition: function(label, coord, pointPosition) {
                var that = this,
                    visibleArea = that._getVisibleArea(),
                    labelBbox = label.getBoundingRect(),
                    graphicBbox = that._getGraphicBbox(pointPosition),
                    offset = LABEL_OFFSET;
                if (visibleArea.minX <= graphicBbox.x + graphicBbox.width && visibleArea.maxX >= graphicBbox.x && visibleArea.minY <= graphicBbox.y + graphicBbox.height && visibleArea.maxY >= graphicBbox.y)
                    if (!that._options.rotated) {
                        if (visibleArea.minX > coord.x && that.adjustSeriesLabels)
                            coord.x = visibleArea.minX;
                        if (visibleArea.maxX < coord.x + labelBbox.width && that.adjustSeriesLabels)
                            coord.x = visibleArea.maxX - labelBbox.width;
                        if (visibleArea.minY > coord.y)
                            coord.y = graphicBbox.y + graphicBbox.height + offset;
                        if (visibleArea.maxY < coord.y + labelBbox.height)
                            coord.y = graphicBbox.y - labelBbox.height - offset
                    }
                    else {
                        if (visibleArea.minX > coord.x)
                            coord.x = graphicBbox.x + graphicBbox.width + offset;
                        if (visibleArea.maxX < coord.x + labelBbox.width)
                            coord.x = graphicBbox.x - offset - labelBbox.width;
                        if (visibleArea.minY > graphicBbox.y && that.adjustSeriesLabels)
                            coord.y = visibleArea.minY;
                        if (visibleArea.maxY < coord.y + labelBbox.height && that.adjustSeriesLabels)
                            coord.y = visibleArea.maxY - labelBbox.height
                    }
                return coord
            },
            _addLabelAlignmentAndOffset: function(label, coord) {
                var labelBBox = label.getBoundingRect(),
                    labelOptions = label.getLayoutOptions();
                if (!this._options.rotated)
                    if (labelOptions.alignment === "left")
                        coord.x += labelBBox.width / 2;
                    else if (labelOptions.alignment === "right")
                        coord.x -= labelBBox.width / 2;
                coord.x += labelOptions.horizontalOffset;
                coord.y += labelOptions.verticalOffset;
                return coord
            },
            _getLabelCoords: function(label, pointPosition) {
                return this._getLabelCoordOfPosition(label, this._getLabelPosition(pointPosition), pointPosition)
            },
            _getLabelCoordOfPosition: function(label, position, pointPosition) {
                var that = this,
                    labelBBox = label.getBoundingRect(),
                    graphicBbox = that._getGraphicBbox(pointPosition),
                    offset = LABEL_OFFSET,
                    centerY = graphicBbox.height / 2 - labelBBox.height / 2,
                    centerX = graphicBbox.width / 2 - labelBBox.width / 2,
                    x = graphicBbox.x,
                    y = graphicBbox.y;
                switch (position) {
                    case"left":
                        x -= labelBBox.width + offset;
                        y += centerY;
                        break;
                    case"right":
                        x += graphicBbox.width + offset;
                        y += centerY;
                        break;
                    case"top":
                        x += centerX;
                        y -= labelBBox.height + offset;
                        break;
                    case"bottom":
                        x += centerX;
                        y += graphicBbox.height + offset;
                        break;
                    case"inside":
                        x += centerX;
                        y += centerY;
                        break
                }
                return {
                        x: x,
                        y: y
                    }
            },
            _drawMarker: function(renderer, group, animationEnabled) {
                var that = this,
                    options = that._options,
                    translates = that._getTranslates(animationEnabled),
                    style = that._getStyle();
                that.graphic = that._createMarker(renderer, group, options.image, _extend({
                    translateX: translates.x,
                    translateY: translates.y,
                    points: that._populatePointShape(options.symbol, style.r)
                }, style), animationEnabled)
            },
            _drawTrackerMarker: function(renderer, group) {
                var that = this,
                    radius = that._options.trackerR || that._storeTrackerR();
                that.trackerGraphic = renderer.circle(that.x, that.y, radius).append(group);
                $(that.trackerGraphic.element).data({point: that})
            },
            _getErrorBarSettings: function(errorBarOptions, animationEnabled) {
                var settings = {
                        stroke: errorBarOptions.color,
                        'stroke-width': errorBarOptions.lineWidth,
                        fill: "none",
                        opacity: errorBarOptions.opacity,
                        visibility: "visible",
                        "stroke-linecap": "square"
                    };
                animationEnabled && (settings.opacity = 0.0001);
                return settings
            },
            _drawErrorBar: function(renderer, group, animationEnabled) {
                var that = this,
                    errorBarOptions = that._options.errorBars || {},
                    points = [],
                    settings,
                    isRotated = that._options.rotated,
                    pos = that._errorBarPos,
                    high = that._highErrorCoord,
                    low = that._lowErrorCoord,
                    displayMode = (errorBarOptions.displayMode + "").toLowerCase(),
                    isHighDisplayMode = displayMode === "high",
                    isLowDispalyMode = displayMode === "low",
                    edgeLength = _floor(parseInt(errorBarOptions.edgeLength) / 2),
                    highErrorOnly = (isHighDisplayMode || !_isDefined(low)) && _isDefined(high) && !isLowDispalyMode,
                    lowErrorOnly = (isLowDispalyMode || !_isDefined(high)) && _isDefined(low) && !isHighDisplayMode;
                highErrorOnly && (low = that._baseErrorBarPos);
                lowErrorOnly && (high = that._baseErrorBarPos);
                if (displayMode !== "none" && _isDefined(high) && _isDefined(low)) {
                    !lowErrorOnly && points.push(pos - edgeLength, high, pos + edgeLength, high);
                    points.push(pos, high, pos, low);
                    !highErrorOnly && points.push(pos - edgeLength, low, pos + edgeLength, low);
                    isRotated && points.reverse();
                    settings = that._getErrorBarSettings(errorBarOptions, animationEnabled);
                    if (!that._errorBar)
                        that._errorBar = renderer.path(points, "line").attr(settings).sharp().append(group);
                    else {
                        settings.points = points;
                        that._errorBar.attr(settings).sharp()
                    }
                }
                else
                    that._errorBar && that._errorBar.attr({visibility: "hidden"})
            },
            getTooltipParams: function() {
                var that = this,
                    graphic = that.graphic;
                return {
                        x: that.x,
                        y: that.y,
                        offset: graphic ? graphic.getBBox().height / 2 : 0
                    }
            },
            hasValue: function() {
                return this.value !== null && this.minValue !== null
            },
            setPercentValue: function(total, fullStacked, leftHoleTotal, rightHoleTotal) {
                var valuePercent = this.value / total || 0,
                    percent = valuePercent,
                    minValuePercent = this.minValue / total || 0;
                percent -= _isNumber(this.minValue) ? minValuePercent : 0;
                this._label.setDataField("percent", percent);
                this._label.setDataField("total", total);
                if (this.series.isFullStackedSeries() && this.hasValue()) {
                    if (this.leftHole) {
                        this.leftHole /= total - leftHoleTotal;
                        this.minLeftHole /= total - leftHoleTotal
                    }
                    if (this.rightHole) {
                        this.rightHole /= total - rightHoleTotal;
                        this.minRightHole /= total - rightHoleTotal
                    }
                    this.value = valuePercent;
                    this.minValue = !minValuePercent ? this.minValue : minValuePercent;
                    this.translate()
                }
            },
            _storeTrackerR: function() {
                var that = this,
                    navigator = window.navigator,
                    r = that._options.styles.normal.r,
                    minTrackerSize;
                navigator = that.__debug_navigator || navigator;
                that.__debug_browserNavigator = navigator;
                minTrackerSize = "ontouchstart" in window || navigator.msPointerEnabled && navigator.msMaxTouchPoints || navigator.pointerEnabled && navigator.maxTouchPoints ? 20 : 6;
                that._options.trackerR = r < minTrackerSize ? minTrackerSize : r;
                return that._options.trackerR
            },
            _translateErrorBars: function(valueTranslator) {
                var that = this,
                    options = that._options,
                    errorBars = options.errorBars || {};
                _isDefined(that.lowError) && (that._lowErrorCoord = valueTranslator.translate(that.lowError));
                _isDefined(that.highError) && (that._highErrorCoord = valueTranslator.translate(that.highError));
                that._errorBarPos = that._options.rotated ? that.vy : that.vx;
                that._baseErrorBarPos = errorBars.type === "stdDeviation" ? that._lowErrorCoord + (that._highErrorCoord - that._lowErrorCoord) / 2 : that._options.rotated ? that.vx : that.vy
            },
            _translate: function(translators) {
                var that = this,
                    valueAxis = that._options.rotated ? "x" : "y",
                    upperValueAxis = valueAxis.toUpperCase(),
                    valueTranslator = translators[valueAxis],
                    argumentAxis = that._options.rotated ? "y" : "x";
                that["v" + valueAxis] = that[valueAxis] = valueTranslator.translate(that.value);
                that["v" + argumentAxis] = that[argumentAxis] = translators[argumentAxis].translate(that.argument);
                that["min" + upperValueAxis] = valueTranslator.translate(that.minValue);
                that["default" + upperValueAxis] = valueTranslator.translate(CANVAS_POSITION_DEFAULT);
                that._translateErrorBars(valueTranslator);
                that._calculateVisibility(that.x, that.y)
            },
            _updateData: function(data) {
                var that = this;
                that.value = that.initialValue = that.originalValue = data.value;
                that.minValue = that.initialMinValue = that.originalMinValue = _isDefined(data.minValue) ? data.minValue : CANVAS_POSITION_DEFAULT
            },
            _getImageSettings: function(image) {
                return {
                        href: image.url || image.toString(),
                        width: image.width || DEFAULT_IMAGE_WIDTH,
                        height: image.height || DEFAULT_IMAGE_HEIGHT
                    }
            },
            getCrosshairCoords: function(x, y) {
                return {
                        x: this.vx,
                        y: this.vy
                    }
            },
            _updateMarker: function(animationEnabled, style) {
                var that = this,
                    options = that._options,
                    settings,
                    image = options.image,
                    visibility = !that.isVisible() ? {visibility: "hidden"} : {};
                style = style || that._getStyle();
                if (that._checkImage(image))
                    settings = _extend({}, {visibility: style.visibility}, visibility, that._getImageSettings(image));
                else
                    settings = _extend({}, style, visibility, {points: that._populatePointShape(options.symbol, style.r)});
                if (!animationEnabled) {
                    settings.translateX = that.x;
                    settings.translateY = that.y
                }
                that.graphic.attr(settings).sharp()
            },
            _updateTracker: function() {
                var that = this;
                that.trackerGraphic.attr({
                    cx: that.x,
                    cy: that.y,
                    r: that._storeTrackerR()
                })
            },
            _getLabelFormatObject: function() {
                var that = this;
                return {
                        argument: that.initialArgument,
                        value: that.initialValue,
                        originalArgument: that.originalArgument,
                        originalValue: that.originalValue,
                        seriesName: that.series.name,
                        lowErrorValue: that.lowError,
                        highErrorValue: that.highError,
                        point: that
                    }
            },
            _getLabelPosition: function() {
                var rotated = this._options.rotated;
                if (this.series.isFullStackedSeries() || this.initialValue > 0)
                    return rotated ? "right" : "top";
                else
                    return rotated ? "left" : "bottom"
            },
            _getFormatObject: function(tooltip) {
                var that = this,
                    labelFormatObject = that._label.getData();
                return _extend({}, labelFormatObject, {
                        argumentText: tooltip.formatValue(that.initialArgument, "argument"),
                        valueText: tooltip.formatValue(that.initialValue)
                    }, _isDefined(labelFormatObject.percent) ? {percentText: tooltip.formatValue(labelFormatObject.percent, "percent")} : {}, _isDefined(labelFormatObject.total) ? {totalText: tooltip.formatValue(labelFormatObject.total)} : {})
            },
            coordsIn: function(x, y) {
                var trackerRadius = this._storeTrackerR();
                return x >= this.x - trackerRadius && x <= this.x + trackerRadius && y >= this.y - trackerRadius && y <= this.y + trackerRadius
            }
        }
    })(jQuery, DevExpress);
    /*! Module viz-core, file barPoint.js */
    (function($, DX) {
        var points = DX.viz.core.series.points.mixins,
            _extend = $.extend,
            _math = Math,
            _round = _math.round,
            _abs = _math.abs,
            _min = _math.min,
            CANVAS_POSITION_DEFAULT = "canvas_position_default",
            DEFAULT_BAR_TRACKER_SIZE = 9,
            CORRECTING_BAR_TRACKER_VALUE = 4;
        points.barPoint = _extend({}, points.symbolPoint, {
            correctCoordinates: function(correctOptions) {
                var correction = correctOptions.offset - _round(correctOptions.width / 2),
                    rotated = this._options.rotated,
                    valueSelector = rotated ? "height" : "width",
                    correctionSelector = (rotated ? "y" : "x") + "Correction";
                this[valueSelector] = correctOptions.width;
                this[correctionSelector] = correction
            },
            _getGraphicBbox: function() {
                var that = this,
                    bbox = {};
                bbox.x = that.x;
                bbox.y = that.y;
                bbox.width = that.width;
                bbox.height = that.height;
                return bbox
            },
            _getLabelPosition: function() {
                var that = this,
                    position,
                    translators = that.translators,
                    initialValue = that.initialValue,
                    invertX = translators.x.getBusinessRange().invert,
                    invertY = translators.y.getBusinessRange().invert,
                    isDiscreteValue = that.series.valueAxisType === "discrete",
                    isFullStacked = that.series.isFullStackedSeries(),
                    notVerticalInverted = !isDiscreteValue && (initialValue >= 0 && !invertY || initialValue < 0 && invertY) || isDiscreteValue && !invertY || isFullStacked,
                    notHorizontalInverted = !isDiscreteValue && (initialValue >= 0 && !invertX || initialValue < 0 && invertX) || isDiscreteValue && !invertX || isFullStacked;
                if (!that._options.rotated)
                    position = notVerticalInverted ? "top" : "bottom";
                else
                    position = notHorizontalInverted ? "right" : "left";
                return position
            },
            _getLabelCoords: function(label) {
                var that = this,
                    coords;
                if (that.initialValue === 0 && that.series.isFullStackedSeries())
                    if (!this._options.rotated)
                        coords = that._getLabelCoordOfPosition(label, "top");
                    else
                        coords = that._getLabelCoordOfPosition(label, "right");
                else if (label.getLayoutOptions().position === "inside")
                    coords = that._getLabelCoordOfPosition(label, "inside");
                else
                    coords = points.symbolPoint._getLabelCoords.call(this, label);
                return coords
            },
            checkLabelPosition: function(label, coord) {
                var that = this,
                    visibleArea = that._getVisibleArea(),
                    x = coord.x,
                    y = coord.y,
                    graphicBbox = that._getGraphicBbox(),
                    labelBbox = label.getBoundingRect(),
                    visible = true;
                if (that._options.resolveLabelsOverlapping && label.getLayoutOptions().position === "inside")
                    if (labelBbox.width > graphicBbox.width || labelBbox.height > graphicBbox.height)
                        visible = false;
                visible ? label.show() : label.hide();
                if (visibleArea.minX <= graphicBbox.x + graphicBbox.width && visibleArea.maxX >= graphicBbox.x && visibleArea.minY <= graphicBbox.y + graphicBbox.height && visibleArea.maxY >= graphicBbox.y)
                    if (!that._options.rotated) {
                        if (visibleArea.minX > x && that.adjustSeriesLabels)
                            x = visibleArea.minX;
                        if (visibleArea.maxX < x + labelBbox.width && that.adjustSeriesLabels)
                            x = visibleArea.maxX - labelBbox.width;
                        if (visibleArea.minY > y)
                            y = visibleArea.minY;
                        if (visibleArea.maxY < y + labelBbox.height)
                            y = visibleArea.maxY - labelBbox.height
                    }
                    else {
                        if (visibleArea.minX > x)
                            x = visibleArea.minX;
                        if (visibleArea.maxX < x + labelBbox.width)
                            x = visibleArea.maxX - labelBbox.width;
                        if (visibleArea.minY > y && that.adjustSeriesLabels)
                            y = visibleArea.minY;
                        if (visibleArea.maxY < y + labelBbox.height && that.adjustSeriesLabels)
                            y = visibleArea.maxY - labelBbox.height
                    }
                return {
                        x: x,
                        y: y
                    }
            },
            _showForZeroValues: function() {
                return this._options.label.showForZeroValues || this.initialValue
            },
            _drawMarker: function(renderer, group, animationEnabled) {
                var that = this,
                    style = that._getStyle(),
                    x = that.x,
                    y = that.y,
                    width = that.width,
                    height = that.height,
                    r = that._options.cornerRadius;
                if (animationEnabled)
                    if (that._options.rotated) {
                        width = 0;
                        x = that.defaultX
                    }
                    else {
                        height = 0;
                        y = that.defaultY
                    }
                that.graphic = renderer.rect(x, y, width, height).attr({
                    rx: r,
                    ry: r
                }).attr(style).append(group);
                $(that.graphic.element).data({point: that})
            },
            _getSettingsForTracker: function() {
                var that = this,
                    y = that.y,
                    height = that.height,
                    x = that.x,
                    width = that.width;
                if (that._options.rotated) {
                    if (width === 1) {
                        width = DEFAULT_BAR_TRACKER_SIZE;
                        x -= CORRECTING_BAR_TRACKER_VALUE
                    }
                }
                else if (height === 1) {
                    height = DEFAULT_BAR_TRACKER_SIZE;
                    y -= CORRECTING_BAR_TRACKER_VALUE
                }
                return {
                        x: x,
                        y: y,
                        width: width,
                        height: height
                    }
            },
            _drawTrackerMarker: function(renderer, group) {
                var that = this,
                    r = that._options.cornerRadius,
                    settings = that._getSettingsForTracker();
                that.trackerGraphic = renderer.rect(settings.x, settings.y, settings.width, settings.height).attr({
                    rx: r,
                    ry: r
                }).append(group);
                $(that.trackerGraphic.element).data({point: that})
            },
            getGraphicSettings: function() {
                var graphic = this.graphic;
                return {
                        x: graphic.attr("x"),
                        y: graphic.attr("y"),
                        height: graphic.attr("height"),
                        width: graphic.attr("width")
                    }
            },
            _getEdgeTooltipParams: function(x, y, width, height) {
                var isPositive = this.value >= 0,
                    arrowSide,
                    verticalPosition,
                    xCoord,
                    yCoord;
                if (this._options.rotated) {
                    xCoord = isPositive ? x + width : x;
                    yCoord = y + height / 2;
                    arrowSide = isPositive ? 'left' : 'right'
                }
                else {
                    xCoord = x + width / 2;
                    yCoord = isPositive ? y : y + height;
                    verticalPosition = isPositive ? 'top' : 'bottom'
                }
                return {
                        x: xCoord,
                        y: yCoord,
                        arrowSide: arrowSide,
                        cloudVerticalPosition: verticalPosition,
                        offset: 0
                    }
            },
            getTooltipParams: function(location) {
                var x = this.x,
                    y = this.y,
                    width = this.width,
                    height = this.height;
                return location === 'edge' ? this._getEdgeTooltipParams(x, y, width, height) : {
                        x: x + width / 2,
                        y: y + height / 2,
                        offset: 0
                    }
            },
            _truncateCoord: function(coord, minBounce, maxBounce) {
                if (coord < minBounce)
                    return minBounce;
                if (coord > maxBounce)
                    return maxBounce;
                return coord
            },
            _translate: function(translators) {
                var that = this,
                    rotated = that._options.rotated,
                    valAxis = rotated ? "x" : "y",
                    argAxis = rotated ? "y" : "x",
                    valIntervalName = rotated ? "width" : "height",
                    argIntervalName = rotated ? "height" : "width",
                    argTranslator = translators[argAxis],
                    valTranslator = translators[valAxis],
                    argVisibleArea = argTranslator.getCanvasVisibleArea(),
                    valVisibleArea = valTranslator.getCanvasVisibleArea(),
                    arg,
                    minArg,
                    val,
                    minVal;
                arg = minArg = argTranslator.translate(that.argument) + (that[argAxis + "Correction"] || 0);
                val = valTranslator.translate(that.value);
                minVal = valTranslator.translate(that.minValue);
                that["v" + valAxis] = val;
                that["v" + argAxis] = arg + that[argIntervalName] / 2;
                that[valIntervalName] = _abs(val - minVal);
                that._calculateVisibility(rotated ? _min(val, minVal) : _min(arg, minArg), rotated ? _min(arg, minArg) : _min(val, minVal), that.width, that.height);
                val = that._truncateCoord(val, valVisibleArea.min, valVisibleArea.max);
                minVal = that._truncateCoord(minVal, valVisibleArea.min, valVisibleArea.max);
                that[argAxis] = arg;
                that["min" + argAxis.toUpperCase()] = minArg;
                that[valIntervalName] = _abs(val - minVal);
                that[valAxis] = _min(val, minVal) + (that[valAxis + "Correction"] || 0);
                that["min" + valAxis.toUpperCase()] = minVal + (that[valAxis + "Correction"] || 0);
                that["default" + valAxis.toUpperCase()] = valTranslator.translate(CANVAS_POSITION_DEFAULT);
                that._translateErrorBars(valTranslator);
                if (that.inVisibleArea) {
                    if (that[argAxis] < argVisibleArea.min) {
                        that[argIntervalName] = that[argIntervalName] - (argVisibleArea.min - that[argAxis]);
                        that[argAxis] = argVisibleArea.min;
                        that["min" + argAxis.toUpperCase()] = argVisibleArea.min
                    }
                    if (that[argAxis] + that[argIntervalName] > argVisibleArea.max)
                        that[argIntervalName] = argVisibleArea.max - that[argAxis]
                }
            },
            _updateMarker: function(animationEnabled, style) {
                var that = this,
                    attributes = _extend({}, style || that._getStyle());
                if (!animationEnabled)
                    attributes = _extend(true, attributes, that.getMarkerCoords());
                that.graphic.attr(attributes)
            },
            getMarkerCoords: function() {
                return {
                        x: this.x,
                        y: this.y,
                        width: this.width,
                        height: this.height
                    }
            },
            _updateTracker: function() {
                this.trackerGraphic.attr(this._getSettingsForTracker())
            },
            coordsIn: function(x, y) {
                var that = this;
                return x >= that.x && x <= that.x + that.width && y >= that.y && y <= that.y + that.height
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file bubblePoint.js */
    (function($, DX) {
        var points = DX.viz.core.series.points.mixins,
            _extend = $.extend,
            MIN_BUBBLE_HEIGHT = 20;
        points.bubblePoint = _extend({}, points.symbolPoint, {
            correctCoordinates: function(diameter) {
                this.bubbleSize = diameter / 2
            },
            _drawMarker: function(renderer, group, animationEnabled) {
                var that = this,
                    attr = _extend({
                        translateX: that.x,
                        translateY: that.y
                    }, that._getStyle());
                that.graphic = renderer.circle(0, 0, animationEnabled ? 0 : that.bubbleSize).attr(attr).append(group);
                $(that.graphic.element).data({series: that.series})
            },
            _drawTrackerMarker: function(renderer, group) {
                var that = this;
                that.trackerGraphic = renderer.circle(that.x, that.y, that.bubbleSize).append(group);
                $(that.trackerGraphic.element).data({point: that})
            },
            getTooltipParams: function(location) {
                var that = this,
                    graphic = that.graphic,
                    height;
                if (!graphic)
                    return;
                height = graphic.getBBox().height;
                return {
                        x: that.x,
                        y: height < MIN_BUBBLE_HEIGHT || location === 'edge' ? this.y - height / 2 : this.y,
                        offset: 0
                    }
            },
            _getLabelFormatObject: function() {
                var formatObject = points.symbolPoint._getLabelFormatObject.call(this);
                formatObject.size = this.initialSize;
                return formatObject
            },
            _updateData: function(data) {
                points.symbolPoint._updateData.call(this, data);
                this.size = this.initialSize = data.size
            },
            _getGraphicBbox: function() {
                var that = this;
                return that._getSymbolBbox(that.x, that.y, that.bubbleSize)
            },
            _updateMarker: function(animationEnabled, style) {
                var that = this,
                    style = style || that._getStyle();
                if (!animationEnabled)
                    style = $.extend({
                        r: that.bubbleSize,
                        translateX: that.x,
                        translateY: that.y
                    }, style);
                that.graphic.attr(style)
            },
            _updateTracker: function() {
                var that = this;
                that.trackerGraphic.attr({
                    cx: that.x,
                    cy: that.y,
                    r: that.bubbleSize
                })
            },
            _getFormatObject: function(tooltip) {
                var formatObject = points.symbolPoint._getFormatObject.call(this, tooltip);
                formatObject.sizeText = tooltip.formatValue(this.initialSize);
                return formatObject
            },
            _storeTrackerR: function() {
                return this.bubbleSize
            },
            _getLabelCoords: function(label) {
                var coords;
                if (label.getLayoutOptions().position === "inside")
                    coords = this._getLabelCoordOfPosition(label, "inside");
                else
                    coords = points.symbolPoint._getLabelCoords.call(this, label);
                return coords
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file piePoint.js */
    (function($, DX) {
        var CONNECTOR_LENGTH = 20,
            series = DX.viz.core.series,
            points = series.points.mixins,
            _extend = $.extend,
            _round = Math.round,
            _acos = Math.acos,
            DEG = 180 / Math.PI,
            _abs = Math.abs,
            _utils = DX.utils,
            INDENT_FROM_PIE = series.helpers.consts.pieLabelIndent,
            _getCosAndSin = _utils.getCosAndSin;
        points.piePoint = _extend({}, points.symbolPoint, {
            _updateData: function(data) {
                var that = this;
                points.symbolPoint._updateData.call(this, data);
                that._visible = true;
                that.minValue = that.initialMinValue = that.originalMinValue = _utils.isDefined(data.minValue) ? data.minValue : 0
            },
            animate: function(complete, duration, step) {
                var that = this;
                that.graphic.animate({
                    x: that.centerX,
                    y: that.centerY,
                    outerRadius: that.radiusOuter,
                    innerRadius: that.radiusInner,
                    startAngle: that.toAngle,
                    endAngle: that.fromAngle
                }, {
                    partitionDuration: duration,
                    step: step
                }, complete)
            },
            correctPosition: function(correction) {
                var that = this;
                that.radiusInner = correction.radiusInner;
                that.radiusOuter = correction.radiusOuter;
                that.centerX = correction.centerX;
                that.centerY = correction.centerY
            },
            correctValue: function(correction, percent, base) {
                var that = this;
                that.value = (base || that.initialValue) + correction;
                that.minValue = correction;
                that.percent = percent;
                that._label.setDataField("percent", percent)
            },
            _updateLabelData: function() {
                this._label.updateData({formatObject: this._getLabelFormatObject()})
            },
            _updateLabelOptions: function() {
                var that = this;
                !that._label && that._createLabel();
                that._label.setOptions(that._options.label)
            },
            _drawLabel: function(renderer, group) {
                var that = this,
                    coord,
                    customVisibility = that._getCustomLabelVisibility();
                if ((that.series.getLabelVisibility() || customVisibility) && that.hasValue()) {
                    that._label.draw(renderer, group, customVisibility);
                    coord = that._getLabelCoords(that._label);
                    coord = that.resolveCollision({
                        x: _round(coord.x),
                        y: _round(coord.y)
                    });
                    that._label.setFigureToDrawConnector(that._getLabelConnector(that._label, coord));
                    that._label.shift(_round(coord.x), _round(coord.y))
                }
                else
                    that._label.hide()
            },
            _getLabelCoords: function(label) {
                var that = this,
                    bbox = label.getBoundingRect(),
                    options = label.getLayoutOptions(),
                    angleFunctions = _getCosAndSin(that.middleAngle),
                    rad = that.radiusOuter + options.radialOffset,
                    x;
                if (options.position === 'inside') {
                    rad -= INDENT_FROM_PIE;
                    x = that.centerX + rad * angleFunctions.cos - bbox.width / 2
                }
                else {
                    rad += INDENT_FROM_PIE;
                    if (angleFunctions.cos > 0.1)
                        x = that.centerX + rad * angleFunctions.cos;
                    else if (angleFunctions.cos < -0.1)
                        x = that.centerX + rad * angleFunctions.cos - bbox.width;
                    else
                        x = that.centerX + rad * angleFunctions.cos - bbox.width / 2
                }
                return {
                        x: x,
                        y: _round(that.centerY - rad * angleFunctions.sin - bbox.height / 2)
                    }
            },
            getColumnsCoord: function(coord) {
                var that = this,
                    label = that._label,
                    bbox = label.getBoundingRect(),
                    options = label.getLayoutOptions(),
                    rad = that.radiusOuter + options.radialOffset,
                    canvas = that.series.canvas,
                    rightBorderX = canvas.width - canvas.right - bbox.width,
                    leftBorderX = canvas.left,
                    angleOfPoint = _utils.normalizeAngle(that.middleAngle),
                    x;
                if (options.position !== 'columns')
                    return coord;
                rad += CONNECTOR_LENGTH;
                if (angleOfPoint < 90 || angleOfPoint >= 270) {
                    x = that._maxLabelLength ? that.centerX + rad + that._maxLabelLength - bbox.width : rightBorderX;
                    x = x > rightBorderX ? rightBorderX : x
                }
                else {
                    x = that._maxLabelLength ? that.centerX - rad - that._maxLabelLength : leftBorderX;
                    x = x < leftBorderX ? leftBorderX : x
                }
                coord.x = x;
                return coord
            },
            drawLabel: function(translators, renderer, group) {
                this.translate(translators);
                this._drawLabel(renderer, group)
            },
            updateLabelCoord: function() {
                var that = this,
                    bbox = that._label.getBoundingRect(),
                    coord = that._notCollisionCoord || {};
                if (coord.x < that.centerX)
                    coord.x += that._oldLabelBBox.width - bbox.width;
                coord = that.getColumnsCoord(coord);
                coord = that.checkLabelPosition(this._label, coord);
                that._label.shift(_round(coord.x), _round(bbox.y))
            },
            setLabelEllipsis: function() {
                var that = this,
                    coord = that._notCollisionCoord || {},
                    bbox = that._label.getBoundingRect();
                that._oldLabelBBox = bbox;
                that._label.checkEllipsis({
                    width: bbox.width - _abs(coord.x - bbox.x),
                    height: bbox.height - _abs(coord.y - bbox.y)
                })
            },
            resolveCollision: function(coord) {
                this._notCollisionCoord = coord;
                return this.checkLabelPosition(this._label, coord)
            },
            _getVisibleArea: function() {
                var canvas = this.series.canvas;
                return {
                        minX: canvas.left,
                        maxX: canvas.width - canvas.right,
                        minY: canvas.top,
                        maxY: canvas.height - canvas.bottom
                    }
            },
            checkLabelPosition: function(label, coord) {
                return this._moveLabelOnCanvas(coord, label.getBoundingRect(), this._getVisibleArea())
            },
            _moveLabelOnCanvas: function(coord, box, visibleArea) {
                var x = coord.x,
                    y = coord.y;
                if (coord.y + box.height > visibleArea.maxY)
                    y = visibleArea.maxY - box.height;
                else if (coord.y < visibleArea.minY)
                    y = visibleArea.minY;
                if (coord.x + box.width > visibleArea.maxX)
                    x = visibleArea.maxX - box.width;
                else if (coord.x < visibleArea.minX)
                    x = visibleArea.minX;
                return {
                        x: x,
                        y: y
                    }
            },
            getBoundaryCoords: function() {
                var that = this,
                    rad = that.radiusOuter,
                    seriesStyle = that._options.styles.normal,
                    strokeWidthBy2 = seriesStyle["stroke-width"] / 2,
                    borderWidth = that.series.getOptions().containerBackgroundColor === seriesStyle.stroke ? _round(strokeWidthBy2) : _round(-strokeWidthBy2),
                    angleFunctions = _getCosAndSin(_round(that.middleAngle));
                return {
                        x: _round(that.centerX + (rad - borderWidth) * angleFunctions.cos),
                        y: _round(that.centerY - (rad - borderWidth) * angleFunctions.sin)
                    }
            },
            _getLabelConnector: function(label) {
                if (label.getLayoutOptions().position !== "inside") {
                    var coords = this.getBoundaryCoords();
                    return {
                            x: coords.x,
                            y: coords.y,
                            angle: this.middleAngle
                        }
                }
            },
            _drawMarker: function(renderer, group, animationEnabled, firstDrawing) {
                var that = this,
                    radiusOuter = that.radiusOuter,
                    radiusInner = that.radiusInner,
                    fromAngle = that.fromAngle,
                    toAngle = that.toAngle;
                if (animationEnabled) {
                    radiusInner = radiusOuter = 0;
                    if (!firstDrawing)
                        fromAngle = toAngle = that.shiftedAngle
                }
                that.graphic = renderer.arc(that.centerX, that.centerY, radiusInner, radiusOuter, toAngle, fromAngle).attr({"stroke-linejoin": "round"}).attr(that._getStyle()).sharp().append(group);
                $(that.graphic.element).data({point: this})
            },
            _drawTrackerMarker: function(renderer, group) {
                var that = this;
                that.trackerGraphic = renderer.arc(that.centerX, that.centerY, that.radiusInner, that.radiusOuter, that.toAngle, that.fromAngle).attr({"stroke-linejoin": "round"}).append(group);
                $(that.trackerGraphic.element).data({point: that})
            },
            getTooltipParams: function() {
                var that = this,
                    angleFunctions = _getCosAndSin(that.middleAngle),
                    radiusInner = that.radiusInner,
                    radiusOuter = that.radiusOuter;
                return {
                        x: that.centerX + (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.cos,
                        y: that.centerY - (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.sin,
                        offset: 0
                    }
            },
            _translate: function(translator) {
                var that = this,
                    angle = that.shiftedAngle || 0,
                    value = that.value,
                    minValue = that.minValue;
                that.fromAngle = translator.translate(minValue) + angle;
                that.toAngle = translator.translate(value) + angle;
                that.middleAngle = translator.translate((value - minValue) / 2 + minValue) + angle;
                if (!that.isVisible())
                    that.middleAngle = that.toAngle = that.fromAngle = that.fromAngle || angle
            },
            _updateMarker: function(animationEnabled, style) {
                var that = this;
                style = style || that._getStyle();
                if (!animationEnabled)
                    style = _extend({
                        x: that.centerX,
                        y: that.centerY,
                        outerRadius: that.radiusOuter,
                        innerRadius: that.radiusInner,
                        startAngle: that.toAngle,
                        endAngle: that.fromAngle
                    }, style);
                that.graphic.attr(style).sharp()
            },
            _updateTracker: function() {
                var that = this;
                that.trackerGraphic.attr({
                    x: that.centerX,
                    y: that.centerY,
                    outerRadius: that.radiusOuter,
                    innerRadius: that.radiusInner,
                    startAngle: that.toAngle,
                    endAngle: that.fromAngle
                })
            },
            getLegendStyles: function() {
                return this._styles.legendStyles
            },
            isInVisibleArea: function() {
                return true
            },
            hide: function() {
                var that = this;
                if (that._visible) {
                    that._visible = false;
                    that.hideTooltip();
                    that._options.visibilityChanged(that)
                }
            },
            show: function() {
                var that = this;
                if (!that._visible) {
                    that._visible = true;
                    that._options.visibilityChanged(that)
                }
            },
            setInvisibility: function() {
                this._setTrackerInvisibility();
                this._label.hide()
            },
            isVisible: function() {
                return this._visible
            },
            _getFormatObject: function(tooltip) {
                var formatObject = points.symbolPoint._getFormatObject.call(this, tooltip),
                    percent = this.percent;
                formatObject.percent = percent;
                formatObject.percentText = tooltip.formatValue(percent, "percent");
                return formatObject
            },
            getColor: function() {
                return this._styles.normal.fill
            },
            coordsIn: function(x, y) {
                var that = this,
                    lx = x - that.centerX,
                    ly = y - that.centerY,
                    r = Math.sqrt(lx * lx + ly * ly),
                    fromAngle = that.fromAngle % 360,
                    toAngle = that.toAngle % 360,
                    angle;
                if (r < that.radiusInner || r > that.radiusOuter || r == 0)
                    return false;
                angle = _acos(lx / r) * DEG * (ly > 0 ? -1 : 1);
                if (angle < 0)
                    angle += 360;
                return fromAngle >= toAngle ? angle <= fromAngle && angle >= toAngle : !(angle >= fromAngle && angle <= toAngle)
            },
            getIndentFromPie: function() {
                return INDENT_FROM_PIE + this._label.getLayoutOptions().radialOffset
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file rangeSymbolPoint.js */
    (function($, DX) {
        var core = DX.viz.core,
            points = core.series.points.mixins,
            _extend = $.extend,
            _isDefined = DX.utils.isDefined,
            _math = Math,
            _abs = _math.abs,
            _min = _math.min,
            _max = _math.max,
            _round = _math.round,
            DEFAULT_IMAGE_WIDTH = 20,
            DEFAULT_IMAGE_HEIGHT = 20;
        points.rangeSymbolPoint = _extend({}, points.symbolPoint, {
            deleteLabel: function() {
                var that = this;
                that._topLabel.dispose();
                that._topLabel = null;
                that._bottomLabel.dispose();
                that._bottomLabel = null
            },
            hideMarker: function(type) {
                var graphic = this.graphic,
                    marker = graphic && graphic[type + "Marker"],
                    label = this["_" + type + "Label"];
                if (marker && marker.attr("visibility") !== "hidden")
                    marker.attr({visibility: "hidden"});
                label.hide()
            },
            setInvisibility: function() {
                this.hideMarker("top");
                this.hideMarker("bottom");
                this._setTrackerInvisibility()
            },
            clearVisibility: function() {
                var that = this,
                    graphic = that.graphic,
                    topMarker = graphic && graphic.topMarker,
                    bottomMarker = graphic && graphic.bottomMarker;
                if (topMarker && topMarker.attr("visibility"))
                    topMarker.attr({visibility: null});
                if (bottomMarker && bottomMarker.attr("visibility"))
                    bottomMarker.attr({visibility: null});
                that._clearTrackerVisibility();
                that._topLabel.clearVisibility();
                that._bottomLabel.clearVisibility()
            },
            clearMarker: function() {
                var that = this,
                    graphic = that.graphic,
                    topMarker = graphic && graphic.topMarker,
                    bottomMarker = graphic && graphic.bottomMarker,
                    emptySettings = that._emptySettings;
                topMarker && topMarker.attr(emptySettings);
                bottomMarker && bottomMarker.attr(emptySettings)
            },
            _getLabelPosition: function(markerType) {
                var position,
                    labelsInside = this._options.label.position === "inside";
                if (!this._options.rotated)
                    position = markerType === "top" ^ labelsInside ? "top" : "bottom";
                else
                    position = markerType === "top" ^ labelsInside ? "right" : "left";
                return position
            },
            _getLabelMinFormatObject: function() {
                var that = this;
                return {
                        index: 0,
                        argument: that.initialArgument,
                        value: that.initialMinValue,
                        seriesName: that.series.name,
                        originalValue: that.originalMinValue,
                        originalArgument: that.originalArgument,
                        point: that
                    }
            },
            _updateLabelData: function() {
                var that = this,
                    maxFormatObject = that._getLabelFormatObject();
                maxFormatObject.index = 1;
                that._topLabel.updateData({
                    formatObject: maxFormatObject,
                    initialValue: that.initialValue
                });
                that._bottomLabel.updateData({
                    formatObject: that._getLabelMinFormatObject(),
                    initialValue: that.initialMinValue
                })
            },
            _updateLabelOptions: function(type) {
                var that = this,
                    options = this._options.label;
                (!that._topLabel || !that._bottomLabel) && that._createLabel();
                that._topLabel.setOptions(options);
                that._bottomLabel.setOptions(options)
            },
            _createLabel: function() {
                this._topLabel = core.CoreFactory.createLabel();
                this._bottomLabel = core.CoreFactory.createLabel()
            },
            _getGraphicBbox: function(location) {
                var options = this._options,
                    images = this._getImage(options.image),
                    image = location === "top" ? this._checkImage(images.top) : this._checkImage(images.bottom),
                    bbox,
                    coord = this._getPositionFromLocation(location);
                if (options.visible)
                    bbox = image ? this._getImageBbox(coord.x, coord.y) : this._getSymbolBbox(coord.x, coord.y, options.styles.normal.r);
                else
                    bbox = {
                        x: coord.x,
                        y: coord.y,
                        width: 0,
                        height: 0
                    };
                return bbox
            },
            _getPositionFromLocation: function(location) {
                var x,
                    y,
                    isTop = location === "top";
                if (!this._options.rotated) {
                    x = this.x;
                    y = isTop ? _min(this.y, this.minY) : _max(this.y, this.minY)
                }
                else {
                    x = isTop ? _max(this.x, this.minX) : _min(this.x, this.minX);
                    y = this.y
                }
                return {
                        x: x,
                        y: y
                    }
            },
            _checkOverlay: function(bottomCoord, topCoord, topValue) {
                return bottomCoord < topCoord + topValue
            },
            _getOverlayCorrections: function(type, topCoords, bottomCoords) {
                var isVertical = type === "vertical",
                    coordSelector = isVertical ? "y" : "x",
                    valueSelector = isVertical ? "height" : "width",
                    visibleArea = this.translators[coordSelector].getCanvasVisibleArea(),
                    minBound = visibleArea.min,
                    maxBound = visibleArea.max,
                    delta = _round((topCoords[coordSelector] + topCoords[valueSelector] - bottomCoords[coordSelector]) / 2),
                    coord1 = topCoords[coordSelector] - delta,
                    coord2 = bottomCoords[coordSelector] + delta;
                if (coord1 < minBound) {
                    delta = minBound - topCoords[coordSelector];
                    coord1 += delta;
                    coord2 += delta
                }
                else if (coord2 + bottomCoords[valueSelector] > maxBound) {
                    delta = -(bottomCoords[coordSelector] + bottomCoords[valueSelector] - maxBound);
                    coord1 += delta;
                    coord2 += delta
                }
                return {
                        coord1: coord1,
                        coord2: coord2
                    }
            },
            _checkLabelsOverlay: function(topLocation) {
                var that = this,
                    topCoords = that._topLabel.getBoundingRect(),
                    bottomCoords = that._bottomLabel.getBoundingRect(),
                    corrections = {};
                if (!that._options.rotated) {
                    if (topLocation === "top") {
                        if (this._checkOverlay(bottomCoords.y, topCoords.y, topCoords.height)) {
                            corrections = this._getOverlayCorrections("vertical", topCoords, bottomCoords);
                            that._topLabel.shift(topCoords.x, corrections.coord1);
                            that._bottomLabel.shift(bottomCoords.x, corrections.coord2)
                        }
                    }
                    else if (this._checkOverlay(topCoords.y, bottomCoords.y, bottomCoords.height)) {
                        corrections = this._getOverlayCorrections("vertical", bottomCoords, topCoords);
                        that._topLabel.shift(topCoords.x, corrections.coord2);
                        that._bottomLabel.shift(bottomCoords.x, corrections.coord1)
                    }
                }
                else if (topLocation === "top") {
                    if (this._checkOverlay(topCoords.x, bottomCoords.x, bottomCoords.width)) {
                        corrections = this._getOverlayCorrections("horizontal", bottomCoords, topCoords);
                        that._topLabel.shift(corrections.coord2, topCoords.y);
                        that._bottomLabel.shift(corrections.coord1, bottomCoords.y)
                    }
                }
                else if (this._checkOverlay(bottomCoords.x, topCoords.x, topCoords.width)) {
                    corrections = this._getOverlayCorrections("horizontal", topCoords, bottomCoords);
                    that._topLabel.shift(corrections.coord1, topCoords.y);
                    that._bottomLabel.shift(corrections.coord2, bottomCoords.y)
                }
            },
            _drawLabel: function(renderer, group) {
                var that = this,
                    coord,
                    visibleArea,
                    labels = [],
                    notInverted = that._options.rotated ? that.x >= that.minX : that.y < that.minY,
                    customVisibility = that._getCustomLabelVisibility();
                that._topLabel.pointPosition = notInverted ? "top" : "bottom";
                that._bottomLabel.pointPosition = notInverted ? "bottom" : "top";
                if ((that.series.getLabelVisibility() || customVisibility) && that.hasValue()) {
                    visibleArea = that._getVisibleArea();
                    that.visibleTopMarker !== false && labels.push(that._topLabel);
                    that.visibleBottomMarker !== false && labels.push(that._bottomLabel);
                    $.each(labels, function(_, label) {
                        var pointPosition = label.pointPosition;
                        label.draw(renderer, group, customVisibility);
                        coord = that._getLabelCoords(label, pointPosition);
                        coord = that._addLabelAlignmentAndOffset(label, coord);
                        coord = that.checkLabelPosition(label, coord, pointPosition);
                        label.setFigureToDrawConnector(that._getLabelConnector(label, coord, pointPosition));
                        label.shift(_round(coord.x), _round(coord.y))
                    });
                    that._checkLabelsOverlay(that._topLabel.pointPosition)
                }
                else {
                    that._topLabel.hide();
                    that._bottomLabel.hide()
                }
            },
            _getImage: function(imageOption) {
                var image = {};
                if (_isDefined(imageOption))
                    if (typeof imageOption === "string")
                        image.top = image.bottom = imageOption;
                    else {
                        image.top = {
                            url: typeof imageOption.url === "string" ? imageOption.url : imageOption.url && imageOption.url.rangeMaxPoint,
                            width: typeof imageOption.width === "number" ? imageOption.width : imageOption.width && imageOption.width.rangeMaxPoint,
                            height: typeof imageOption.height === "number" ? imageOption.height : imageOption.height && imageOption.height.rangeMaxPoint
                        };
                        image.bottom = {
                            url: typeof imageOption.url === "string" ? imageOption.url : imageOption.url && imageOption.url.rangeMinPoint,
                            width: typeof imageOption.width === "number" ? imageOption.width : imageOption.width && imageOption.width.rangeMinPoint,
                            height: typeof imageOption.height === "number" ? imageOption.height : imageOption.height && imageOption.height.rangeMinPoint
                        }
                    }
                return image
            },
            _checkSymbol: function(oldOptions, newOptions) {
                var that = this,
                    oldSymbol = oldOptions.symbol,
                    newSymbol = newOptions.symbol,
                    symbolChanged = oldSymbol === "circle" && newSymbol !== "circle" || oldSymbol !== "circle" && newSymbol === "circle",
                    oldImages = that._getImage(oldOptions.image),
                    newImages = that._getImage(newOptions.image),
                    topImageChanged = that._checkImage(oldImages.top) !== that._checkImage(newImages.top),
                    bottomImageChanged = that._checkImage(oldImages.bottom) !== that._checkImage(newImages.bottom);
                return symbolChanged || topImageChanged || bottomImageChanged
            },
            _getSettingsForTwoMarkers: function(style) {
                var that = this,
                    options = that._options,
                    settings = {},
                    x = options.rotated ? _min(that.x, that.minX) : that.x,
                    y = options.rotated ? that.y : _min(that.y, that.minY),
                    radius = style.r,
                    points = that._populatePointShape(options.symbol, radius);
                settings.top = _extend({
                    translateX: x + that.width,
                    translateY: y,
                    r: radius
                }, style);
                settings.bottom = _extend({
                    translateX: x,
                    translateY: y + that.height,
                    r: radius
                }, style);
                points && (settings.top.points = points, settings.bottom.points = points);
                return settings
            },
            _hasGraphic: function() {
                return this.graphic && this.graphic.topMarker && this.graphic.bottomMarker
            },
            _drawOneMarker: function(renderer, markerType, imageSettings, settings) {
                var that = this,
                    graphic = that.graphic;
                if (graphic[markerType])
                    that._updateOneMarker(markerType, settings);
                else
                    graphic[markerType] = that._createMarker(renderer, graphic, imageSettings, settings)
            },
            _drawMarker: function(renderer, group, animationEnabled, style) {
                var that = this,
                    settings = that._getSettingsForTwoMarkers(style || that._getStyle()),
                    image = that._getImage(that._options.image);
                if (that._checkImage(image.top))
                    settings.top = that._getImageSettings(settings.top, image.top);
                if (that._checkImage(image.bottom))
                    settings.bottom = that._getImageSettings(settings.bottom, image.bottom);
                that.graphic = that.graphic || renderer.g().append(group);
                that.visibleTopMarker && that._drawOneMarker(renderer, 'topMarker', image.top, settings.top);
                that.visibleBottomMarker && that._drawOneMarker(renderer, 'bottomMarker', image.bottom, settings.bottom)
            },
            _getSettingsForTracker: function(radius) {
                var that = this,
                    rotated = that._options.rotated;
                return {
                        translateX: rotated ? _min(that.x, that.minX) - radius : that.x - radius,
                        translateY: rotated ? that.y - radius : _min(that.y, that.minY) - radius,
                        width: that.width + 2 * radius,
                        height: that.height + 2 * radius
                    }
            },
            _drawTrackerMarker: function(renderer, group) {
                var that = this,
                    radius = that._options.trackerR || that._storeTrackerR(),
                    settings = that._getSettingsForTracker(radius);
                that.trackerGraphic = renderer.rect().attr(settings).append(group);
                $(that.trackerGraphic.element).data({point: that})
            },
            isInVisibleArea: function() {
                var that = this,
                    rotated = that._options.rotated,
                    argument = !rotated ? that.x : that.y,
                    maxValue = !rotated ? _max(that.minY, that.y) : _max(that.minX, that.x),
                    minValue = !rotated ? _min(that.minY, that.y) : _min(that.minX, that.x),
                    translators = that.translators,
                    notVisibleByArg,
                    notVisibleByVal,
                    tmp,
                    visibleTopMarker = true,
                    visibleBottomMarker = true,
                    visibleRangeArea = true,
                    visibleArgArea,
                    visibleValArea;
                if (translators) {
                    visibleArgArea = translators[!rotated ? "x" : "y"].getCanvasVisibleArea();
                    visibleValArea = translators[!rotated ? "y" : "x"].getCanvasVisibleArea();
                    notVisibleByArg = visibleArgArea.max < argument || visibleArgArea.min > argument;
                    notVisibleByVal = visibleValArea.min > minValue && visibleValArea.min > maxValue || visibleValArea.max < minValue && visibleValArea.max < maxValue;
                    if (notVisibleByArg || notVisibleByVal)
                        visibleTopMarker = visibleBottomMarker = visibleRangeArea = false;
                    else {
                        visibleTopMarker = visibleValArea.min < minValue && visibleValArea.max > minValue;
                        visibleBottomMarker = visibleValArea.min < maxValue && visibleValArea.max > maxValue;
                        if (rotated) {
                            tmp = visibleTopMarker;
                            visibleTopMarker = visibleBottomMarker;
                            visibleBottomMarker = tmp
                        }
                    }
                }
                that.visibleTopMarker = visibleTopMarker;
                that.visibleBottomMarker = visibleBottomMarker;
                return visibleRangeArea
            },
            getTooltipParams: function() {
                var that = this,
                    x,
                    y,
                    min,
                    max,
                    minValue,
                    translators = that.translators,
                    visibleAreaX = translators.x.getCanvasVisibleArea(),
                    visibleAreaY = translators.y.getCanvasVisibleArea();
                if (!that._options.rotated) {
                    minValue = _min(that.y, that.minY);
                    x = that.x;
                    min = visibleAreaY.min > minValue ? visibleAreaY.min : minValue;
                    max = visibleAreaY.max < minValue + that.height ? visibleAreaY.max : minValue + that.height;
                    y = min + (max - min) / 2
                }
                else {
                    minValue = _min(that.x, that.minX);
                    y = that.y;
                    min = visibleAreaX.min > minValue ? visibleAreaX.min : minValue;
                    max = visibleAreaX.max < minValue + that.width ? visibleAreaX.max : minValue + that.width;
                    x = min + (max - min) / 2
                }
                return {
                        x: x,
                        y: y,
                        offset: 0
                    }
            },
            _translate: function(translators) {
                var that = this,
                    rotated = that._options.rotated;
                that.minX = that.minY = translators.y.translate(that.minValue);
                points.symbolPoint._translate.call(that, translators);
                that.height = rotated ? 0 : _abs(that.minY - that.y);
                that.width = rotated ? _abs(that.x - that.minX) : 0
            },
            _updateData: function(data) {
                var that = this;
                points.symbolPoint._updateData.call(that, data);
                that.minValue = that.initialMinValue = that.originalMinValue = data.minValue
            },
            _getImageSettings: function(settings, image) {
                return {
                        href: image.url || image.toString(),
                        width: image.width || DEFAULT_IMAGE_WIDTH,
                        height: image.height || DEFAULT_IMAGE_HEIGHT,
                        translateX: settings.translateX,
                        translateY: settings.translateY
                    }
            },
            getCrosshairCoords: function(x, y) {
                var coords;
                if (this._options.rotated)
                    coords = {
                        y: this.vy,
                        x: Math.abs(this.vx - x) < Math.abs(this.minX - x) ? this.vx : this.minX
                    };
                else
                    coords = {
                        x: this.vx,
                        y: Math.abs(this.vy - y) < Math.abs(this.minY - y) ? this.vy : this.minY
                    };
                return coords
            },
            _updateOneMarker: function(markerType, settings) {
                this.graphic && this.graphic[markerType] && this.graphic[markerType].attr(settings)
            },
            _updateMarker: function(animationEnabled, style) {
                this._drawMarker(undefined, undefined, undefined, style)
            },
            _updateTracker: function() {
                this.trackerGraphic.attr(this._getSettingsForTracker(this._storeTrackerR()))
            },
            _getFormatObject: function(tooltip) {
                var that = this,
                    initialMinValue = that.initialMinValue,
                    initialValue = that.initialValue,
                    initialArgument = that.initialArgument,
                    minValue = tooltip.formatValue(initialMinValue),
                    value = tooltip.formatValue(initialValue);
                return {
                        argument: initialArgument,
                        argumentText: tooltip.formatValue(initialArgument, "argument"),
                        valueText: minValue + " - " + value,
                        rangeValue1Text: minValue,
                        rangeValue2Text: value,
                        rangeValue1: initialMinValue,
                        rangeValue2: initialValue,
                        seriesName: that.series.name,
                        point: that,
                        originalMinValue: that.originalMinValue,
                        originalValue: that.originalValue,
                        originalArgument: that.originalArgument
                    }
            },
            getLabel: function() {
                return [this._topLabel, this._bottomLabel]
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file rangeBarPoint.js */
    (function($, DX) {
        var points = DX.viz.core.series.points.mixins,
            _isDefined = DX.utils.isDefined,
            rangeSymbolPointMethods = points.rangeSymbolPoint,
            _math = Math,
            _round = Math.round,
            _min = _math.min,
            _max = _math.max,
            _extend = $.extend;
        points.rangeBarPoint = _extend({}, points.barPoint, {
            deleteLabel: rangeSymbolPointMethods.deleteLabel,
            _getFormatObject: rangeSymbolPointMethods._getFormatObject,
            clearVisibility: function() {
                var graphic = this.graphic;
                if (graphic && graphic.attr("visibility"))
                    graphic.attr({visibility: null});
                this._topLabel.clearVisibility();
                this._bottomLabel.clearVisibility()
            },
            setInvisibility: function() {
                var graphic = this.graphic;
                if (graphic && graphic.attr("visibility") !== "hidden")
                    graphic.attr({visibility: "hidden"});
                this._topLabel.hide();
                this._bottomLabel.hide()
            },
            getTooltipParams: function(location) {
                var edgeLocation = location === 'edge',
                    x,
                    y,
                    arrowSide;
                if (this._options.rotated) {
                    x = edgeLocation ? this.x + this.width : this.x + this.width / 2;
                    y = this.y + this.height / 2;
                    arrowSide = edgeLocation ? 'left' : undefined
                }
                else {
                    x = this.x + this.width / 2;
                    y = edgeLocation ? this.y : this.y + this.height / 2
                }
                return {
                        x: x,
                        y: y,
                        offset: 0,
                        arrowSide: arrowSide
                    }
            },
            _translate: function(translator) {
                var that = this,
                    barMethods = points.barPoint;
                barMethods._translate.call(that, translator);
                if (that._options.rotated)
                    that.width = that.width || 1;
                else
                    that.height = that.height || 1
            },
            _updateData: rangeSymbolPointMethods._updateData,
            _getLabelPosition: rangeSymbolPointMethods._getLabelPosition,
            _getLabelMinFormatObject: rangeSymbolPointMethods._getLabelMinFormatObject,
            _updateLabelData: rangeSymbolPointMethods._updateLabelData,
            _updateLabelOptions: rangeSymbolPointMethods._updateLabelOptions,
            getCrosshairCoords: rangeSymbolPointMethods.getCrosshairCoords,
            _createLabel: rangeSymbolPointMethods._createLabel,
            _checkOverlay: rangeSymbolPointMethods._checkOverlay,
            _checkLabelsOverlay: rangeSymbolPointMethods._checkLabelsOverlay,
            _getOverlayCorrections: rangeSymbolPointMethods._getOverlayCorrections,
            _drawLabel: rangeSymbolPointMethods._drawLabel,
            _getLabelCoords: rangeSymbolPointMethods._getLabelCoords,
            _getGraphicBbox: function(location) {
                var isTop = location === "top",
                    bbox = points.barPoint._getGraphicBbox.call(this);
                if (!this._options.rotated) {
                    bbox.y = isTop ? bbox.y : bbox.y + bbox.height;
                    bbox.height = 0
                }
                else {
                    bbox.x = isTop ? bbox.x + bbox.width : bbox.x;
                    bbox.width = 0
                }
                return bbox
            },
            getLabel: rangeSymbolPointMethods.getLabel
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file candlestickPoint.js */
    (function($, DX) {
        var viz = DX.viz,
            points = viz.core.series.points.mixins,
            rendererNS = viz.renderers,
            _isNumeric = $.isNumeric,
            _extend = $.extend,
            _math = Math,
            _abs = _math.abs,
            _min = _math.min,
            _max = _math.max,
            _round = _math.round,
            DEFAULT_FINANCIAL_TRACKER_MARGIN = 2;
        points.candlestickPoint = _extend({}, points.barPoint, {
            _getContinuousPoints: function(minValueName, maxValueName) {
                var that = this,
                    x = that.x,
                    createPoint = that._options.rotated ? function(x, y) {
                        return [y, x]
                    } : function(x, y) {
                        return [x, y]
                    },
                    width = that.width,
                    min = that[minValueName],
                    max = that[maxValueName],
                    points;
                if (min === max)
                    points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, that.closeY)).concat(createPoint(x - width / 2, that.closeY)).concat(createPoint(x + width / 2, that.closeY)).concat(createPoint(x, that.closeY));
                else
                    points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, max)).concat(createPoint(x + width / 2, max)).concat(createPoint(x + width / 2, min)).concat(createPoint(x, min)).concat(createPoint(x, that.lowY)).concat(createPoint(x, min)).concat(createPoint(x - width / 2, min)).concat(createPoint(x - width / 2, max)).concat(createPoint(x, max));
                return points
            },
            _getCategoryPoints: function(y) {
                var that = this,
                    x = that.x,
                    createPoint = that._options.rotated ? function(x, y) {
                        return [y, x]
                    } : function(x, y) {
                        return [x, y]
                    };
                return [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, y)).concat(createPoint(x - that.width / 2, y)).concat(createPoint(x + that.width / 2, y)).concat(createPoint(x, y))
            },
            _getPoints: function() {
                var that = this,
                    points,
                    minValueName,
                    maxValueName,
                    openValue = that.openValue,
                    closeValue = that.closeValue;
                if (_isNumeric(openValue) && _isNumeric(closeValue)) {
                    minValueName = openValue > closeValue ? "closeY" : "openY";
                    maxValueName = openValue > closeValue ? "openY" : "closeY";
                    points = that._getContinuousPoints(minValueName, maxValueName)
                }
                else if (openValue === closeValue)
                    points = [that.x, that.highY, that.x, that.lowY];
                else
                    points = that._getCategoryPoints(_isNumeric(openValue) ? that.openY : that.closeY);
                return points
            },
            getColor: function() {
                var that = this;
                return that._isReduction ? that._options.reduction.color : that._styles.normal.stroke || that.series.getColor()
            },
            _drawMarkerInGroup: function(group, attributes, renderer) {
                var that = this;
                that.graphic = renderer.path(that._getPoints(), "area").attr({"stroke-linecap": "square"}).attr(attributes).sharp().append(group);
                $(that.graphic.element).data({point: that})
            },
            _fillStyle: function() {
                var that = this,
                    styles = that._options.styles;
                if (that._isReduction && that._isPositive)
                    that._styles = styles.reductionPositive;
                else if (that._isReduction)
                    that._styles = styles.reduction;
                else if (that._isPositive)
                    that._styles = styles.positive;
                else
                    that._styles = styles
            },
            _getMinTrackerWidth: function() {
                return 1 + 2 * this._styles.normal['stroke-width']
            },
            correctCoordinates: function(correctOptions) {
                var minWidth = this._getMinTrackerWidth(),
                    maxWidth = 10;
                this.width = correctOptions.width < minWidth ? minWidth : correctOptions.width > maxWidth ? maxWidth : correctOptions.width;
                this.xCorrection = correctOptions.offset
            },
            _getMarkerGroup: function(group) {
                var that = this,
                    markerGroup;
                if (that._isReduction && that._isPositive)
                    markerGroup = group.reductionPositiveMarkersGroup;
                else if (that._isReduction)
                    markerGroup = group.reductionMarkersGroup;
                else if (that._isPositive)
                    markerGroup = group.defaultPositiveMarkersGroup;
                else
                    markerGroup = group.defaultMarkersGroup;
                return markerGroup
            },
            _drawMarker: function(renderer, group) {
                this._drawMarkerInGroup(this._getMarkerGroup(group), this._getStyle(), renderer)
            },
            _getSettingsForTracker: function() {
                var that = this,
                    highY = that.highY,
                    lowY = that.lowY,
                    rotated = that._options.rotated,
                    x,
                    y,
                    width,
                    height;
                if (highY === lowY) {
                    highY = rotated ? highY + DEFAULT_FINANCIAL_TRACKER_MARGIN : highY - DEFAULT_FINANCIAL_TRACKER_MARGIN;
                    lowY = rotated ? lowY - DEFAULT_FINANCIAL_TRACKER_MARGIN : lowY + DEFAULT_FINANCIAL_TRACKER_MARGIN
                }
                if (rotated) {
                    x = _min(lowY, highY);
                    y = that.x - that.width / 2;
                    width = _abs(lowY - highY);
                    height = that.width
                }
                else {
                    x = that.x - that.width / 2;
                    y = _min(lowY, highY);
                    width = that.width;
                    height = _abs(lowY - highY)
                }
                return {
                        x: x,
                        y: y,
                        width: width,
                        height: height
                    }
            },
            _drawTrackerMarker: function(renderer, group) {
                var that = this,
                    settings = that._getSettingsForTracker();
                that.trackerGraphic = renderer.rect(settings.x, settings.y, settings.width, settings.height).append(group);
                $(that.trackerGraphic.element).data({point: that})
            },
            _getGraphicBbox: function() {
                var that = this,
                    rotated = that._options.rotated,
                    x = that.x,
                    width = that.width,
                    lowY = that.lowY,
                    highY = that.highY;
                return {
                        x: !rotated ? x - _round(width / 2) : lowY,
                        y: !rotated ? highY : x - _round(width / 2),
                        width: !rotated ? width : highY - lowY,
                        height: !rotated ? lowY - highY : width
                    }
            },
            getTooltipParams: function(location) {
                var that = this;
                if (that.graphic) {
                    var x,
                        y,
                        min,
                        max,
                        minValue = _min(that.lowY, that.highY),
                        maxValue = _max(that.lowY, that.highY),
                        visibleAreaX = that.translators.x.getCanvasVisibleArea(),
                        visibleAreaY = that.translators.y.getCanvasVisibleArea(),
                        edgeLocation = location === 'edge',
                        arrowSide;
                    if (!that._options.rotated) {
                        min = _max(visibleAreaY.min, minValue);
                        max = _min(visibleAreaY.max, maxValue);
                        x = that.x;
                        y = edgeLocation ? min : min + (max - min) / 2
                    }
                    else {
                        min = _max(visibleAreaX.min, minValue);
                        max = _min(visibleAreaX.max, maxValue);
                        y = that.x;
                        x = edgeLocation ? max : min + (max - min) / 2;
                        arrowSide = edgeLocation ? 'left' : undefined
                    }
                    return {
                            x: x,
                            y: y,
                            offset: 0,
                            arrowSide: arrowSide
                        }
                }
            },
            hasValue: function() {
                return this.highValue !== null && this.lowValue !== null
            },
            _translate: function() {
                var that = this,
                    rotated = that._options.rotated,
                    translators = that.translators,
                    argTranslator = rotated ? translators.y : translators.x,
                    valTranslator = rotated ? translators.x : translators.y,
                    centerValue,
                    height;
                that.vx = that.vy = that.x = argTranslator.translate(that.argument) + (that.xCorrection || 0);
                that.openY = that.openValue !== null ? valTranslator.translate(that.openValue) : null;
                that.highY = valTranslator.translate(that.highValue);
                that.lowY = valTranslator.translate(that.lowValue);
                that.closeY = that.closeValue !== null ? valTranslator.translate(that.closeValue) : null;
                height = _abs(that.lowY - that.highY);
                centerValue = _min(that.lowY, that.highY) + _abs(that.lowY - that.highY) / 2;
                that._calculateVisibility(!rotated ? that.x : centerValue, !rotated ? centerValue : that.x)
            },
            getCrosshairCoords: function(x, y) {
                var coords,
                    valueCoord = this._options.rotated ? x : y,
                    value = Math.abs(this.lowY - valueCoord) < Math.abs(this.closeY - valueCoord) ? this.lowY : this.closeY;
                value = Math.abs(value - valueCoord) < Math.abs(this.openY - valueCoord) ? value : this.openY;
                value = Math.abs(value - valueCoord) < Math.abs(this.highY - valueCoord) ? value : this.highY;
                if (this._options.rotated)
                    coords = {
                        y: this.vy,
                        x: value
                    };
                else
                    coords = {
                        x: this.vx,
                        y: value
                    };
                return coords
            },
            _updateData: function(data) {
                var that = this,
                    label = that._label,
                    reductionColor = this._options.reduction.color;
                that.value = that.initialValue = data.reductionValue;
                that.originalValue = data.value;
                that.lowValue = that.originalLowValue = data.lowValue;
                that.highValue = that.originalHighValue = data.highValue;
                that.openValue = that.originalOpenValue = data.openValue;
                that.closeValue = that.originalCloseValue = data.closeValue;
                that._isPositive = data.openValue < data.closeValue;
                that._isReduction = data.isReduction;
                if (that._isReduction)
                    label.updateOptions({
                        background: {fill: reductionColor},
                        connector: {stroke: reductionColor}
                    })
            },
            _updateMarker: function(animationEnabled, style, group) {
                var that = this,
                    graphic = that.graphic;
                graphic.attr({points: that._getPoints()}).attr(style || that._getStyle()).sharp();
                group && graphic.append(that._getMarkerGroup(group))
            },
            _updateTracker: function() {
                this.trackerGraphic.attr(this._getSettingsForTracker())
            },
            _getLabelFormatObject: function() {
                var that = this;
                return {
                        openValue: that.openValue,
                        highValue: that.highValue,
                        lowValue: that.lowValue,
                        closeValue: that.closeValue,
                        reductionValue: that.initialValue,
                        argument: that.initialArgument,
                        value: that.initialValue,
                        seriesName: that.series.name,
                        originalOpenValue: that.originalOpenValue,
                        originalCloseValue: that.originalCloseValue,
                        originalLowValue: that.originalLowValue,
                        originalHighValue: that.originalHighValue,
                        originalArgument: that.originalArgument,
                        point: that
                    }
            },
            _getFormatObject: function(tooltip) {
                var that = this,
                    highValue = tooltip.formatValue(that.highValue),
                    openValue = tooltip.formatValue(that.openValue),
                    closeValue = tooltip.formatValue(that.closeValue),
                    lowValue = tooltip.formatValue(that.lowValue),
                    symbolMethods = points.symbolPoint,
                    formatObject = symbolMethods._getFormatObject.call(that, tooltip);
                return _extend({}, formatObject, {
                        valueText: "h: " + highValue + (openValue !== "" ? " o: " + openValue : "") + (closeValue !== "" ? " c: " + closeValue : "") + " l: " + lowValue,
                        highValueText: highValue,
                        openValueText: openValue,
                        closeValueText: closeValue,
                        lowValueText: lowValue
                    })
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file stockPoint.js */
    (function($, DX) {
        var points = DX.viz.core.series.points.mixins,
            _extend = $.extend,
            _isNumeric = $.isNumeric;
        points.stockPoint = _extend({}, points.candlestickPoint, {
            _getPoints: function() {
                var that = this,
                    createPoint = that._options.rotated ? function(x, y) {
                        return [y, x]
                    } : function(x, y) {
                        return [x, y]
                    },
                    openYExist = _isNumeric(that.openY),
                    closeYExist = _isNumeric(that.closeY),
                    x = that.x,
                    width = that.width,
                    points;
                points = [].concat(createPoint(x, that.highY));
                openYExist && (points = points.concat(createPoint(x, that.openY)));
                openYExist && (points = points.concat(createPoint(x - width / 2, that.openY)));
                openYExist && (points = points.concat(createPoint(x, that.openY)));
                closeYExist && (points = points.concat(createPoint(x, that.closeY)));
                closeYExist && (points = points.concat(createPoint(x + width / 2, that.closeY)));
                closeYExist && (points = points.concat(createPoint(x, that.closeY)));
                points = points.concat(createPoint(x, that.lowY));
                return points
            },
            _drawMarkerInGroup: function(group, attributes, renderer) {
                this.graphic = renderer.path(this._getPoints(), "line").attr({"stroke-linecap": "square"}).attr(attributes).sharp().append(group);
                $(this.graphic.element).data({point: this})
            },
            _getMinTrackerWidth: function() {
                return 2 + this._styles.normal['stroke-width']
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file polarPoint.js */
    (function($, DX, undefined) {
        var _extend = $.extend,
            viz = DX.viz,
            utils = DX.utils,
            isDefined = utils.isDefined,
            normalizeAngle = utils.normalizeAngle,
            ERROR_BARS_ANGLE_OFFSET = 90,
            CANVAS_POSITION_START = "canvas_position_start",
            CANVAS_POSITION_TOP = "canvas_position_top",
            CANVAS_POSITION_END = "canvas_position_end",
            CANVAS_POSITION_DEFAULT = "canvas_position_default",
            points = viz.core.series.points.mixins;
        points.polarSymbolPoint = _extend({}, points.symbolPoint, {
            _translate: function(translator) {
                var that = this,
                    coord = translator.translate(that.argument, that.value),
                    center = translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP);
                that.vx = normalizeAngle(coord.angle);
                that.vy = that.radiusOuter = coord.radius;
                that.radius = coord.radius;
                that.middleAngle = -coord.angle;
                that.angle = -coord.angle;
                that.x = coord.x;
                that.y = coord.y;
                that.defaultX = that.centerX = center.x;
                that.defaultY = that.centerY = center.y;
                that._translateErrorBars(translator);
                that.inVisibleArea = that._checkVisibility(translator)
            },
            _checkVisibility: function(translator) {
                return translator.checkVisibility(this.radius)
            },
            _translateErrorBars: function(translator) {
                var that = this;
                isDefined(that.lowError) && (that._lowErrorCoord = that.centerY - translator.translate(that.argument, that.lowError).radius);
                isDefined(that.highError) && (that._highErrorCoord = that.centerY - translator.translate(that.argument, that.highError).radius);
                that._errorBarPos = that.centerX;
                that._baseErrorBarPos = (that._options.errorBars || {}).type === "stdDeviation" ? that._lowErrorCoord + (that._highErrorCoord - that._lowErrorCoord) / 2 : that.centerY - that.radius
            },
            _getTranslates: function(animationEnabled) {
                return animationEnabled ? this.getDefaultCoords() : {
                        x: this.x,
                        y: this.y
                    }
            },
            getDefaultCoords: function() {
                var cossin = utils.getCosAndSin(-this.angle),
                    radius = this.translators.translate(CANVAS_POSITION_START, CANVAS_POSITION_DEFAULT).radius,
                    x = this.defaultX + radius * cossin.cos,
                    y = this.defaultY + radius * cossin.sin;
                return {
                        x: x,
                        y: y
                    }
            },
            _addLabelAlignmentAndOffset: function(label, coord) {
                return coord
            },
            _getLabelCoords: points.piePoint._getLabelCoords,
            _getVisibleArea: function() {
                var canvas = this.translators.canvas;
                return {
                        minX: canvas.left,
                        maxX: canvas.width - canvas.right,
                        minY: canvas.top,
                        maxY: canvas.height - canvas.bottom
                    }
            },
            checkLabelPosition: function(label, coord) {
                var that = this,
                    visibleArea = that._getVisibleArea(),
                    graphicBbox = that._getGraphicBbox();
                if (visibleArea.minX <= graphicBbox.x + graphicBbox.width && visibleArea.maxX >= graphicBbox.x && visibleArea.minY <= graphicBbox.y + graphicBbox.height && visibleArea.maxY >= graphicBbox.y)
                    coord = that._moveLabelOnCanvas(coord, label.getBoundingRect(), visibleArea);
                return coord
            },
            _moveLabelOnCanvas: points.piePoint._moveLabelOnCanvas,
            _getErrorBarSettings: function(errorBarOptions, animationEnabled) {
                var settings = points.symbolPoint._getErrorBarSettings.call(this, errorBarOptions, animationEnabled);
                settings.rotate = ERROR_BARS_ANGLE_OFFSET - this.angle;
                settings.rotateX = this.centerX;
                settings.rotateY = this.centerY;
                return settings
            },
            getCoords: function(min) {
                if (min)
                    return this.getDefaultCoords();
                return {
                        x: this.x,
                        y: this.y
                    }
            }
        });
        points.polarBarPoint = _extend({}, points.barPoint, {
            _translate: function(translator) {
                var that = this,
                    maxRadius = translator.translate(CANVAS_POSITION_TOP, CANVAS_POSITION_END).radius;
                that.radiusInner = translator.translate(that.argument, that.minValue).radius;
                points.polarSymbolPoint._translate.call(that, translator);
                if (that.radiusInner === null)
                    that.radiusInner = that.radius = maxRadius;
                else if (that.radius === null)
                    this.radius = this.value >= 0 ? maxRadius : 0;
                that.radiusOuter = Math.max(that.radiusInner, that.radius);
                that.radiusInner = that.defaultRadius = Math.min(that.radiusInner, that.radius);
                that.middleAngle = that.angle = that.angle - that.middleAngleCorrection
            },
            _checkVisibility: function(translator) {
                return translator.checkVisibility(this.radius, this.radiusInner)
            },
            _translateErrorBars: points.polarSymbolPoint._translateErrorBars,
            _getErrorBarSettings: points.polarSymbolPoint._getErrorBarSettings,
            getMarkerCoords: function() {
                return {
                        x: this.centerX,
                        y: this.centerY,
                        outerRadius: this.radiusOuter,
                        innerRadius: this.defaultRadius,
                        startAngle: this.middleAngle - this.interval / 2,
                        endAngle: this.middleAngle + this.interval / 2
                    }
            },
            _drawMarker: function(renderer, group) {
                var that = this,
                    styles = that._getStyle();
                that.graphic = renderer.arc(that.centerX, that.centerY, that.defaultRadius, that.radiusOuter, that.middleAngle - that.interval / 2, that.middleAngle + that.interval / 2).attr(styles).append(group);
                $(that.graphic.element).data({point: this})
            },
            _getVisibleArea: points.polarSymbolPoint._getVisibleArea,
            checkLabelPosition: function(label, coord) {
                var that = this,
                    visibleArea = that._getVisibleArea(),
                    angleFunctions = utils.getCosAndSin(that.middleAngle),
                    x = that.centerX + that.defaultRadius * angleFunctions.cos,
                    y = that.centerY - that.defaultRadius * angleFunctions.sin;
                if (x > visibleArea.minX && x < visibleArea.maxX && y > visibleArea.minY && y < visibleArea.maxY)
                    coord = that._moveLabelOnCanvas(coord, label.getBoundingRect(), visibleArea);
                return coord
            },
            _moveLabelOnCanvas: points.piePoint._moveLabelOnCanvas,
            _getLabelCoords: points.piePoint._getLabelCoords,
            _addLabelAlignmentAndOffset: function(label, coord) {
                return coord
            },
            _getLabelConnector: points.piePoint._getLabelConnector,
            getBoundaryCoords: points.piePoint.getBoundaryCoords,
            getTooltipParams: points.piePoint.getTooltipParams,
            correctCoordinates: function(correctOptions) {
                this.middleAngleCorrection = correctOptions.offset;
                this.interval = correctOptions.width
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file default.js */
    (function($, DX, undefined) {
        var fontFamilyDefault = "'Segoe UI', 'Helvetica Neue', 'Trebuchet MS', Verdana",
            fontFamilyLight = "'Segoe UI Light', 'Helvetica Neue Light', 'Segoe UI', 'Helvetica Neue', 'Trebuchet MS', Verdana",
            baseChartTheme = {
                containerBackgroundColor: '#ffffff',
                animation: {
                    enabled: true,
                    duration: 1000,
                    easing: 'easeOutCubic',
                    maxPointCountSupported: 300
                },
                commonSeriesSettings: {
                    border: {
                        visible: false,
                        width: 2
                    },
                    showInLegend: true,
                    visible: true,
                    hoverMode: 'excludePoints',
                    selectionMode: 'includePoints',
                    hoverStyle: {
                        hatching: {
                            direction: 'right',
                            width: 2,
                            step: 6,
                            opacity: 0.75
                        },
                        border: {
                            visible: false,
                            width: 3
                        }
                    },
                    selectionStyle: {
                        hatching: {
                            direction: 'right',
                            width: 2,
                            step: 6,
                            opacity: 0.5
                        },
                        border: {
                            visible: false,
                            width: 3
                        }
                    },
                    valueErrorBar: {
                        displayMode: "auto",
                        value: 1,
                        color: "#656565",
                        lineWidth: 2,
                        edgeLength: 8
                    },
                    label: {
                        visible: false,
                        alignment: 'center',
                        rotationAngle: 0,
                        horizontalOffset: 0,
                        verticalOffset: 0,
                        radialOffset: 0,
                        format: '',
                        argumentFormat: '',
                        precision: 0,
                        argumentPrecision: 0,
                        percentPrecision: 0,
                        showForZeroValues: true,
                        customizeText: undefined,
                        maxLabelCount: undefined,
                        position: 'outside',
                        font: {color: '#ffffff'},
                        border: {
                            visible: false,
                            width: 1,
                            color: '#d3d3d3',
                            dashStyle: 'solid'
                        },
                        connector: {
                            visible: false,
                            width: 1
                        }
                    }
                },
                redrawOnResize: true,
                margin: {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0
                },
                seriesSelectionMode: 'single',
                pointSelectionMode: 'single',
                legend: {
                    hoverMode: 'includePoints',
                    verticalAlignment: 'top',
                    horizontalAlignment: 'right',
                    position: 'outside',
                    visible: true,
                    customizeText: undefined,
                    customizeHint: undefined,
                    itemTextPosition: undefined,
                    itemsAlignment: undefined,
                    margin: 10,
                    equalColumnWidth: false,
                    markerSize: 12,
                    backgroundColor: undefined,
                    backgroundOpacity: undefined,
                    border: {
                        visible: false,
                        width: 1,
                        color: '#d3d3d3',
                        cornerRadius: 0,
                        dashStyle: 'solid'
                    },
                    paddingLeftRight: 20,
                    paddingTopBottom: 15,
                    columnCount: 0,
                    rowCount: 0,
                    columnItemSpacing: 20,
                    rowItemSpacing: 8
                },
                tooltip: {
                    enabled: false,
                    border: {
                        width: 1,
                        color: '#d3d3d3',
                        dashStyle: 'solid',
                        visible: true
                    },
                    font: {
                        family: fontFamilyDefault,
                        weight: 400,
                        size: 12,
                        color: '#232323'
                    },
                    color: '#ffffff',
                    arrowLength: 10,
                    paddingLeftRight: 18,
                    paddingTopBottom: 15,
                    shared: false,
                    location: 'center',
                    format: '',
                    argumentFormat: '',
                    precision: 0,
                    argumentPrecision: 0,
                    percentPrecision: 0,
                    customizeText: undefined,
                    customizeTooltip: undefined,
                    shadow: {
                        opacity: 0.4,
                        offsetX: 0,
                        offsetY: 4,
                        blur: 2,
                        color: '#000000'
                    }
                },
                size: {
                    width: undefined,
                    height: undefined
                },
                loadingIndicator: {
                    font: {},
                    backgroundColor: '#ffffff',
                    text: 'Loading...'
                },
                dataPrepareSettings: {
                    checkTypeForAllData: false,
                    convertToAxisDataType: true,
                    sortingMethod: true
                },
                title: {
                    font: {
                        family: fontFamilyLight,
                        weight: 200,
                        color: '#232323',
                        size: 28
                    },
                    margin: 10
                },
                adaptiveLayout: {
                    width: 80,
                    height: 80,
                    keepLabels: true
                },
                _rtl: {legend: {itemTextPosition: 'left'}},
                resolveLabelOverlapping: "none"
            },
            baseDarkChartTheme = {
                containerBackgroundColor: '#2b2b2b',
                commonSeriesSettings: {label: {border: {color: '#494949'}}},
                legend: {border: {color: '#494949'}},
                loadingIndicator: {backgroundColor: '#2b2b2b'},
                title: {font: {color: '#929292'}},
                tooltip: {
                    color: '#2b2b2b',
                    border: {color: '#494949'},
                    font: {color: '#929292'}
                }
            };
        DX.viz.themes.push({
            name: 'desktop',
            font: {
                color: '#767676',
                family: fontFamilyDefault,
                weight: 400,
                size: 12,
                cursor: 'default'
            },
            chart: $.extend(true, {}, baseChartTheme, {
                commonSeriesSettings: {
                    type: 'line',
                    stack: 'default',
                    point: {
                        visible: true,
                        symbol: 'circle',
                        size: 12,
                        border: {
                            visible: false,
                            width: 1
                        },
                        hoverMode: 'onlyPoint',
                        selectionMode: 'onlyPoint',
                        hoverStyle: {
                            border: {
                                visible: true,
                                width: 4
                            },
                            size: 12
                        },
                        selectionStyle: {
                            border: {
                                visible: true,
                                width: 4
                            },
                            size: 12
                        }
                    },
                    scatter: {},
                    line: {
                        width: 2,
                        dashStyle: 'solid',
                        hoverStyle: {
                            width: 3,
                            hatching: {direction: 'none'}
                        },
                        selectionStyle: {width: 3}
                    },
                    stackedline: {
                        width: 2,
                        dashStyle: 'solid',
                        hoverStyle: {
                            width: 3,
                            hatching: {direction: 'none'}
                        },
                        selectionStyle: {width: 3}
                    },
                    stackedspline: {
                        width: 2,
                        dashStyle: 'solid',
                        hoverStyle: {
                            width: 3,
                            hatching: {direction: 'none'}
                        },
                        selectionStyle: {width: 3}
                    },
                    fullstackedline: {
                        width: 2,
                        dashStyle: 'solid',
                        hoverStyle: {
                            width: 3,
                            hatching: {direction: 'none'}
                        },
                        selectionStyle: {width: 3}
                    },
                    fullstackedspline: {
                        width: 2,
                        dashStyle: 'solid',
                        hoverStyle: {
                            width: 3,
                            hatching: {direction: 'none'}
                        },
                        selectionStyle: {width: 3}
                    },
                    stepline: {
                        width: 2,
                        dashStyle: 'solid',
                        hoverStyle: {
                            width: 3,
                            hatching: {direction: 'none'}
                        },
                        selectionStyle: {width: 3}
                    },
                    area: {
                        point: {visible: false},
                        opacity: 0.5
                    },
                    stackedarea: {
                        point: {visible: false},
                        opacity: 0.5
                    },
                    fullstackedarea: {
                        point: {visible: false},
                        opacity: 0.5
                    },
                    fullstackedsplinearea: {
                        point: {visible: false},
                        opacity: 0.5
                    },
                    steparea: {
                        border: {
                            visible: true,
                            width: 2
                        },
                        point: {visible: false},
                        hoverStyle: {border: {
                                visible: true,
                                width: 3
                            }},
                        selectionStyle: {border: {
                                visible: true,
                                width: 3
                            }},
                        opacity: 0.5
                    },
                    spline: {
                        width: 2,
                        hoverStyle: {
                            width: 3,
                            hatching: {direction: 'none'}
                        },
                        selectionStyle: {width: 3}
                    },
                    splinearea: {
                        point: {visible: false},
                        opacity: 0.5
                    },
                    stackedsplinearea: {
                        point: {visible: false},
                        opacity: 0.5
                    },
                    bar: {
                        cornerRadius: 0,
                        point: {
                            hoverStyle: {border: {visible: false}},
                            selectionStyle: {border: {visible: false}}
                        }
                    },
                    stackedbar: {
                        cornerRadius: 0,
                        point: {
                            hoverStyle: {border: {visible: false}},
                            selectionStyle: {border: {visible: false}}
                        },
                        label: {position: "inside"}
                    },
                    fullstackedbar: {
                        cornerRadius: 0,
                        point: {
                            hoverStyle: {border: {visible: false}},
                            selectionStyle: {border: {visible: false}}
                        },
                        label: {position: "inside"}
                    },
                    rangebar: {
                        cornerRadius: 0,
                        point: {
                            hoverStyle: {border: {visible: false}},
                            selectionStyle: {border: {visible: false}}
                        }
                    },
                    rangearea: {
                        point: {visible: false},
                        opacity: 0.5
                    },
                    rangesplinearea: {
                        point: {visible: false},
                        opacity: 0.5
                    },
                    bubble: {
                        opacity: 0.5,
                        point: {
                            hoverStyle: {border: {visible: false}},
                            selectionStyle: {border: {visible: false}}
                        }
                    },
                    candlestick: {
                        width: 1,
                        innerColor: '#ffffff',
                        reduction: {color: '#ff0000'},
                        hoverStyle: {
                            width: 3,
                            hatching: {direction: 'none'}
                        },
                        selectionStyle: {width: 3},
                        point: {border: {visible: true}}
                    },
                    stock: {
                        width: 1,
                        reduction: {color: '#ff0000'},
                        hoverStyle: {
                            width: 3,
                            hatching: {direction: 'none'}
                        },
                        selectionStyle: {width: 3},
                        point: {border: {visible: true}}
                    }
                },
                crosshair: {
                    enabled: false,
                    color: '#f78119',
                    width: 1,
                    dashStyle: 'solid',
                    label: {
                        visible: false,
                        font: {
                            color: "#ffffff",
                            size: 12
                        }
                    },
                    verticalLine: {visible: true},
                    horizontalLine: {visible: true}
                },
                commonAxisSettings: {
                    tickInterval: undefined,
                    setTicksAtUnitBeginning: true,
                    valueMarginsEnabled: true,
                    placeholderSize: null,
                    logarithmBase: 10,
                    discreteAxisDivisionMode: 'betweenLabels',
                    visible: false,
                    color: '#d3d3d3',
                    width: 1,
                    multipleAxesSpacing: 5,
                    label: {
                        visible: true,
                        overlappingBehavior: {
                            mode: 'auto',
                            rotationAngle: 90,
                            staggeringSpacing: 5
                        },
                        precision: 0,
                        format: '',
                        customizeText: undefined,
                        customizeHint: undefined,
                        indentFromAxis: 10
                    },
                    grid: {
                        visible: false,
                        color: '#d3d3d3',
                        width: 1
                    },
                    minorGrid: {
                        visible: false,
                        color: '#d3d3d3',
                        width: 1,
                        opacity: 0.3
                    },
                    tick: {
                        visible: false,
                        color: '#d3d3d3'
                    },
                    minorTick: {
                        visible: false,
                        color: '#d3d3d3',
                        opacity: 0.3
                    },
                    title: {
                        font: {size: 16},
                        margin: 10
                    },
                    stripStyle: {
                        paddingLeftRight: 10,
                        paddingTopBottom: 5
                    },
                    constantLineStyle: {
                        paddingLeftRight: 10,
                        paddingTopBottom: 10,
                        width: 1,
                        color: '#000000',
                        dashStyle: 'solid',
                        label: {
                            visible: true,
                            position: 'inside'
                        }
                    }
                },
                horizontalAxis: {
                    isHorizontal: true,
                    position: 'bottom',
                    axisDivisionFactor: 50,
                    label: {alignment: "center"},
                    stripStyle: {label: {
                            horizontalAlignment: 'center',
                            verticalAlignment: 'top'
                        }},
                    constantLineStyle: {label: {
                            horizontalAlignment: 'right',
                            verticalAlignment: 'top'
                        }},
                    constantLines: {}
                },
                verticalAxis: {
                    isHorizontal: false,
                    position: 'left',
                    axisDivisionFactor: 30,
                    label: {
                        alignment: 'right',
                        overlappingBehavior: {mode: 'enlargeTickInterval'}
                    },
                    stripStyle: {label: {
                            horizontalAlignment: 'left',
                            verticalAlignment: 'center'
                        }},
                    constantLineStyle: {label: {
                            horizontalAlignment: 'left',
                            verticalAlignment: 'top'
                        }},
                    constantLines: {}
                },
                argumentAxis: {},
                valueAxis: {grid: {visible: true}},
                commonPaneSettings: {
                    backgroundColor: 'none',
                    border: {
                        color: '#d3d3d3',
                        width: 1,
                        visible: false,
                        top: true,
                        bottom: true,
                        left: true,
                        right: true,
                        dashStyle: 'solid'
                    }
                },
                scrollBar: {
                    visible: false,
                    offset: 5,
                    color: "gray",
                    width: 10
                },
                useAggregation: false,
                adjustOnZoom: true,
                rotated: false,
                zoomingMode: 'none',
                scrollingMode: 'none',
                synchronizeMultiAxes: true,
                equalBarWidth: true,
                minBubbleSize: 12,
                maxBubbleSize: 0.2
            }),
            pie: $.extend(true, {}, baseChartTheme, {
                commonSeriesSettings: {
                    type: 'pie',
                    pie: {
                        border: {
                            visible: false,
                            width: 2,
                            color: '#ffffff'
                        },
                        hoverStyle: {
                            hatching: {
                                direction: 'right',
                                width: 4,
                                step: 10,
                                opacity: 0.75
                            },
                            border: {
                                visible: false,
                                width: 2
                            }
                        },
                        selectionStyle: {
                            hatching: {
                                direction: 'right',
                                width: 4,
                                step: 10,
                                opacity: 0.5
                            },
                            border: {
                                visible: false,
                                width: 2
                            }
                        }
                    },
                    doughnut: {
                        innerRadius: 0.5,
                        border: {
                            visible: false,
                            width: 2,
                            color: '#ffffff'
                        },
                        hoverStyle: {
                            hatching: {
                                direction: 'right',
                                width: 4,
                                step: 10,
                                opacity: 0.75
                            },
                            border: {
                                visible: false,
                                width: 2
                            }
                        },
                        selectionStyle: {
                            hatching: {
                                direction: 'right',
                                width: 4,
                                step: 10,
                                opacity: 0.5
                            },
                            border: {
                                visible: false,
                                width: 2
                            }
                        }
                    },
                    donut: {
                        innerRadius: 0.5,
                        border: {
                            visible: false,
                            width: 2,
                            color: '#ffffff'
                        },
                        hoverStyle: {
                            hatching: {
                                direction: 'right',
                                width: 4,
                                step: 10,
                                opacity: 0.75
                            },
                            border: {
                                visible: false,
                                width: 2
                            }
                        },
                        selectionStyle: {
                            hatching: {
                                direction: 'right',
                                width: 4,
                                step: 10,
                                opacity: 0.5
                            },
                            border: {
                                visible: false,
                                width: 2
                            }
                        }
                    }
                },
                legend: {hoverMode: 'markPoint'},
                adaptiveLayout: {keepLabels: false}
            }),
            pieIE8: {commonSeriesSettings: {
                    pie: {
                        hoverStyle: {border: {
                                visible: true,
                                color: '#ffffff'
                            }},
                        selectionStyle: {border: {
                                visible: true,
                                color: '#ffffff'
                            }}
                    },
                    donut: {
                        hoverStyle: {border: {
                                visible: true,
                                color: '#ffffff'
                            }},
                        selectionStyle: {border: {
                                visible: true,
                                color: '#ffffff'
                            }}
                    },
                    doughnut: {
                        hoverStyle: {border: {
                                visible: true,
                                color: '#ffffff'
                            }},
                        selectionStyle: {border: {
                                visible: true,
                                color: '#ffffff'
                            }}
                    }
                }},
            gauge: {
                containerBackgroundColor: '#ffffff',
                scale: {
                    majorTick: {
                        visible: true,
                        length: 5,
                        width: 2,
                        showCalculatedTicks: true,
                        useTicksAutoArrangement: true,
                        color: '#ffffff'
                    },
                    minorTick: {
                        visible: false,
                        length: 3,
                        width: 1,
                        showCalculatedTicks: true,
                        color: '#ffffff'
                    },
                    label: {
                        visible: true,
                        font: {}
                    }
                },
                rangeContainer: {
                    offset: 0,
                    width: 5,
                    backgroundColor: '#808080'
                },
                valueIndicator: {
                    _default: {color: '#c2c2c2'},
                    rangebar: {
                        space: 2,
                        size: 10,
                        color: '#cbc5cf',
                        backgroundColor: 'none',
                        text: {
                            indent: 0,
                            font: {
                                size: 14,
                                color: null
                            }
                        }
                    },
                    twocolorneedle: {secondColor: '#e18e92'}
                },
                subvalueIndicator: {
                    _default: {color: '#8798a5'},
                    trianglemarker: {
                        space: 2,
                        length: 14,
                        width: 13,
                        color: '#8798a5'
                    },
                    textcloud: {
                        arrowLength: 5,
                        horizontalOffset: 6,
                        verticalOffset: 3,
                        color: '#679ec5',
                        text: {font: {
                                color: '#ffffff',
                                size: 18
                            }}
                    }
                },
                valueIndicators: {
                    _default: {color: '#c2c2c2'},
                    rangebar: {
                        space: 2,
                        size: 10,
                        color: '#cbc5cf',
                        backgroundColor: 'none',
                        text: {
                            indent: 0,
                            font: {
                                size: 14,
                                color: null
                            }
                        }
                    },
                    twocolorneedle: {secondColor: '#e18e92'},
                    trianglemarker: {
                        space: 2,
                        length: 14,
                        width: 13,
                        color: '#8798a5'
                    },
                    textcloud: {
                        arrowLength: 5,
                        horizontalOffset: 6,
                        verticalOffset: 3,
                        color: '#679ec5',
                        text: {font: {
                                color: '#ffffff',
                                size: 18
                            }}
                    }
                },
                title: {
                    layout: {
                        horizontalAlignment: 'center',
                        verticalAlignment: 'top',
                        overlay: 0
                    },
                    font: {
                        size: 16,
                        color: '#232323',
                        family: fontFamilyDefault,
                        weight: 400
                    }
                },
                subtitle: {font: {
                        size: 14,
                        color: '#232323',
                        family: fontFamilyDefault,
                        weight: 400
                    }},
                indicator: {
                    hasPositiveMeaning: true,
                    layout: {
                        horizontalAlignment: 'center',
                        verticalAlignment: 'bottom',
                        overlay: 0
                    },
                    text: {font: {size: 18}}
                },
                tooltip: {
                    arrowLength: 10,
                    paddingLeftRight: 18,
                    paddingTopBottom: 15,
                    enabled: false,
                    border: {
                        width: 1,
                        color: '#d3d3d3',
                        dashStyle: 'solid',
                        visible: true
                    },
                    color: '#ffffff',
                    font: {
                        color: '#232323',
                        size: 12,
                        family: fontFamilyDefault,
                        weight: 400
                    },
                    shadow: {
                        opacity: 0.4,
                        offsetX: 0,
                        offsetY: 4,
                        blur: 2,
                        color: '#000000'
                    }
                },
                loadingIndicator: {
                    show: false,
                    font: {},
                    backgroundColor: '#ffffff',
                    text: 'Loading...'
                },
                _circular: {
                    scale: {
                        orientation: 'outside',
                        label: {indentFromTick: 10}
                    },
                    rangeContainer: {orientation: 'outside'},
                    valueIndicator: {
                        type: 'rectangleneedle',
                        _default: {
                            offset: 20,
                            indentFromCenter: 0,
                            width: 2,
                            spindleSize: 14,
                            spindleGapSize: 10
                        },
                        triangleneedle: {width: 4},
                        twocolorneedle: {
                            space: 2,
                            secondFraction: 0.4
                        },
                        rangebar: {offset: 30}
                    },
                    subvalueIndicator: {
                        type: 'trianglemarker',
                        trianglemarker: {offset: 6},
                        textcloud: {offset: -6}
                    },
                    valueIndicators: {
                        _type: 'rectangleneedle',
                        _default: {
                            offset: 20,
                            indentFromCenter: 0,
                            width: 2,
                            spindleSize: 14,
                            spindleGapSize: 10
                        },
                        triangleneedle: {width: 4},
                        twocolorneedle: {
                            space: 2,
                            secondFraction: 0.4
                        },
                        rangebar: {offset: 30},
                        trianglemarker: {offset: 6},
                        textcloud: {offset: -6}
                    }
                },
                _linear: {
                    scale: {
                        horizontalOrientation: 'right',
                        verticalOrientation: 'bottom',
                        label: {indentFromTick: -10}
                    },
                    rangeContainer: {
                        horizontalOrientation: 'right',
                        verticalOrientation: 'bottom'
                    },
                    valueIndicator: {
                        type: 'rangebar',
                        _default: {
                            offset: 2.5,
                            length: 15,
                            width: 15
                        },
                        rectangle: {width: 10},
                        rangebar: {
                            offset: 10,
                            horizontalOrientation: 'right',
                            verticalOrientation: 'bottom'
                        }
                    },
                    subvalueIndicator: {
                        type: 'trianglemarker',
                        _default: {
                            offset: -1,
                            horizontalOrientation: 'left',
                            verticalOrientation: 'top'
                        }
                    },
                    valueIndicators: {
                        _type: 'rectangle',
                        _default: {
                            offset: 2.5,
                            length: 15,
                            width: 15
                        },
                        rectangle: {width: 10},
                        rangebar: {
                            offset: 10,
                            horizontalOrientation: 'right',
                            verticalOrientation: 'bottom'
                        },
                        trianglemarker: {
                            offset: -1,
                            horizontalOrientation: 'left',
                            verticalOrientation: 'top'
                        },
                        textcloud: {
                            offset: -1,
                            horizontalOrientation: 'left',
                            verticalOrientation: 'top'
                        }
                    }
                }
            },
            barGauge: {
                backgroundColor: '#e0e0e0',
                relativeInnerRadius: 0.3,
                barSpacing: 4,
                label: {
                    indent: 20,
                    connectorWidth: 2,
                    font: {size: 16}
                },
                title: {
                    layout: {
                        horizontalAlignment: 'center',
                        verticalAlignment: 'top',
                        overlay: 0
                    },
                    font: {
                        size: 16,
                        color: '#232323',
                        family: fontFamilyDefault,
                        weight: 400
                    }
                },
                subtitle: {font: {
                        size: 14,
                        color: '#232323',
                        family: fontFamilyDefault,
                        weight: 400
                    }},
                indicator: {
                    hasPositiveMeaning: true,
                    layout: {
                        horizontalAlignment: 'center',
                        verticalAlignment: 'bottom',
                        overlay: 0
                    },
                    text: {font: {size: 18}}
                },
                tooltip: {
                    arrowLength: 10,
                    paddingLeftRight: 18,
                    paddingTopBottom: 15,
                    enabled: false,
                    border: {
                        width: 1,
                        color: '#d3d3d3',
                        dashStyle: 'solid',
                        visible: true
                    },
                    color: '#ffffff',
                    font: {
                        size: 12,
                        color: '#232323',
                        family: fontFamilyDefault,
                        weight: 400
                    },
                    shadow: {
                        opacity: 0.4,
                        offsetX: 0,
                        offsetY: 4,
                        blur: 2,
                        color: '#000000'
                    }
                },
                loadingIndicator: {
                    show: false,
                    font: {},
                    backgroundColor: '#ffffff',
                    text: 'Loading...'
                }
            },
            rangeSelector: {
                containerBackgroundColor: '#ffffff',
                scale: {
                    label: {
                        topIndent: 7,
                        font: {size: 11}
                    },
                    tick: {
                        width: 1,
                        color: '#000000',
                        opacity: 0.1
                    },
                    marker: {
                        separatorHeight: 33,
                        topIndent: 10,
                        textLeftIndent: 7,
                        textTopIndent: 11
                    }
                },
                loadingIndicator: {
                    show: false,
                    font: {},
                    backgroundColor: '#ffffff',
                    text: 'Loading...'
                },
                sliderMarker: {
                    padding: 7,
                    pointerSize: 6,
                    color: '#9b9b9b',
                    invalidRangeColor: '#ff0000',
                    font: {
                        color: '#ffffff',
                        size: 11
                    }
                },
                sliderHandle: {
                    width: 1,
                    color: '#000000',
                    opacity: 0.2
                },
                shutter: {
                    color: undefined,
                    opacity: 0.75
                },
                background: {color: "#c0bae1"},
                chart: {
                    containerBackgroundColor: undefined,
                    commonSeriesSettings: {
                        label: baseChartTheme.commonSeriesSettings.label,
                        border: {
                            visible: false,
                            width: 1
                        },
                        visible: true,
                        type: 'area',
                        hoverMode: 'none',
                        hoverStyle: {border: {}},
                        selectionStyle: {border: {}},
                        point: {
                            visible: false,
                            symbol: 'circle',
                            border: {
                                visible: false,
                                width: 1
                            },
                            size: 12,
                            hoverStyle: {border: {}},
                            selectionStyle: {border: {}}
                        },
                        line: {width: 2},
                        stepline: {width: 2},
                        scatter: {point: {visible: true}},
                        stackedline: {width: 2},
                        fullstackedline: {width: 2},
                        area: {opacity: 0.5},
                        stackedarea: {opacity: 0.5},
                        fullstackedarea: {opacity: 0.5},
                        spline: {width: 2},
                        splinearea: {opacity: 0.5},
                        steparea: {
                            border: {
                                visible: true,
                                width: 2
                            },
                            opacity: 0.5
                        },
                        bubble: {
                            opacity: 0.5,
                            point: {visible: true}
                        },
                        bar: {
                            cornerRadius: 0,
                            point: {visible: true}
                        },
                        stackedbar: {
                            cornerRadius: 0,
                            point: {visible: true}
                        },
                        fullstackedbar: {
                            cornerRadius: 0,
                            point: {visible: true}
                        },
                        rangebar: {
                            cornerRadius: 0,
                            point: {visible: true}
                        },
                        rangearea: {opacity: 0.5},
                        rangesplinearea: {opacity: 0.5},
                        candlestick: {
                            width: 1,
                            innerColor: '#ffffff',
                            reduction: {color: '#ff0000'}
                        },
                        stock: {
                            width: 1,
                            reduction: {color: '#ff0000'}
                        },
                        valueErrorBar: baseChartTheme.commonSeriesSettings.valueErrorBar
                    },
                    dataPrepareSettings: {
                        checkTypeForAllData: false,
                        convertToAxisDataType: true,
                        sortingMethod: true
                    },
                    useAggregation: false,
                    equalBarWidth: true,
                    minBubbleSize: 12,
                    maxBubbleSize: 0.2,
                    topIndent: 0.1,
                    bottomIndent: 0,
                    valueAxis: {
                        min: undefined,
                        max: undefined,
                        inverted: false,
                        logarithmBase: 10
                    }
                }
            },
            map: {
                background: {
                    borderWidth: 1,
                    borderColor: '#cacaca',
                    color: '#ffffff'
                },
                areaSettings: {
                    borderWidth: 1,
                    borderColor: '#ffffff',
                    color: '#d2d2d2',
                    hoveredBorderColor: '#303030',
                    selectedBorderWidth: 2,
                    selectedBorderColor: '#303030',
                    label: {
                        enabled: false,
                        stroke: '#ffffff',
                        'stroke-width': 2,
                        'stroke-opacity': 0.5,
                        font: {
                            color: '#2b2b2b',
                            size: 16,
                            opacity: 0.5
                        }
                    }
                },
                markerSettings: {
                    label: {
                        enabled: true,
                        stroke: '#ffffff',
                        'stroke-width': 1,
                        'stroke-opacity': 0.5,
                        font: {
                            color: '#2b2b2b',
                            size: 12
                        }
                    },
                    _dot: {
                        borderWidth: 2,
                        borderColor: '#ffffff',
                        color: '#ba4d51',
                        size: 8,
                        selectedStep: 2,
                        backStep: 18,
                        backColor: '#ffffff',
                        backOpacity: 0.32,
                        shadow: true
                    },
                    _bubble: {
                        minSize: 20,
                        maxSize: 50,
                        color: '#ba4d51',
                        hoveredBorderWidth: 1,
                        hoveredBorderColor: '#303030',
                        selectedBorderWidth: 2,
                        selectedBorderColor: '#303030'
                    },
                    _pie: {
                        size: 50,
                        hoveredBorderWidth: 1,
                        hoveredBorderColor: '#303030',
                        selectedBorderWidth: 2,
                        selectedBorderColor: '#303030'
                    },
                    _image: {size: 20}
                },
                legend: {
                    verticalAlignment: 'bottom',
                    horizontalAlignment: 'right',
                    position: 'inside',
                    visible: true,
                    margin: 10,
                    equalColumnWidth: false,
                    markerSize: 12,
                    backgroundColor: '#ffffff',
                    backgroundOpacity: 0.65,
                    border: {
                        visible: true,
                        width: 1,
                        color: '#cacaca',
                        cornerRadius: 0,
                        dashStyle: 'solid'
                    },
                    paddingLeftRight: 16,
                    paddingTopBottom: 12,
                    columnItemSpacing: 20,
                    rowItemSpacing: 8,
                    markerColor: '#ba4d51',
                    font: {
                        color: '#2b2b2b',
                        size: 12
                    }
                },
                controlBar: {
                    borderColor: '#5d5d5d',
                    borderWidth: 3,
                    color: '#ffffff',
                    margin: 20
                },
                tooltip: {
                    arrowLength: 10,
                    paddingLeftRight: 18,
                    paddingTopBottom: 15,
                    border: {
                        width: 1,
                        color: '#d7d7d7',
                        dashStyle: 'solid',
                        visible: true
                    },
                    color: '#ffffff',
                    font: {
                        color: '#232323',
                        size: 12,
                        family: fontFamilyDefault,
                        weight: 400
                    },
                    shadow: {
                        opacity: 0.4,
                        offsetX: 0,
                        offsetY: 4,
                        blur: 2,
                        color: '#000000'
                    }
                },
                loadingIndicator: {
                    show: false,
                    backgroundColor: '#ffffff',
                    font: {},
                    text: 'Loading...'
                },
                _rtl: {legend: {itemTextPosition: 'left'}}
            },
            sparkline: {
                lineColor: '#666666',
                lineWidth: 2,
                areaOpacity: 0.2,
                minColor: '#e8c267',
                maxColor: '#e55253',
                barPositiveColor: '#a9a9a9',
                barNegativeColor: '#d7d7d7',
                winColor: '#a9a9a9',
                lossColor: '#d7d7d7',
                firstLastColor: '#666666',
                pointSymbol: 'circle',
                pointColor: '#ffffff',
                pointSize: 4,
                tooltip: {
                    enabled: true,
                    allowContainerResizing: true,
                    verticalAlignment: 'top',
                    horizontalAlignment: 'center',
                    format: '',
                    paddingLeftRight: 18,
                    paddingTopBottom: 15,
                    arrowLength: 10,
                    precision: 0,
                    color: '#ffffff',
                    border: {
                        width: 1,
                        color: '#d3d3d3',
                        dashStyle: 'solid',
                        visible: true
                    },
                    font: {
                        color: '#232323',
                        family: fontFamilyDefault,
                        size: 12,
                        weight: 400
                    },
                    shadow: {
                        opacity: 0.4,
                        offsetX: 0,
                        offsetY: 4,
                        blur: 2,
                        color: '#000000'
                    }
                }
            },
            bullet: {
                color: '#e8c267',
                targetColor: '#666666',
                targetWidth: 4,
                showTarget: true,
                showZeroLevel: true,
                tooltip: {
                    enabled: true,
                    allowContainerResizing: true,
                    verticalAlignment: 'top',
                    horizontalAlignment: 'center',
                    format: '',
                    precision: 0,
                    paddingLeftRight: 18,
                    paddingTopBottom: 15,
                    arrowLength: 10,
                    color: '#ffffff',
                    border: {
                        width: 1,
                        color: '#d3d3d3',
                        dashStyle: 'solid',
                        visible: true
                    },
                    font: {
                        color: '#232323',
                        family: fontFamilyDefault,
                        size: 12,
                        weight: 400
                    },
                    shadow: {
                        opacity: 0.4,
                        offsetX: 0,
                        offsetY: 4,
                        blur: 2,
                        color: '#000000'
                    }
                }
            },
            polar: $.extend(true, {}, baseChartTheme, {
                commonSeriesSettings: {
                    type: 'scatter',
                    closed: true,
                    point: {
                        visible: true,
                        symbol: 'circle',
                        size: 12,
                        border: {
                            visible: false,
                            width: 1
                        },
                        hoverMode: 'onlyPoint',
                        selectionMode: 'onlyPoint',
                        hoverStyle: {
                            border: {
                                visible: true,
                                width: 4
                            },
                            size: 12
                        },
                        selectionStyle: {
                            border: {
                                visible: true,
                                width: 4
                            },
                            size: 12
                        }
                    },
                    scatter: {},
                    line: {
                        width: 2,
                        dashStyle: 'solid',
                        hoverStyle: {
                            width: 3,
                            hatching: {direction: 'none'}
                        },
                        selectionStyle: {width: 3}
                    },
                    area: {
                        point: {visible: false},
                        opacity: 0.5
                    },
                    stackedline: {width: 2},
                    bar: {opacity: 0.8},
                    stackedbar: {opacity: 0.8}
                },
                adaptiveLayout: {
                    width: 170,
                    height: 170,
                    keepLabels: true
                },
                equalBarWidth: true,
                commonAxisSettings: {
                    tickInterval: undefined,
                    valueMarginsEnabled: true,
                    logarithmBase: 10,
                    discreteAxisDivisionMode: 'betweenLabels',
                    visible: true,
                    color: '#d3d3d3',
                    width: 1,
                    label: {
                        visible: true,
                        overlappingBehavior: {mode: 'enlargeTickInterval'},
                        precision: 0,
                        format: '',
                        customizeText: undefined,
                        customizeHint: undefined,
                        indentFromAxis: 10
                    },
                    grid: {
                        visible: true,
                        color: '#d3d3d3',
                        width: 1
                    },
                    minorGrid: {
                        visible: true,
                        color: '#d3d3d3',
                        width: 1,
                        opacity: 0.3
                    },
                    tick: {
                        visible: true,
                        color: '#d3d3d3'
                    },
                    minorTick: {
                        visible: false,
                        color: '#d3d3d3',
                        opacity: 0.3
                    },
                    title: {
                        font: {size: 16},
                        margin: 10
                    },
                    stripStyle: {},
                    constantLineStyle: {
                        width: 1,
                        color: '#000000',
                        dashStyle: 'solid',
                        label: {
                            visible: true,
                            position: 'inside'
                        }
                    }
                },
                argumentAxis: {
                    startAngle: 0,
                    firstPointOnStartAngle: false,
                    period: undefined
                },
                valueAxis: {tick: {visible: false}},
                horizontalAxis: {
                    isHorizontal: 1,
                    position: 'top',
                    axisDivisionFactor: 50,
                    label: {alignment: "center"}
                },
                verticalAxis: {
                    isHorizontal: 1,
                    position: 'top',
                    axisDivisionFactor: 30,
                    label: {alignment: "right"}
                }
            })
        });
        DX.viz.core.registerTheme({
            name: 'desktop-dark',
            font: {color: '#808080'},
            chart: $.extend(true, {}, baseDarkChartTheme, {
                commonSeriesSettings: {candlestick: {innerColor: '#2b2b2b'}},
                crosshair: {color: '#515151'},
                commonAxisSettings: {
                    color: '#494949',
                    grid: {color: '#494949'},
                    tick: {color: '#494949'},
                    constantLineStyle: {color: '#ffffff'}
                },
                commonPaneSettings: {border: {color: '#494949'}}
            }),
            pie: $.extend(true, {}, baseDarkChartTheme),
            pieIE8: {commonSeriesSettings: {
                    pie: {
                        hoverStyle: {border: {color: '#2b2b2b'}},
                        selectionStyle: {border: {color: '#2b2b2b'}}
                    },
                    donut: {
                        hoverStyle: {border: {color: '#2b2b2b'}},
                        selectionStyle: {border: {color: '#2b2b2b'}}
                    },
                    doughnut: {
                        hoverStyle: {border: {color: '#2b2b2b'}},
                        selectionStyle: {border: {color: '#2b2b2b'}}
                    }
                }},
            gauge: {
                containerBackgroundColor: '#2b2b2b',
                scale: {
                    majorTick: {color: '#303030'},
                    minorTick: {color: '#303030'}
                },
                rangeContainer: {backgroundColor: '#b5b5b5'},
                valueIndicator: {
                    _default: {color: '#b5b5b5'},
                    rangebar: {color: '#84788b'},
                    twocolorneedle: {secondColor: '#ba544d'}
                },
                subvalueIndicator: {_default: {color: '#b7918f'}},
                valueIndicators: {
                    _default: {color: '#b5b5b5'},
                    rangebar: {color: '#84788b'},
                    twocolorneedle: {secondColor: '#ba544d'},
                    trianglemarker: {color: '#b7918f'},
                    textcloud: {color: '#ba544d'}
                },
                title: {font: {color: '#929292'}},
                subtitle: {font: {color: '#929292'}},
                loadingIndicator: {backgroundColor: '#2b2b2b'},
                tooltip: {
                    color: '#2b2b2b',
                    border: {color: '#494949'},
                    font: {color: '#929292'}
                }
            },
            barGauge: {
                title: {font: {color: '#929292'}},
                subtitle: {font: {color: '#929292'}},
                tooltip: {
                    color: '#2b2b2b',
                    border: {color: '#494949'},
                    font: {color: '#929292'}
                },
                loadingIndicator: {backgroundColor: '#2b2b2b'}
            },
            rangeSelector: {
                containerBackgroundColor: '#2b2b2b',
                scale: {tick: {
                        color: '#ffffff',
                        opacity: 0.05
                    }},
                loadingIndicator: {backgroundColor: '#2b2b2b'},
                sliderMarker: {
                    color: '#b5b5b5',
                    font: {color: '#303030'}
                },
                sliderHandle: {
                    color: '#ffffff',
                    opacity: 0.35
                },
                shutter: {
                    color: '#2b2b2b',
                    opacity: 0.9
                }
            },
            map: {
                background: {
                    borderColor: '#3f3f3f',
                    color: '#303030'
                },
                areaSettings: {
                    borderColor: '#303030',
                    color: '#686868',
                    hoveredBorderColor: '#ffffff',
                    selectedBorderColor: '#ffffff',
                    label: {
                        stroke: '#000000',
                        font: {color: '#ffffff'}
                    }
                },
                markerSettings: {
                    label: {
                        stroke: '#000000',
                        font: {color: '#ffffff'}
                    },
                    _bubble: {
                        hoveredBorderColor: '#ffffff',
                        selectedBorderColor: '#ffffff'
                    },
                    _pie: {
                        hoveredBorderColor: '#ffffff',
                        selectedBorderColor: '#ffffff'
                    }
                },
                legend: {
                    border: {color: '#3f3f3f'},
                    backgroundColor: '#303030',
                    font: {color: '#ffffff'}
                },
                controlBar: {
                    borderColor: '#c7c7c7',
                    color: '#303030'
                },
                tooltip: {
                    color: '#2b2b2b',
                    border: {color: '#494949'},
                    font: {color: '#929292'}
                },
                loadingIndicator: {backgroundColor: '#2b2b2b'}
            },
            sparkline: {
                lineColor: '#c7c7c7',
                firstLastColor: '#c7c7c7',
                barPositiveColor: '#b8b8b8',
                barNegativeColor: '#8e8e8e',
                winColor: '#b8b8b8',
                lossColor: '#8e8e8e',
                pointColor: '#303030',
                tooltip: {
                    color: '#2b2b2b',
                    border: {color: '#494949'},
                    font: {color: '#929292'}
                }
            },
            bullet: {
                targetColor: '#8e8e8e',
                tooltip: {
                    color: '#2b2b2b',
                    border: {color: '#494949'},
                    font: {color: '#929292'}
                }
            },
            polar: $.extend(true, {}, baseDarkChartTheme)
        }, 'desktop')
    })(jQuery, DevExpress);
    /*! Module viz-core, file android.js */
    (function($, DX, undefined) {
        var baseChartTheme = {
                containerBackgroundColor: '#050506',
                title: {font: {color: '#ffffff'}},
                commonSeriesSettings: {label: {border: {color: '#4c4c4c'}}},
                legend: {
                    font: {
                        color: '#ffffff',
                        size: 11
                    },
                    border: {color: '#4c4c4c'}
                },
                loadingIndicator: {backgroundColor: '#050506'},
                tooltip: {
                    color: '#050506',
                    border: {color: '#4c4c4c'},
                    font: {color: '#ffffff'}
                }
            },
            baseLightChartTheme = {
                containerBackgroundColor: '#e8e8e8',
                title: {font: {color: '#808080'}},
                legend: {font: {
                        color: '#000000',
                        size: 11
                    }},
                loadingIndicator: {backgroundColor: '#e8e8e8'},
                tooltip: {
                    color: '#e8e8e8',
                    font: {color: '#808080'}
                }
            };
        DX.viz.core.registerTheme({
            name: 'android',
            chart: $.extend(true, {}, baseChartTheme, {
                commonSeriesSettings: {candlestick: {innerColor: '#050506'}},
                commonAxisSettings: {
                    color: '#4c4c4c',
                    grid: {color: '#4c4c4c'},
                    tick: {color: '#4c4c4c'},
                    title: {font: {color: '#545455'}},
                    label: {font: {
                            color: '#ffffff',
                            size: 11
                        }}
                },
                commonPaneSettings: {border: {color: '#4c4c4c'}}
            }),
            pie: $.extend(true, {}, baseChartTheme),
            pieIE8: {commonSeriesSettings: {
                    pie: {
                        hoverStyle: {border: {color: '#050506'}},
                        selectionStyle: {border: {color: '#050506'}}
                    },
                    donut: {
                        hoverStyle: {border: {color: '#050506'}},
                        selectionStyle: {border: {color: '#050506'}}
                    },
                    doughnut: {
                        hoverStyle: {border: {color: '#050506'}},
                        selectionStyle: {border: {color: '#050506'}}
                    }
                }},
            gauge: {
                containerBackgroundColor: '#050506',
                title: {font: {color: '#ffffff'}},
                subtitle: {font: {color: '#ffffff'}},
                loadingIndicator: {backgroundColor: '#050506'},
                tooltip: {
                    color: '#050506',
                    border: {color: '#4c4c4c'},
                    font: {color: '#ffffff'}
                }
            },
            barGauge: {
                title: {font: {color: '#ffffff'}},
                subtitle: {font: {color: '#ffffff'}},
                tooltip: {
                    color: '#050506',
                    border: {color: '#4c4c4c'},
                    font: {color: '#ffffff'}
                },
                loadingIndicator: {backgroundColor: '#050506'}
            },
            rangeSelector: {
                containerBackgroundColor: '#050506',
                loadingIndicator: {backgroundColor: '#050506'}
            },
            map: {
                loadingIndicator: {backgroundColor: '#050506'},
                tooltip: {
                    color: '#050506',
                    border: {color: '#4c4c4c'},
                    font: {color: '#ffffff'}
                }
            },
            sparkline: {tooltip: {
                    color: '#050506',
                    border: {color: '#4c4c4c'},
                    font: {color: '#ffffff'}
                }},
            bullet: {tooltip: {
                    color: '#050506',
                    border: {color: '#4c4c4c'},
                    font: {color: '#ffffff'}
                }}
        }, 'desktop-dark');
        DX.viz.core.registerTheme({
            name: 'android-holo-light',
            chart: $.extend(true, {}, baseLightChartTheme, {
                commonSeriesSettings: {candlestick: {innerColor: '#e8e8e8'}},
                commonAxisSettings: {
                    title: {font: {color: '#939393'}},
                    label: {font: {
                            color: '#404040',
                            size: 11
                        }}
                }
            }),
            pie: $.extend(true, {}, baseLightChartTheme),
            pieIE8: {commonSeriesSettings: {
                    pie: {
                        hoverStyle: {border: {color: '#e8e8e8'}},
                        selectionStyle: {border: {color: '#e8e8e8'}}
                    },
                    donut: {
                        hoverStyle: {border: {color: '#e8e8e8'}},
                        selectionStyle: {border: {color: '#e8e8e8'}}
                    },
                    doughnut: {
                        hoverStyle: {border: {color: '#e8e8e8'}},
                        selectionStyle: {border: {color: '#e8e8e8'}}
                    }
                }},
            gauge: {
                containerBackgroundColor: '#e8e8e8',
                title: {font: {color: '#808080'}},
                subtitle: {font: {color: '#808080'}},
                loadingIndicator: {backgroundColor: '#e8e8e8'},
                tooltip: {
                    color: '#e8e8e8',
                    font: {color: '#808080'}
                }
            },
            barGauge: {
                title: {font: {color: '#808080'}},
                subtitle: {font: {color: '#808080'}},
                tooltip: {
                    color: '#e8e8e8',
                    font: {color: '#808080'}
                },
                loadingIndicator: {backgroundColor: '#e8e8e8'}
            },
            rangeSelector: {
                containerBackgroundColor: '#e8e8e8',
                loadingIndicator: {backgroundColor: '#e8e8e8'}
            },
            map: {
                loadingIndicator: {backgroundColor: '#e8e8e8'},
                tooltip: {
                    color: '#e8e8e8',
                    font: {color: '#808080'}
                }
            },
            sparkline: {tooltip: {
                    color: '#e8e8e8',
                    font: {color: '#808080'}
                }},
            bullet: {tooltip: {
                    color: '#e8e8e8',
                    font: {color: '#808080'}
                }}
        }, 'desktop')
    })(jQuery, DevExpress);
    /*! Module viz-core, file ios.js */
    (function($, DX, undefined) {
        var baseChartTheme = {
                containerBackgroundColor: '#cbd0da',
                title: {font: {color: '#808080'}},
                commonSeriesSettings: {label: {border: {color: '#b0b3ba'}}},
                legend: {
                    font: {
                        color: '#000000',
                        size: 11
                    },
                    border: {color: '#b0b3ba'}
                },
                loadingIndicator: {backgroundColor: '#cbd0da'},
                tooltip: {font: {color: '#808080'}}
            },
            baseIos7ChartTheme = {
                containerBackgroundColor: '#ffffff',
                title: {font: {color: '#808080'}},
                commonSeriesSettings: {label: {border: {color: '#d3d3d3'}}},
                legend: {
                    font: {
                        color: '#000000',
                        size: 11
                    },
                    border: {color: '#d3d3d3'}
                },
                loadingIndicator: {backgroundColor: '#ffffff'},
                tooltip: {font: {color: '#808080'}}
            };
        DX.viz.core.registerTheme({
            name: 'ios',
            chart: $.extend(true, {}, baseChartTheme, {
                commonSeriesSettings: {candlestick: {innerColor: '#cbd0da'}},
                commonAxisSettings: {
                    color: '#b0b3ba',
                    grid: {color: '#b0b3ba'},
                    tick: {color: '#b0b3ba'},
                    title: {font: {color: '#939393'}},
                    label: {font: {
                            color: '#000000',
                            size: 11
                        }}
                },
                commonPaneSettings: {border: {color: '#b0b3ba'}}
            }),
            pie: $.extend(true, {}, baseChartTheme),
            pieIE8: {commonSeriesSettings: {
                    pie: {
                        hoverStyle: {border: {color: '#cbd0da'}},
                        selectionStyle: {border: {color: '#cbd0da'}}
                    },
                    donut: {
                        hoverStyle: {border: {color: '#cbd0da'}},
                        selectionStyle: {border: {color: '#cbd0da'}}
                    },
                    doughnut: {
                        hoverStyle: {border: {color: '#cbd0da'}},
                        selectionStyle: {border: {color: '#cbd0da'}}
                    }
                }},
            gauge: {
                title: {font: {color: '#808080'}},
                subtitle: {font: {color: '#808080'}},
                tooltip: {font: {color: '#808080'}}
            },
            barGauge: {
                title: {font: {color: '#808080'}},
                subtitle: {font: {color: '#808080'}},
                tooltip: {font: {color: '#808080'}}
            },
            map: {tooltip: {font: {color: '#808080'}}},
            sparkline: {tooltip: {font: {color: '#808080'}}},
            bullet: {tooltip: {font: {color: '#808080'}}}
        }, 'desktop');
        DX.viz.core.registerTheme({
            name: 'ios:7',
            chart: $.extend(true, {}, baseIos7ChartTheme, {
                commonAxisSettings: {
                    color: '#d3d3d3',
                    grid: {color: '#d3d3d3'},
                    tick: {color: '#d3d3d3'},
                    title: {font: {color: '#939393'}},
                    label: {font: {
                            color: '#000000',
                            size: 11
                        }}
                },
                commonPaneSettings: {border: {color: '#d3d3d3'}}
            }),
            pie: $.extend(true, {}, baseIos7ChartTheme),
            gauge: {
                title: {font: {color: '#808080'}},
                subtitle: {font: {color: '#808080'}},
                tooltip: {font: {color: '#808080'}}
            },
            barGauge: {
                title: {font: {color: '#808080'}},
                subtitle: {font: {color: '#808080'}},
                tooltip: {font: {color: '#808080'}}
            },
            map: {tooltip: {font: {color: '#808080'}}},
            sparkline: {tooltip: {font: {color: '#808080'}}},
            bullet: {tooltip: {font: {color: '#808080'}}}
        }, 'desktop')
    })(jQuery, DevExpress);
    /*! Module viz-core, file win8.js */
    (function($, DX) {
        var baseChartTheme = {
                containerBackgroundColor: '#000000',
                title: {font: {color: '#ffffff'}},
                commonSeriesSettings: {label: {border: {color: '#454545'}}},
                legend: {
                    font: {
                        color: '#ffffff',
                        size: 11
                    },
                    border: {color: '#454545'}
                },
                loadingIndicator: {backgroundColor: '#000000'},
                tooltip: {
                    color: '#000000',
                    font: {color: '#ffffff'}
                }
            },
            baseWhiteChartTheme = {
                title: {font: {color: '#808080'}},
                legend: {font: {
                        color: '#000000',
                        size: 11
                    }},
                tooltip: {font: {color: '#808080'}}
            };
        DX.viz.core.registerTheme({
            name: 'win8',
            chart: $.extend(true, {}, baseChartTheme, {
                commonSeriesSettings: {candlestick: {innerColor: '#000000'}},
                commonAxisSettings: {
                    color: '#454545',
                    grid: {color: '#454545'},
                    tick: {color: '#454545'},
                    title: {font: {color: '#535353'}},
                    label: {font: {
                            color: '#ffffff',
                            size: 11
                        }}
                },
                commonPaneSettings: {border: {color: '#454545'}}
            }),
            pie: $.extend(true, {}, baseChartTheme),
            pieIE8: {commonSeriesSettings: {
                    pie: {
                        hoverStyle: {border: {color: '#000000'}},
                        selectionStyle: {border: {color: '#000000'}}
                    },
                    donut: {
                        hoverStyle: {border: {color: '#000000'}},
                        selectionStyle: {border: {color: '#000000'}}
                    },
                    doughnut: {
                        hoverStyle: {border: {color: '#000000'}},
                        selectionStyle: {border: {color: '#000000'}}
                    }
                }},
            gauge: {
                containerBackgroundColor: '#000000',
                title: {font: {color: '#ffffff'}},
                subtitle: {font: {color: '#ffffff'}},
                loadingIndicator: {backgroundColor: '#000000'},
                tooltip: {
                    color: '#000000',
                    font: {color: '#ffffff'}
                }
            },
            barGauge: {
                title: {font: {color: '#ffffff'}},
                subtitle: {font: {color: '#ffffff'}},
                tooltip: {
                    color: '#000000',
                    font: {color: '#ffffff'}
                },
                loadingIndicator: {backgroundColor: '#000000'}
            },
            rangeSelector: {
                containerBackgroundColor: '#000000',
                loadingIndicator: {backgroundColor: '#000000'}
            },
            map: {
                loadingIndicator: {backgroundColor: '#000000'},
                tooltip: {
                    color: '#000000',
                    font: {color: '#ffffff'}
                }
            },
            sparkline: {tooltip: {
                    color: '#000000',
                    font: {color: '#ffffff'}
                }},
            bullet: {tooltip: {
                    color: '#000000',
                    font: {color: '#ffffff'}
                }}
        }, 'desktop-dark');
        DX.viz.core.registerTheme({
            name: 'win8-white',
            chart: $.extend(true, {}, baseWhiteChartTheme, {commonAxisSettings: {
                    title: {font: {color: '#939393'}},
                    label: {font: {
                            color: '#404040',
                            size: 11
                        }}
                }}),
            pie: $.extend(true, {}, baseWhiteChartTheme),
            gauge: {
                title: {font: {color: '#808080'}},
                subtitle: {font: {color: '#808080'}},
                tooltip: {font: {color: '#808080'}}
            },
            barGauge: {
                title: {font: {color: '#808080'}},
                subtitle: {font: {color: '#808080'}},
                tooltip: {font: {color: '#808080'}}
            },
            map: {tooltip: {font: {color: '#808080'}}},
            sparkline: {tooltip: {font: {color: '#808080'}}},
            bullet: {tooltip: {font: {color: '#808080'}}}
        }, 'desktop')
    })(jQuery, DevExpress);
    /*! Module viz-core, file others.js */
    (function($, DX) {
        DX.viz.core.registerTheme({name: 'generic'}, 'desktop');
        DX.viz.core.registerTheme({name: 'generic-dark'}, 'desktop-dark');
        DX.viz.core.registerTheme({name: 'tizen'}, 'desktop');
        DX.viz.core.registerTheme({name: 'tizen-black'}, 'desktop-dark')
    })(jQuery, DevExpress);
    /*! Module viz-core, file namespaces.js */
    (function(DevExpress) {
        DevExpress.viz.charts = {series: {}}
    })(DevExpress);
    /*! Module viz-core, file chartsConsts.js */
    (function(DX) {
        DX.viz.charts.consts = {
            dataTypes: {
                STRING: 'string',
                NUMERIC: 'numeric',
                DATETIME: 'datetime'
            },
            axisTypes: {
                DISCRETE: 'discrete',
                CONTINUOUS: 'continuous',
                LOGARITHMIC: 'logarithmic'
            }
        }
    })(DevExpress);
    /*! Module viz-core, file dataValidator.js */
    (function($, DX) {
        var viz = DX.viz,
            parseUtils = new viz.core.ParseUtils,
            chartConst = viz.charts.consts,
            dataTypes = chartConst.dataTypes,
            axisTypes = chartConst.axisTypes,
            utils = DX.utils,
            _each = $.each,
            _isDefined = utils.isDefined;
        var mergeSort = function(data, field) {
                function merge_sort(array, low, high, field) {
                    if (low < high) {
                        var mid = Math.floor((low + high) / 2);
                        merge_sort(array, low, mid, field);
                        merge_sort(array, mid + 1, high, field);
                        merge(array, low, mid, high, field)
                    }
                }
                var n = data.length;
                merge_sort(data, 0, n - 1, field);
                return data
            };
        var merge = function(array, low, mid, high, field) {
                var newArray = new Array(high - low + 1),
                    countL = low,
                    countR = mid + 1,
                    k,
                    i = 0;
                while (countL <= mid && countR <= high) {
                    if (array[countL][field] <= array[countR][field] || !_isDefined(array[countR][field])) {
                        newArray[i] = array[countL];
                        countL++
                    }
                    else {
                        newArray[i] = array[countR];
                        countR++
                    }
                    i++
                }
                if (countL > mid)
                    for (k = countR; k <= high; k++, i++)
                        newArray[i] = array[k];
                else
                    for (k = countL; k <= mid; k++, i++)
                        newArray[i] = array[k];
                for (k = 0; k <= high - low; k++)
                    array[k + low] = newArray[k];
                return array
            };
        viz.charts.DataValidator = DX.Class.inherit({
            ctor: function(data, groups, incidentOccured, dataPrepareOptions) {
                var that = this;
                groups = groups || [[]];
                if (!data)
                    that._nullData = true;
                that.groups = groups;
                that.data = data || [];
                that._parsers = {};
                that._errorShowList = {};
                that._skipFields = {};
                that.options = dataPrepareOptions || {};
                that.incidentOccured = incidentOccured;
                that.userArgumentCategories = that.groups.length && that.groups[0].length && that.groups[0][0].getArgumentCategories();
                if (!incidentOccured)
                    that.incidentOccured = $.noop
            },
            validate: function validate() {
                var that = this;
                that._data = that.data;
                that.groups.argumentType = null;
                that.groups.argumentAxisType = null;
                $.each(that.groups, function(_, group) {
                    group.valueType = null;
                    group.valueAxisType = null;
                    $.each(group, function(_, series) {
                        series.updateDataType({})
                    })
                });
                that._checkType();
                that._checkAxisType();
                if (!utils.isArray(that.data) || that._nullData)
                    that._incorrectDataMessage();
                if (that.options.convertToAxisDataType) {
                    that._createParser();
                    that._parse()
                }
                that._groupData();
                that._sort();
                $.each(that._skipFields, function(field, fieldValue) {
                    if (fieldValue === that._data.length)
                        that.incidentOccured("W2002", [field])
                });
                return that._data
            },
            _checkType: function _checkType() {
                var that = this,
                    groupsWithUndefinedValueType = [],
                    groupsWithUndefinedArgumentType = [],
                    checkValueTypeOfGroup = function checkValueTypeOfGroup(group, cell) {
                        $.each(group, function(_, series) {
                            $.each(series.getValueFields(), function(_, field) {
                                group.valueType = that._getType(cell[field], group.valueType)
                            })
                        });
                        if (group.valueType)
                            return true
                    },
                    checkArgumentTypeOfGroup = function checkArgumentTypeOfGroup(group, cell) {
                        $.each(group, function(_, series) {
                            that.groups.argumentType = that._getType(cell[series.getArgumentField()], that.groups.argumentType)
                        });
                        if (that.groups.argumentType)
                            return true
                    };
                $.each(that.groups, function(_, group) {
                    if (!group.length)
                        return null;
                    var options = group[0].getOptions(),
                        valueTypeGroup = options.valueType,
                        argumentTypeGroup = options.argumentType;
                    group.valueType = valueTypeGroup;
                    that.groups.argumentType = argumentTypeGroup;
                    valueTypeGroup ? null : groupsWithUndefinedValueType.push(group);
                    argumentTypeGroup ? null : groupsWithUndefinedArgumentType.push(group)
                });
                if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length)
                    $.each(that.data, function(_, cell) {
                        var define = true;
                        if (!utils.isObject(cell))
                            return;
                        $.each(groupsWithUndefinedValueType, function(index, group) {
                            define = define && checkValueTypeOfGroup(group, cell)
                        });
                        $.each(groupsWithUndefinedArgumentType, function(index, group) {
                            define = define && checkArgumentTypeOfGroup(group, cell)
                        });
                        if (!that.options.checkTypeForAllData && define)
                            return false
                    })
            },
            _checkAxisType: function _checkAxisType() {
                var that = this;
                $.each(that.groups, function(_, group) {
                    $.each(group, function(_, series) {
                        var optionsSeries = {},
                            existingSeriesOptions = series.getOptions();
                        optionsSeries.argumentAxisType = that._correctAxisType(that.groups.argumentType, existingSeriesOptions.argumentAxisType, !!that.userArgumentCategories.length);
                        optionsSeries.valueAxisType = that._correctAxisType(group.valueType, existingSeriesOptions.valueAxisType, !!series.getValueCategories().length);
                        that.groups.argumentAxisType = that.groups.argumentAxisType || optionsSeries.argumentAxisType;
                        group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;
                        optionsSeries.argumentType = that.groups.argumentType;
                        optionsSeries.valueType = group.valueType;
                        series.updateDataType(optionsSeries)
                    });
                    if (group.valueAxis) {
                        group.valueAxis.setTypes(group.valueAxisType, group.valueType, "valueType");
                        group.valueAxis.validate(false, that.incidentOccured)
                    }
                });
                if (that.groups.argumentAxes)
                    _each(that.groups.argumentAxes, function(_, axis) {
                        axis.setTypes(that.groups.argumentAxisType, that.groups.argumentType, "argumentType");
                        axis.validate(true, that.incidentOccured)
                    })
            },
            _createParser: function _createParser() {
                var that = this;
                $.each(that.groups, function(index, group) {
                    $.each(group, function(_, series) {
                        that._parsers[series.getArgumentField()] = that._createParserUnit(that.groups.argumentType, that.groups.argumentAxisType === axisTypes.LOGARITHMIC ? that._filterForLogAxis : null);
                        $.each(series.getValueFields(), function(_, field) {
                            that._parsers[field] = that._createParserUnit(group.valueType, group.valueAxisType === axisTypes.LOGARITHMIC ? that._filterForLogAxis : null, series.getOptions().ignoreEmptyPoints)
                        });
                        if (series.getTagField())
                            that._parsers[series.getTagField()] = null
                    })
                })
            },
            _parse: function _parse() {
                var that = this,
                    parsedData = [];
                $.each(that.data, function(_, cell) {
                    var parserObject = {};
                    if (!utils.isObject(cell)) {
                        cell && that._incorrectDataMessage();
                        return
                    }
                    $.each(that._parsers, function(field, parser) {
                        parserObject[field] = parser ? parser(cell[field], field) : cell[field];
                        parserObject["original" + field] = cell[field]
                    });
                    parsedData.push(parserObject)
                });
                this._data = parsedData
            },
            _groupMinSlices: function(argumentField, valueField, smallValuesGrouping) {
                var that = this,
                    smallValuesGrouping = smallValuesGrouping || {},
                    mode = smallValuesGrouping.mode,
                    count = smallValuesGrouping.topCount,
                    threshold = smallValuesGrouping.threshold,
                    name = smallValuesGrouping.groupName || "others",
                    others = {},
                    data = that._data.slice(),
                    index;
                var groupingValues = function(index) {
                        if (!_isDefined(index) || index < 0)
                            return;
                        _each(data.slice(index), function(_, cell) {
                            if (!_isDefined(cell[valueField]))
                                return;
                            others[valueField] += cell[valueField];
                            cell[valueField] = undefined;
                            cell["original" + valueField] = undefined
                        })
                    };
                if (!mode || mode === "none")
                    return;
                others[argumentField] = name + "";
                others[valueField] = 0;
                data.sort(function(a, b) {
                    if (_isDefined(b[valueField]) && _isDefined(a[valueField]))
                        return b[valueField] - a[valueField];
                    else if (!_isDefined(b[valueField]) && a[valueField])
                        return -1;
                    else if (!_isDefined(a[valueField]) && b[valueField])
                        return 1
                });
                if (mode === "smallValueThreshold") {
                    _each(data, function(i, cell) {
                        if (_isDefined(index) || !_isDefined(cell[valueField]))
                            return;
                        if (threshold > cell[valueField])
                            index = i
                    });
                    groupingValues(index)
                }
                else if (mode === "topN")
                    groupingValues(count);
                others[valueField] && that._data.push(others)
            },
            _groupData: function() {
                var that = this,
                    groups = that.groups,
                    isPie = groups.length && groups[0].length && (groups[0][0].type === "pie" || groups[0][0].type === "doughnut" || groups[0][0].type === "donut"),
                    argumentField,
                    valueFields;
                if (!isPie)
                    return;
                _each(groups, function(_, group) {
                    _each(group, function(_, series) {
                        argumentField = series.getArgumentField();
                        valueFields = series.getValueFields();
                        if (groups.argumentAxisType === axisTypes.DISCRETE)
                            that._groupSameArguments(argumentField, valueFields);
                        that._groupMinSlices(argumentField, valueFields[0], series.getOptions().smallValuesGrouping)
                    })
                })
            },
            _groupSameArguments: function(argumentField, valueFields) {
                var that = this,
                    argument,
                    dataOfArguments = {},
                    parsedData = that._data;
                _each(parsedData, function(i, cell) {
                    if (!_isDefined(cell[argumentField]) || !_isDefined(cell[valueFields[0]]))
                        return;
                    argument = cell[argumentField];
                    if (_isDefined(dataOfArguments[argument])) {
                        var data = parsedData[dataOfArguments[argument]];
                        _each(valueFields, function(_, field) {
                            data[field] += cell[field];
                            cell[field] = undefined;
                            cell["original" + field] = undefined
                        })
                    }
                    else
                        dataOfArguments[argument] = i
                })
            },
            _getType: function _getType(unit, type) {
                if (type === dataTypes.STRING || utils.isString(unit))
                    return dataTypes.STRING;
                if (type === dataTypes.DATETIME || utils.isDate(unit))
                    return dataTypes.DATETIME;
                if (utils.isNumber(unit))
                    return dataTypes.NUMERIC;
                return type
            },
            _correctAxisType: function _correctAxisType(type, axisType, hasCategories) {
                if (type === dataTypes.STRING && (axisType === axisTypes.CONTINUOUS || axisType === axisTypes.LOGARITHMIC))
                    this.incidentOccured("E2002");
                if (axisType === axisTypes.LOGARITHMIC)
                    return axisTypes.LOGARITHMIC;
                axisType = (hasCategories || axisType === axisTypes.DISCRETE || type === dataTypes.STRING) && axisTypes.DISCRETE;
                return axisType || axisTypes.CONTINUOUS
            },
            _filterForLogAxis: function(val, field) {
                if (val <= 0) {
                    this.incidentOccured("E2004", [field]);
                    return null
                }
                return val
            },
            _createParserUnit: function _createParserUnit(type, filter, ignoreEmptyPoints) {
                var that = this,
                    parser = type ? parseUtils.getParser(type, undefined, true) : function(unit) {
                        return unit
                    };
                return function(unit, field) {
                        var parseUnit = parser(unit);
                        if (filter)
                            parseUnit = filter.call(that, parseUnit, field);
                        parseUnit === null && ignoreEmptyPoints && (parseUnit = undefined);
                        if (parseUnit === undefined) {
                            that._addSkipFields(field);
                            that._validUnit(unit, field, type)
                        }
                        return parseUnit
                    }
            },
            _validUnit: function _validUnit(unit, field, type) {
                if (!unit)
                    return;
                if (!utils.isNumber(unit) && !utils.isDate(unit) && !utils.isString(unit)) {
                    this.incidentOccured("E2003", [field]);
                    return
                }
                this.incidentOccured("E2004", [field])
            },
            _sort: function _sort() {
                var that = this,
                    groups = that.groups,
                    hash = {},
                    argumentField = groups.length && groups[0].length && groups[0][0].getArgumentField();
                if (utils.isFunction(that.options.sortingMethod))
                    that._data.sort(that.options.sortingMethod);
                else if (that.userArgumentCategories.length) {
                    $.each(that.userArgumentCategories, function(index, value) {
                        hash[value] = index
                    });
                    that._data.sort(function sortCat(a, b) {
                        a = a[argumentField];
                        b = b[argumentField];
                        return hash[a] - hash[b]
                    })
                }
                else if (that.options.sortingMethod === true && groups.argumentType !== dataTypes.STRING)
                    mergeSort(that._data, argumentField)
            },
            _addSkipFields: function _addSkipFields(field) {
                this._skipFields[field] = (this._skipFields[field] || 0) + 1
            },
            _incorrectDataMessage: function() {
                if (this._erorrDataSource !== true) {
                    this._erorrDataSource = true;
                    this.incidentOccured("E2001")
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-core, file themeManager.js */
    (function($, DX, undefined) {
        var viz = DX.viz,
            Palette = viz.core.Palette,
            utils = DX.utils;
        var HOVER_COLOR_HIGHLIGHTING = 20,
            HIGHLIGHTING_STEP = 50;
        viz.charts.ThemeManager = viz.core.BaseThemeManager.inherit(function() {
            var ctor = function(options, themeGroupName) {
                    var that = this;
                    options = options || {};
                    that._userOptions = options;
                    that._mergeAxisTitleOptions = [];
                    themeGroupName && (that._themeSection = themeGroupName);
                    that._IE8 = DX.browser.msie && DX.browser.version < 9;
                    that.setTheme(options.theme);
                    that.palette = new Palette(options.palette, {
                        stepHighlight: HIGHLIGHTING_STEP,
                        theme: that._themeName
                    })
                };
            var dispose = function() {
                    var that = this;
                    that.palette.dispose();
                    that.palette = that._userOptions = that._mergedSettings = null;
                    that.callBase()
                };
            var initDefaultSeriesTheme = function(that) {
                    var commonSeriesSettings = that._theme.commonSeriesSettings;
                    commonSeriesSettings.point = commonSeriesSettings.point || {};
                    commonSeriesSettings.label = commonSeriesSettings.label || {};
                    that._initializeFont(commonSeriesSettings.label.font)
                };
            var initAxisTheme = function(that) {
                    var axisTheme = that._theme.commonAxisSettings;
                    if (axisTheme) {
                        axisTheme.label = axisTheme.label || {};
                        axisTheme.grid = axisTheme.grid || {};
                        axisTheme.ticks = axisTheme.ticks || {};
                        axisTheme.line = axisTheme.line || {};
                        axisTheme.title = axisTheme.title || {};
                        axisTheme.label.font = axisTheme.label.font || {};
                        that._initializeFont(axisTheme.label.font);
                        axisTheme.title.font = axisTheme.title.font || {};
                        that._initializeFont(axisTheme.title.font)
                    }
                };
            var resetPalette = function() {
                    this.palette.reset()
                };
            var updatePalette = function(palette) {
                    this.palette = new Palette(palette || this._theme.defaultPalette, {
                        stepHighlight: HIGHLIGHTING_STEP,
                        theme: this.themeName
                    })
                };
            var processTitleOptions = function(options) {
                    return utils.isString(options) ? {text: options} : options
                };
            var processAxisOptions = function(axisOptions, name) {
                    if (!axisOptions)
                        return;
                    axisOptions = $.extend(true, {}, axisOptions);
                    axisOptions.title = processTitleOptions(axisOptions.title);
                    if (axisOptions.type === 'logarithmic' && axisOptions.logarithmBase <= 0 || axisOptions.logarithmBase && !$.isNumeric(axisOptions.logarithmBase)) {
                        axisOptions.logarithmBase = undefined;
                        axisOptions.logarithmBaseError = true
                    }
                    if (axisOptions.label) {
                        if (axisOptions.label.alignment)
                            axisOptions.label['userAlignment'] = true;
                        if (utils.isString(axisOptions.label.overlappingBehavior))
                            axisOptions.label.overlappingBehavior = {mode: axisOptions.label.overlappingBehavior};
                        if (!axisOptions.label.overlappingBehavior || !axisOptions.label.overlappingBehavior.mode)
                            axisOptions.label.overlappingBehavior = axisOptions.label.overlappingBehavior || {}
                    }
                    return axisOptions
                };
            var applyParticularAxisOptions = function(name, userOptions, rotated) {
                    var theme = this._theme,
                        position = !(rotated ^ name === "valueAxis") ? "horizontalAxis" : "verticalAxis",
                        commonAxisSettings = processAxisOptions(this._userOptions["commonAxisSettings"], name);
                    return $.extend(true, {}, theme.commonAxisSettings, theme[position], theme[name], commonAxisSettings, processAxisOptions(userOptions, name))
                };
            var mergeOptions = function(name, userOptions) {
                    userOptions = userOptions || this._userOptions[name];
                    var theme = this._theme[name],
                        result = this._mergedSettings[name];
                    if (result)
                        return result;
                    if ($.isPlainObject(theme) && $.isPlainObject(userOptions))
                        result = $.extend(true, {}, theme, userOptions);
                    else
                        result = utils.isDefined(userOptions) ? userOptions : theme;
                    this._mergedSettings[name] = result;
                    return result
                };
            var applyParticularTheme = {
                    base: mergeOptions,
                    argumentAxis: applyParticularAxisOptions,
                    valueAxisRangeSelector: function() {
                        return mergeOptions.call(this, 'valueAxis')
                    },
                    valueAxis: applyParticularAxisOptions,
                    title: function(name) {
                        var userOptions = processTitleOptions(this._userOptions[name]);
                        return mergeOptions.call(this, name, userOptions)
                    },
                    series: function(name, userOptions) {
                        var theme = this._theme,
                            userCommonSettings = this._userOptions.commonSeriesSettings || {},
                            themeCommonSettings = theme.commonSeriesSettings,
                            type = ((userOptions.type || userCommonSettings.type || themeCommonSettings.type) + '').toLowerCase(),
                            settings,
                            palette = this.palette,
                            isBar = ~type.indexOf('bar'),
                            isBubble = ~type.indexOf('bubble'),
                            mainSeriesColor,
                            resolveLabelsOverlapping = this.getOptions("resolveLabelsOverlapping"),
                            resolveLabelOverlapping = this.getOptions("resolveLabelOverlapping"),
                            containerBackgroundColor = this.getOptions("containerBackgroundColor");
                        if (isBar || isBubble) {
                            userOptions = $.extend(true, {}, userCommonSettings, userCommonSettings[type], userOptions);
                            var seriesVisibility = userOptions.visible;
                            userCommonSettings = {type: {}};
                            $.extend(true, userOptions, userOptions.point);
                            userOptions.visible = seriesVisibility
                        }
                        settings = $.extend(true, {}, themeCommonSettings, themeCommonSettings[type], userCommonSettings, userCommonSettings[type], userOptions);
                        settings.type = type;
                        settings.widgetType = this._themeSection.split(".").slice(-1)[0];
                        settings.containerBackgroundColor = containerBackgroundColor;
                        if (settings.widgetType !== "pie")
                            mainSeriesColor = settings.color || palette.getNextColor();
                        else
                            mainSeriesColor = function() {
                                return palette.getNextColor()
                            };
                        settings.mainSeriesColor = mainSeriesColor;
                        settings._IE8 = this._IE8;
                        settings.resolveLabelOverlapping = resolveLabelOverlapping;
                        settings.resolveLabelsOverlapping = resolveLabelsOverlapping;
                        return settings
                    },
                    pieSegment: function(name, seriesSettings, segmentSettings) {
                        var settings = $.extend(true, {}, seriesSettings, segmentSettings);
                        var mainColor = new DX.Color(settings.color || this.palette.getNextColor());
                        settings.color = mainColor.toHex();
                        settings.border.color = settings.border.color || mainColor.toHex();
                        settings.hoverStyle.color = settings.hoverStyle.color || this._IE8 && mainColor.highlight(HOVER_COLOR_HIGHLIGHTING) || mainColor.toHex();
                        settings.hoverStyle.border.color = settings.hoverStyle.border.color || mainColor.toHex();
                        settings.selectionStyle.color = settings.selectionStyle.color || this._IE8 && mainColor.highlight(HOVER_COLOR_HIGHLIGHTING) || mainColor.toHex();
                        settings.selectionStyle.border.color = settings.selectionStyle.border.color || mainColor.toHex();
                        return settings
                    },
                    animation: function(name) {
                        var userOptions = this._userOptions[name];
                        userOptions = $.isPlainObject(userOptions) ? userOptions : utils.isDefined(userOptions) ? {enabled: !!userOptions} : {};
                        return mergeOptions.call(this, name, userOptions)
                    }
                };
            return {
                    _themeSection: 'chart',
                    ctor: ctor,
                    dispose: dispose,
                    _initializeTheme: function() {
                        var that = this,
                            theme = this._theme;
                        theme.legend = theme.legend || {};
                        theme.legend.font = theme.legend.font || {};
                        that._initializeFont(theme.legend.font);
                        initDefaultSeriesTheme(that);
                        initAxisTheme(that);
                        theme.title = theme.title || {};
                        theme.title.font = theme.title.font || {};
                        that._initializeFont(theme.title.font);
                        theme.tooltip = theme.tooltip || {};
                        theme.tooltip.font = theme.tooltip.font || {};
                        that._initializeFont(theme.tooltip.font);
                        theme.loadingIndicator = theme.loadingIndicator || {};
                        theme.loadingIndicator.font = theme.loadingIndicator.font || {};
                        that._initializeFont(theme.loadingIndicator.font);
                        theme.crosshair = theme.crosshair || {};
                        theme.crosshair.label = theme.crosshair.label || {};
                        theme.crosshair.label.font = theme.crosshair.label.font || {};
                        that._initializeFont(theme.crosshair.label.font)
                    },
                    resetPalette: resetPalette,
                    getOptions: function(name) {
                        return (applyParticularTheme[name] || applyParticularTheme["base"]).apply(this, arguments)
                    },
                    setTheme: function(theme) {
                        var that = this;
                        that._mergedSettings = {};
                        that.callBase(theme);
                        that.getOptions('rtlEnabled') && $.extend(true, that._theme, that._theme._rtl)
                    },
                    resetOptions: function(name) {
                        this._mergedSettings[name] = null
                    },
                    update: function(options) {
                        this._userOptions = options
                    },
                    updatePalette: updatePalette
                }
        }())
    })(jQuery, DevExpress);
    /*! Module viz-core, file factory.js */
    (function($, DX) {
        var viz = DX.viz,
            charts = viz.charts,
            series = charts.series;
        charts.factory = function() {
            var createSeriesFamily = function(options) {
                    return new series.SeriesFamily(options)
                };
            var createAxis = function(renderer, options) {
                    return new charts.Axis(renderer, options)
                };
            var createThemeManager = function(options, groupName) {
                    return new charts.ThemeManager(options, groupName)
                };
            var createDataValidator = function(data, groups, incidentOccured, dataPrepareOptions) {
                    return new charts.DataValidator(data, groups, incidentOccured, dataPrepareOptions)
                };
            var createTracker = function(options, name) {
                    return name == "dxPieChart" ? new charts.PieTracker(options) : new charts.ChartTracker(options)
                };
            var createTitle = function(renderer, canvas, options, group) {
                    return new charts.ChartTitle(renderer, canvas, options, group)
                };
            var createChartLayoutManager = function(options) {
                    return new charts.LayoutManager(options)
                };
            var createCrosshair = function(renderer, options, isHorizontal, canvas, axes, group) {
                    return new charts.Crosshair(renderer, options, isHorizontal, canvas, axes, group)
                };
            return {
                    createSeriesFamily: createSeriesFamily,
                    createAxis: createAxis,
                    createThemeManager: createThemeManager,
                    createDataValidator: createDataValidator,
                    createTracker: createTracker,
                    createChartLayoutManager: createChartLayoutManager,
                    createTitle: createTitle,
                    createCrosshair: createCrosshair,
                    createScrollBar: function(renderer, group) {
                        return new DevExpress.viz.charts.ScrollBar(renderer, group)
                    }
                }
        }()
    })(jQuery, DevExpress);
    /*! Module viz-core, file baseWidget.js */
    (function(DX, $, undefined) {
        var _windowResizeCallbacks = DX.utils.windowResizeCallbacks,
            _createResizeHandler = DX.utils.createResizeHandler,
            _stringFormat = DX.utils.stringFormat,
            _isFunction = DX.utils.isFunction;
        function defaultIncidentOccured(options) {
            var args = [options.id];
            args.push.apply(args, options.args || []);
            DX.log.apply(null, args)
        }
        function createEventTrigger(callback, deprectatedCallback, deprecatedContext, deprecatedArgs) {
            return function(arg, complete) {
                    setTimeout(function() {
                        callback(arg);
                        deprectatedCallback && deprectatedCallback.apply(deprecatedContext(arg), deprecatedArgs(arg));
                        complete && complete()
                    })
                }
        }
        DX.viz.core.BaseWidget = DX.DOMComponent.inherit({
            _eventsMap: {
                onIncidentOccurred: {
                    name: 'incidentOccured',
                    deprecated: 'incidentOccured',
                    deprecatedContext: $.noop,
                    deprecatedArgs: function(arg) {
                        return [arg.target]
                    }
                },
                onDrawn: {
                    name: 'drawn',
                    deprecated: 'drawn',
                    deprecatedContext: $.noop,
                    deprecatedArgs: function(arg) {
                        return [arg.component]
                    }
                },
                incidentOccured: {newName: 'onIncidentOccurred'},
                drawn: {newName: 'onDrawn'}
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    incidentOccured: {
                        since: '14.2',
                        message: "Use the 'onIncidentOccurred' option instead"
                    },
                    drawn: {
                        since: '14.2',
                        message: "Use the 'onDrawn' option instead"
                    },
                    'tooltip.customizeText': {
                        since: '14.1',
                        message: "Use the 'tooltip.customizeTooltip' option instead"
                    }
                })
            },
            _setDefaultOptions: function() {
                this.callBase.apply(this, arguments);
                this.option({incidentOccured: defaultIncidentOccured})
            },
            _init: function() {
                var that = this;
                that.callBase.apply(that, arguments);
                that._setupResizeHandler();
                that._initIncidentOccured();
                that._renderVisibilityChange();
                that._initEventTriggers();
                if (that._getLoadIndicatorOption().show)
                    that.showLoadingIndicator()
            },
            _dispose: function() {
                this._removeResizeHandler();
                this._eventTriggers = this._eventTrigger = null;
                this.callBase.apply(this, arguments)
            },
            _initEventTriggers: function() {
                var that = this;
                that._eventTriggers = {};
                $.each(that._eventsMap, function(name, info) {
                    if (info.name)
                        that._createEventTrigger(name)
                });
                that._eventTrigger = function(eventName, arg, complete) {
                    that._eventTriggers[eventName](arg, complete)
                }
            },
            _createEventTrigger: function(option) {
                var that = this,
                    eventInfo = that._eventsMap[option],
                    callback = that._createActionByOption(option),
                    deprecatedCallback;
                that._suppressDeprecatedWarnings();
                if (!DX.utils.isDefined(that.option(option)))
                    deprecatedCallback = that.option(eventInfo.deprecated);
                that._resumeDeprecatedWarnings();
                that._eventTriggers[eventInfo.name] = createEventTrigger(callback, _isFunction(deprecatedCallback) && deprecatedCallback, eventInfo.deprecatedContext, eventInfo.deprecatedArgs)
            },
            _setupResizeHandler: function() {
                var redrawOnResize = this.option('redrawOnResize');
                if (redrawOnResize === undefined || !!redrawOnResize)
                    this._addResizeHandler();
                else
                    this._removeResizeHandler()
            },
            _addResizeHandler: function() {
                var that = this;
                if (!that._resizeHandler && that._resize) {
                    that._resizeHandler = _createResizeHandler(function() {
                        that._resize()
                    });
                    _windowResizeCallbacks.add(that._resizeHandler)
                }
            },
            _removeResizeHandler: function() {
                if (this._resizeHandler) {
                    _windowResizeCallbacks.remove(this._resizeHandler);
                    this._resizeHandler.stop();
                    this._resizeHandler = null
                }
            },
            _optionChanged: function(args) {
                var that = this,
                    name = args.name,
                    eventInfo = that._eventsMap[name];
                if (eventInfo)
                    that._createEventTrigger(eventInfo.newName || name);
                else
                    switch (name) {
                        case'redrawOnResize':
                            that._setupResizeHandler();
                            break;
                        case'loadingIndicator':
                            that._updateLoadIndicator(that._getLoadIndicatorOption());
                            if (that._getLoadIndicatorOption().show) {
                                that._skipHideLoadIndicatorOnEndUpdate = true;
                                that.showLoadingIndicator()
                            }
                            break;
                        default:
                            that._invalidate()
                    }
                that.callBase(args)
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this.render()
            },
            _initIncidentOccured: function() {
                var that = this;
                that._incidentOccured = function(errorOrWarningId, options) {
                    that._eventTrigger('incidentOccured', {target: {
                            id: errorOrWarningId,
                            type: errorOrWarningId[0] === 'E' ? 'error' : 'warning',
                            args: options,
                            text: _stringFormat.apply(null, [DX.ERROR_MESSAGES[errorOrWarningId]].concat(options ? options.slice(0) : [])),
                            widget: that.NAME,
                            version: DX.VERSION
                        }})
                }
            },
            _getLoadIndicatorOption: function() {
                return this.option('loadingIndicator') || {}
            },
            _showLoadIndicator: function(options, canvas) {
                var that = this;
                that._loadIndicator = this._loadIndicator || DX.viz.core.CoreFactory.createLoadIndicator(options, that.element());
                that._loadIndicator.show(canvas.width, canvas.height);
                that._initializing && that._loadIndicator.endLoading(undefined, true)
            },
            _updateLoadIndicator: function(options, width, height) {
                this._loadIndicator && this._loadIndicator.applyOptions(options, width, height)
            },
            _endLoading: function(complete) {
                if (this._loadIndicator)
                    this._loadIndicator.endLoading(complete);
                else
                    complete && complete()
            },
            _reappendLoadIndicator: function() {
                this._loadIndicator && this._loadIndicator.toForeground()
            },
            _disposeLoadIndicator: function() {
                this._loadIndicator && this._loadIndicator.dispose();
                this._loadIndicator = null
            },
            _normalizeHtml: function(html) {
                var re = /xmlns="[\s\S]*?"/gi,
                    first = true;
                html = html.replace(re, function(match) {
                    if (!first)
                        return "";
                    first = false;
                    return match
                });
                return html.replace(/xmlns:NS1="[\s\S]*?"/gi, "").replace(/NS1:xmlns:xlink="([\s\S]*?)"/gi, 'xmlns:xlink="$1"')
            },
            _drawn: function() {
                this._eventTrigger('drawn', {})
            },
            showLoadingIndicator: function() {
                this._showLoadIndicator(this._getLoadIndicatorOption(), this.canvas || {})
            },
            hideLoadingIndicator: function() {
                if (this._loadIndicator && this._getLoadIndicatorOption().show) {
                    this.option("loadingIndicator", $.extend(true, {}, this.option("loadingIndicator"), {show: false}));
                    return
                }
                this._loadIndicator && this._loadIndicator.hide()
            },
            endUpdate: function() {
                if (this._updateLockCount === 1 && !this._requireRefresh) {
                    !this._skipHideLoadIndicatorOnEndUpdate && this.hideLoadingIndicator();
                    delete this._skipHideLoadIndicatorOnEndUpdate
                }
                this.callBase()
            },
            svg: function() {
                var renderer = this.renderer || this._renderer;
                return renderer ? this._normalizeHtml(renderer.svg()) : ''
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz-core, file CoreFactory.js */
    (function(DX, undefined) {
        var viz = DX.viz,
            core = viz.core,
            seriesNS = core.series;
        core.CoreFactory = {
            createSeries: function(renderSettings, options) {
                return new seriesNS.Series(renderSettings, options)
            },
            createPoint: function(series, data, options) {
                return new seriesNS.points.Point(series, data, options)
            },
            createLabel: function() {
                return new core.series.points.Label
            },
            createRenderer: function(options) {
                return new viz.renderers.Renderer(options)
            },
            createTranslator1D: function(fromValue, toValue, fromAngle, toAngle) {
                return (new core.Translator1D).setDomain(fromValue, toValue).setCodomain(fromAngle, toAngle)
            },
            createTranslator2D: function(range, canvas, options) {
                return new core.Translator2D(range, canvas, options)
            },
            createTickManager: function(types, data, options) {
                return new core.tickManager.TickManager(types, data, options)
            },
            createTooltip: function(options, group, renderer) {
                return new core.Tooltip(options, group, renderer)
            },
            createLoadIndicator: function(options, group) {
                return new core.LoadIndicator(options, group)
            },
            createLegend: function(data, options, renderer, group) {
                return new core.Legend(data, options, renderer, group)
            },
            createSeriesFamily: function(options) {
                return new seriesNS.helpers.SeriesFamily(options)
            }
        }
    })(DevExpress);
    DevExpress.MOD_VIZ_CORE = true
}
if (!DevExpress.MOD_VIZ_CHARTS) {
    if (!DevExpress.MOD_VIZ_CORE)
        throw Error('Required module is not referenced: viz-core');
    /*! Module viz-charts, file chartTitle.js */
    (function($, DX, undefined) {
        var viz = DX.viz,
            vizUtils = viz.core.utils,
            isDefined = DX.utils.isDefined,
            DEFAULT_MARGIN = 10;
        function parseMargins(options) {
            options.margin = isDefined(options.margin) ? options.margin : {};
            if (typeof options.margin === 'number') {
                options.margin = options.margin >= 0 ? options.margin : DEFAULT_MARGIN;
                options.margin = {
                    top: options.margin,
                    bottom: options.margin,
                    left: options.margin,
                    right: options.margin
                }
            }
            else {
                options.margin.top = options.margin.top >= 0 ? options.margin.top : DEFAULT_MARGIN;
                options.margin.bottom = options.margin.bottom >= 0 ? options.margin.bottom : DEFAULT_MARGIN;
                options.margin.left = options.margin.left >= 0 ? options.margin.left : DEFAULT_MARGIN;
                options.margin.right = options.margin.right >= 0 ? options.margin.right : DEFAULT_MARGIN
            }
        }
        function parseAlignments(options) {
            options.verticalAlignment = (options.verticalAlignment || '').toLowerCase();
            options.horizontalAlignment = (options.horizontalAlignment || '').toLowerCase();
            if (options.verticalAlignment !== 'top' && options.verticalAlignment !== 'bottom')
                options.verticalAlignment = 'top';
            if (options.horizontalAlignment !== 'left' && options.horizontalAlignment !== 'center' && options.horizontalAlignment !== 'right')
                options.horizontalAlignment = 'center'
        }
        function endsWith(value, pattern) {
            return value.substr(value.length - pattern.length) === pattern
        }
        function startsWith(value, pattern) {
            return value.indexOf(pattern) === 0
        }
        function ChartTitle() {
            this.ctor.apply(this, arguments)
        }
        viz.charts.ChartTitle = ChartTitle;
        ChartTitle.prototype = {
            ctor: function(renderer, options, width, group) {
                var that = this;
                that.update(options, width);
                that.renderer = renderer;
                that.titleGroup = group
            },
            dispose: function() {
                var that = this;
                that.renderer = null;
                that.clipRect = null;
                that.title = null;
                that.innerTitleGroup = null;
                that.titleGroup = null;
                that.options = null
            },
            update: function(options, width) {
                var that = this;
                if (options) {
                    parseAlignments(options);
                    that.horizontalAlignment = options.horizontalAlignment;
                    that.verticalAlignment = options.verticalAlignment;
                    parseMargins(options);
                    that.margin = options.margin;
                    that.options = options
                }
                that.setSize({width: width})
            },
            _setBoundingRect: function() {
                var that = this,
                    options = that.options,
                    margin = that.changedMargin || that.margin,
                    box;
                if (!that.innerTitleGroup)
                    return;
                box = that.innerTitleGroup.getBBox();
                box.height += margin.top + margin.bottom;
                box.width += margin.left + margin.right;
                box.x -= margin.left;
                box.y -= margin.top;
                if (isDefined(options.placeholderSize))
                    box.height = options.placeholderSize;
                that.boundingRect = box
            },
            draw: function() {
                var that = this,
                    titleOptions = that.options,
                    renderer = that.renderer;
                if (!titleOptions.text)
                    return;
                that.changedMargin = null;
                if (!that.innerTitleGroup) {
                    that.innerTitleGroup = renderer.g();
                    that.clipRect = that.createClipRect();
                    that.titleGroup && that.clipRect && that.titleGroup.attr({clipId: that.clipRect.id})
                }
                else
                    that.innerTitleGroup.clear();
                that.innerTitleGroup.append(that.titleGroup);
                that.title = renderer.text(titleOptions.text, 0, 0).css(vizUtils.patchFontOptions(titleOptions.font)).attr({
                    align: that.horizontalAlignment,
                    style: titleOptions.fontStyle
                }).append(that.innerTitleGroup);
                that.title.text = titleOptions.text;
                that._correctTitleLength();
                that._setClipRectSettings()
            },
            _correctTitleLength: function() {
                var that = this,
                    text = that.title.text,
                    lineLength,
                    box;
                that.title.attr({text: text});
                that._setBoundingRect();
                box = that.getLayoutOptions();
                if (that._width > box.width || text.indexOf("<br/>") !== -1)
                    return;
                lineLength = text.length * that._width / box.width;
                that.title.attr({text: text.substr(0, ~~lineLength - 1 - 3) + "..."});
                that.title.setTitle(text);
                that._setBoundingRect()
            },
            changeSize: function(size) {
                var that = this,
                    margin = $.extend(true, {}, that.margin);
                if (margin.top + margin.bottom < size.height) {
                    if (this.innerTitleGroup) {
                        that.options._incidentOccured("W2103");
                        this.innerTitleGroup.remove();
                        this.innerTitleGroup = null
                    }
                    if (that.clipRect) {
                        that.clipRect.remove();
                        that.clipRect = null
                    }
                }
                else if (size.height > 0) {
                    vizUtils.decreaseGaps(margin, ["top", "bottom"], size.height);
                    size.height && (that.changedMargin = margin)
                }
                that._correctTitleLength();
                that._setBoundingRect();
                that._setClipRectSettings()
            },
            getLayoutOptions: function() {
                var options = this.options,
                    boundingRect = this.innerTitleGroup ? this.boundingRect : {
                        width: 0,
                        height: 0,
                        x: 0,
                        y: 0
                    };
                boundingRect.verticalAlignment = options.verticalAlignment;
                boundingRect.horizontalAlignment = options.horizontalAlignment;
                boundingRect.cutLayoutSide = options.verticalAlignment;
                return boundingRect
            },
            setSize: function(size) {
                this._width = size.width || this._width
            },
            shift: function(x, y) {
                var that = this,
                    box = that.getLayoutOptions();
                x -= box.x;
                y -= box.y;
                that.innerTitleGroup && that.innerTitleGroup.move(x, y);
                that.clipRect && that.clipRect.attr({
                    translateX: x,
                    translateY: y
                })
            },
            createClipRect: function() {
                if (isDefined(this.options.placeholderSize))
                    return this.renderer.clipRect(0, 0, 0, 0)
            },
            _setClipRectSettings: function() {
                var bbox = this.getLayoutOptions(),
                    clipRect = this.clipRect;
                if (clipRect)
                    clipRect.attr({
                        x: bbox.x,
                        y: bbox.y,
                        width: bbox.width,
                        height: bbox.height
                    })
            }
        };
        DX.viz.charts.ChartTitle.__DEFAULT_MARGIN = DEFAULT_MARGIN
    })(jQuery, DevExpress);
    /*! Module viz-charts, file axis.js */
    (function($, DX, undefined) {
        var viz = DX.viz,
            core = viz.core,
            utils = DX.utils,
            _isDefined = utils.isDefined,
            _isNumber = utils.isNumber,
            _getSignificantDigitPosition = utils.getSignificantDigitPosition,
            _roundValue = utils.roundValue,
            _math = Math,
            _abs = _math.abs,
            _round = _math.round,
            _pow = _math.pow,
            _sqrt = _math.sqrt,
            _extend = $.extend,
            _each = $.each,
            _noop = $.noop,
            _map = $.map,
            PERPENDICULAR_ANGLE = 90,
            AXIS_VALUE_MARGIN_PRIORITY = 100,
            DEFAULT_AXIS_LABEL_SPACING = 5,
            MAX_GRID_BORDER_ADHENSION = 4,
            CANVAS_POSITION_PREFIX = "canvas_position_",
            CANVAS_POSITION_START = "canvas_position_start",
            CANVAS_POSITION_BOTTOM = "canvas_position_bottom",
            CANVAS_POSITION_TOP = "canvas_position_top",
            CANVAS_POSITION_END = "canvas_position_end",
            LOGARITHMIC = "logarithmic",
            DISCRETE = "discrete",
            TOP = "top",
            BOTTOM = "bottom",
            LEFT = "left",
            RIGHT = "right",
            HALF_TICK_LENGTH = 4,
            CENTER = "center",
            LABEL_BACKGROUND_PADDING_X = 8,
            LABEL_BACKGROUND_PADDING_Y = 4,
            _Axis;
        var axesMethods = {};
        function validateOverlappingMode(mode) {
            return mode !== "ignore" ? "enlargeTickInterval" : "ignore"
        }
        axesMethods.normal = {
            _createAxis: function(options) {
                return this._createPathElement(this._getAxisPoints(this._axisPosition), options)
            },
            _getAxisPoints: function(axisCoord) {
                var canvas = this._getCanvasStartEnd();
                return this._options.isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]
            },
            _getTranslatedCoord: function(value) {
                return this._translator.translate(value)
            },
            _getCanvasStartEnd: function() {
                return {
                        start: this._translator.translateSpecialCase(CANVAS_POSITION_START),
                        end: this._translator.translateSpecialCase(CANVAS_POSITION_END)
                    }
            },
            _getScreenDelta: function() {
                return _abs(this._translator.translateSpecialCase(CANVAS_POSITION_START) - this._translator.translateSpecialCase(CANVAS_POSITION_END))
            },
            _initAxisPositions: function() {
                var that = this,
                    position = that._options.position,
                    delta = 0;
                if (that.delta)
                    delta = that.delta[position] || 0;
                that._axisPosition = that._orthogonalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + position) + delta
            },
            _drawTitle: function() {
                var that = this,
                    options = that._options,
                    axisPosition = that._axisPosition,
                    titleOptions = options.title,
                    attr = {
                        opacity: titleOptions.opacity,
                        align: CENTER,
                        "class": "dx-chart-axis-title"
                    },
                    centerPosition = that._translator.translateSpecialCase(CANVAS_POSITION_PREFIX + CENTER),
                    x,
                    y;
                if (!titleOptions.text || !that._axisTitleGroup)
                    return;
                if (options.isHorizontal) {
                    x = centerPosition;
                    y = axisPosition
                }
                else {
                    attr.rotate = options.position === LEFT ? 270 : 90;
                    x = axisPosition;
                    y = centerPosition
                }
                that._title = that._renderer.text(titleOptions.text, x, y).css(core.utils.patchFontOptions(titleOptions.font)).attr(attr).append(that._axisTitleGroup)
            },
            _adjustConstantLineLabels: function() {
                var that = this,
                    options = that._options,
                    isHorizontal = options.isHorizontal,
                    lines = that._constantLines,
                    labels = that._constantLineLabels,
                    label,
                    line,
                    lineBox,
                    linesOptions,
                    labelOptions,
                    box,
                    x,
                    y,
                    i,
                    padding = isHorizontal ? {
                        top: 0,
                        bottom: 0
                    } : {
                        left: 0,
                        right: 0
                    };
                if (labels === undefined && lines === undefined)
                    return;
                for (i = 0; i < labels.length; i++) {
                    x = y = 0;
                    linesOptions = options.constantLines[i];
                    labelOptions = linesOptions.label;
                    label = labels[i];
                    if (label !== null) {
                        line = lines[i];
                        box = label.getBBox();
                        lineBox = line.getBBox();
                        if (isHorizontal)
                            if (labelOptions.position === "inside") {
                                switch (labelOptions.horizontalAlignment) {
                                    case LEFT:
                                        x -= linesOptions.paddingLeftRight;
                                        break;
                                    default:
                                        x += linesOptions.paddingLeftRight;
                                        break
                                }
                                switch (labelOptions.verticalAlignment) {
                                    case CENTER:
                                        y += lineBox.y + lineBox.height / 2 - box.y - box.height / 2;
                                        break;
                                    case BOTTOM:
                                        y -= linesOptions.paddingTopBottom;
                                        break;
                                    default:
                                        y += linesOptions.paddingTopBottom + box.height;
                                        break
                                }
                            }
                            else
                                switch (labelOptions.verticalAlignment) {
                                    case BOTTOM:
                                        y += box.height + linesOptions.paddingTopBottom - (box.y + box.height - that._orthogonalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + labelOptions.verticalAlignment));
                                        if (padding[BOTTOM] < box.height + linesOptions.paddingTopBottom)
                                            padding[BOTTOM] = box.height + linesOptions.paddingTopBottom;
                                        break;
                                    default:
                                        y -= linesOptions.paddingTopBottom;
                                        if (padding[TOP] < linesOptions.paddingTopBottom + box.height)
                                            padding[TOP] = linesOptions.paddingTopBottom + box.height;
                                        break
                                }
                        else if (labelOptions.position === "inside") {
                            switch (labelOptions.horizontalAlignment) {
                                case CENTER:
                                    x += lineBox.x + lineBox.width / 2 - box.x - box.width / 2;
                                    break;
                                case RIGHT:
                                    x -= linesOptions.paddingLeftRight;
                                    break;
                                default:
                                    x += linesOptions.paddingLeftRight;
                                    break
                            }
                            switch (labelOptions.verticalAlignment) {
                                case BOTTOM:
                                    y += lineBox.y - box.y + linesOptions.paddingTopBottom;
                                    break;
                                default:
                                    y -= linesOptions.paddingTopBottom;
                                    break
                            }
                        }
                        else {
                            y += lineBox.y + lineBox.height / 2 - box.y - box.height / 2;
                            switch (labelOptions.horizontalAlignment) {
                                case RIGHT:
                                    x += linesOptions.paddingLeftRight;
                                    if (padding[RIGHT] < linesOptions.paddingLeftRight + box.width)
                                        padding[RIGHT] = linesOptions.paddingLeftRight + box.width;
                                    break;
                                default:
                                    x -= linesOptions.paddingLeftRight;
                                    if (padding[LEFT] < linesOptions.paddingLeftRight + box.width)
                                        padding[LEFT] = linesOptions.paddingLeftRight + box.width;
                                    break
                            }
                        }
                        label.move(x, y)
                    }
                }
                that.padding = padding
            },
            _checkAlignmentConstantLineLabels: function(labelOptions) {
                var options = this._options,
                    position = labelOptions.position,
                    verticalAlignment = (labelOptions.verticalAlignment || "").toLowerCase(),
                    horizontalAlignment = (labelOptions.horizontalAlignment || "").toLowerCase();
                if (options.isHorizontal)
                    if (position === "outside") {
                        verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;
                        horizontalAlignment = CENTER
                    }
                    else {
                        verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;
                        horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT
                    }
                else if (position === "outside") {
                    verticalAlignment = CENTER;
                    horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT
                }
                else {
                    verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;
                    horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT
                }
                labelOptions.verticalAlignment = verticalAlignment;
                labelOptions.horizontalAlignment = horizontalAlignment
            },
            _getConstantLineLabelsCoords: function(value, lineLabelOptions) {
                var that = this,
                    orthogonalTranslator = that._orthogonalTranslator,
                    options = that._options,
                    align = CENTER,
                    x = value,
                    y = value;
                if (options.isHorizontal)
                    y = orthogonalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + lineLabelOptions.verticalAlignment);
                else
                    x = orthogonalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + lineLabelOptions.horizontalAlignment);
                switch (lineLabelOptions.horizontalAlignment) {
                    case LEFT:
                        align = !options.isHorizontal && lineLabelOptions.position === "inside" ? LEFT : RIGHT;
                        break;
                    case CENTER:
                        align = CENTER;
                        break;
                    case RIGHT:
                        align = !options.isHorizontal && lineLabelOptions.position === "inside" ? RIGHT : LEFT;
                        break
                }
                return {
                        x: x,
                        y: y,
                        align: align
                    }
            },
            _getAdjustedStripLabelCoords: function(stripOptions, label, rect) {
                var x = 0,
                    y = 0,
                    horizontalAlignment = stripOptions.label.horizontalAlignment,
                    verticalAlignment = stripOptions.label.verticalAlignment,
                    box = label.getBBox(),
                    rectBox = rect.getBBox();
                if (horizontalAlignment === LEFT)
                    x += stripOptions.paddingLeftRight;
                else if (horizontalAlignment === RIGHT)
                    x -= stripOptions.paddingLeftRight;
                if (verticalAlignment === TOP)
                    y += rectBox.y - box.y + stripOptions.paddingTopBottom;
                else if (verticalAlignment === CENTER)
                    y += rectBox.y + rectBox.height / 2 - box.y - box.height / 2;
                else if (verticalAlignment === BOTTOM)
                    y -= stripOptions.paddingTopBottom;
                return {
                        x: x,
                        y: y
                    }
            },
            _adjustTitle: function() {
                var that = this,
                    options = that._options,
                    position = options.position,
                    title = that._title,
                    margin = options.title.margin,
                    boxGroup,
                    boxTitle,
                    params;
                if (!title || !that._axisElementsGroup)
                    return;
                boxTitle = title.getBBox();
                boxGroup = that._axisElementsGroup.getBBox();
                if (options.isHorizontal)
                    if (position === BOTTOM)
                        params = {
                            y: boxGroup.isEmpty ? undefined : boxGroup.y + boxGroup.height,
                            translateY: margin + boxTitle.height
                        };
                    else
                        params = {
                            y: boxGroup.isEmpty ? undefined : boxGroup.y,
                            translateY: -margin
                        };
                else if (position === LEFT)
                    params = {
                        x: boxGroup.isEmpty ? undefined : boxGroup.x,
                        translateX: -margin
                    };
                else
                    params = {
                        x: boxGroup.isEmpty ? undefined : boxGroup.x + boxGroup.width,
                        translateX: margin
                    };
                title.attr(params)
            },
            coordsIn: function(x, y) {
                var rect = this.getBoundingRect();
                return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height
            },
            _getTicksOptions: function() {
                var options = this._options;
                return {
                        base: options.type === LOGARITHMIC ? options.logarithmBase : undefined,
                        tickInterval: options.stubData ? null : options.tickInterval,
                        gridSpacingFactor: options.axisDivisionFactor,
                        incidentOccured: options.incidentOccured,
                        setTicksAtUnitBeginning: options.setTicksAtUnitBeginning,
                        showMinorTicks: options.minorTick.visible || options.minorGrid.visible,
                        minorTickInterval: options.minorTickInterval,
                        minorTickCount: options.minorTickCount
                    }
            },
            _getOverlappingBehaviorOptions: function() {
                var that = this,
                    options = that._options,
                    getText = function() {
                        return ""
                    },
                    overlappingBehavior = options.label.overlappingBehavior ? $.extend({}, options.label.overlappingBehavior) : null;
                if (overlappingBehavior) {
                    if (!options.isHorizontal)
                        overlappingBehavior.mode = validateOverlappingMode(overlappingBehavior.mode);
                    if (overlappingBehavior.mode !== "rotate")
                        overlappingBehavior.rotationAngle = 0
                }
                if (!options.stubData)
                    getText = function(value, labelOptions) {
                        return formatLabel(value, labelOptions, {
                                min: options.min,
                                max: options.max
                            })
                    };
                return {
                        hasLabelFormat: that._hasLabelFormat,
                        labelOptions: options.label,
                        overlappingBehavior: overlappingBehavior,
                        isHorizontal: options.isHorizontal,
                        textOptions: that._textOptions,
                        textFontStyles: that._textFontStyles,
                        textSpacing: options.label.minSpacing,
                        getText: getText,
                        renderText: function(text, x, y, options) {
                            return that._renderer.text(text, x, y, options).append(that._renderer.root)
                        },
                        translate: function(value, useOrthogonalTranslator) {
                            return useOrthogonalTranslator ? that._orthogonalTranslator.translate(value) : that._translator.translate(value)
                        },
                        isInverted: that._translator.getBusinessRange().invert
                    }
            },
            getRangeData: function() {
                var options = this._options,
                    range = options.range;
                return this._getRange(options, range.min, range.max, options.categories, this.minRangeArg, this.maxRangeArg, !options.valueMarginsEnabled)
            },
            _getStripLabelCoords: function(stripLabelOptions, stripFrom, stripTo) {
                var that = this,
                    orthogonalTranslator = that._orthogonalTranslator,
                    options = that._options,
                    isHorizontal = options.isHorizontal,
                    align = isHorizontal ? CENTER : LEFT,
                    x,
                    y;
                if (isHorizontal) {
                    if (stripLabelOptions.horizontalAlignment === CENTER) {
                        x = stripFrom + (stripTo - stripFrom) / 2;
                        align = CENTER
                    }
                    else if (stripLabelOptions.horizontalAlignment === LEFT) {
                        x = stripFrom;
                        align = LEFT
                    }
                    else if (stripLabelOptions.horizontalAlignment === RIGHT) {
                        x = stripTo;
                        align = RIGHT
                    }
                    y = orthogonalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + stripLabelOptions.verticalAlignment)
                }
                else {
                    x = orthogonalTranslator.translateSpecialCase(CANVAS_POSITION_PREFIX + stripLabelOptions.horizontalAlignment);
                    align = stripLabelOptions.horizontalAlignment;
                    if (stripLabelOptions.verticalAlignment === TOP)
                        y = stripFrom;
                    else if (stripLabelOptions.verticalAlignment === CENTER)
                        y = stripTo + (stripFrom - stripTo) / 2;
                    else if (stripLabelOptions.verticalAlignment === BOTTOM)
                        y = stripTo
                }
                return {
                        x: x,
                        y: y,
                        align: align
                    }
            },
            _getTranslatedValue: function(value, y, offset) {
                return {
                        x: this._translator.translate(value, offset),
                        y: y
                    }
            }
        };
        axesMethods.circular = {
            _createAxis: function(options) {
                var that = this,
                    centerCoord = that._translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP),
                    r = that._translator.getValLength();
                return that._renderer.circle(centerCoord.x, centerCoord.y, r).attr(options).sharp()
            },
            _getOverlappingBehaviorType: function() {
                return "circular"
            },
            _setBoundingRect: function() {
                this.boundingRect = {
                    width: 0,
                    height: 0
                }
            },
            _getStick: function() {
                return this._options.type !== DISCRETE
            },
            _getTicksOptions: axesMethods.normal._getTicksOptions,
            _getOverlappingBehaviorOptions: function() {
                var options = axesMethods.normal._getOverlappingBehaviorOptions.call(this),
                    translator = this._translator,
                    range = translator.getBusinessRange(),
                    indentFromAxis = this._options.label.indentFromAxis || 0;
                if (options.overlappingBehavior)
                    options.overlappingBehavior = {mode: validateOverlappingMode(options.overlappingBehavior.mode)};
                options.translate = function(value) {
                    return translator.translate(value, CANVAS_POSITION_BOTTOM)
                };
                options.isInverted = translator.getBusinessRange().arg.invert;
                options.circularRadius = translator.translate(CANVAS_POSITION_TOP, CANVAS_POSITION_BOTTOM).radius + indentFromAxis;
                options.circularStartAngle = options.circularEndAngle = translator.getStartAngle();
                options.isHorizontal = false;
                return options
            },
            getRangeData: function(min) {
                var options = this._options,
                    period = utils.isNumber(options.period) ? options.period + (min || 0) : undefined;
                return this._getRange(options, undefined, period, options.categories, this.minRangeArg, this.maxRangeArg, this._getStick())
            },
            measureLabels: function() {
                var that = this,
                    indentFromAxis = that._options.label.indentFromAxis || 0,
                    maxLabelParams;
                if (!that._axisElementsGroup || !that._options.label.visible)
                    return {
                            height: 0,
                            width: 0
                        };
                that._updateTickManager();
                maxLabelParams = that._tickManager.getMaxLabelParams();
                return {
                        height: maxLabelParams.height + indentFromAxis + HALF_TICK_LENGTH,
                        width: maxLabelParams.width + indentFromAxis + HALF_TICK_LENGTH
                    }
            },
            _getTranslatedCoord: function(value) {
                var options = this._options,
                    offset = options.discreteAxisDivisionMode !== "crossLabels" || !options.discreteAxisDivisionMode;
                return this._translator.translate(value, -offset).angle
            },
            _getCanvasStartEnd: function() {
                return {
                        start: this._translator.translate(CANVAS_POSITION_START).angle,
                        end: this._translator.translate(CANVAS_POSITION_END).angle
                    }
            },
            _createStrip: function(fromAngle, toAngle, attr) {
                var center = this._translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP),
                    r = this._translator.getValLength();
                return this._renderer.arc(center.x, center.y, 0, r, -toAngle, -fromAngle).attr(attr)
            },
            _getStripLabelCoords: function(stripLabelOptions, stripFrom, stripTo) {
                var that = this,
                    translator = that._translator,
                    angle = stripFrom + (stripTo - stripFrom) / 2,
                    cossin = utils.getCosAndSin(-angle),
                    halfRad = translator.getValLength() / 2,
                    center = translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP),
                    x = _round(center.x + halfRad * cossin.cos),
                    y = _round(center.y - halfRad * cossin.sin);
                return {
                        x: x,
                        y: y,
                        align: CENTER
                    }
            },
            _createConstantLine: function(value, attr) {
                var center = this._translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP),
                    r = this._translator.getValLength();
                return this._createPathElement([center.x, center.y, center.x + r, center.y], attr).rotate(value, center.x, center.y)
            },
            _getConstantLineLabelsCoords: function(value) {
                var that = this,
                    translator = that._translator,
                    cossin = utils.getCosAndSin(-value),
                    halfRad = translator.getValLength() / 2,
                    center = translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP),
                    x = _round(center.x + halfRad * cossin.cos),
                    y = _round(center.y - halfRad * cossin.sin);
                return {
                        x: x,
                        y: y,
                        align: CENTER
                    }
            },
            _checkAlignmentConstantLineLabels: _noop,
            _getScreenDelta: function() {
                return 2 * Math.PI * this._translator.getValLength()
            },
            _getTickCoord: function(tick) {
                var center = this._translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP),
                    r = this._translator.getValLength();
                return {
                        x1: center.x + r - HALF_TICK_LENGTH,
                        y1: center.y,
                        x2: center.x + r + HALF_TICK_LENGTH,
                        y2: center.y,
                        angle: tick.angle
                    }
            },
            _getLabelAdjustedCoord: function(tick) {
                var that = this,
                    pos = tick.labelPos,
                    cossin = utils.getCosAndSin(pos.angle),
                    indentFromAxis = that._options.label.indentFromAxis || 0,
                    box = tick.label.getBBox(),
                    x,
                    y;
                x = pos.x + (indentFromAxis + box.width / 2) * cossin.cos;
                y = pos.y + (pos.y - box.y - box.height / 2) + indentFromAxis * cossin.sin;
                return {
                        x: x,
                        y: y
                    }
            },
            _getGridLineDrawer: function() {
                var that = this,
                    translator = that._translator,
                    r = translator.getValLength(),
                    center = translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP);
                return function(tick) {
                        return that._createPathElement([center.x, center.y, center.x + r, center.y], tick.gridStyle).rotate(tick.angle, center.x, center.y)
                    }
            },
            _getTranslatedValue: function(value, _, offset) {
                return this._translator.translate(value, CANVAS_POSITION_BOTTOM, -offset)
            },
            _getAdjustedStripLabelCoords: function(stripOptions, label) {
                var x,
                    y,
                    box = label.getBBox();
                y = label.attr("y") - box.y - box.height / 2;
                return {
                        x: 0,
                        y: y
                    }
            },
            coordsIn: function(x, y) {
                if (this._translator.untranslate(x, y).r > this._translator.getValLength())
                    return true
            },
            _rotateTick: function(tick, angle) {
                var center = this._translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP);
                tick.graphic.rotate(angle, center.x, center.y)
            }
        };
        axesMethods.linear = {
            _createAxis: function(options) {
                var that = this,
                    centerCoord = that._translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP),
                    r = that._translator.getValLength();
                return that._createPathElement([centerCoord.x, centerCoord.y, centerCoord.x + r, centerCoord.y], options).rotate(centerCoord.angle, centerCoord.x, centerCoord.y)
            },
            _getOverlappingBehaviorType: function() {
                return "linear"
            },
            _getStick: function() {
                return !this._options.valueMarginsEnabled
            },
            getRangeData: axesMethods.circular.getRangeData,
            _setBoundingRect: axesMethods.circular._setBoundingRect,
            _getScreenDelta: function() {
                return this._translator.getValLength()
            },
            _getTickCoord: function(tick) {
                return {
                        x1: tick.posX - HALF_TICK_LENGTH,
                        y1: tick.posY,
                        x2: tick.posX + HALF_TICK_LENGTH,
                        y2: tick.posY,
                        angle: tick.angle + PERPENDICULAR_ANGLE
                    }
            },
            _getTicksOptions: axesMethods.normal._getTicksOptions,
            _getOverlappingBehaviorOptions: function() {
                var translator = this._translator,
                    options = axesMethods.normal._getOverlappingBehaviorOptions.call(this),
                    startAngle = utils.normalizeAngle(translator.getStartAngle());
                if (options.overlappingBehavior)
                    options.overlappingBehavior = {mode: validateOverlappingMode(options.overlappingBehavior.mode)};
                options.isHorizontal = startAngle > 45 && startAngle < 135 || startAngle > 225 && startAngle < 315 ? true : false;
                options.isInverted = translator.getBusinessRange().val.invert;
                options.translate = function(value) {
                    return translator.translate(CANVAS_POSITION_TOP, value).x
                };
                return options
            },
            _getLabelAdjustedCoord: function(tick) {
                var that = this,
                    pos = tick.labelPos,
                    cossin = utils.getCosAndSin(pos.angle),
                    indentFromAxis = that._options.label.indentFromAxis || 0,
                    box = tick.label.getBBox(),
                    x,
                    y;
                x = pos.x - _abs(indentFromAxis * cossin.sin) + _abs(box.width / 2 * cossin.cos);
                y = pos.y + (pos.y - box.y) - _abs(box.height / 2 * cossin.sin) + _abs(indentFromAxis * cossin.cos);
                return {
                        x: x,
                        y: y
                    }
            },
            _getGridLineDrawer: function() {
                var that = this,
                    translator = that._translator,
                    pos = translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP);
                return function(tick) {
                        return that._renderer.circle(pos.x, pos.y, utils.getDistance(pos.x, pos.y, tick.posX, tick.posY)).attr(tick.gridStyle).sharp()
                    }
            },
            _getTranslatedValue: function(value, _, offset) {
                return this._translator.translate(CANVAS_POSITION_START, value, undefined, offset)
            },
            _getTranslatedCoord: function(value) {
                return this._translator.translate(CANVAS_POSITION_START, value).radius
            },
            _getCanvasStartEnd: function() {
                return {
                        start: this._translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_START).radius,
                        end: this._translator.translate(CANVAS_POSITION_TOP, CANVAS_POSITION_END).radius
                    }
            },
            _createStrip: function(fromPoint, toPoint, attr) {
                var center = this._translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP);
                return this._renderer.arc(center.x, center.y, fromPoint, toPoint, 0, 360).attr(attr)
            },
            _getAdjustedStripLabelCoords: axesMethods.circular._getAdjustedStripLabelCoords,
            _getStripLabelCoords: function(stripLabelOptions, stripFrom, stripTo) {
                var that = this,
                    translator = that._translator,
                    labelPos = stripFrom + (stripTo - stripFrom) / 2,
                    center = translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP),
                    y = _round(center.y - labelPos);
                return {
                        x: center.x,
                        y: y,
                        align: CENTER
                    }
            },
            _createConstantLine: function(value, attr) {
                var center = this._translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP);
                return this._renderer.circle(center.x, center.y, value).attr(attr).sharp()
            },
            _getConstantLineLabelsCoords: function(value) {
                var that = this,
                    translator = that._translator,
                    center = translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP),
                    y = _round(center.y - value);
                return {
                        x: center.x,
                        y: y,
                        align: CENTER
                    }
            },
            _checkAlignmentConstantLineLabels: _noop,
            _rotateTick: function(tick, angle) {
                tick.graphic.rotate(angle, tick.posX, tick.posY)
            }
        };
        axesMethods.circularSpider = $.extend({}, axesMethods.circular, {
            _createAxis: function(options) {
                var that = this,
                    points = $.map(that.getSpiderTicks(), function(tick) {
                        return {
                                x: tick.posX,
                                y: tick.posY
                            }
                    });
                return that._createPathElement(points, options)
            },
            getSpiderTicks: function(stick) {
                var that = this,
                    rangeStick = stick || that._range.stick;
                that._spiderTicks = that._convertValuesToTicks(that._tickManager.getFullTicks());
                that._initTicks(that._spiderTicks, {}, {});
                if (!rangeStick)
                    that._spiderTicks.push(that._spiderTicks[0]);
                return that._spiderTicks
            },
            _createStrip: function(fromAngle, toAngle, attr) {
                var center = this._translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP),
                    points = $.map(this.getSpiderTicks(true), function(tick) {
                        if (_isDefined(tick.angle) && tick.angle >= fromAngle && tick.angle <= toAngle)
                            return {
                                    x: tick.posX,
                                    y: tick.posY
                                };
                        else
                            return null
                    });
                points.push({
                    x: center.x,
                    y: center.y
                });
                return this._renderer.path(points, "area").attr(attr)
            },
            _getTranslatedCoord: function(value) {
                return this._translator.translate(value, false).angle
            },
            _getTickOffset: function() {
                return false
            }
        });
        axesMethods.linearSpider = $.extend({}, axesMethods.linear, {
            setSpiderTicks: function(ticks) {
                this._spiderTicks = ticks
            },
            _getGridLineDrawer: function() {
                var that = this,
                    translator = that._translator,
                    pos = translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP);
                return function(tick) {
                        var radius = utils.getDistance(pos.x, pos.y, tick.posX, tick.posY);
                        return that._createPathElement(that._getGridPoints(pos, radius), tick.gridStyle)
                    }
            },
            _getGridPoints: function(pos, radius) {
                return $.map(this._spiderTicks, function(tick) {
                        var cossin = utils.getCosAndSin(tick.angle);
                        return {
                                x: _round(pos.x + radius * cossin.cos),
                                y: _round(pos.y + radius * cossin.sin)
                            }
                    })
            },
            _createStrip: function(fromPoint, toPoint, attr) {
                var center = this._translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP),
                    innerPoints = this._getGridPoints(center, toPoint),
                    outerPoints = this._getGridPoints(center, fromPoint);
                return this._renderer.path(outerPoints.concat(innerPoints.reverse()), "area").attr(attr)
            },
            _createConstantLine: function(value, attr) {
                var center = this._translator.translate(CANVAS_POSITION_START, CANVAS_POSITION_TOP),
                    points = this._getGridPoints(center, value);
                return this._createPathElement(points, attr)
            }
        });
        var _validateAxisOptions = function(options) {
                var labelOptions = options.label,
                    position = options.position,
                    defaultPosition = options.isHorizontal ? BOTTOM : LEFT,
                    secondaryPosition = options.isHorizontal ? TOP : RIGHT;
                if (position !== defaultPosition && position !== secondaryPosition)
                    position = defaultPosition;
                if (position === RIGHT && !labelOptions.userAlignment)
                    labelOptions.alignment = LEFT;
                options.position = position;
                options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : "none";
                labelOptions.minSpacing = _isDefined(labelOptions.minSpacing) ? labelOptions.minSpacing : DEFAULT_AXIS_LABEL_SPACING
            };
        var getFormatObject = function(value, options, axisMinMax) {
                var formatObject = {
                        value: value,
                        valueText: DX.formatHelper.format(value, options.format, options.precision) || ""
                    };
                if (axisMinMax) {
                    formatObject.min = axisMinMax.min;
                    formatObject.max = axisMinMax.max
                }
                return formatObject
            };
        var formatLabel = function(value, options, axisMinMax) {
                var formatObject = getFormatObject(value, options, axisMinMax);
                return $.isFunction(options.customizeText) ? options.customizeText.call(formatObject, formatObject) : formatObject.valueText
            };
        var formatHint = function(value, options, axisMinMax) {
                var formatObject = getFormatObject(value, options, axisMinMax);
                return $.isFunction(options.customizeHint) ? options.customizeHint.call(formatObject, formatObject) : undefined
            };
        _Axis = DX.viz.charts.Axis = function(renderer, options) {
            var debug = DX.utils.debug;
            debug.assertParam(renderer, "renderer was not passed");
            debug.assertParam(options.label, "label was not passed");
            debug.assertParam(options.tick, "tick was not passed");
            debug.assertParam(options.grid, "grid was not passed");
            debug.assertParam(options.title, "title was not passed");
            debug.assert(options.axisDivisionFactor, "axisDivisionFactor was not passed");
            debug.assert(options.stripStyle, "stripStyle was not passed");
            debug.assert(options.constantLineStyle, "constantLineStyle was not passed");
            debug.assert(options.position, "position was not passed");
            debug.assertParam(options.isHorizontal, "isHorizontal was not passed");
            this._renderer = renderer;
            this._init(options)
        };
        _Axis.prototype = {
            constructor: _Axis,
            dispose: function() {
                var that = this;
                that._axisElementsGroup && that._axisElementsGroup.dispose();
                that._deleteLabelsData();
                that._stripLabels = that._strips = null;
                that._title = null;
                that._axisStripGroup = that._axisConstantLineGroup = that._axisLabelGroup = null;
                that._axisLineGroup = that._axisElementsGroup = that._axisGridGroup = null;
                that._axisGroup = that._axisTitleGroup = null;
                that._axesContainerGroup = that._stripsGroup = that._constantLinesGroup = null;
                that._renderer = that._options = that._textOptions = that._textFontStyles = null;
                that._range = that._translator = that._orthogonalTranslator = null;
                that._majorTicks = that._minorTicks = null;
                that._tickManager = null
            },
            getOptions: function() {
                return this._options
            },
            setPane: function(pane) {
                this.pane = pane;
                this._options.pane = pane
            },
            setTypes: function(type, axisType, typeSelector) {
                this._options.type = type || this._options.type;
                this._options[typeSelector] = axisType || this._options[typeSelector]
            },
            getTranslator: function() {
                return this._translator
            },
            _init: function(options) {
                var that = this,
                    opt,
                    labelOpt = options.label;
                that._options = opt = options;
                _validateAxisOptions(opt);
                that._setType(options.drawingType);
                opt.range = {
                    min: opt.min,
                    max: opt.max
                };
                that.pane = opt.pane;
                that.name = opt.name;
                that.priority = opt.priority;
                that._virtual = opt.virtual;
                that._stripsGroup = opt.stripsGroup;
                that._labelAxesGroup = opt.labelAxesGroup;
                that._constantLinesGroup = opt.constantLinesGroup;
                that._axesContainerGroup = opt.axesContainerGroup;
                that._createAxisGroups();
                that._hasLabelFormat = labelOpt.format !== "" && _isDefined(labelOpt.format);
                that._textOptions = {
                    align: labelOpt.alignment,
                    opacity: labelOpt.opacity
                };
                that._textFontStyles = core.utils.patchFontOptions(labelOpt.font);
                that._tickManager = that._createTickManager();
                if (opt.type === LOGARITHMIC) {
                    if (opt.logarithmBaseError) {
                        opt.incidentOccured("E2104");
                        delete opt.logarithmBaseError
                    }
                    that.calcInterval = function(value, prevValue) {
                        return utils.getLog(value / prevValue, options.logarithmBase)
                    }
                }
            },
            updateSize: function(clearAxis) {
                var that = this,
                    options = that._options,
                    direction = options.isHorizontal ? "horizontal" : "vertical";
                if (options.title.text && that._axisTitleGroup) {
                    options.incidentOccured("W2105", [direction]);
                    that._axisTitleGroup.remove();
                    that._axisTitleGroup = null
                }
                if (clearAxis && that._axisElementsGroup && options.label.visible && !options.stubData) {
                    options.incidentOccured("W2106", [direction]);
                    that._axisElementsGroup.remove();
                    that._axisElementsGroup = null
                }
                that._setBoundingRect()
            },
            _updateTranslatorInterval: function() {
                var that = this,
                    i,
                    majorTicks,
                    majorTicksLength,
                    translator = that._translator,
                    businessRange = that._range,
                    tickBounds;
                if (!businessRange.categories && !businessRange.isSynchronized) {
                    that.getMajorTicks(true);
                    businessRange.addRange(that._tickManager.getTickBounds());
                    translator.reinit()
                }
                that._majorTicks = majorTicks = that.getMajorTicks();
                if (!businessRange.categories) {
                    majorTicksLength = majorTicks.length;
                    for (i = 0; i < majorTicksLength - 1; i++)
                        businessRange.addRange({interval: _abs(majorTicks[i].value - majorTicks[i + 1].value)})
                }
                that._decimatedTicks = that._range.categories ? that.getDecimatedTicks() : [];
                that._minorTicks = that.getMinorTicks()
            },
            setTranslator: function(translator, orthogonalTranslator) {
                var debug = DX.utils.debug;
                debug.assertParam(translator, "translator was not passed");
                this._translator = translator;
                this._orthogonalTranslator = _isDefined(orthogonalTranslator) ? orthogonalTranslator : undefined;
                this.resetTicks();
                this._updateTranslatorInterval()
            },
            resetTicks: function() {
                this._deleteLabelsData();
                this._majorTicks = this._minorTicks = null
            },
            setRange: function(range) {
                var debug = DX.utils.debug;
                debug.assertParam(range, "range was not passed");
                var options = this._options;
                options.min = range.minVisible;
                options.max = range.maxVisible;
                options.stubData = range.stubData;
                this._range = range;
                this._tickManager && this._tickManager.updateMinMax({
                    min: options.min,
                    max: options.max
                });
                this.resetTicks()
            },
            getCurrentLabelPos: function() {
                var that = this,
                    options = that._options,
                    position = options.position,
                    labelOffset = options.label.indentFromAxis,
                    axisPosition = that._axisPosition;
                return position === TOP || position === LEFT ? axisPosition - labelOffset : axisPosition + labelOffset
            },
            getUntranslatedValue: function(pos) {
                var that = this,
                    translator = that._translator,
                    value = translator.untranslate(pos);
                if (_isDefined(value))
                    return formatLabel(_isNumber(value) ? _roundValue(value, _getSignificantDigitPosition(that._range.interval)) : value, that._options.label);
                return null
            },
            _drawAxis: function() {
                var that = this,
                    options = that._options,
                    axis = that._createAxis({
                        "stroke-width": options.width,
                        stroke: options.color,
                        "stroke-opacity": options.opacity
                    });
                axis.append(that._axisLineGroup)
            },
            _correctMinForTicks: function(min, max, screenDelta) {
                var digitPosition = _getSignificantDigitPosition(_abs(max - min) / screenDelta),
                    newMin = _roundValue(Number(min), digitPosition),
                    correctingValue;
                if (newMin < min) {
                    correctingValue = _math.pow(10, -digitPosition);
                    newMin = utils.applyPrecisionByMinDelta(newMin, correctingValue, newMin + correctingValue)
                }
                if (newMin > max)
                    newMin = min;
                return newMin
            },
            _getTickManagerData: function() {
                var that = this,
                    options = that._options,
                    screenDelta = that._getScreenDelta(),
                    min = options.min,
                    max = options.max,
                    categories = that._translator.getVisibleCategories() || that._range.categories,
                    customTicks = $.isArray(categories) ? categories : that._majorTicks && that._convertTicksToValues(that._majorTicks),
                    customMinorTicks = that._minorTicks && that._convertTicksToValues(that._minorTicks);
                if (_isNumber(min) && options.type !== LOGARITHMIC)
                    min = that._correctMinForTicks(min, max, screenDelta);
                return {
                        min: min,
                        max: max,
                        customTicks: customTicks,
                        customMinorTicks: customMinorTicks,
                        screenDelta: screenDelta
                    }
            },
            _getTickManagerTypes: function() {
                return {
                        axisType: this._options.type,
                        dataType: this._options.dataType
                    }
            },
            _getOverlappingBehaviorType: function() {
                return "linear"
            },
            _createTickManager: function() {
                return DX.viz.core.CoreFactory.createTickManager({}, {}, {overlappingBehaviorType: this._getOverlappingBehaviorType()})
            },
            _getMarginsOptions: function() {
                var range = this._range;
                return {
                        stick: range.stick,
                        minStickValue: range.minStickValue,
                        maxStickValue: range.maxStickValue,
                        percentStick: range.percentStick,
                        minValueMargin: this._options.minValueMargin,
                        maxValueMargin: this._options.maxValueMargin,
                        minSpaceCorrection: range.minSpaceCorrection,
                        maxSpaceCorrection: range.maxSpaceCorrection
                    }
            },
            _updateTickManager: function() {
                var overlappingOptions = this._getOverlappingBehaviorOptions(),
                    options;
                options = _extend(true, {}, this._getMarginsOptions(), overlappingOptions, this._getTicksOptions());
                this._tickManager.update(this._getTickManagerTypes(), this._getTickManagerData(), options)
            },
            _correctLabelAlignment: function() {
                var that = this,
                    labelOptions = that._options.label,
                    overlappingBehavior = that._tickManager.getOverlappingBehavior();
                if (overlappingBehavior && overlappingBehavior.mode === "rotate") {
                    that._textOptions.rotate = overlappingBehavior.rotationAngle;
                    if (!labelOptions.userAlignment)
                        that._textOptions.align = LEFT
                }
                else if (!labelOptions.userAlignment)
                    that._textOptions.align = labelOptions.alignment
            },
            _correctLabelFormat: function() {
                this._options.label = this._tickManager.getOptions().labelOptions
            },
            _convertTicksToValues: function(ticks) {
                return _map(ticks || [], function(item) {
                        return item.value
                    })
            },
            _convertValuesToTicks: function(values) {
                return _map(values || [], function(item) {
                        return {value: item}
                    })
            },
            getTicksValues: function() {
                return {
                        majorTicksValues: this._convertTicksToValues(this._majorTicks || this.getMajorTicks()),
                        minorTicksValues: this._convertTicksToValues(this._minorTicks || this.getMinorTicks())
                    }
            },
            getMajorTicks: function(withoutOverlappingBehavior) {
                var that = this,
                    majorTicks;
                that._updateTickManager();
                that._textOptions.rotate = 0;
                majorTicks = that._convertValuesToTicks(that._tickManager.getTicks(withoutOverlappingBehavior));
                that._correctLabelAlignment();
                that._correctLabelFormat();
                that._testTKScreenDelta = that._screenDelta;
                that._useTicksAutoArrangement = that._options.useTicksAutoArrangement;
                if (that._options.stubData)
                    that._testSkippedFormattingAndOverlapping = true;
                return majorTicks
            },
            getMinorTicks: function() {
                return this._convertValuesToTicks(this._tickManager.getMinorTicks())
            },
            getDecimatedTicks: function() {
                return this._convertValuesToTicks(this._tickManager.getDecimatedTicks())
            },
            setTicks: function(ticks) {
                this.resetTicks();
                this._majorTicks = this._convertValuesToTicks(ticks.majorTicks);
                this._minorTicks = this._convertValuesToTicks(ticks.minorTicks)
            },
            _deleteLabelsData: function() {
                _each(this._majorTicks || [], function(_, item) {
                    item.label && $(item.label.element).removeData()
                })
            },
            _drawTicks: function(ticks) {
                var that = this,
                    renderer = that._renderer,
                    group = that._axisLineGroup;
                _each(ticks || [], function(_, tick) {
                    var coord = that._getTickCoord(tick),
                        points;
                    if (coord) {
                        points = that._options.isHorizontal ? [coord.x1, coord.y1, coord.x2, coord.y2] : [coord.y1, coord.x1, coord.y2, coord.x2];
                        tick.graphic = that._createPathElement(points, tick.tickStyle).append(group);
                        coord.angle && that._rotateTick(tick, coord.angle)
                    }
                })
            },
            _createPathElement: function(points, attr) {
                return this._renderer.path(points, "line").attr(attr).sharp()
            },
            _getTickCoord: function(tick) {
                if (_isDefined(tick.posX) && _isDefined(tick.posY))
                    return {
                            x1: tick.posX,
                            y1: tick.posY - HALF_TICK_LENGTH,
                            x2: tick.posX,
                            y2: tick.posY + HALF_TICK_LENGTH
                        };
                else
                    return null
            },
            setPercentLabelFormat: function() {
                if (!this._hasLabelFormat)
                    this._options.label.format = "percent"
            },
            resetAutoLabelFormat: function() {
                if (!this._hasLabelFormat)
                    delete this._options.label.format
            },
            _drawLabels: function() {
                var that = this,
                    renderer = that._renderer,
                    group = that._axisElementsGroup,
                    options = that._options,
                    emptyStrRegExp = /^\s+$/;
                _each(that._majorTicks, function(_, tick) {
                    var text = tick.labelText,
                        xCoord,
                        yCoord;
                    if (_isDefined(text) && text !== "" && !emptyStrRegExp.test(text)) {
                        xCoord = options.isHorizontal ? tick.labelPos.x : tick.labelPos.y;
                        yCoord = options.isHorizontal ? tick.labelPos.y : tick.labelPos.x;
                        if (!tick.label)
                            tick.label = renderer.text(text, xCoord, yCoord).css(tick.labelFontStyle).attr(tick.labelStyle).append(group);
                        else
                            tick.label.css(tick.labelFontStyle).attr(tick.labelStyle).attr({
                                text: text,
                                x: xCoord,
                                y: yCoord
                            });
                        $(tick.label.element).data({argument: tick.value})
                    }
                })
            },
            getMultipleAxesSpacing: function() {
                return this._options.multipleAxesSpacing || 0
            },
            _drawTitle: _noop,
            _getGridLineDrawer: function(borderOptions) {
                var that = this,
                    translator = that._translator,
                    options = that._options,
                    orthogonalTranslator = that._orthogonalTranslator,
                    isHorizontal = options.isHorizontal,
                    canvasStart = isHorizontal ? LEFT : TOP,
                    canvasEnd = isHorizontal ? RIGHT : BOTTOM,
                    positionFrom = orthogonalTranslator.translateSpecialCase(CANVAS_POSITION_START),
                    positionTo = orthogonalTranslator.translateSpecialCase(CANVAS_POSITION_END),
                    firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? translator.translateSpecialCase(CANVAS_POSITION_PREFIX + canvasStart) : undefined,
                    lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? translator.translateSpecialCase(CANVAS_POSITION_PREFIX + canvasEnd) : undefined,
                    getPoints = isHorizontal ? function(tick) {
                        return tick.posX ? [tick.posX, positionFrom, tick.posX, positionTo] : null
                    } : function(tick) {
                        return tick.posX ? [positionFrom, tick.posX, positionTo, tick.posX] : null
                    };
                return function(tick) {
                        var points;
                        if (_abs(tick.posX - firstBorderLinePosition) < MAX_GRID_BORDER_ADHENSION || _abs(tick.posX - lastBorderLinePosition) < MAX_GRID_BORDER_ADHENSION)
                            return;
                        points = getPoints(tick);
                        return points && that._createPathElement(points, tick.gridStyle)
                    }
            },
            _drawGrids: function(ticks, borderOptions) {
                var that = this,
                    group = that._axisGridGroup,
                    drawLine = that._getGridLineDrawer(borderOptions || {visible: false});
                _each(ticks || [], function(_, tick) {
                    tick.grid = drawLine(tick);
                    tick.grid && tick.grid.append(group)
                })
            },
            _getConstantLinePos: function(lineValue, canvasStart, canvasEnd, range) {
                var parsedValue = this._validateUnit(lineValue, "E2105", "constantLine"),
                    value = this._getTranslatedCoord(parsedValue),
                    isContinous = !!(range.minVisible || range.maxVisible);
                if (!isContinous && $.inArray(lineValue, range.categories || []) === -1 || !_isDefined(value) || value < _math.min(canvasStart, canvasEnd) || value > _math.max(canvasStart, canvasEnd))
                    return {};
                return {
                        value: value,
                        parsedValue: parsedValue
                    }
            },
            _createConstantLine: function(value, attr) {
                var that = this,
                    orthogonalTranslator = this._orthogonalTranslator,
                    positionFrom = orthogonalTranslator.translateSpecialCase(CANVAS_POSITION_START),
                    positionTo = orthogonalTranslator.translateSpecialCase(CANVAS_POSITION_END),
                    points = this._options.isHorizontal ? [value, positionTo, value, positionFrom] : [positionFrom, value, positionTo, value];
                return that._createPathElement(points, attr)
            },
            _drawConstantLinesAndLabels: function(lineOptions, canvasStart, canvasEnd, range) {
                if (!_isDefined(lineOptions.value))
                    return;
                var pos = this._getConstantLinePos(lineOptions.value, canvasStart, canvasEnd, range),
                    labelOptions = lineOptions.label || {},
                    value = pos.value,
                    attr = {
                        stroke: lineOptions.color,
                        "stroke-width": lineOptions.width,
                        dashStyle: lineOptions.dashStyle
                    };
                if (!_isDefined(value)) {
                    this._constantLines.push(null);
                    if (labelOptions.visible)
                        this._constantLineLabels.push(null);
                    return
                }
                this._constantLines.push(this._createConstantLine(value, attr).append(this._axisConstantLineGroup));
                this._constantLineLabels.push(labelOptions.visible ? this._drawConstantLineLabels(pos.parsedValue, labelOptions, value) : null)
            },
            _drawConstantLine: function() {
                var that = this,
                    options = that._options,
                    data = options.constantLines,
                    canvas = that._getCanvasStartEnd();
                if (options.stubData)
                    return;
                that._constantLines = [];
                that._constantLineLabels = [];
                _each(data, function(_, dataItem) {
                    that._drawConstantLinesAndLabels(dataItem, canvas.start, canvas.end, that._range)
                })
            },
            _drawConstantLineLabels: function(parsedValue, lineLabelOptions, value) {
                var that = this,
                    text = lineLabelOptions.text,
                    options = that._options,
                    labelOptions = options.label,
                    coords;
                that._checkAlignmentConstantLineLabels(lineLabelOptions);
                text = _isDefined(text) ? text : formatLabel(parsedValue, labelOptions);
                coords = that._getConstantLineLabelsCoords(value, lineLabelOptions);
                return that._renderer.text(text, coords.x, coords.y).css(core.utils.patchFontOptions($.extend({}, labelOptions.font, lineLabelOptions.font))).attr({align: coords.align}).append(that._axisConstantLineGroup)
            },
            _adjustConstantLineLabels: _noop,
            _getStripPos: function(startValue, endValue, canvasStart, canvasEnd, range) {
                var isContinous = !!(range.minVisible || range.maxVisible),
                    categories = range.categories || [],
                    start = this._getTranslatedCoord(this._validateUnit(startValue, "E2105", "strip")),
                    end = this._getTranslatedCoord(this._validateUnit(endValue, "E2105", "strip")),
                    min = range.minVisible;
                if (!isContinous && ($.inArray(startValue, categories) === -1 || $.inArray(endValue, categories) === -1))
                    return {
                            stripFrom: 0,
                            stripTo: 0
                        };
                if (!_isDefined(start) && isContinous)
                    start = startValue < min ? canvasStart : canvasEnd;
                if (!_isDefined(end) && isContinous)
                    end = endValue < min ? canvasStart : canvasEnd;
                return start < end ? {
                        stripFrom: start,
                        stripTo: end
                    } : {
                        stripFrom: end,
                        stripTo: start
                    }
            },
            _createStrip: function(fromPoint, toPoint, attr) {
                var x,
                    y,
                    width,
                    height,
                    orthogonalTranslator = this._orthogonalTranslator,
                    positionFrom = orthogonalTranslator.translateSpecialCase(CANVAS_POSITION_START),
                    positionTo = orthogonalTranslator.translateSpecialCase(CANVAS_POSITION_END);
                if (this._options.isHorizontal) {
                    x = fromPoint;
                    y = _math.min(positionFrom, positionTo);
                    width = toPoint - fromPoint;
                    height = _abs(positionFrom - positionTo)
                }
                else {
                    x = _math.min(positionFrom, positionTo);
                    y = fromPoint;
                    width = _abs(positionFrom - positionTo);
                    height = _abs(fromPoint - toPoint)
                }
                return this._renderer.rect(x, y, width, height).attr(attr)
            },
            _drawStrip: function() {
                var that = this,
                    options = that._options,
                    stripData = options.strips,
                    canvas = this._getCanvasStartEnd(),
                    i,
                    stripOptions,
                    stripPos,
                    stripLabelOptions,
                    attr;
                if (options.stubData)
                    return;
                that._strips = [];
                that._stripLabels = [];
                for (i = 0; i < stripData.length; i++) {
                    stripOptions = stripData[i];
                    stripLabelOptions = stripOptions.label || {};
                    attr = {fill: stripOptions.color};
                    if (_isDefined(stripOptions.startValue) && _isDefined(stripOptions.endValue) && _isDefined(stripOptions.color)) {
                        stripPos = that._getStripPos(stripOptions.startValue, stripOptions.endValue, canvas.start, canvas.end, that._range);
                        if (stripPos.stripTo - stripPos.stripFrom === 0 || !_isDefined(stripPos.stripTo) || !_isDefined(stripPos.stripFrom)) {
                            that._strips.push(null);
                            if (stripLabelOptions.text)
                                that._stripLabels.push(null);
                            continue
                        }
                        that._strips.push(that._createStrip(stripPos.stripFrom, stripPos.stripTo, attr).append(that._axisStripGroup));
                        that._stripLabels.push(stripLabelOptions.text ? that._drawStripLabel(stripLabelOptions, stripPos.stripFrom, stripPos.stripTo) : null)
                    }
                }
            },
            _drawStripLabel: function(stripLabelOptions, stripFrom, stripTo) {
                var that = this,
                    options = that._options,
                    coords = that._getStripLabelCoords(stripLabelOptions, stripFrom, stripTo);
                return that._renderer.text(stripLabelOptions.text, coords.x, coords.y).css(core.utils.patchFontOptions($.extend({}, options.label.font, stripLabelOptions.font))).attr({align: coords.align}).append(that._axisLabelGroup)
            },
            _adjustStripLabels: function() {
                var that = this,
                    labels = that._stripLabels,
                    rects = that._strips,
                    i,
                    coords;
                if (labels === undefined && rects === undefined)
                    return;
                for (i = 0; i < labels.length; i++)
                    if (labels[i] !== null) {
                        coords = that._getAdjustedStripLabelCoords(that._options.strips[i], labels[i], rects[i]);
                        labels[i].move(coords.x, coords.y)
                    }
            },
            _initAxisPositions: _noop,
            _adjustLabels: function() {
                var that = this,
                    options = that._options,
                    majorTicks = that._majorTicks,
                    majorTicksLength = majorTicks.length,
                    isHorizontal = options.isHorizontal,
                    overlappingBehavior = that._tickManager ? that._tickManager.getOverlappingBehavior() : options.label.overlappingBehavior,
                    position = options.position,
                    label,
                    labelHeight,
                    isNeedLabelAdjustment,
                    staggeringSpacing,
                    i,
                    box,
                    hasLabels = false;
                _each(majorTicks, function(_, tick) {
                    if (tick.label) {
                        tick.label.attr(that._getLabelAdjustedCoord(tick));
                        hasLabels = true
                    }
                });
                isNeedLabelAdjustment = hasLabels && isHorizontal && overlappingBehavior && overlappingBehavior.mode === "stagger";
                if (isNeedLabelAdjustment) {
                    labelHeight = 0;
                    for (i = 0; i < majorTicksLength; i = i + 2) {
                        label = majorTicks[i].label;
                        box = label && label.getBBox() || {};
                        if (box.height > labelHeight)
                            labelHeight = box.height
                    }
                    staggeringSpacing = overlappingBehavior.staggeringSpacing;
                    labelHeight = _round(labelHeight) + staggeringSpacing;
                    for (i = 1; i < majorTicksLength; i = i + 2) {
                        label = majorTicks[i].label;
                        if (label)
                            if (position === BOTTOM)
                                label.move(0, labelHeight);
                            else if (position === TOP)
                                label.move(0, -labelHeight)
                    }
                    for (i = 0; i < majorTicksLength; i++)
                        majorTicks[i].label && majorTicks[i].label.rotate(0)
                }
            },
            _getLabelAdjustedCoord: function(tick) {
                var that = this,
                    options = that._options,
                    box = tick.label.getBBox(),
                    x,
                    y,
                    boxAxis = that._axisElementsGroup && that._axisElementsGroup.getBBox() || {},
                    isHorizontal = options.isHorizontal,
                    position = options.position,
                    shift = that.padding && that.padding[position] || 0,
                    textOptions = that._textOptions,
                    labelSettingsY = tick.label.attr("y");
                if (isHorizontal && position === BOTTOM)
                    y = 2 * labelSettingsY - box.y + shift;
                else if (!isHorizontal) {
                    if (position === LEFT)
                        if (textOptions.align === RIGHT)
                            x = box.x + box.width - shift;
                        else if (textOptions.align === CENTER)
                            x = box.x + box.width / 2 - shift - (boxAxis.width / 2 || 0);
                        else
                            x = box.x - shift - (boxAxis.width || 0);
                    else if (textOptions.align === CENTER)
                        x = box.x + box.width / 2 + (boxAxis.width / 2 || 0) + shift;
                    else if (textOptions.align === RIGHT)
                        x = box.x + box.width + (boxAxis.width || 0) + shift;
                    else
                        x = box.x + shift;
                    y = labelSettingsY + ~~(labelSettingsY - box.y - box.height / 2)
                }
                else if (isHorizontal && position === TOP)
                    y = 2 * labelSettingsY - box.y - box.height - shift;
                return {
                        x: x,
                        y: y
                    }
            },
            _adjustTitle: _noop,
            _createAxisGroups: function() {
                var renderer = this._renderer,
                    isHorizontal = this._options.isHorizontal,
                    cssClass = isHorizontal ? "dxc-h-axis" : "dxc-v-axis",
                    stripClass = isHorizontal ? "dxc-h-strips" : "dxc-v-strips",
                    constantLineClass = isHorizontal ? "dxc-h-constant-lines" : "dxc-v-constant-lines";
                this._axisGroup = renderer.g().attr({"class": cssClass});
                this._axisStripGroup = renderer.g().attr({"class": stripClass});
                this._axisGridGroup = renderer.g().attr({"class": "dxc-grid"}).append(this._axisGroup);
                this._axisElementsGroup = renderer.g().attr({"class": "dxc-elements"}).append(this._axisGroup);
                this._axisLineGroup = renderer.g().attr({"class": "dxc-line"}).append(this._axisGroup);
                this._axisTitleGroup = renderer.g().attr({"class": "dxc-title"}).append(this._axisGroup);
                this._axisConstantLineGroup = renderer.g().attr({"class": constantLineClass});
                this._axisLabelGroup = renderer.g().attr({"class": "dxc-axis-labels"})
            },
            _clearAxisGroups: function(adjustAxis) {
                this._axisGroup.remove();
                this._axisStripGroup.remove();
                this._axisLabelGroup.remove();
                this._axisConstantLineGroup.remove();
                if (this._axisTitleGroup)
                    this._axisTitleGroup.clear();
                else if (!adjustAxis)
                    this._axisTitleGroup = this._renderer.g().attr({"class": "dxc-title"}).append(this._axisGroup);
                this._axisGridGroup.clear();
                if (this._axisElementsGroup)
                    this._axisElementsGroup.clear();
                else if (!adjustAxis)
                    this._axisElementsGroup = this._renderer.g().attr({"class": "dxc-elements"}).append(this._axisGroup);
                this._axisLineGroup.clear();
                this._axisStripGroup.clear();
                this._axisConstantLineGroup.clear();
                this._axisLabelGroup.clear()
            },
            _initTicks: function(ticks, tickOptions, gridOptions, withLabels) {
                var that = this,
                    options = that._options,
                    axisPosition = that._axisPosition,
                    tickStyle = {
                        stroke: tickOptions.color,
                        "stroke-width": 1,
                        "stroke-opacity": tickOptions.opacity
                    },
                    gridStyle = {
                        stroke: gridOptions.color,
                        "stroke-width": gridOptions.width,
                        "stroke-opacity": gridOptions.opacity
                    },
                    currentLabelConst = that.getCurrentLabelPos();
                _each(ticks || [], function(_, tick) {
                    var coord = that._getTranslatedValue(tick.value, axisPosition, that._getTickOffset());
                    tick.posX = coord.x;
                    tick.posY = coord.y;
                    tick.angle = coord.angle;
                    tick.tickStyle = tickStyle;
                    tick.gridStyle = gridStyle;
                    if (withLabels) {
                        tick.labelText = formatLabel(tick.value, that._options.label, {
                            min: that._options.min,
                            max: that._options.max
                        });
                        tick.labelPos = that._getTranslatedValue(tick.value, currentLabelConst);
                        tick.labelStyle = that._textOptions;
                        tick.labelFontStyle = that._textFontStyles;
                        tick.labelHint = formatHint(tick.value, that._options.label, {
                            min: that._options.min,
                            max: that._options.max
                        })
                    }
                })
            },
            _getTickOffset: function() {
                var options = this._options,
                    offset = options.discreteAxisDivisionMode !== "crossLabels" || !options.discreteAxisDivisionMode;
                return options.isHorizontal ? +offset : -offset
            },
            draw: function(externalOptions, adjustAxis) {
                var that = this,
                    options = that._options,
                    areLabelsVisible;
                externalOptions = externalOptions || {};
                var debug = DX.utils.debug;
                debug.assertParam(this._translator, "translator was not set before Draw call");
                if (that._axisGroup)
                    that._clearAxisGroups(adjustAxis);
                areLabelsVisible = options.label.visible && that._axisElementsGroup && !that._options.stubData;
                that._updateTranslatorInterval();
                that._initAxisPositions();
                that._initTicks(that._majorTicks, options.tick, options.grid, areLabelsVisible);
                that._initTicks(that._decimatedTicks, options.tick, options.grid, false);
                that._initTicks(that._minorTicks, options.minorTick, options.minorGrid);
                if (!that._virtual) {
                    options.visible && that._drawAxis();
                    if (options.tick.visible) {
                        that._drawTicks(that._majorTicks);
                        that._drawTicks(that._decimatedTicks)
                    }
                    options.minorTick.visible && that._drawTicks(that._minorTicks);
                    areLabelsVisible && that._drawLabels();
                    that._drawTitle()
                }
                options.strips && that._drawStrip();
                options.constantLines && that._drawConstantLine();
                if (options.grid.visible) {
                    that._drawGrids(that._majorTicks, externalOptions.borderOptions || {});
                    that._drawGrids(that._decimatedTicks, externalOptions.borderOptions || {})
                }
                options.minorGrid.visible && that._drawGrids(that._minorTicks, externalOptions.borderOptions || {});
                that._axisStripGroup.append(that._stripsGroup);
                that._axisConstantLineGroup.append(that._constantLinesGroup);
                that._axisGroup.append(that._axesContainerGroup);
                that._axisLabelGroup.append(that._labelAxesGroup);
                that._adjustConstantLineLabels();
                areLabelsVisible && that._adjustLabels();
                that._createHints();
                that._adjustStripLabels();
                that._adjustTitle();
                that._setBoundingRect()
            },
            _createHints: function() {
                var that = this;
                _each(that._majorTicks || [], function(_, tick) {
                    if (_isDefined(tick.labelHint) && tick.labelHint !== "")
                        tick.label.setTitle(tick.labelHint)
                })
            },
            _setBoundingRect: function() {
                var that = this,
                    options = that._options,
                    axisBox = that._axisElementsGroup ? that._axisElementsGroup.getBBox() : {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0,
                        isEmpty: true
                    },
                    lineBox = that._axisLineGroup.getBBox(),
                    placeholderSize = options.placeholderSize,
                    start,
                    isHorizontal = options.isHorizontal,
                    coord = isHorizontal && "y" || "x",
                    side = isHorizontal && "height" || "width",
                    shiftCoords = options.crosshairEnabled ? isHorizontal ? LABEL_BACKGROUND_PADDING_Y : LABEL_BACKGROUND_PADDING_X : 0,
                    axisTitleBox = that._title && that._axisTitleGroup ? that._axisTitleGroup.getBBox() : axisBox;
                if (axisBox.isEmpty && axisTitleBox.isEmpty && !placeholderSize) {
                    that.boundingRect = axisBox;
                    return
                }
                start = lineBox[coord] || that._axisPosition;
                if (options.position === (isHorizontal && BOTTOM || RIGHT)) {
                    axisBox[side] = (placeholderSize || axisTitleBox[coord] + axisTitleBox[side] - start) + shiftCoords;
                    axisBox[coord] = start
                }
                else {
                    axisBox[side] = (placeholderSize || lineBox[side] + start - axisTitleBox[coord]) + shiftCoords;
                    axisBox[coord] = (axisTitleBox.isEmpty ? start : axisTitleBox[coord]) - shiftCoords
                }
                that.boundingRect = axisBox
            },
            getBoundingRect: function() {
                return this._axisElementsGroup ? this.boundingRect : {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }
            },
            shift: function(x, y) {
                var settings = {};
                if (x)
                    settings.translateX = x;
                if (y)
                    settings.translateY = y;
                this._axisGroup.attr(settings)
            },
            applyClipRects: function(elementsClipID, canvasClipID) {
                this._axisGroup.attr({clipId: canvasClipID});
                this._axisStripGroup.attr({clipId: elementsClipID})
            },
            validate: function(isArgumentAxis, incidentOccured) {
                var that = this,
                    options = that._options,
                    range = options.range,
                    parseUtils = new core.ParseUtils,
                    dataType = isArgumentAxis ? options.argumentType : options.valueType,
                    parser = dataType ? parseUtils.getParser(dataType, "axis") : function(unit) {
                        return unit
                    };
                that.parser = parser;
                that.incidentOccured = incidentOccured;
                options.dataType = dataType;
                if (options.min)
                    options.min = that._validateUnit(options.min, "E2106");
                if (options.max)
                    options.max = that._validateUnit(options.max, "E2106");
                if (range.min)
                    range.min = that._validateUnit(range.min);
                if (range.max)
                    range.max = that._validateUnit(range.max)
            },
            _validateUnit: function(unit, idError, parameters) {
                var that = this;
                unit = that.parser(unit);
                if (unit === undefined && idError)
                    that.incidentOccured(idError, [parameters]);
                return unit
            },
            adjustZoomValues: function(min, max, skipAdjusting) {
                var that = this,
                    range = that._options.range;
                skipAdjusting = skipAdjusting || that._options.type === DISCRETE;
                min = that._validateUnit(min);
                max = that._validateUnit(max);
                if (!skipAdjusting && range) {
                    if (_isDefined(range.min)) {
                        min = _isDefined(min) ? range.min < min ? min : range.min : min;
                        max = _isDefined(max) ? range.min < max ? max : range.min : max
                    }
                    if (_isDefined(range.max)) {
                        max = _isDefined(max) ? range.max > max ? max : range.max : max;
                        min = _isDefined(min) ? range.max > min ? min : range.max : min
                    }
                }
                that.minRangeArg = min;
                that.maxRangeArg = max;
                return {
                        min: min,
                        max: max
                    }
            },
            _getRange: function(options, min, max, categories, minRangeArg, maxRangeArg, stick) {
                var range = {},
                    addValueMarginToRange = function(prefix) {
                        if (options.valueMarginsEnabled) {
                            if (_isDefined(options[prefix])) {
                                range[prefix] = options[prefix];
                                range[prefix + "Priority"] = AXIS_VALUE_MARGIN_PRIORITY
                            }
                        }
                        else {
                            range[prefix] = 0;
                            range[prefix + "Priority"] = AXIS_VALUE_MARGIN_PRIORITY
                        }
                    },
                    type = options.type,
                    isDiscrete = type === DISCRETE;
                if (_isDefined(min) && _isDefined(max))
                    if (isDiscrete) {
                        range.startCategories = _isDefined(minRangeArg) ? minRangeArg : min;
                        range.endCategories = _isDefined(maxRangeArg) ? maxRangeArg : max
                    }
                    else {
                        range.min = min < max ? min : max;
                        range.max = max > min ? max : min
                    }
                else {
                    range.min = min;
                    range.max = max
                }
                addValueMarginToRange("minValueMargin");
                addValueMarginToRange("maxValueMargin");
                range.stick = stick;
                range.categories = categories;
                range.dataType = options.dataType;
                range.axisType = type;
                if (range.axisType === LOGARITHMIC)
                    range.base = options.logarithmBase;
                range.invert = options.inverted;
                range.minVisible = !isDiscrete ? _isDefined(minRangeArg) ? minRangeArg : min : undefined;
                range.maxVisible = !isDiscrete ? _isDefined(maxRangeArg) ? maxRangeArg : max : undefined;
                return range
            },
            _setType: function(type) {
                var that = this;
                _each(axesMethods[type], function(methodName, method) {
                    that[methodName] = method
                })
            },
            getSpiderTicks: _noop,
            setSpiderTicks: _noop,
            measureLabels: _noop,
            getRangeData: _noop,
            coordsIn: _noop
        };
        DX.viz.charts.Axis.__DEBUG = {axesMethods: axesMethods}
    })(jQuery, DevExpress);
    /*! Module viz-charts, file scrollBar.js */
    (function($, DX, math) {
        var MIN_SCROLL_BAR_SIZE = 2;
        DX.viz.charts.ScrollBar = function(renderer, group) {
            this._translator = DX.viz.core.CoreFactory.createTranslator2D({}, {}, {});
            this._scroll = renderer.rect().append(group);
            this._addEvents()
        };
        function _getXCoord(canvas, pos, offset, width) {
            var x = 0;
            if (pos === "right")
                x = canvas.width - canvas.right + offset;
            else if (pos === "left")
                x = canvas.left - offset - width;
            return x
        }
        function _getYCoord(canvas, pos, offset, width) {
            var y = 0;
            if (pos === "top")
                y = canvas.top - offset;
            else if (pos === "bottom")
                y = canvas.height - canvas.bottom + width + offset;
            return y
        }
        DX.viz.charts.ScrollBar.prototype = {
            _addEvents: function() {
                var that = this,
                    $scroll = $(that._scroll.element),
                    startPosX = 0,
                    startPosY = 0,
                    scrollChangeHandler = function(e) {
                        var dX = (startPosX - e.pageX) * that._scale,
                            dY = (startPosY - e.pageY) * that._scale;
                        $scroll.trigger(new $.Event("dxc-scroll-move", $.extend(e, {
                            type: "dxc-scroll-move",
                            pointers: [{
                                    pageX: startPosX + dX,
                                    pageY: startPosY + dY
                                }]
                        })))
                    };
                $scroll.on("dxpointerdown", function(e) {
                    startPosX = e.pageX;
                    startPosY = e.pageY;
                    $scroll.trigger(new $.Event("dxc-scroll-start", {pointers: [{
                                pageX: startPosX,
                                pageY: startPosY
                            }]}));
                    $(document).on("dxpointermove", scrollChangeHandler)
                });
                $(document).on("dxpointerup", function() {
                    $(document).off("dxpointermove", scrollChangeHandler)
                })
            },
            update: function(options) {
                var that = this,
                    scrollOptions = options.scrollBar,
                    position = scrollOptions.position,
                    isVertical = options.rotated,
                    defaultPosition = isVertical ? "right" : "top",
                    secondaryPosition = isVertical ? "left" : "bottom";
                if (position !== defaultPosition && position !== secondaryPosition)
                    position = defaultPosition;
                that._scroll.attr({
                    rotate: !options.rotated ? -90 : 0,
                    rotateX: 0,
                    rotateY: 0,
                    fill: scrollOptions.color,
                    width: scrollOptions.width,
                    opacity: scrollOptions.opacity
                });
                that._layoutOptions = {
                    width: scrollOptions.width,
                    offset: scrollOptions.offset,
                    vertical: isVertical,
                    position: position
                };
                return that
            },
            init: function(range, canvas) {
                var that = this;
                that._translateWithOffset = range.axisType === "discrete" && !range.stick && 1 || 0;
                that._translator.update($.extend({}, range, {
                    minVisible: null,
                    maxVisible: null,
                    visibleCategories: null,
                    startCategories: null
                }), $.extend({}, canvas), {direction: that._layoutOptions.vertical ? "vertical" : "horizontal"});
                return that
            },
            getOptions: function() {
                return this._layoutOptions
            },
            shift: function(x, y) {
                this._scroll.attr({
                    translateX: x,
                    translateY: y
                })
            },
            setPane: function(panes) {
                var position = this._layoutOptions.position,
                    pane;
                if (position === "left" || position === "top")
                    pane = panes[0];
                else
                    pane = panes[panes.length - 1];
                this.pane = pane.name;
                this._canvas = pane.canvas;
                return this
            },
            getMultipleAxesSpacing: function() {
                return 0
            },
            getBoundingRect: function() {
                var options = this._layoutOptions,
                    isVertical = options.vertical,
                    offset = options.offset,
                    width = options.width,
                    pos = options.position,
                    size = width + offset,
                    canvas = this._canvas;
                return isVertical ? {
                        x: _getXCoord(canvas, pos, offset, width),
                        y: canvas.top,
                        width: size,
                        height: canvas.height - canvas.top - canvas.bottom
                    } : {
                        x: canvas.left,
                        y: _getYCoord(canvas, pos, offset, width),
                        width: canvas.width - canvas.left - canvas.right,
                        height: size
                    }
            },
            applyLayout: function() {
                var canvas = this._canvas,
                    options = this._layoutOptions,
                    pos = options.position,
                    offset = options.offset,
                    width = options.width;
                this.shift(_getXCoord(canvas, pos, offset, width), _getYCoord(canvas, pos, offset, width))
            },
            setPosition: function(min, max) {
                var that = this,
                    translator = that._translator,
                    visibleArea = translator.getCanvasVisibleArea(),
                    minPoint = translator.translate(min, -that._translateWithOffset) || visibleArea.min,
                    maxPoint = translator.translate(max, that._translateWithOffset) || visibleArea.max;
                that._offset = math.min(minPoint, maxPoint);
                that._scale = translator.getScale(min, max);
                that._applyPosition(math.min(minPoint, maxPoint), math.max(minPoint, maxPoint))
            },
            transform: function(translate, scale) {
                var x = this._translator.getCanvasVisibleArea().min,
                    dx = x - (x * scale - translate),
                    lx = this._offset + dx / (this._scale * scale);
                this._applyPosition(lx, lx + this._translator.canvasLength / (this._scale * scale))
            },
            dispose: function() {
                $(this._scroll.element).off();
                this._scroll.remove();
                this._scroll = this._translator = null
            },
            _applyPosition: function(x1, x2) {
                var that = this,
                    visibleArea = that._translator.getCanvasVisibleArea(),
                    height;
                x1 = math.max(x1, visibleArea.min);
                x1 = math.min(x1, visibleArea.max);
                x2 = math.min(x2, visibleArea.max);
                x2 = math.max(x2, visibleArea.min);
                height = math.abs(x2 - x1);
                that._scroll.attr({
                    y: x1,
                    height: height < MIN_SCROLL_BAR_SIZE ? MIN_SCROLL_BAR_SIZE : height
                })
            }
        }
    })(jQuery, DevExpress, Math);
    /*! Module viz-charts, file baseChart.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            charts = DX.viz.charts,
            utils = DX.utils,
            ACTIONS_BY_PRIORITY = ['reinit', '_reinitDataSource', '_dataSourceChangedHandler', 'force_render'],
            core = DX.viz.core,
            _each = $.each,
            DEFAULT_ANIMATION_OPTIONS = {asyncSeriesRendering: true};
        function createEventMapObject(name, deprecatedArgs) {
            return {
                    name: name,
                    deprecated: name,
                    deprecatedContext: function(arg) {
                        return arg.target
                    },
                    deprecatedArgs: deprecatedArgs || function(arg) {
                        return [arg.target, arg.jQueryEvent]
                    }
                }
        }
        function resolveLabelOverlappingInOneDirection(points, canvas, isRotated) {
            var rollingStocks = $.map(points, function(point) {
                    return new RollingStock(point, isRotated)
                });
            rollingStocks.sort(function(a, b) {
                return a.getPointPosition() - b.getPointPosition()
            });
            if (!checkStackOverlap(rollingStocks))
                return;
            rollingStocks.reverse();
            moveRollingStock(rollingStocks, {
                start: isRotated ? canvas.left : canvas.top,
                end: isRotated ? canvas.width - canvas.right : canvas.height - canvas.bottom
            })
        }
        function overlapRollingStock(firstRolling, secondRolling) {
            if (!firstRolling || !secondRolling)
                return;
            return firstRolling.getBoundingRect().end > secondRolling.getBoundingRect().start
        }
        function checkStackOverlap(rollingStocks) {
            var i,
                j,
                currentRollingStock,
                nextRollingStock,
                overlap;
            for (i = 0; i < rollingStocks.length; i++) {
                currentRollingStock = rollingStocks[i];
                for (j = i + 1; j < rollingStocks.length; j++) {
                    nextRollingStock = rollingStocks[j];
                    if (overlapRollingStock(currentRollingStock, nextRollingStock)) {
                        currentRollingStock.toChain(nextRollingStock);
                        overlap = true;
                        rollingStocks[j] = null
                    }
                }
            }
            return overlap
        }
        function moveRollingStock(rollingStocks, canvas) {
            var i,
                j,
                currentRollingStock,
                nextRollingStock,
                currentBBox,
                nextBBox;
            for (i = 0; i < rollingStocks.length; i++) {
                currentRollingStock = rollingStocks[i];
                if (rollingStocksIsOut(currentRollingStock, canvas)) {
                    currentBBox = currentRollingStock.getBoundingRect();
                    for (j = i + 1; j < rollingStocks.length; j++) {
                        nextRollingStock = rollingStocks[j];
                        if (!nextRollingStock)
                            continue;
                        nextBBox = nextRollingStock.getBoundingRect();
                        if (nextBBox.end > currentBBox.start - (currentBBox.end - canvas.end)) {
                            nextRollingStock.toChain(currentRollingStock);
                            rollingStocks[i] = currentRollingStock = null;
                            break
                        }
                    }
                }
                currentRollingStock && currentRollingStock.setRollingStockInCanvas(canvas)
            }
        }
        function rollingStocksIsOut(rollingStock, canvas) {
            return rollingStock && rollingStock.getBoundingRect().end > canvas.end
        }
        function RollingStock(point, isRotated) {
            var label = point.getLabel(),
                bbox = label.getBoundingRect();
            this.labels = [label];
            this.points = [point];
            this.direction = isRotated;
            this._bbox = {
                start: isRotated ? bbox.x : bbox.y,
                width: isRotated ? bbox.width : bbox.height,
                end: isRotated ? bbox.x + bbox.width : bbox.y + bbox.height
            };
            this._pointPositionInitialize = isRotated ? point.getBoundaryCoords().x : point.getBoundaryCoords().y;
            return this
        }
        RollingStock.prototype = {
            toChain: function(nextRollingStock) {
                var nextRollingStockBBox = nextRollingStock.getBoundingRect();
                nextRollingStock.shift(nextRollingStockBBox.start - this._bbox.end);
                this._changeBoxWidth(nextRollingStockBBox.width);
                this.labels = this.labels.concat(nextRollingStock.labels);
                this.points = this.points.concat(nextRollingStock.points)
            },
            getBoundingRect: function() {
                return this._bbox
            },
            shift: function(shiftLength, startIndex) {
                var isRotated = this.direction;
                _each(this.labels, function(index, label) {
                    if (!label || startIndex > index)
                        return;
                    var bbox = label.getBoundingRect();
                    label.shift(isRotated ? bbox.x - shiftLength : bbox.x, isRotated ? bbox.y : bbox.y - shiftLength)
                });
                if (!startIndex) {
                    this._bbox.end -= shiftLength;
                    this._bbox.start -= shiftLength
                }
            },
            setRollingStockInCanvas: function(canvas) {
                var i;
                for (i = 0; i < this.labels.length; i++) {
                    if (this._bbox.end <= canvas.end)
                        break;
                    if (this._bbox.start - (this._bbox.end - (canvas.end - canvas.start)) >= 0)
                        this.shift(this._bbox.end - canvas.end);
                    else
                        this._killSmallestValueLabel()
                }
            },
            getPointPosition: function() {
                return this._pointPositionInitialize
            },
            _changeBoxWidth: function(width) {
                this._bbox.end += width;
                this._bbox.width += width
            },
            _killSmallestValueLabel: function() {
                var smallestValuePoint = {originalValue: Infinity},
                    labelBBox,
                    indexOfPoint = null;
                _each(this.points, function(index, point) {
                    if (point && smallestValuePoint.originalValue >= point.originalValue) {
                        smallestValuePoint = point;
                        indexOfPoint = index
                    }
                });
                if (indexOfPoint !== null) {
                    labelBBox = this.labels[indexOfPoint].getBoundingRect();
                    this._changeBoxWidth(-(this.direction ? labelBBox.width : labelBBox.height));
                    this.labels[indexOfPoint].hide();
                    this.points[indexOfPoint] = this.labels[indexOfPoint] = null;
                    this.shift(this.direction ? labelBBox.width : labelBBox.height, indexOfPoint + 1)
                }
            }
        };
        charts.BaseChart = core.BaseWidget.inherit({
            _eventsMap: $.extend({}, core.BaseWidget.prototype._eventsMap, {
                onSeriesClick: createEventMapObject("seriesClick"),
                onPointClick: createEventMapObject("pointClick"),
                onArgumentAxisClick: createEventMapObject("argumentAxisClick", function(arg) {
                    return [arg.target, arg.argument, arg.jQueryEvent]
                }),
                onLegendClick: createEventMapObject("legendClick"),
                onSeriesSelectionChanged: createEventMapObject('seriesSelectionChanged'),
                onPointSelectionChanged: createEventMapObject('pointSelectionChanged'),
                onSeriesHoverChanged: createEventMapObject('seriesHoverChanged'),
                onPointHoverChanged: createEventMapObject('pointHoverChanged'),
                onTooltipShown: createEventMapObject('tooltipShown'),
                onTooltipHidden: createEventMapObject('tooltipHidden'),
                onDone: createEventMapObject("done"),
                seriesClick: {newName: 'onSeriesClick'},
                pointClick: {newName: 'onPointClick'},
                argumentAxisClick: {newName: 'onArgumentAxisClick'},
                legendClick: {newName: 'onLegendClick'},
                pointHoverChanged: {newName: 'onPointHoverChanged'},
                seriesSelectionChanged: {newName: 'onSeriesSelectionChanged'},
                pointSelectionChanged: {newName: 'onPointSelectionChanged'},
                seriesHoverChanged: {newName: 'onSeriesHoverChanged'},
                tooltipShown: {newName: 'onTooltipShown'},
                tooltipHidden: {newName: 'onTooltipHidden'},
                done: {newName: 'onDone'}
            }),
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    seriesClick: {
                        since: '14.2',
                        message: "Use the 'onSeriesClick' option instead"
                    },
                    pointClick: {
                        since: '14.2',
                        message: "Use the 'onPointClick' option instead"
                    },
                    argumentAxisClick: {
                        since: '14.2',
                        message: "Use the 'onArgumentAxisClick' option instead"
                    },
                    legendClick: {
                        since: '14.2',
                        message: "Use the 'onLegendClick' option instead"
                    },
                    seriesSelectionChanged: {
                        since: '14.2',
                        message: "Use the 'onSeriesSelectionChanged' option instead"
                    },
                    pointSelectionChanged: {
                        since: '14.2',
                        message: "Use the 'onPointSelectionChanged' option instead"
                    },
                    seriesHoverChanged: {
                        since: '14.2',
                        message: "Use the 'onSeriesHoverChanged' option instead"
                    },
                    pointHoverChanged: {
                        since: '14.2',
                        message: "Use the 'onPointHoverChanged' option instead"
                    },
                    tooltipShown: {
                        since: '14.2',
                        message: "Use the 'onTooltipShown' option instead"
                    },
                    tooltipHidden: {
                        since: '14.2',
                        message: "Use the 'onTooltipHidden' option instead"
                    },
                    done: {
                        since: '14.2',
                        message: "Use the 'onDone' option instead"
                    }
                })
            },
            _init: function() {
                var that = this;
                that.themeManager = charts.factory.createThemeManager(that.option(), that._chartType);
                that.callBase();
                that._initRenderer();
                that.canvasClipRect = that.renderer.clipRect();
                that._createHtmlStructure();
                that._needHandleRenderComplete = true;
                that.layoutManager = charts.factory.createChartLayoutManager(that._layoutManagerOptions());
                that._createScrollBar();
                that._reinit();
                that.element().css({webkitUserSelect: 'none'}).on('contextmenu', function(event) {
                    that.eventType = 'contextmenu';
                    if (ui.events.isTouchEvent(event) || ui.events.isPointerEvent(event))
                        event.preventDefault()
                }).on('MSHoldVisual', function(event) {
                    that.eventType = 'MSHoldVisual';
                    event.preventDefault()
                })
            },
            _layoutManagerOptions: function() {
                return this.themeManager.getOptions("adaptiveLayout")
            },
            _reinit: function(needRedraw) {
                var that = this;
                charts._setCanvasValues(that.canvas);
                that._createTracker();
                that._reinitAxes();
                that._reinitDataSource();
                if (!that.series)
                    that._dataSpecificInit();
                that._correctAxes();
                needRedraw && that._endLoading(function() {
                    that._render({force: true})
                })
            },
            _createHtmlStructure: function() {
                var that = this,
                    renderer = that.renderer;
                that._backgroundRect = renderer.rect(0, 0, 0, 0).attr({
                    fill: "gray",
                    opacity: 0.0001
                });
                that._panesBackgroundGroup = renderer.g().attr({'class': 'dxc-background'});
                that._titleGroup = renderer.g().attr({'class': 'dxc-title'});
                that._legendGroup = renderer.g().attr({
                    'class': 'dxc-legend',
                    clipId: that._getCanvasClipRectID()
                });
                that._stripsGroup = renderer.g().attr({'class': 'dxc-strips-group'});
                that._constantLinesGroup = renderer.g().attr({'class': 'dxc-constant-lines-group'});
                that._axesGroup = renderer.g().attr({'class': 'dxc-axes-group'});
                that._panesBorderGroup = renderer.g().attr({'class': 'dxc-border'});
                that._labelAxesGroup = renderer.g().attr({'class': 'dxc-strips-labels-group'});
                that._scrollBarGroup = renderer.g().attr({'class': 'dxc-scroll-bar'});
                that._seriesGroup = renderer.g().attr({'class': 'dxc-series-group'});
                that._labelsGroup = renderer.g().attr({'class': 'dxc-labels-group'});
                that._tooltipGroup = renderer.g().attr({'class': 'dxc-tooltip'});
                that._crosshairCursorGroup = renderer.g().attr({'class': 'dxc-crosshair-cursor'})
            },
            _disposeObjectsInArray: function(propName, fieldNames) {
                $.each(this[propName] || [], function(_, item) {
                    if (fieldNames && item)
                        $.each(fieldNames, function(_, field) {
                            item[field] && item[field].dispose()
                        });
                    else
                        item && item.dispose()
                });
                this[propName] = null
            },
            _dispose: function() {
                var that = this,
                    disposeObject = function(propName) {
                        that[propName] && that[propName].dispose(),
                        that[propName] = null
                    },
                    detachGroup = function(groupName) {
                        that[groupName] && that[groupName].remove()
                    },
                    disposeObjectsInArray = this._disposeObjectsInArray;
                clearTimeout(that._delayedRedraw);
                that.renderer.stopAllAnimations();
                that.callBase();
                disposeObjectsInArray.call(that, "businessRanges", ["arg", "val"]);
                that.translators = null;
                disposeObjectsInArray.call(that, "series");
                disposeObject("layoutManager");
                disposeObject("themeManager");
                disposeObject("renderer");
                disposeObject("tracker");
                disposeObject("tooltip");
                disposeObject("chartTitle");
                that.paneAxis = null;
                that._userOptions = null;
                that.dirtyCanvas = null;
                that.canvas = null;
                detachGroup("_legendGroup");
                detachGroup("_stripsGroup");
                detachGroup("_constantLinesGroup");
                detachGroup("_axesGroup");
                detachGroup("_labelAxesGroup");
                detachGroup("_seriesGroup");
                detachGroup("_labelsGroup");
                detachGroup("_crosshairCursorGroup");
                disposeObject("canvasClipRect");
                disposeObject("_panesBackgroundGroup");
                disposeObject("_titleGroup");
                disposeObject("_scrollBarGroup");
                disposeObject("_legendGroup");
                disposeObject("_stripsGroup");
                disposeObject("_constantLinesGroup");
                disposeObject("_axesGroup");
                disposeObject("_labelAxesGroup");
                disposeObject("_panesBorderGroup");
                disposeObject("_seriesGroup");
                disposeObject("_labelsGroup");
                disposeObject("_tooltipGroup");
                disposeObject("_crosshairCursorGroup");
                that._disposeLoadIndicator()
            },
            _getAnimationOptions: function() {
                return $.extend({}, DEFAULT_ANIMATION_OPTIONS, this.themeManager.getOptions("animation"))
            },
            _initRenderer: function _initRenderer() {
                this.renderer = core.CoreFactory.createRenderer({
                    animation: this._getAnimationOptions(),
                    cssClass: 'dxc dxc-chart',
                    pathModified: this.option('pathModified'),
                    rtl: this.themeManager.getOptions('rtlEnabled')
                })
            },
            _reinitDataSource: function() {
                this._refreshDataSource()
            },
            _saveDirtyCanvas: function() {
                this.dirtyCanvas = $.extend({}, this.canvas)
            },
            _resize: function() {
                this._render({
                    animate: false,
                    isResize: true
                })
            },
            _calculateCanvas: function() {
                var canvas = this.themeManager.getOptions('size'),
                    width,
                    height;
                if (!utils.isDefined(canvas.width))
                    width = this.element().width() || 400;
                else
                    width = canvas.width < 0 ? 0 : canvas.width;
                if (!utils.isDefined(canvas.height))
                    height = this.element().height() || 400;
                else
                    height = canvas.height < 0 ? 0 : canvas.height;
                return $.extend({
                        width: width,
                        height: height
                    }, this.themeManager.getOptions('margin'))
            },
            _createTracker: function() {
                var that = this;
                if (that.tracker)
                    that.tracker.dispose();
                that.tracker = charts.factory.createTracker({
                    seriesSelectionMode: that.themeManager.getOptions('seriesSelectionMode'),
                    pointSelectionMode: that.themeManager.getOptions('pointSelectionMode'),
                    crosshair: that._crosshair,
                    seriesGroup: that._seriesGroup,
                    renderer: that.renderer,
                    eventTrigger: that._eventTrigger
                }, that.NAME)
            },
            _getTrackerSettings: function() {
                var that = this,
                    canvas = that.canvas;
                return {
                        series: that.series,
                        legend: that.legend,
                        tooltip: that.tooltip,
                        legendCallback: $.proxy(that.legend.getActionCallback, that.legend),
                        mainCanvas: {
                            left: 0,
                            right: canvas.width,
                            top: 0,
                            bottom: canvas.height
                        }
                    }
            },
            _updateTracker: function(canvases) {
                var that = this;
                if (!that.tracker)
                    that._createTracker();
                that.tracker.update(that._getTrackerSettings(canvases))
            },
            _render: function(_options) {
                var that = this,
                    renderer = that.renderer,
                    drawOptions = that._prepareDrawOptions(_options) || {recreateCanvas: true},
                    updatedCanvas = that.canvas,
                    currentDirtyCanvas = that._calculateCanvas(),
                    oldDirtyCanvas = that.dirtyCanvas;
                if (!drawOptions.force && oldDirtyCanvas && oldDirtyCanvas.width === currentDirtyCanvas.width && oldDirtyCanvas.height === currentDirtyCanvas.height && !that._hiddenContainer)
                    return;
                clearTimeout(that._delayedRedraw);
                if (drawOptions.recreateCanvas)
                    that.canvas = updatedCanvas = that._calculateCanvas();
                if (updatedCanvas.width && updatedCanvas.height && that.element().is(':visible'))
                    that._hiddenContainer = false;
                else {
                    that._incidentOccured('W2001', [that.NAME]);
                    that._hiddenContainer = true;
                    renderer.clear();
                    return
                }
                if (drawOptions.recreateCanvas) {
                    renderer.resize(that.canvas.width, that.canvas.height);
                    renderer.draw(that.element()[0]);
                    that._reappendLoadIndicator();
                    that._updateLoadIndicator(undefined, updatedCanvas.width, updatedCanvas.height);
                    that._updateCanvasClipRect()
                }
                that.renderer.stopAllAnimations(true);
                charts._setCanvasValues(that.canvas);
                that._cleanGroups(drawOptions);
                that._saveDirtyCanvas();
                that._renderElements(drawOptions)
            },
            _renderElements: function(drawOptions) {
                var that = this,
                    preparedOptions = that._prepareToRender(drawOptions),
                    isRotated = that._isRotated(),
                    isLegendInside = that._isLegendInside(),
                    trackerCanvases = [],
                    layoutTargets = that._getLayoutTargets(),
                    needHideLoadingIndicator = that._loadIndicator && that._loadIndicator.isShown && that._dataSource && that._dataSource.isLoaded() && !drawOptions.isResize,
                    argBusinessRange,
                    zoomMinArg,
                    zoomMaxArg;
                that._renderTitleAndLegend(drawOptions, isLegendInside);
                that._renderAxes(drawOptions, preparedOptions, isRotated);
                if (that.layoutManager.needMoreSpaceForPanesCanvas(that._getLayoutTargets(), isRotated)) {
                    that.layoutManager.updateDrawnElements(that._getAxesForTransform(isRotated), that.canvas, that.dirtyCanvas, that._getLayoutTargets(), isRotated);
                    if (that.chartTitle)
                        that.layoutManager.correctSizeElement(that.chartTitle, that.canvas);
                    that._updateCanvasClipRect(that.dirtyCanvas);
                    that._updateAxesLayout(drawOptions, preparedOptions, isRotated)
                }
                that.layoutManager.placeDrawnElements(that.canvas);
                that._applyClipRects(preparedOptions);
                that._appendSeriesGroups();
                that._createTooltip();
                $.each(layoutTargets, function() {
                    var canvas = this.canvas;
                    trackerCanvases.push({
                        left: canvas.left,
                        right: canvas.width - canvas.right,
                        top: canvas.top,
                        bottom: canvas.height - canvas.bottom
                    })
                });
                if (that._scrollBar) {
                    argBusinessRange = that.businessRanges[0].arg;
                    if (argBusinessRange.categories && argBusinessRange.categories.length <= 1)
                        zoomMinArg = zoomMaxArg = undefined;
                    else {
                        zoomMinArg = utils.isDefined(that._zoomMinArg) ? that._zoomMinArg : argBusinessRange.minVisible;
                        zoomMaxArg = utils.isDefined(that._zoomMaxArg) ? that._zoomMaxArg : argBusinessRange.maxVisible
                    }
                    that._scrollBar.init(argBusinessRange, layoutTargets[0].canvas).setPosition(zoomMinArg, zoomMaxArg)
                }
                drawOptions.updateTracker && that._updateTracker(trackerCanvases);
                var timeout = that._getSeriesRenderTimeout(drawOptions);
                if (timeout >= 0)
                    that._delayedRedraw = setTimeout(renderSeries, timeout);
                else
                    renderSeries();
                function renderSeries() {
                    that._renderSeries(drawOptions, isRotated, isLegendInside, needHideLoadingIndicator)
                }
            },
            _appendSeriesGroups: function() {
                var that = this;
                that._seriesGroup.append(that.renderer.root);
                that._labelsGroup.append(that.renderer.root);
                that._appendAdditionalSeriesGroups();
                that._tooltipGroup.append(that.renderer.root)
            },
            _renderSeries: function(drawOptions, isRotated, isLegendInside, needHideLoadingIndicator) {
                var that = this,
                    resolveLabelOverlapping = that.themeManager.getOptions("resolveLabelOverlapping");
                that._drawSeries(drawOptions, isRotated);
                that._updateLegendAndTooltip(drawOptions, isLegendInside);
                resolveLabelOverlapping !== "none" && that._resolveLabelOverlapping(resolveLabelOverlapping);
                that._renderTrackers(isLegendInside);
                if (needHideLoadingIndicator)
                    that.hideLoadingIndicator();
                that._drawn();
                that._renderCompleteHandler()
            },
            _resolveLabelOverlapping: function(resolveLabelOverlapping) {
                var func;
                switch (resolveLabelOverlapping) {
                    case"stack":
                        func = this._resolveLabelOverlappingStack;
                        break;
                    case"hide":
                        func = this._resolveLabelOverlappingHide;
                        break;
                    case"shift":
                        func = this._resolveLabelOverlappingShift;
                        break
                }
                $.isFunction(func) && func.call(this)
            },
            _resolveLabelOverlappingHide: function() {
                var labels = $.map(this.getAllSeries(), function(series) {
                        return $.map(series.getVisiblePoints(), function(point) {
                                return point.getLabel()
                            })
                    }),
                    currenctLabel,
                    nextLabel,
                    currenctLabelRect,
                    nextLabelRect,
                    i,
                    j;
                for (i = 0; i < labels.length; i++) {
                    currenctLabel = labels[i];
                    currenctLabelRect = currenctLabel.getBoundingRect();
                    if (currenctLabel.getVisibility() === "hidden")
                        continue;
                    for (j = i + 1; j < labels.length; j++) {
                        nextLabel = labels[j];
                        nextLabelRect = nextLabel.getBoundingRect();
                        if (utils.checkOverlapping(currenctLabelRect, nextLabelRect))
                            nextLabel.hide()
                    }
                }
            },
            _cleanGroups: function(drawOptions) {
                var that = this;
                that._stripsGroup.remove();
                that._constantLinesGroup.remove();
                that._axesGroup.remove();
                that._labelAxesGroup.remove();
                that._labelsGroup.remove();
                that._tooltipGroup.remove();
                that._crosshairCursorGroup.remove();
                if (!drawOptions || drawOptions.drawLegend)
                    that._legendGroup.remove().clear();
                if (!drawOptions || drawOptions.drawTitle)
                    that._titleGroup.remove().clear();
                that._stripsGroup.clear();
                that._constantLinesGroup.clear();
                that._axesGroup.clear();
                that._labelAxesGroup.clear();
                that._labelsGroup.clear();
                that._tooltipGroup.clear();
                that._crosshairCursorGroup.clear()
            },
            _drawTitle: function() {
                var that = this,
                    options = that.themeManager.getOptions("title"),
                    width = that.canvas.width - that.canvas.left - that.canvas.right;
                options._incidentOccured = that._incidentOccured;
                if (that.chartTitle)
                    that.chartTitle.update(options, width);
                else
                    that.chartTitle = charts.factory.createTitle(that.renderer, options, width, that._titleGroup)
            },
            _createLegend: function() {
                var that = this,
                    legendOptions = that.themeManager.getOptions('legend'),
                    legendData = that._getLegendData();
                legendOptions.containerBackgroundColor = that.themeManager.getOptions("containerBackgroundColor");
                legendOptions._incidentOccured = that._incidentOccured;
                if (that.legend)
                    that.legend.update(legendData, legendOptions);
                else
                    that.legend = core.CoreFactory.createLegend(legendData, legendOptions, that.renderer, that._legendGroup)
            },
            _createTooltip: function() {
                var that = this,
                    tooltipOptions = that.themeManager.getOptions('tooltip');
                if (!$.isFunction(tooltipOptions.customizeText) && utils.isDefined(tooltipOptions.customizeText)) {
                    that._incidentOccured("E2103", ['customizeText']);
                    tooltipOptions.customizeText = undefined
                }
                if (that.tooltip)
                    that.tooltip.update(tooltipOptions);
                else
                    that.tooltip = core.CoreFactory.createTooltip(tooltipOptions, that._tooltipGroup, that.renderer);
                that.tooltip.setSize(that.canvas.width, that.canvas.height)
            },
            _prepareDrawOptions: function(drawOptions) {
                var animationOptions = this._getAnimationOptions(),
                    options;
                options = $.extend({}, {
                    force: false,
                    adjustAxes: true,
                    drawLegend: true,
                    drawTitle: true,
                    adjustSeriesLabels: true,
                    animate: animationOptions.enabled,
                    animationPointsLimit: animationOptions.maxPointCountSupported,
                    asyncSeriesRendering: animationOptions.asyncSeriesRendering,
                    asyncTrackersRendering: animationOptions.asyncTrackersRendering,
                    trackerRenderingDelay: animationOptions.trackerRenderingDelay,
                    updateTracker: true
                }, drawOptions);
                if (!utils.isDefined(options.recreateCanvas))
                    options.recreateCanvas = options.adjustAxes && options.drawLegend && options.drawTitle;
                return options
            },
            _processRefreshData: function(newRefreshAction) {
                var currentRefreshActionPosition = $.inArray(this._currentRefreshData, ACTIONS_BY_PRIORITY),
                    newRefreshActionPosition = $.inArray(newRefreshAction, ACTIONS_BY_PRIORITY);
                if (!this._currentRefreshData || currentRefreshActionPosition >= 0 && newRefreshActionPosition < currentRefreshActionPosition)
                    this._currentRefreshData = newRefreshAction
            },
            _disposeSeries: function() {
                var that = this;
                $.each(that.series || [], function(_, series) {
                    series.dispose()
                });
                that.series = null;
                $.each(that.seriesFamilies || [], function(_, family) {
                    family.dispose()
                });
                that.seriesFamilies = null
            },
            _optionChanged: function(args) {
                var name = args.name;
                var that = this;
                that.themeManager.resetOptions(name);
                that.themeManager.update(that._options);
                if (name === 'animation') {
                    that.renderer.updateAnimationOptions(that._getAnimationOptions());
                    return
                }
                clearTimeout(that._delayedRedraw);
                switch (name) {
                    case'dataSource':
                        that._needHandleRenderComplete = true;
                        that._processRefreshData('_reinitDataSource');
                        break;
                    case'palette':
                        that.themeManager.updatePalette(that.option(name));
                        that._disposeSeries();
                        that._needHandleRenderComplete = true;
                        that._processRefreshData('_dataSourceChangedHandler');
                        break;
                    case'series':
                    case'commonSeriesSettings':
                    case'containerBackgroundColor':
                    case'dataPrepareSettings':
                        that._disposeSeries();
                        that._needHandleRenderComplete = true;
                        that._processRefreshData('_dataSourceChangedHandler');
                        break;
                    case'legend':
                    case'seriesTemplate':
                        that._processRefreshData('_dataSourceChangedHandler');
                        break;
                    case'title':
                        that._processRefreshData('force_render');
                        break;
                    case'valueAxis':
                    case'argumentAxis':
                    case'commonAxisSettings':
                        that._needHandleRenderComplete = true;
                        that._processRefreshData('reinit');
                        that._disposeSeries();
                        that.paneAxis = {};
                        break;
                    case'panes':
                    case'defaultPane':
                        that._disposeSeries();
                        that.paneAxis = {};
                        that._needHandleRenderComplete = true;
                        that._processRefreshData('reinit');
                        break;
                    case'size':
                        that._processRefreshData('force_render');
                        break;
                    case'rotated':
                    case'equalBarWidth':
                    case'customizePoint':
                    case'customizeLabel':
                        that._disposeSeries();
                        that._needHandleRenderComplete = true;
                        that._processRefreshData('reinit');
                        break;
                    case'theme':
                        that._disposeSeries();
                        that.themeManager.setTheme(that.option(name));
                        that._processRefreshData('reinit');
                        break;
                    case'scrollBar':
                        that._createScrollBar();
                        that._processRefreshData('force_render');
                    default:
                        that._processRefreshData('reinit')
                }
                that.callBase.apply(that, arguments)
            },
            _getLoadIndicatorOption: function() {
                return this.themeManager.getOptions("loadingIndicator")
            },
            _refresh: function() {
                var that = this;
                that.renderer.stopAllAnimations(true);
                if (that._currentRefreshData) {
                    switch (that._currentRefreshData) {
                        case'force_render':
                            that._render({force: true});
                            break;
                        case'reinit':
                            that._reinit(true);
                            break;
                        default:
                            that[that._currentRefreshData] && that[that._currentRefreshData]()
                    }
                    delete that._currentRefreshData
                }
                else
                    that._render({force: true})
            },
            _dataSourceOptions: function() {
                return {
                        paginate: false,
                        _preferSync: true
                    }
            },
            _updateCanvasClipRect: function(canvas) {
                var that = this,
                    width,
                    height;
                canvas = canvas || that.canvas;
                width = Math.max(canvas.width - canvas.left - canvas.right, 0);
                height = Math.max(canvas.height - canvas.top - canvas.bottom, 0);
                that.canvasClipRect.attr({
                    x: canvas.left,
                    y: canvas.top,
                    width: width,
                    height: height
                });
                that._backgroundRect.attr({
                    x: canvas.left,
                    y: canvas.top,
                    width: width,
                    height: height
                }).append(that.renderer.root).toBackground()
            },
            _getCanvasClipRectID: function() {
                return this.canvasClipRect.id
            },
            _dataSourceChangedHandler: function() {
                clearTimeout(this._delayedRedraw);
                this._dataSpecificInit(true)
            },
            _dataSpecificInit: function(needRedraw) {
                this.series = this.series || this._populateSeries();
                this._repopulateSeries();
                this._seriesPopulatedHandler(needRedraw)
            },
            _seriesPopulatedHandler: function(needRedraw) {
                var that = this;
                that._seriesPopulatedHandlerCore();
                that._populateBusinessRange();
                that._createLegend();
                needRedraw && that._endLoading(function() {
                    that._render({force: true})
                })
            },
            _repopulateSeries: function() {
                var that = this,
                    parsedData,
                    data = that._dataSource && that._dataSource.items(),
                    dataValidatorOptions = that.themeManager.getOptions('dataPrepareSettings'),
                    sharedTooltip = that.themeManager.getOptions("tooltip").shared,
                    stackPoints = {},
                    seriesTemplate = that.themeManager.getOptions('seriesTemplate');
                if (that._dataSource && seriesTemplate) {
                    that._templatedSeries = utils.processSeriesTemplate(seriesTemplate, that._dataSource.items());
                    that._populateSeries();
                    delete that._templatedSeries;
                    data = that.teamplateData || data
                }
                that._groupSeries();
                that._dataValidator = charts.factory.createDataValidator(data, that._groupedSeries, that._incidentOccured, dataValidatorOptions);
                parsedData = that._dataValidator.validate();
                that.themeManager.resetPalette();
                $.each(that.series, function(_, singleSeries) {
                    singleSeries.updateData(parsedData);
                    that._processSingleSeries(singleSeries);
                    sharedTooltip && that._prepareStackPoints(singleSeries, stackPoints, true)
                })
            },
            _renderCompleteHandler: function() {
                var that = this,
                    allSeriesInited = true;
                if (that._needHandleRenderComplete) {
                    $.each(that.series, function(_, s) {
                        allSeriesInited = allSeriesInited && s.canRenderCompleteHandle()
                    });
                    if (allSeriesInited) {
                        that._needHandleRenderComplete = false;
                        that._eventTrigger("done", {target: that})
                    }
                }
            },
            _renderTitleAndLegend: function(drawOptions, legendHasInsidePosition) {
                var that = this,
                    titleOptions = that.themeManager.getOptions("title"),
                    drawTitle = titleOptions.text && drawOptions.drawTitle,
                    drawLegend = drawOptions.drawLegend && that.legend && !legendHasInsidePosition,
                    drawElements = [];
                if (drawTitle) {
                    that._titleGroup.append(that.renderer.root);
                    that._drawTitle();
                    drawElements.push(that.chartTitle)
                }
                if (drawLegend) {
                    that._legendGroup.append(that.renderer.root);
                    drawElements.push(that.legend)
                }
                drawElements.length && that.layoutManager.drawElements(drawElements, that.canvas);
                if (drawTitle)
                    that.layoutManager.correctSizeElement(that.chartTitle, that.canvas)
            },
            _prepareStackPoints: $.noop,
            _resolveLabelOverlappingInOneDirection: function() {
                resolveLabelOverlappingInOneDirection.apply(null, arguments)
            },
            getAllSeries: function getAllSeries() {
                return this.series.slice()
            },
            getSeriesByName: function getSeriesByName(name) {
                var found = null;
                $.each(this.series, function(i, singleSeries) {
                    if (singleSeries.name === name) {
                        found = singleSeries;
                        return false
                    }
                });
                return found
            },
            getSeriesByPos: function getSeriesByPos(pos) {
                return this.series[pos]
            },
            clearSelection: function clearSelection() {
                this.tracker.clearSelection()
            },
            hideTooltip: function() {
                this.tracker._hideTooltip()
            },
            render: function(renderOptions) {
                this._render(renderOptions)
            },
            getSize: function() {
                var canvas = this.canvas || {};
                return {
                        width: canvas.width,
                        height: canvas.height
                    }
            }
        }).include(ui.DataHelperMixin)
    })(jQuery, DevExpress);
    /*! Module viz-charts, file advancedChart.js */
    (function($, DX, undefined) {
        var charts = DX.viz.charts,
            utils = DX.utils,
            core = DX.viz.core,
            DEFAULT_AXIS_NAME = "defaultAxisName",
            _isArray = utils.isArray,
            _isDefined = utils.isDefined,
            _each = $.each,
            _extend = $.extend,
            _map = $.map,
            MIN = 'min',
            MAX = 'max';
        function prepareAxis(axisOptions) {
            return _isArray(axisOptions) ? axisOptions.length === 0 ? [{}] : axisOptions : [axisOptions]
        }
        function unique(array) {
            var values = {},
                i,
                len = array.length;
            for (i = 0; i < len; i++)
                values[array[i]] = true;
            return _map(values, function(_, key) {
                    return key
                })
        }
        function prepareVisibleArea(visibleArea, axisRange, useAggregation, aggregationRange) {
            visibleArea.minVal = axisRange.min;
            visibleArea.maxVal = axisRange.max;
            if (useAggregation && !visibleArea.adjustOnZoom) {
                visibleArea.minVal = _isDefined(visibleArea.minVal) ? visibleArea.minVal : aggregationRange.val.min;
                visibleArea.maxVal = _isDefined(visibleArea.maxVal) ? visibleArea.maxVal : aggregationRange.val.max
            }
        }
        charts.AdvancedChart = charts.BaseChart.inherit({
            _dispose: function() {
                var that = this,
                    disposeObjectsInArray = this._disposeObjectsInArray;
                that.callBase();
                that.panes = null;
                that.legend && (that.legend.dispose(), that.legend = null);
                disposeObjectsInArray.call(that, "panesBackground");
                disposeObjectsInArray.call(that, "seriesFamilies");
                that._disposeAxes()
            },
            _reinitAxes: function() {
                this.translators = {};
                this.panes = this._createPanes();
                this._populateAxes()
            },
            _populateSeries: function() {
                var that = this,
                    themeManager = that.themeManager,
                    hasSeriesTemplate = !!themeManager.getOptions("seriesTemplate"),
                    series = hasSeriesTemplate ? that._templatedSeries : that.option("series"),
                    allSeriesOptions = _isArray(series) ? series : series ? [series] : [],
                    argumentAxisOptions = that.option("argumentAxis"),
                    valueAxisOptions = that.option("valueAxis"),
                    data,
                    particularSeriesOptions,
                    particularSeries,
                    rotated = that._isRotated(),
                    i,
                    paneList = _map(that.panes, function(pane) {
                        return pane.name
                    }),
                    paneName;
                that.teamplateData = [];
                that._disposeSeries();
                that.series = [];
                themeManager.resetPalette();
                for (i = 0; i < allSeriesOptions.length; i++) {
                    particularSeriesOptions = _extend(true, {}, allSeriesOptions[i]);
                    if (particularSeriesOptions.type && !utils.isString(particularSeriesOptions.type))
                        particularSeriesOptions.type = "";
                    data = particularSeriesOptions.data;
                    particularSeriesOptions.data = null;
                    particularSeriesOptions.rotated = rotated;
                    particularSeriesOptions.customizePoint = themeManager.getOptions("customizePoint");
                    particularSeriesOptions.customizeLabel = themeManager.getOptions("customizeLabel");
                    particularSeriesOptions.visibilityChanged = $.proxy(that._seriesVisibilityChanged, that);
                    particularSeriesOptions.resolveLabelsOverlapping = themeManager.getOptions("resolveLabelsOverlapping");
                    if (argumentAxisOptions) {
                        particularSeriesOptions.argumentCategories = argumentAxisOptions.categories;
                        particularSeriesOptions.argumentAxisType = argumentAxisOptions.type;
                        particularSeriesOptions.argumentType = argumentAxisOptions.argumentType
                    }
                    if (valueAxisOptions)
                        if (_isArray(valueAxisOptions))
                            _each(valueAxisOptions, function(iter, options) {
                                if (!particularSeriesOptions.axis && !iter || particularSeriesOptions.axis === options.name) {
                                    particularSeriesOptions.valueCategories = options.categories;
                                    particularSeriesOptions.valueAxisType = options.type;
                                    particularSeriesOptions.valueType = options.valueType;
                                    particularSeriesOptions.showZero = options.showZero
                                }
                            });
                        else {
                            particularSeriesOptions.valueCategories = valueAxisOptions.categories;
                            particularSeriesOptions.valueAxisType = valueAxisOptions.type;
                            particularSeriesOptions.valueType = valueAxisOptions.valueType;
                            particularSeriesOptions.showZero = valueAxisOptions.showZero
                        }
                    particularSeriesOptions.incidentOccured = that._incidentOccured;
                    if (!particularSeriesOptions.name)
                        particularSeriesOptions.name = "Series " + (i + 1).toString();
                    var seriesTheme = themeManager.getOptions("series", particularSeriesOptions);
                    seriesTheme.pane = seriesTheme.pane || that.defaultPane;
                    paneName = seriesTheme.pane;
                    if ($.inArray(paneName, paneList) === -1)
                        continue;
                    particularSeries = core.CoreFactory.createSeries({
                        renderer: that.renderer,
                        seriesGroup: that._seriesGroup,
                        labelsGroup: that._labelsGroup
                    }, seriesTheme);
                    if (!particularSeries.isUpdated)
                        that._incidentOccured("E2101", [seriesTheme.type]);
                    else {
                        particularSeries.index = i;
                        that.series.push(particularSeries)
                    }
                    if (hasSeriesTemplate) {
                        _each(data, function(_, data) {
                            _each(particularSeries.getTeamplatedFields(), function(_, field) {
                                data[field.teamplateField] = data[field.originalField]
                            });
                            that.teamplateData.push(data)
                        });
                        particularSeries.updateTeamplateFieldNames()
                    }
                }
                return that.series
            },
            _populateAxes: function() {
                var that = this,
                    valueAxes = [],
                    argumentAxes,
                    panes = that.panes,
                    themeManager = that.themeManager,
                    rotated = themeManager.getOptions("rotated"),
                    valueAxisOptions = that.option("valueAxis") || {},
                    argumentOption = that.option("argumentAxis") || {},
                    crosshairOptions = that.option("crosshair") || {},
                    argumentAxesOptions = prepareAxis(argumentOption)[0],
                    valueAxesOptions = prepareAxis(valueAxisOptions),
                    axisNames = [],
                    valueAxesCounter = 0,
                    paneWithNonVirtualAxis;
                function getNextAxisName() {
                    return DEFAULT_AXIS_NAME + valueAxesCounter++
                }
                that._disposeAxes();
                if (rotated)
                    paneWithNonVirtualAxis = argumentAxesOptions.position === "right" ? panes[panes.length - 1].name : panes[0].name;
                else
                    paneWithNonVirtualAxis = argumentAxesOptions.position === "top" ? panes[0].name : panes[panes.length - 1].name;
                argumentAxes = _map(panes, function(pane) {
                    return that._createAxis("argumentAxis", argumentAxesOptions, {
                            virtual: pane.name != paneWithNonVirtualAxis,
                            pane: pane.name,
                            crosshairEnabled: crosshairOptions.enabled
                        }, rotated)
                });
                _each(valueAxesOptions, function(priority, axisOptions) {
                    var axisPanes = [],
                        name = axisOptions.name;
                    if (name && $.inArray(name, axisNames) != -1) {
                        that._incidentOccured("E2102");
                        return
                    }
                    name && axisNames.push(name);
                    if (axisOptions.pane)
                        axisPanes.push(axisOptions.pane);
                    if (axisOptions.panes && axisOptions.panes.length)
                        axisPanes = axisPanes.concat(axisOptions.panes.slice(0));
                    axisPanes = unique(axisPanes);
                    if (!axisPanes.length)
                        axisPanes.push(undefined);
                    _each(axisPanes, function(_, pane) {
                        valueAxes.push(that._createAxis("valueAxis", axisOptions, {
                            name: name || getNextAxisName(),
                            pane: pane,
                            priority: priority,
                            crosshairEnabled: crosshairOptions.enabled
                        }, rotated))
                    })
                });
                that._valueAxes = valueAxes;
                that._argumentAxes = argumentAxes
            },
            _prepareStackPoints: function(singleSeries, stackPoints, isSharedTooltip) {
                var points = singleSeries.getPoints(),
                    stackName = singleSeries.getStackName();
                _each(points, function(index, point) {
                    var argument = point.argument;
                    if (!stackPoints[argument]) {
                        stackPoints[argument] = {};
                        stackPoints[argument][null] = []
                    }
                    if (stackName && !_isArray(stackPoints[argument][stackName])) {
                        stackPoints[argument][stackName] = [];
                        _each(stackPoints[argument][null], function(_, point) {
                            if (!point.stackName)
                                stackPoints[argument][stackName].push(point)
                        })
                    }
                    if (stackName) {
                        stackPoints[argument][stackName].push(point);
                        stackPoints[argument][null].push(point)
                    }
                    else
                        _each(stackPoints[argument], function(_, stack) {
                            stack.push(point)
                        });
                    if (isSharedTooltip) {
                        point.stackPoints = stackPoints[argument][stackName];
                        point.stackName = stackName
                    }
                })
            },
            _disposeAxes: function() {
                var disposeObjectsInArray = this._disposeObjectsInArray;
                disposeObjectsInArray.call(this, "_argumentAxes");
                disposeObjectsInArray.call(this, "_valueAxes")
            },
            _drawAxes: function(panesBorderOptions, drawOptions, adjustUnits) {
                var that = this;
                function drawAxes(axes) {
                    _each(axes, function(_, axis) {
                        axis.draw({borderOptions: panesBorderOptions[axis.pane]}, adjustUnits)
                    })
                }
                that._reinitTranslators();
                that._prepareAxesAndDraw(drawAxes, drawOptions)
            },
            _appendAdditionalSeriesGroups: function() {
                var that = this,
                    rendererRoot = that.renderer.root;
                that._crosshairCursorGroup.append(rendererRoot);
                that._legendGroup.append(rendererRoot);
                that._scrollBar && that._scrollBarGroup.append(rendererRoot)
            },
            _getLegendData: function() {
                return _map(this.series, function(seriesItem) {
                        if (seriesItem.getOptions().showInLegend)
                            return {
                                    text: seriesItem.name,
                                    id: seriesItem.index,
                                    states: seriesItem.getLegendStyles()
                                }
                    })
            },
            _seriesPopulatedHandlerCore: function() {
                this._processSeriesFamilies();
                this._processValueAxisFormat()
            },
            _renderTrackers: function(legendHasInsidePosition) {
                var that = this,
                    i,
                    rendererRoot = that.renderer.root;
                for (i = 0; i < that.series.length; i++)
                    that.series[i].drawTrackers();
                if (that.legend) {
                    legendHasInsidePosition && that._legendGroup.append(rendererRoot);
                    legendHasInsidePosition && that._tooltipGroup.append(rendererRoot)
                }
            },
            _seriesVisibilityChanged: function() {
                this._processSeriesFamilies();
                this._populateBusinessRange();
                this.renderer.stopAllAnimations(true);
                this._render({
                    force: true,
                    asyncSeriesRendering: false,
                    asyncTrackersRendering: false
                })
            },
            _processSeriesFamilies: function() {
                var that = this,
                    types = [],
                    families = [],
                    paneSeries,
                    themeManager = that.themeManager;
                if (that.seriesFamilies && that.seriesFamilies.length) {
                    _each(that.seriesFamilies, function(_, family) {
                        family.adjustSeriesValues()
                    });
                    return
                }
                _each(that.series, function(_, item) {
                    if ($.inArray(item.type, types) === -1)
                        types.push(item.type)
                });
                _each(that._getLayoutTargets(), function(_, pane) {
                    paneSeries = that._getSeriesForPane(pane.name);
                    _each(types, function(_, type) {
                        var family = core.CoreFactory.createSeriesFamily({
                                type: type,
                                pane: pane.name,
                                equalBarWidth: themeManager.getOptions("equalBarWidth"),
                                minBubbleSize: themeManager.getOptions("minBubbleSize"),
                                maxBubbleSize: themeManager.getOptions("maxBubbleSize")
                            });
                        family.add(paneSeries);
                        family.adjustSeriesValues();
                        families.push(family)
                    })
                });
                that.seriesFamilies = families
            },
            _appendAxesGroups: function() {
                var that = this,
                    rendererRoot = that.renderer.root;
                that._stripsGroup.append(rendererRoot);
                that._axesGroup.append(rendererRoot);
                that._constantLinesGroup.append(rendererRoot);
                that._labelAxesGroup.append(rendererRoot)
            },
            _updateAxesLayout: function(drawOptions, panesBorderOptions, rotated) {
                this.layoutManager.updatePanesCanvases(this._getLayoutTargets(), this.canvas, rotated);
                this._drawAxes(panesBorderOptions, drawOptions, true)
            },
            _populateBusinessRange: function(visibleArea) {
                var that = this,
                    businessRanges = [],
                    themeManager = that.themeManager,
                    rotated = themeManager.getOptions("rotated"),
                    useAggregation = themeManager.getOptions('useAggregation'),
                    argAxes = that._argumentAxes,
                    lastArgAxis = argAxes[argAxes.length - 1],
                    calcInterval = lastArgAxis.calcInterval,
                    argRange = new core.Range({rotated: !!rotated}),
                    argBusinessRange;
                that._disposeObjectsInArray("businessRanges", ["arg", "val"]);
                _each(that._groupedSeries, function(_, group) {
                    var groupRange = new core.Range({
                            rotated: !!rotated,
                            isValueRange: true,
                            pane: group.valueAxis.pane,
                            axis: group.valueAxis.name
                        }),
                        groupAxisRange = group.valueAxis.getRangeData();
                    groupRange.addRange(groupAxisRange);
                    _each(group, function(_, series) {
                        visibleArea && prepareVisibleArea(visibleArea, groupAxisRange, useAggregation, series._originalBusinessRange);
                        var seriesRange = series.getRangeData(visibleArea, calcInterval);
                        groupRange.addRange(seriesRange.val);
                        argRange.addRange(seriesRange.arg)
                    });
                    if (!groupRange.isDefined())
                        groupRange.setStubData(group.valueAxis.getOptions().valueType === 'datetime' ? 'datetime' : undefined);
                    if (group.valueAxis.getOptions().showZero)
                        groupRange.correctValueZeroLevel();
                    groupRange.checkZeroStick();
                    businessRanges.push({
                        val: groupRange,
                        arg: argRange
                    })
                });
                _each(argAxes, function(_, axis) {
                    argRange.addRange(axis.getRangeData(argRange.min))
                });
                if (!argRange.isDefined())
                    argRange.setStubData(argAxes[0].getOptions().argumentType);
                if (visibleArea && visibleArea.notApplyMargins && argRange.axisType !== "discrete") {
                    argBusinessRange = argAxes[0].getTranslator().getBusinessRange();
                    argRange.addRange({
                        min: argBusinessRange.min,
                        max: argBusinessRange.max,
                        stick: true
                    })
                }
                that._correctBusinessRange(argRange, lastArgAxis);
                that.businessRanges = businessRanges
            },
            _correctBusinessRange: function(range, lastArgAxis) {
                var setTicksAtUnitBeginning = lastArgAxis.getOptions().setTicksAtUnitBeginning,
                    tickIntervalRange = {},
                    tickInterval = lastArgAxis.getOptions().tickInterval,
                    originInterval = tickInterval;
                tickInterval = $.isNumeric(tickInterval) ? tickInterval : utils.convertDateTickIntervalToMilliseconds(tickInterval);
                if (tickInterval && _isDefined(range[MIN]) && _isDefined(range[MAX]) && tickInterval >= Math.abs(range[MAX] - range[MIN])) {
                    if (utils.isDate(range[MIN])) {
                        if (!$.isNumeric(originInterval)) {
                            tickIntervalRange[MIN] = utils.addInterval(range[MIN], originInterval, true);
                            tickIntervalRange[MAX] = utils.addInterval(range[MAX], originInterval, false)
                        }
                        else {
                            tickIntervalRange[MIN] = new Date(range[MIN].valueOf() - tickInterval);
                            tickIntervalRange[MAX] = new Date(range[MAX].valueOf() + tickInterval)
                        }
                        if (setTicksAtUnitBeginning) {
                            utils.correctDateWithUnitBeginning(tickIntervalRange[MAX], originInterval);
                            utils.correctDateWithUnitBeginning(tickIntervalRange[MIN], originInterval)
                        }
                    }
                    else {
                        tickIntervalRange[MIN] = range[MIN] - tickInterval;
                        tickIntervalRange[MAX] = range[MAX] + tickInterval
                    }
                    range.addRange(tickIntervalRange)
                }
            },
            _getArgumentAxes: function() {
                return this._argumentAxes
            },
            _getValueAxes: function() {
                return this._valueAxes
            },
            _processValueAxisFormat: function() {
                var that = this,
                    valueAxes = that._valueAxes,
                    axesWithFullStackedFormat = [];
                _each(that.series, function() {
                    if (this.isFullStackedSeries() && $.inArray(this.axis, axesWithFullStackedFormat) === -1)
                        axesWithFullStackedFormat.push(this.axis)
                });
                _each(valueAxes, function() {
                    if ($.inArray(this.name, axesWithFullStackedFormat) !== -1)
                        this.setPercentLabelFormat();
                    else
                        this.resetAutoLabelFormat()
                })
            },
            _createAxis: function(typeSelector, userOptions, axisOptions, rotated) {
                userOptions = this._prepareStripsAndConstantLines(typeSelector, userOptions, rotated);
                var optionsForAxis = this._prepareAxisOptions(typeSelector, userOptions, axisOptions, rotated);
                _extend(optionsForAxis, {
                    stripsGroup: this._stripsGroup,
                    labelAxesGroup: this._labelAxesGroup,
                    constantLinesGroup: this._constantLinesGroup,
                    axesContainerGroup: this._axesGroup
                });
                return charts.factory.createAxis(this.renderer, optionsForAxis)
            },
            _getTrackerSettings: function(canvases) {
                return _extend(this.callBase(canvases), {
                        argumentAxis: this._argumentAxes,
                        canvases: canvases
                    })
            },
            _prepareStripsAndConstantLines: function(typeSelector, userOptions, rotated) {
                userOptions = this.themeManager.getOptions(typeSelector, userOptions, rotated);
                if (userOptions.strips)
                    _each(userOptions.strips, function(i) {
                        userOptions.strips[i] = _extend(true, {}, userOptions.stripStyle, userOptions.strips[i])
                    });
                if (userOptions.constantLines)
                    _each(userOptions.constantLines, function(i, line) {
                        userOptions.constantLines[i] = _extend(true, {}, userOptions.constantLineStyle, line)
                    });
                return userOptions
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-charts, file chart.js */
    (function($, DX, undefined) {
        var viz = DX.viz,
            core = viz.core,
            charts = viz.charts,
            utils = DX.utils,
            MAX_ADJUSTMENT_ATTEMPTS = 5,
            DEFAULT_PANE_NAME = "default",
            ASYNC_SERIES_RENDERING_DELAY = 25,
            DEFAULT_PANES = [{
                    name: DEFAULT_PANE_NAME,
                    border: {}
                }],
            _map = $.map,
            _each = $.each,
            _extend = $.extend,
            _isArray = utils.isArray,
            _isDefined = utils.isDefined;
        function getFirstAxisNameForPane(axes, paneName) {
            var result;
            for (var i = 0; i < axes.length; i++)
                if (axes[i].pane === paneName) {
                    result = axes[i].name;
                    break
                }
            if (!result)
                result = axes[0].name;
            return result
        }
        function hideGridsOnNonFirstValueAxisForPane(valAxes, paneName, synchronizeMultiAxes) {
            var axesForPane = [],
                firstShownAxis;
            _each(valAxes, function(_, axis) {
                if (axis.pane === paneName)
                    axesForPane.push(axis)
            });
            if (axesForPane.length > 1 && synchronizeMultiAxes)
                _each(axesForPane, function(_, axis) {
                    var gridOpt = axis.getOptions().grid,
                        minorGridOpt = axis.getOptions().minorGrid;
                    if (firstShownAxis && gridOpt && gridOpt.visible) {
                        gridOpt.visible = false;
                        minorGridOpt && (minorGridOpt.visible = false)
                    }
                    else
                        firstShownAxis = firstShownAxis ? firstShownAxis : gridOpt && gridOpt.visible
                })
        }
        function getPaneForAxis(paneAxis, axisNameWithoutPane) {
            var result;
            _each(paneAxis, function(paneName, pane) {
                _each(pane, function(axisName) {
                    if (axisNameWithoutPane == axisName) {
                        result = paneName;
                        return false
                    }
                })
            });
            return result
        }
        function findAxisOptions(valueAxes, valueAxesOptions, axisName) {
            var result,
                axInd;
            for (axInd = 0; axInd < valueAxesOptions.length; axInd++)
                if (valueAxesOptions[axInd].name == axisName) {
                    result = valueAxesOptions[axInd];
                    result.priority = axInd;
                    break
                }
            if (!result)
                for (axInd = 0; axInd < valueAxes.length; axInd++)
                    if (valueAxes[axInd].name == axisName) {
                        result = valueAxes[axInd].getOptions();
                        result.priority = valueAxes[axInd].priority;
                        break
                    }
            return result
        }
        function findAxis(paneName, axisName, axes) {
            var axis,
                i;
            for (i = 0; i < axes.length; i++) {
                axis = axes[i];
                if (axis.name === axisName && axis.pane === paneName)
                    return axis
            }
        }
        function prepareSegmentRectPoints(left, top, width, height, borderOptions) {
            var maxSW = ~~((width < height ? width : height) / 2),
                sw = borderOptions.width || 0,
                newSW = sw < maxSW ? sw : maxSW;
            left = left + newSW / 2;
            top = top + newSW / 2;
            width = width - newSW;
            height = height - newSW;
            var right = left + width,
                bottom = top + height,
                points = [],
                segments = [],
                segmentSequence,
                visiblyOpt = 0,
                prevSegmentVisibility = 0;
            var allSegment = {
                    top: [[left, top], [right, top]],
                    right: [[right, top], [right, bottom]],
                    bottom: [[right, bottom], [left, bottom]],
                    left: [[left, bottom], [left, top]]
                };
            _each(allSegment, function(seg) {
                var visibility = !!borderOptions[seg];
                visiblyOpt = visiblyOpt * 2 + ~~visibility
            });
            switch (visiblyOpt) {
                case(13):
                case(9):
                    segmentSequence = ['left', 'top', 'right', 'bottom'];
                    break;
                case(11):
                    segmentSequence = ['bottom', 'left', 'top', 'right'];
                    break;
                default:
                    segmentSequence = ['top', 'right', 'bottom', 'left']
            }
            _each(segmentSequence, function(_, seg) {
                var segmentVisibility = !!borderOptions[seg];
                if (!prevSegmentVisibility && segments.length) {
                    points.push(segments);
                    segments = []
                }
                if (segmentVisibility)
                    _each(allSegment[seg].slice(prevSegmentVisibility), function(_, segment) {
                        segments = segments.concat(segment)
                    });
                prevSegmentVisibility = ~~segmentVisibility
            });
            segments.length && points.push(segments);
            points.length === 1 && (points = points[0]);
            return {
                    points: points,
                    pathType: visiblyOpt == 15 ? "area" : "line"
                }
        }
        function applyClipSettings(clipRects, settings) {
            _each(clipRects || [], function(_, c) {
                c && c.attr(settings)
            })
        }
        charts._test_prepareSegmentRectPoints = function() {
            var original = prepareSegmentRectPoints.original || prepareSegmentRectPoints;
            if (arguments[0])
                prepareSegmentRectPoints = arguments[0];
            prepareSegmentRectPoints.original = original;
            prepareSegmentRectPoints.restore = function() {
                prepareSegmentRectPoints = original
            };
            return prepareSegmentRectPoints
        };
        DX.registerComponent("dxChart", viz.charts, charts.AdvancedChart.inherit({
            _chartType: "chart",
            _setDefaultOptions: function() {
                this.callBase();
                this.option({defaultPane: DEFAULT_PANE_NAME})
            },
            _init: function() {
                this.__ASYNC_SERIES_RENDERING_DELAY = ASYNC_SERIES_RENDERING_DELAY;
                this.paneAxis = {};
                this._crosshair = {};
                this._panesClipRects = {};
                this.callBase()
            },
            _dispose: function() {
                var that = this,
                    disposeObjectsInArray = this._disposeObjectsInArray,
                    panesClipRects = that._panesClipRects;
                that.callBase();
                disposeObjectsInArray.call(panesClipRects, "fixed");
                disposeObjectsInArray.call(panesClipRects, "base");
                disposeObjectsInArray.call(panesClipRects, "wide");
                that._panesClipRects = null
            },
            _correctAxes: function() {
                this.series && this._correctValueAxes()
            },
            _processSingleSeries: $.noop,
            _groupSeries: function() {
                var that = this,
                    panes = that.panes,
                    valAxes = that._valueAxes,
                    paneList = _map(panes, function(pane) {
                        return pane.name
                    }),
                    series = that.series,
                    paneAxis = that.paneAxis,
                    synchronizeMultiAxes = that.themeManager.getOptions("synchronizeMultiAxes"),
                    groupedSeries = that._groupedSeries = [];
                _each(series, function(i, particularSeries) {
                    particularSeries.axis = particularSeries.axis || getFirstAxisNameForPane(valAxes, particularSeries.pane);
                    if (particularSeries.axis) {
                        paneAxis[particularSeries.pane] = paneAxis[particularSeries.pane] || {};
                        paneAxis[particularSeries.pane][particularSeries.axis] = true
                    }
                });
                _each(valAxes, function(_, axis) {
                    if (axis.name && axis.pane && $.inArray(axis.pane, paneList) != -1) {
                        paneAxis[axis.pane] = paneAxis[axis.pane] || {};
                        paneAxis[axis.pane][axis.name] = true
                    }
                });
                that._correctValueAxes();
                _each(paneAxis, function(paneName, pane) {
                    hideGridsOnNonFirstValueAxisForPane(valAxes, paneName, synchronizeMultiAxes);
                    _each(pane, function(axisName) {
                        var group = [];
                        _each(series, function(_, particularSeries) {
                            if (particularSeries.pane === paneName && particularSeries.axis === axisName)
                                group.push(particularSeries)
                        });
                        groupedSeries.push(group);
                        group.valueAxis = findAxis(paneName, axisName, valAxes)
                    })
                });
                groupedSeries.argumentAxes = that._argumentAxes
            },
            _cleanPanesClipRects: function(clipArrayName) {
                var that = this,
                    clipArray = that._panesClipRects[clipArrayName];
                _each(clipArray || [], function(_, clipRect) {
                    clipRect && clipRect.remove()
                });
                that._panesClipRects[clipArrayName] = []
            },
            _createPanes: function() {
                var that = this,
                    panes = that.option("panes"),
                    panesNameCounter = 0,
                    bottomPaneName;
                if (panes && _isArray(panes) && !panes.length || $.isEmptyObject(panes))
                    panes = DEFAULT_PANES;
                that._cleanPanesClipRects("fixed");
                that._cleanPanesClipRects("base");
                that._cleanPanesClipRects("wide");
                that.defaultPane = that.option("defaultPane");
                panes = _extend(true, [], _isArray(panes) ? panes : panes ? [panes] : []);
                _each(panes, function(_, pane) {
                    pane.name = !_isDefined(pane.name) ? DEFAULT_PANE_NAME + panesNameCounter++ : pane.name
                });
                if (!that._doesPaneExists(panes, that.defaultPane) && panes.length > 0) {
                    bottomPaneName = panes[panes.length - 1].name;
                    that._incidentOccured("W2101", [that.defaultPane, bottomPaneName]);
                    that.defaultPane = bottomPaneName
                }
                panes = that.themeManager.getOptions("rotated") ? panes.reverse() : panes;
                return panes
            },
            _doesPaneExists: function(panes, paneName) {
                var found = false;
                _each(panes, function(_, pane) {
                    if (pane.name === paneName) {
                        found = true;
                        return false
                    }
                });
                return found
            },
            _prepareAxisOptions: function(typeSelector, userOptions, axisOptions, rotated) {
                return _extend(true, {}, userOptions, axisOptions, {
                        isHorizontal: typeSelector === "argumentAxis" ? !rotated : rotated,
                        incidentOccured: this._incidentOccured,
                        drawingType: "normal"
                    })
            },
            _correctValueAxes: function() {
                var that = this,
                    rotated = that.themeManager.getOptions("rotated"),
                    valueAxisOptions = that.option("valueAxis") || {},
                    valueAxesOptions = _isArray(valueAxisOptions) ? valueAxisOptions : [valueAxisOptions],
                    valueAxes = that._valueAxes || [],
                    defaultAxisName = valueAxes[0].name,
                    paneAxis = that.paneAxis || {},
                    panes = that.panes,
                    i,
                    neededAxis = {};
                _each(valueAxes, function(_, axis) {
                    if (axis.pane)
                        return;
                    var pane = getPaneForAxis(that.paneAxis, axis.name);
                    if (!pane) {
                        pane = that.defaultPane;
                        paneAxis[pane] = paneAxis[pane] || {};
                        paneAxis[pane][axis.name] = true
                    }
                    axis.setPane(pane)
                });
                for (i = 0; i < panes.length; i++)
                    if (!paneAxis[panes[i].name]) {
                        paneAxis[panes[i].name] = {};
                        paneAxis[panes[i].name][defaultAxisName] = true
                    }
                _each(that.paneAxis, function(paneName, axisNames) {
                    _each(axisNames, function(axisName) {
                        neededAxis[axisName + "-" + paneName] = true;
                        if (!findAxis(paneName, axisName, valueAxes)) {
                            var axisOptions = findAxisOptions(valueAxes, valueAxesOptions, axisName);
                            if (!axisOptions) {
                                that._incidentOccured("W2102", [axisName]);
                                axisOptions = {
                                    name: axisName,
                                    priority: valueAxes.length
                                }
                            }
                            delete axisOptions.stripsGroup;
                            delete axisOptions.labelAxesGroup;
                            delete axisOptions.constantLinesGroup;
                            delete axisOptions.axesContainerGroup;
                            valueAxes.push(that._createAxis("valueAxis", axisOptions, {
                                pane: paneName,
                                name: axisName
                            }, rotated))
                        }
                    })
                });
                valueAxes = $.grep(valueAxes, function(elem) {
                    return !!neededAxis[elem.name + "-" + elem.pane]
                });
                valueAxes.sort(function(a, b) {
                    return a.priority - b.priority
                });
                that._valueAxes = valueAxes
            },
            _getSeriesForPane: function(paneName) {
                var paneSeries = [];
                _each(this.series, function(_, oneSeries) {
                    if (oneSeries.pane === paneName)
                        paneSeries.push(oneSeries)
                });
                return paneSeries
            },
            _createTranslator: function(range, canvas, options) {
                return core.CoreFactory.createTranslator2D(range, canvas, options)
            },
            _createPanesBorderOptions: function() {
                var commonBorderOptions = this.themeManager.getOptions("commonPaneSettings").border,
                    panesBorderOptions = {};
                _each(this.panes, function(_, pane) {
                    panesBorderOptions[pane.name] = _extend(true, {}, commonBorderOptions, pane.border)
                });
                return panesBorderOptions
            },
            _createScrollBar: function() {
                var that = this,
                    themeManager = that.themeManager,
                    scrollBarOptions = themeManager.getOptions("scrollBar") || {};
                if (scrollBarOptions.visible)
                    that._scrollBar = (that._scrollBar || charts.factory.createScrollBar(that.renderer, that._scrollBarGroup)).update({
                        rotated: that._isRotated(),
                        scrollBar: scrollBarOptions
                    });
                else {
                    that._scrollBarGroup.remove();
                    that._scrollBar && that._scrollBar.dispose();
                    that._scrollBar = null
                }
            },
            _prepareToRender: function(drawOptions) {
                var that = this,
                    rotated = that.themeManager.getOptions("rotated"),
                    panesBorderOptions = that._createPanesBorderOptions();
                that._createPanesBackground();
                that._appendAxesGroups();
                that._transformed && that._resetTransform();
                that._createTranslators(drawOptions);
                that._options.useAggregation && _each(that.series, function(_, series) {
                    series._originalBusinessRange = series._originalBusinessRange || series.getRangeData();
                    var tr = that._getTranslator(series.pane, series.axis),
                        translators = {};
                    translators[rotated ? "x" : "y"] = tr.val;
                    translators[rotated ? "y" : "x"] = tr.arg;
                    series.resamplePoints(translators, that._zoomMinArg, that._zoomMaxArg)
                });
                if (_isDefined(that._zoomMinArg) || _isDefined(that._zoomMaxArg))
                    that._populateBusinessRange({
                        adjustOnZoom: that.themeManager.getOptions("adjustOnZoom"),
                        minArg: that._zoomMinArg,
                        maxArg: that._zoomMaxArg,
                        notApplyMargins: that._notApplyMargins
                    });
                if (that._options.useAggregation || _isDefined(that._zoomMinArg) || _isDefined(that._zoomMaxArg))
                    that._updateTranslators();
                return panesBorderOptions
            },
            _isLegendInside: function() {
                return this.legend && this.legend.getPosition() === "inside"
            },
            _renderAxes: function(drawOptions, panesBorderOptions, rotated) {
                if (drawOptions && drawOptions.recreateCanvas)
                    this.layoutManager.updatePanesCanvases(this.panes, this.canvas, rotated);
                this._drawAxes(panesBorderOptions, drawOptions)
            },
            _isRotated: function() {
                return this.themeManager.getOptions("rotated")
            },
            _getLayoutTargets: function() {
                return this.panes
            },
            _applyClipRects: function(panesBorderOptions) {
                var that = this,
                    canvasClipRectID = that._getCanvasClipRectID(),
                    i;
                that._drawPanesBorders(panesBorderOptions);
                that._createClipRectsForPanes();
                for (i = 0; i < that._argumentAxes.length; i++)
                    that._argumentAxes[i].applyClipRects(that._getElementsClipRectID(that._argumentAxes[i].pane), canvasClipRectID);
                for (i = 0; i < that._valueAxes.length; i++)
                    that._valueAxes[i].applyClipRects(that._getElementsClipRectID(that._valueAxes[i].pane), canvasClipRectID);
                that._fillPanesBackground()
            },
            _getSeriesRenderTimeout: function(drawOptions) {
                return drawOptions.asyncSeriesRendering ? ASYNC_SERIES_RENDERING_DELAY : undefined
            },
            _updateLegendAndTooltip: function(drawOptions, legendHasInsidePosition) {
                var that = this,
                    panes = that.panes,
                    rendererRoot = that.renderer.root;
                if (drawOptions.drawLegend && that.legend && legendHasInsidePosition) {
                    var newCanvas = _extend({}, panes[0].canvas),
                        layoutManager = charts.factory.createChartLayoutManager();
                    newCanvas.right = panes[panes.length - 1].canvas.right;
                    newCanvas.bottom = panes[panes.length - 1].canvas.bottom;
                    that._legendGroup.append(rendererRoot);
                    that._tooltipGroup.append(rendererRoot);
                    layoutManager.drawElements([that.legend], newCanvas);
                    layoutManager.placeDrawnElements(newCanvas)
                }
            },
            _drawSeries: function(drawOptions, rotated) {
                var that = this,
                    hideLayoutLabels = that.layoutManager.needMoreSpaceForPanesCanvas(that.panes, rotated) && !that.themeManager.getOptions("adaptiveLayout").keepLabels;
                _each(that.seriesFamilies || [], function(_, seriesFamily) {
                    var translators = that._getTranslator(seriesFamily.pane) || {};
                    seriesFamily.updateSeriesValues(translators);
                    seriesFamily.adjustSeriesDimensions(translators)
                });
                that._createCrosshairCursor();
                _each(that.series, function(_, particularSeries) {
                    that._applyPaneClipRect(particularSeries);
                    particularSeries.setAdjustSeriesLabels(drawOptions.adjustSeriesLabels);
                    var tr = that._getTranslator(particularSeries.pane, particularSeries.axis),
                        translators = {};
                    translators[rotated ? "x" : "y"] = tr.val;
                    translators[rotated ? "y" : "x"] = tr.arg;
                    particularSeries.draw(translators, drawOptions.animate && particularSeries.getPoints().length <= drawOptions.animationPointsLimit && that.renderer.animationEnabled(), hideLayoutLabels, that.legend && that.legend.getActionCallback(particularSeries))
                })
            },
            _applyPaneClipRect: function(seriesOptions) {
                var that = this,
                    paneIndex = that._getPaneIndex(seriesOptions.pane),
                    panesClipRects = that._panesClipRects,
                    wideClipRect = panesClipRects.wide[paneIndex];
                seriesOptions.setClippingParams(panesClipRects.base[paneIndex].id, wideClipRect && wideClipRect.id, that._getPaneBorderVisibility(paneIndex))
            },
            _createTranslators: function(drawOptions) {
                var that = this,
                    rotated = that.themeManager.getOptions("rotated"),
                    translators;
                if (!drawOptions.recreateCanvas)
                    return;
                that.translators = translators = {};
                that.layoutManager.updatePanesCanvases(that.panes, that.canvas, rotated);
                _each(that.paneAxis, function(paneName, pane) {
                    translators[paneName] = translators[paneName] || {};
                    _each(pane, function(axisName) {
                        var translator = that._createTranslator(new core.Range(that._getBusinessRange(paneName, axisName).val), that._getCanvasForPane(paneName), rotated ? {direction: "horizontal"} : {});
                        translator.pane = paneName;
                        translator.axis = axisName;
                        translators[paneName][axisName] = {val: translator}
                    })
                });
                _each(that._argumentAxes, function(_, axis) {
                    var translator = that._createTranslator(new core.Range(that._getBusinessRange(axis.pane).arg), that._getCanvasForPane(axis.pane), !rotated ? {direction: "horizontal"} : {});
                    _each(translators[axis.pane], function(valAxis, paneAxisTran) {
                        paneAxisTran.arg = translator
                    })
                })
            },
            _updateTranslators: function() {
                var that = this;
                _each(that.translators, function(pane, axisTrans) {
                    _each(axisTrans, function(axis, translator) {
                        translator.arg.updateBusinessRange(new core.Range(that._getBusinessRange(pane).arg));
                        delete translator.arg._originalBusinessRange;
                        translator.val.updateBusinessRange(new core.Range(that._getBusinessRange(pane, axis).val));
                        delete translator.val._originalBusinessRange
                    })
                })
            },
            _getAxesForTransform: function(rotated) {
                return {
                        verticalAxes: !rotated ? this._getValueAxes() : this._getArgumentAxes(),
                        horizontalAxes: !rotated ? this._getArgumentAxes() : this._getValueAxes()
                    }
            },
            _reinitTranslators: function() {
                var that = this;
                _each(that._argumentAxes, function(_, axis) {
                    var translator = that._getTranslator(axis.pane);
                    if (translator) {
                        translator.arg.reinit();
                        axis.setRange(translator.arg.getBusinessRange());
                        axis.setTranslator(translator.arg, translator.val)
                    }
                });
                _each(that._valueAxes, function(_, axis) {
                    var translator = that._getTranslator(axis.pane, axis.name);
                    if (translator) {
                        translator.val.reinit();
                        axis.setRange(translator.val.getBusinessRange());
                        axis.setTranslator(translator.val, translator.arg)
                    }
                })
            },
            _prepareAxesAndDraw: function(drawAxes, drawOptions) {
                var that = this,
                    i = 0,
                    layoutManager = that.layoutManager,
                    rotated = that.themeManager.getOptions("rotated"),
                    translators = that.translators,
                    adjustmentCounter = 0,
                    synchronizeMultiAxes = that.themeManager.getOptions('synchronizeMultiAxes'),
                    layoutTargets = that._getLayoutTargets(),
                    hElements = rotated ? that._valueAxes : that._argumentAxes,
                    vElements = rotated ? that._argumentAxes : that._valueAxes;
                if (that._scrollBar) {
                    that._scrollBar.setPane(layoutTargets);
                    if (rotated)
                        vElements = [that._scrollBar].concat(vElements);
                    else
                        hElements = hElements.concat([that._scrollBar])
                }
                do {
                    for (i = 0; i < that._argumentAxes.length; i++)
                        that._argumentAxes[i].resetTicks();
                    for (i = 0; i < that._valueAxes.length; i++)
                        that._valueAxes[i].resetTicks();
                    if (synchronizeMultiAxes)
                        charts.multiAxesSynchronizer.synchronize(that._valueAxes);
                    drawAxes(rotated ? that._valueAxes : that._argumentAxes);
                    layoutManager.requireAxesRedraw = false;
                    if (drawOptions.adjustAxes) {
                        layoutManager.applyHorizontalAxesLayout(hElements, layoutTargets, rotated);
                        !layoutManager.stopDrawAxes && _each(translators, function(pane, axisTrans) {
                            _each(axisTrans, function(axis, translator) {
                                translator.arg.reinit();
                                translator.val.reinit()
                            })
                        })
                    }
                    drawAxes(rotated ? that._argumentAxes : that._valueAxes);
                    if (drawOptions.adjustAxes && !layoutManager.stopDrawAxes) {
                        layoutManager.applyVerticalAxesLayout(vElements, layoutTargets, rotated);
                        !layoutManager.stopDrawAxes && _each(translators, function(pane, axisTrans) {
                            _each(axisTrans, function(axis, translator) {
                                translator.arg.reinit();
                                translator.val.reinit()
                            })
                        })
                    }
                    adjustmentCounter = adjustmentCounter + 1
                } while (!layoutManager.stopDrawAxes && layoutManager.requireAxesRedraw && adjustmentCounter < MAX_ADJUSTMENT_ATTEMPTS);
                this._scrollBar && this._scrollBar.applyLayout();
                that.__axisAdjustmentsCount = adjustmentCounter
            },
            _createCrosshairCursor: function() {
                var that = this,
                    commonCanvas,
                    directionCrosshairLines = ["horizontal", "vertical"],
                    options = that.themeManager.getOptions("crosshair") || {},
                    rotated = that.themeManager.getOptions("rotated");
                function getAxes(direction) {
                    return direction === "horizontal" ? !rotated ? that._valueAxes : that._argumentAxes : !rotated ? that._argumentAxes : that._valueAxes
                }
                if (!options || !options.enabled)
                    return;
                commonCanvas = that._getCommonCanvas();
                _each(directionCrosshairLines, function(_, direction) {
                    that._crosshair[direction] = charts.factory.createCrosshair(that.renderer, options, direction === "horizontal", commonCanvas, getAxes(direction), that._crosshairCursorGroup);
                    that._crosshair[direction].render()
                })
            },
            _getCommonCanvas: function() {
                var i,
                    canvas,
                    commonCanvas,
                    panes = this.panes;
                for (i = 0; i < panes.length; i++) {
                    canvas = panes[i].canvas;
                    if (!commonCanvas)
                        commonCanvas = _extend({}, canvas);
                    else {
                        commonCanvas.right = canvas.right;
                        commonCanvas.bottom = canvas.bottom
                    }
                }
                return commonCanvas
            },
            _createPanesBackground: function() {
                var that = this,
                    defaultBackgroundColor = that.themeManager.getOptions("commonPaneSettings").backgroundColor,
                    backgroundColor,
                    renderer = that.renderer,
                    rect,
                    i,
                    rects = [];
                that._panesBackgroundGroup && that._panesBackgroundGroup.clear();
                for (i = 0; i < that.panes.length; i++) {
                    backgroundColor = that.panes[i].backgroundColor || defaultBackgroundColor;
                    if (!backgroundColor || backgroundColor === "none") {
                        rects.push(null);
                        continue
                    }
                    rect = renderer.rect(0, 0, 0, 0).attr({
                        fill: backgroundColor,
                        "stroke-width": 0
                    }).append(that._panesBackgroundGroup);
                    rects.push(rect)
                }
                that.panesBackground = rects;
                that._panesBackgroundGroup.append(renderer.root)
            },
            _fillPanesBackground: function() {
                var that = this,
                    bc;
                _each(that.panes, function(i, pane) {
                    bc = pane.borderCoords;
                    if (that.panesBackground[i] != null)
                        that.panesBackground[i].attr({
                            x: bc.left,
                            y: bc.top,
                            width: bc.width,
                            height: bc.height
                        })
                })
            },
            _calcPaneBorderCoords: function(pane) {
                var canvas = pane.canvas,
                    bc = pane.borderCoords = pane.borderCoords || {};
                bc.left = canvas.left;
                bc.top = canvas.top;
                bc.right = canvas.width - canvas.right;
                bc.bottom = canvas.height - canvas.bottom;
                bc.width = Math.max(bc.right - bc.left, 0);
                bc.height = Math.max(bc.bottom - bc.top, 0)
            },
            _drawPanesBorders: function(panesBorderOptions) {
                var that = this,
                    rotated = that.themeManager.getOptions("rotated");
                that._panesBorderGroup && that._panesBorderGroup.remove().clear();
                _each(that.panes, function(i, pane) {
                    var bc,
                        borderOptions = panesBorderOptions[pane.name],
                        segmentRectParams,
                        attr = {
                            fill: "none",
                            stroke: borderOptions.color,
                            "stroke-opacity": borderOptions.opacity,
                            "stroke-width": borderOptions.width,
                            dashStyle: borderOptions.dashStyle,
                            "stroke-linecap": "square"
                        };
                    that._calcPaneBorderCoords(pane, rotated);
                    if (!borderOptions.visible)
                        return;
                    bc = pane.borderCoords;
                    segmentRectParams = prepareSegmentRectPoints(bc.left, bc.top, bc.width, bc.height, borderOptions);
                    that.renderer.path(segmentRectParams.points, segmentRectParams.pathType).attr(attr).append(that._panesBorderGroup)
                });
                that._panesBorderGroup.append(that.renderer.root)
            },
            _createClipRect: function(clipArray, index, left, top, width, height) {
                var that = this,
                    clipRect = clipArray[index];
                if (!clipRect) {
                    clipRect = that.renderer.clipRect(left, top, width, height);
                    clipArray[index] = clipRect
                }
                else
                    clipRect.attr({
                        x: left,
                        y: top,
                        width: width,
                        height: height
                    })
            },
            _createClipRectsForPanes: function() {
                var that = this,
                    canvas = that.canvas;
                _each(that.panes, function(i, pane) {
                    var hasFinancialSeries = false,
                        bc = pane.borderCoords,
                        left = bc.left,
                        top = bc.top,
                        width = bc.width,
                        height = bc.height,
                        panesClipRects = that._panesClipRects;
                    that._createClipRect(panesClipRects.fixed, i, left, top, width, height);
                    that._createClipRect(panesClipRects.base, i, left, top, width, height);
                    _each(that.series, function(_, series) {
                        if (series.pane === pane.name && series.isFinancialSeries())
                            hasFinancialSeries = true
                    });
                    if (hasFinancialSeries) {
                        if (that.themeManager.getOptions("rotated")) {
                            top = 0;
                            height = canvas.height
                        }
                        else {
                            left = 0;
                            width = canvas.width
                        }
                        that._createClipRect(panesClipRects.wide, i, left, top, width, height)
                    }
                    else
                        panesClipRects.wide.push(null)
                })
            },
            _getPaneIndex: function(paneName) {
                var paneIndex;
                _each(this.panes, function(index, pane) {
                    if (pane.name === paneName) {
                        paneIndex = index;
                        return false
                    }
                });
                return paneIndex
            },
            _getPaneBorderVisibility: function(paneIndex) {
                var commonPaneBorderVisible = this.themeManager.getOptions("commonPaneSettings").border.visible,
                    pane = this.panes[paneIndex] || {},
                    paneBorder = pane.border || {};
                return "visible" in paneBorder ? paneBorder.visible : commonPaneBorderVisible
            },
            _getElementsClipRectID: function(paneName) {
                return this._panesClipRects.fixed[this._getPaneIndex(paneName)].id
            },
            _getTranslator: function(paneName, axisName) {
                var paneTrans = this.translators[paneName],
                    foundTranslator = null;
                if (!paneTrans)
                    return foundTranslator;
                foundTranslator = paneTrans[axisName];
                if (!foundTranslator)
                    _each(paneTrans, function(axis, trans) {
                        foundTranslator = trans;
                        return false
                    });
                return foundTranslator
            },
            _getCanvasForPane: function(paneName) {
                var panes = this.panes,
                    panesNumber = panes.length,
                    i;
                for (i = 0; i < panesNumber; i++)
                    if (panes[i].name === paneName)
                        return panes[i].canvas
            },
            _getBusinessRange: function(paneName, axisName) {
                var ranges = this.businessRanges || [],
                    rangesNumber = ranges.length,
                    foundRange,
                    i;
                for (i = 0; i < rangesNumber; i++)
                    if (ranges[i].val.pane === paneName && ranges[i].val.axis === axisName) {
                        foundRange = ranges[i];
                        break
                    }
                if (!foundRange)
                    for (i = 0; i < rangesNumber; i++)
                        if (ranges[i].val.pane === paneName) {
                            foundRange = ranges[i];
                            break
                        }
                return foundRange
            },
            _transformArgument: function(translate, scale) {
                var that = this,
                    rotated = that.themeManager.getOptions("rotated"),
                    settings,
                    clipSettings,
                    panesClipRects = that._panesClipRects;
                if (!that._transformed) {
                    that._transformed = true;
                    that._labelsGroup.remove();
                    _each(that.series || [], function(i, s) {
                        s.applyClip()
                    })
                }
                if (rotated) {
                    settings = {
                        translateY: translate,
                        scaleY: scale
                    };
                    clipSettings = {
                        translateY: -translate / scale,
                        scaleY: 1 / scale
                    }
                }
                else {
                    settings = {
                        translateX: translate,
                        scaleX: scale
                    };
                    clipSettings = {
                        translateX: -translate / scale,
                        scaleX: 1 / scale
                    }
                }
                applyClipSettings(panesClipRects.base, clipSettings);
                applyClipSettings(panesClipRects.wide, clipSettings);
                that._seriesGroup.attr(settings);
                that._scrollBar && that._scrollBar.transform(-translate, scale)
            },
            _resetTransform: function() {
                var that = this,
                    settings = {
                        translateX: 0,
                        translateY: 0,
                        scaleX: null,
                        scaleY: null
                    },
                    panesClipRects = that._panesClipRects;
                applyClipSettings(panesClipRects.base, settings);
                applyClipSettings(panesClipRects.wide, settings);
                that._seriesGroup.attr(settings);
                _each(that.series || [], function(i, s) {
                    s.resetClip()
                });
                that._transformed = false
            },
            _getTrackerSettings: function(canvases) {
                var that = this,
                    themeManager = that.themeManager;
                return _extend(this.callBase(canvases), {
                        chart: that,
                        zoomingMode: themeManager.getOptions("zoomingMode"),
                        scrollingMode: themeManager.getOptions("scrollingMode"),
                        rotated: that._isRotated()
                    })
            },
            _resolveLabelOverlappingStack: function() {
                var that = this,
                    stackPoints = {},
                    isRotated = that._isRotated();
                _each(this.series, function(_, particularSeries) {
                    that._prepareStackPoints(particularSeries, stackPoints)
                });
                _each(stackPoints, function(_, stacks) {
                    _each(stacks, function(_, points) {
                        that._resolveLabelOverlappingInOneDirection(points, that._getCommonCanvas(), isRotated)
                    })
                })
            },
            zoomArgument: function(min, max, gesturesUsed) {
                var that = this,
                    zoomArg;
                if (!_isDefined(min) && !_isDefined(max))
                    return;
                zoomArg = that._argumentAxes[0].adjustZoomValues(min, max, gesturesUsed);
                that._zoomMinArg = zoomArg.min;
                that._zoomMaxArg = zoomArg.max;
                that._notApplyMargins = gesturesUsed;
                that._render({
                    force: true,
                    drawTitle: false,
                    drawLegend: false,
                    adjustAxes: false,
                    animate: false,
                    adjustSeriesLabels: false,
                    asyncSeriesRendering: false,
                    updateTracker: false
                })
            }
        }))
    })(jQuery, DevExpress);
    /*! Module viz-charts, file pieChart.js */
    (function($, DX, undefined) {
        var viz = DX.viz,
            core = viz.core,
            charts = viz.charts,
            utils = DX.utils,
            _extend = $.extend,
            _map = $.map,
            _noop = $.noop;
        DX.registerComponent("dxPieChart", viz.charts, charts.BaseChart.inherit({
            _chartType: 'pie',
            _reinitAxes: _noop,
            _correctAxes: _noop,
            _layoutManagerOptions: function() {
                var diameter = this.themeManager.getOptions('diameter');
                if (utils.isNumber(diameter)) {
                    if (diameter > 1)
                        diameter = 1;
                    else if (diameter < 0)
                        diameter = 0
                }
                else
                    diameter = undefined;
                return _extend(true, {}, this.callBase(), {piePercentage: diameter})
            },
            _groupSeries: function() {
                this._groupedSeries = [this.series]
            },
            _populateBusinessRange: function() {
                var businessRanges = [],
                    series = this.series,
                    singleSeries = series[0],
                    range = new core.Range,
                    singleSeriesRange;
                this._disposeObjectsInArray("businessRanges");
                if (singleSeries) {
                    singleSeriesRange = singleSeries.getRangeData();
                    range.addRange(singleSeriesRange.val);
                    if (!range.isDefined())
                        range.setStubData();
                    businessRanges.push(range)
                }
                this.businessRanges = businessRanges
            },
            _seriesVisibilityChanged: function() {
                this.series[0].arrangePoints();
                this._populateBusinessRange();
                this._refresh()
            },
            _createTranslator: function(range) {
                return core.CoreFactory.createTranslator1D(range.min, range.max, 360, 0)
            },
            _populateSeries: function() {
                var that = this,
                    themeManager = that.themeManager,
                    hasSeriesTemplate = !!themeManager.getOptions("seriesTemplate"),
                    seriesOptions = hasSeriesTemplate ? that._templatedSeries : that.option("series"),
                    allSeriesOptions = $.isArray(seriesOptions) ? seriesOptions : seriesOptions ? [seriesOptions] : [],
                    data,
                    particularSeriesOptions,
                    particularSeries,
                    seriesTheme;
                that._disposeSeries();
                that.series = [];
                themeManager.resetPalette();
                if (allSeriesOptions.length) {
                    particularSeriesOptions = _extend(true, {}, allSeriesOptions[0]);
                    if (particularSeriesOptions.type && !utils.isString(particularSeriesOptions.type))
                        particularSeriesOptions.type = "";
                    data = particularSeriesOptions.data;
                    particularSeriesOptions.data = null;
                    particularSeriesOptions.incidentOccured = that._incidentOccured;
                    seriesTheme = themeManager.getOptions("series", particularSeriesOptions, true);
                    seriesTheme.visibilityChanged = $.proxy(that._seriesVisibilityChanged, that);
                    seriesTheme.customizePoint = themeManager.getOptions("customizePoint");
                    seriesTheme.customizeLabel = themeManager.getOptions("customizeLabel");
                    particularSeries = core.CoreFactory.createSeries({
                        renderer: that.renderer,
                        seriesGroup: that._seriesGroup,
                        labelsGroup: that._labelsGroup
                    }, seriesTheme);
                    if (!particularSeries.isUpdated)
                        that._incidentOccured("E2101", [seriesTheme.type]);
                    else {
                        that._processSingleSeries(particularSeries);
                        that.series.push(particularSeries)
                    }
                    particularSeriesOptions.data = data
                }
                return that.series
            },
            _processSingleSeries: function(singleSeries) {
                singleSeries.arrangePoints()
            },
            _seriesPopulatedHandlerCore: _noop,
            _getLegendData: function() {
                return _map(this.series[0] ? this.series[0].getPoints() : [], function(item) {
                        return {
                                text: item.argument,
                                id: item.index,
                                states: item.getLegendStyles()
                            }
                    })
            },
            _prepareToRender: _noop,
            _isLegendInside: _noop,
            _renderAxes: _noop,
            _isRotated: _noop,
            _getLayoutTargets: function() {
                return [this]
            },
            _getAxesForTransform: function() {
                return {
                        verticalAxes: [],
                        horizontalAxes: []
                    }
            },
            _updateAxesLayout: _noop,
            _applyClipRects: _noop,
            _appendAdditionalSeriesGroups: _noop,
            _getSeriesRenderTimeout: _noop,
            _drawSeries: function(drawOptions) {
                var that = this,
                    singleSeries = that.series && that.series[0],
                    hideLayoutLabels;
                if (singleSeries) {
                    hideLayoutLabels = that.layoutManager.needMoreSpaceForPanesCanvas([that]) && !that.themeManager.getOptions("adaptiveLayout").keepLabels;
                    that.layoutManager.applyPieChartSeriesLayout(that.canvas, singleSeries, true);
                    singleSeries.canvas = that.canvas;
                    singleSeries.resetLabelSetups();
                    if (singleSeries.drawLabelsWOPoints(that._createTranslator(that.businessRanges[0], that.canvas)))
                        that.layoutManager.applyPieChartSeriesLayout(that.canvas, singleSeries, hideLayoutLabels);
                    singleSeries.draw(that._createTranslator(that.businessRanges[0], that.canvas), drawOptions.animate && that.renderer.animationEnabled(), hideLayoutLabels)
                }
            },
            _updateLegendAndTooltip: _noop,
            _renderTrackers: _noop,
            _createScrollBar: _noop,
            _resolveLabelOverlappingShift: function() {
                var points = _map(this.getSeries().getVisiblePoints(), function(point) {
                        var angleOfPoint = utils.normalizeAngle(point.middleAngle);
                        if (angleOfPoint < 90 || angleOfPoint >= 270)
                            return point
                    });
                this._resolveLabelOverlappingInOneDirection(points, this.canvas);
                points = _map(this.getSeries().getVisiblePoints(), function(point) {
                    var angleOfPoint = utils.normalizeAngle(point.middleAngle);
                    if (angleOfPoint >= 90 && angleOfPoint < 270)
                        return point
                });
                this._resolveLabelOverlappingInOneDirection(points, this.canvas);
                $.each(this.getSeries().getVisiblePoints(), function(_, point) {
                    point.setLabelEllipsis();
                    point.updateLabelCoord()
                })
            },
            getSeries: function getSeries() {
                return this.series && this.series[0]
            }
        }))
    })(jQuery, DevExpress);
    /*! Module viz-charts, file polarChart.js */
    (function($, DX, undefined) {
        var charts = DX.viz.charts,
            core = DX.viz.core,
            DEFAULT_PANE_NAME = 'default';
        var PolarChart = charts.AdvancedChart.inherit({
                _chartType: 'polar',
                _populateSeries: function() {
                    this.defaultPane = DEFAULT_PANE_NAME;
                    return this.callBase(arguments)
                },
                _createPanes: function() {
                    return [{name: DEFAULT_PANE_NAME}]
                },
                _prepareAxisOptions: function(typeSelector, axisOptions) {
                    return this.themeManager.getOptions(typeSelector, $.extend(true, axisOptions, {
                            drawingType: this._getTypeOfAxis(typeSelector),
                            incidentOccured: this._incidentOccured
                        }))
                },
                _getTypeOfAxis: function(type) {
                    type = type === "argumentAxis" ? "circular" : "linear";
                    if (this.option("useSpiderWeb"))
                        type += "Spider";
                    return type
                },
                _correctAxes: $.noop,
                _groupSeries: function() {
                    this._groupedSeries = [this.series];
                    this._groupedSeries[0].valueAxis = this._valueAxes[0];
                    this._groupedSeries.argumentAxes = this._argumentAxes
                },
                _processSingleSeries: $.noop,
                _prepareToRender: function() {
                    this._appendAxesGroups();
                    return {}
                },
                _isLegendInside: $.noop,
                _renderAxes: function(drawOptions) {
                    this._drawAxes({}, drawOptions)
                },
                _reinitTranslators: function() {
                    var that = this,
                        valueAxes = that._valueAxes,
                        argumentAxes = that._argumentAxes,
                        argumentBR = new core.Range(that.businessRanges[0].arg),
                        valueBR = new core.Range(that.businessRanges[0].val),
                        translator = that._createTranslator({
                            arg: argumentBR,
                            val: valueBR
                        });
                    that.translator = translator;
                    argumentAxes[0].setRange(argumentBR);
                    argumentAxes[0].setTranslator(translator);
                    for (var i = 0; i < valueAxes.length; i++) {
                        valueAxes[i].setRange(valueBR);
                        valueAxes[i].setTranslator(translator)
                    }
                },
                _prepareAxesAndDraw: function(drawAxes) {
                    var that = this,
                        valueAxes = that._valueAxes,
                        argAxes = that._argumentAxes,
                        argumentAxis = argAxes[0];
                    that._calcCanvas(argumentAxis.measureLabels());
                    that.translator.reinit();
                    argumentAxis.setTranslator(that.translator);
                    drawAxes(argAxes);
                    $.each(valueAxes, function(_, valAxis) {
                        valAxis.setSpiderTicks(argumentAxis.getSpiderTicks())
                    });
                    drawAxes(valueAxes)
                },
                _calcCanvas: function(measure) {
                    var canvas = this.translator.canvas;
                    canvas.left += measure.width;
                    canvas.right += measure.width;
                    canvas.top += measure.height;
                    canvas.bottom += measure.height
                },
                _isRotated: $.noop,
                _getLayoutTargets: function() {
                    return [this]
                },
                _getAxesForTransform: function() {
                    var argAxes = this._getArgumentAxes();
                    return {
                            verticalAxes: argAxes,
                            horizontalAxes: argAxes
                        }
                },
                _applyClipRects: $.noop,
                _getSeriesRenderTimeout: $.noop,
                _drawSeries: function(drawOptions) {
                    var that = this,
                        seriesFamilies = that.seriesFamilies || [],
                        series = that.series;
                    if (!series.length)
                        return;
                    for (var i = 0; i < seriesFamilies.length; i++) {
                        var translators = {};
                        translators.val = that.translator;
                        translators.arg = that.translator;
                        seriesFamilies[i].updateSeriesValues(translators);
                        seriesFamilies[i].adjustSeriesDimensions(translators)
                    }
                    for (var i = 0; i < series.length; i++)
                        series[i].draw(that.translator, drawOptions.animate && that.renderer.animationEnabled())
                },
                _updateLegendAndTooltip: $.noop,
                _createScrollBar: $.noop,
                _createTranslator: function(br) {
                    var themeManager = this.themeManager,
                        axisUserOptions = this.option("argumentAxis"),
                        axisOptions = themeManager.getOptions("argumentAxis", axisUserOptions) || {},
                        firstPointOnStartAngle = !this.option("useSpiderWeb") ? axisOptions.firstPointOnStartAngle : true;
                    return new core.PolarTranslator(br, $.extend(true, {}, this.canvas), {
                            startAngle: axisOptions.startAngle,
                            firstPointOnStartAngle: firstPointOnStartAngle
                        })
                },
                _getSeriesForPane: function() {
                    return this.series
                }
            });
        DX.registerComponent('dxPolarChart', charts, PolarChart)
    })(jQuery, DevExpress);
    /*! Module viz-charts, file layoutManager.js */
    (function($, DX, undefined) {
        var _isNumber = DX.utils.isNumber,
            _decreaseGaps = DX.viz.core.utils.decreaseGaps,
            _round = Math.round,
            _min = Math.min,
            _max = Math.max,
            _floor = Math.floor,
            _sqrt = Math.sqrt,
            _each = $.each,
            _extend = $.extend;
        function correctElementsPosition(elements, direction, canvas) {
            _each(elements, function(_, element) {
                var options = element.getLayoutOptions(),
                    side = options.cutLayoutSide;
                canvas[side] -= options[direction]
            })
        }
        function placeElementAndCutCanvas(elements, canvas) {
            _each(elements, function(_, element) {
                var shiftX,
                    shiftY,
                    options = element.getLayoutOptions(),
                    length = getLength(options.cutLayoutSide);
                if (!options.width)
                    return;
                switch (options.horizontalAlignment) {
                    case"left":
                        shiftX = canvas.left;
                        break;
                    case"center":
                        shiftX = (canvas.width - canvas.left - canvas.right - options.width) / 2 + canvas.left;
                        break;
                    case"right":
                        shiftX = canvas.width - canvas.right - options.width;
                        break
                }
                switch (options.verticalAlignment) {
                    case"top":
                        shiftY = canvas.top;
                        break;
                    case"bottom":
                        shiftY = canvas.height - canvas.bottom - options.height;
                        break
                }
                element.shift(_round(shiftX), _round(shiftY));
                canvas[options.cutLayoutSide] += options[length];
                setCanvasValues(canvas)
            })
        }
        function getLength(side) {
            return side === 'left' || side === 'right' ? 'width' : 'height'
        }
        function setCanvasValues(canvas) {
            if (canvas) {
                canvas.originalTop = canvas.top;
                canvas.originalBottom = canvas.bottom;
                canvas.originalLeft = canvas.left;
                canvas.originalRight = canvas.right
            }
        }
        function updateElements(elements, length, otherLength, dirtyCanvas, canvas, needRemoveSpace) {
            _each(elements, function(_, element) {
                var options = element.getLayoutOptions(),
                    side = options.cutLayoutSide,
                    freeSpaceWidth = dirtyCanvas.width - dirtyCanvas.left - dirtyCanvas.right,
                    freeSpaceHeight = dirtyCanvas.height - dirtyCanvas.top - dirtyCanvas.bottom,
                    updateObject = {};
                element.setSize({
                    width: freeSpaceWidth,
                    height: freeSpaceHeight
                });
                updateObject[otherLength] = 0;
                updateObject[length] = needRemoveSpace[length];
                element.changeSize(updateObject);
                canvas[side] -= options[length] - element.getLayoutOptions()[length];
                needRemoveSpace[length] -= options[length] - element.getLayoutOptions()[length]
            })
        }
        function updateAxis(axes, side, needRemoveSpace) {
            if (axes && needRemoveSpace[side] > 0) {
                _each(axes, function(i, axis) {
                    var bbox = axis.getBoundingRect();
                    axis.updateSize();
                    needRemoveSpace[side] -= bbox[side] - axis.getBoundingRect()[side]
                });
                if (needRemoveSpace[side] > 0)
                    _each(axes, function(_, axis) {
                        axis.updateSize(true)
                    })
            }
        }
        function getNearestCoord(firstCoord, secondCoord, pointCenterCoord) {
            var nearestCoord;
            if (pointCenterCoord < firstCoord)
                nearestCoord = firstCoord;
            else if (secondCoord < pointCenterCoord)
                nearestCoord = secondCoord;
            else
                nearestCoord = pointCenterCoord;
            return nearestCoord
        }
        function getLengthFromCenter(x, y, paneCenterX, paneCenterY) {
            return _sqrt((x - paneCenterX) * (x - paneCenterX) + (y - paneCenterY) * (y - paneCenterY))
        }
        function getInnerRadius(series) {
            var innerRadius;
            if (series.type === "pie")
                innerRadius = 0;
            else {
                innerRadius = _isNumber(series.innerRadius) ? Number(series.innerRadius) : 0.5;
                innerRadius = innerRadius < 0.2 ? 0.2 : innerRadius;
                innerRadius = innerRadius > 0.8 ? 0.8 : innerRadius
            }
            return innerRadius
        }
        function isValidBox(box) {
            return !!(box.x || box.y || box.width || box.height)
        }
        function correctDeltaMarginValue(panes, marginSides) {
            var canvasCell,
                canvas,
                deltaSide,
                requireAxesRedraw;
            _each(panes, function(_, pane) {
                canvas = pane.canvas;
                _each(marginSides, function(_, side) {
                    deltaSide = "delta" + side;
                    canvas[deltaSide] = _max(canvas[deltaSide] - (canvas[side.toLowerCase()] - canvas["original" + side]), 0);
                    if (canvas[deltaSide] > 0)
                        requireAxesRedraw = true
                })
            });
            return requireAxesRedraw
        }
        function getPane(name, panes) {
            var findPane = panes[0];
            _each(panes, function(_, pane) {
                if (name === pane.name)
                    findPane = pane
            });
            return findPane
        }
        function applyFoundExceedings(panes, rotated) {
            var stopDrawAxes,
                maxLeft = 0,
                maxRight = 0,
                maxTop = 0,
                maxBottom = 0,
                maxColNumber = 0;
            _each(panes, function(_, pane) {
                maxLeft = _max(maxLeft, pane.canvas.deltaLeft);
                maxRight = _max(maxRight, pane.canvas.deltaRight);
                maxTop = _max(maxTop, pane.canvas.deltaTop);
                maxBottom = _max(maxBottom, pane.canvas.deltaBottom)
            });
            if (rotated)
                _each(panes, function(_, pane) {
                    pane.canvas.top += maxTop;
                    pane.canvas.bottom += maxBottom;
                    pane.canvas.right += pane.canvas.deltaRight;
                    pane.canvas.left += pane.canvas.deltaLeft
                });
            else
                _each(panes, function(_, pane) {
                    pane.canvas.top += pane.canvas.deltaTop;
                    pane.canvas.bottom += pane.canvas.deltaBottom;
                    pane.canvas.right += maxRight;
                    pane.canvas.left += maxLeft
                });
            _each(panes, function(_, pane) {
                if (pane.canvas.top + pane.canvas.bottom > pane.canvas.height)
                    stopDrawAxes = true;
                if (pane.canvas.left + pane.canvas.right > pane.canvas.width)
                    stopDrawAxes = true
            });
            return stopDrawAxes
        }
        function LayoutManager(options) {
            this._verticalElements = [];
            this._horizontalElements = [];
            this._options = options
        }
        LayoutManager.prototype = {
            constructor: LayoutManager,
            dispose: function() {
                this._verticalElements = this._horizontalElements = this._options = null
            },
            drawElements: function(elements, canvas) {
                var horizontalElements = [],
                    verticalElements = [];
                _each(elements, function(_, element) {
                    var options,
                        length;
                    element.setSize({
                        width: canvas.width - canvas.left - canvas.right,
                        height: canvas.height - canvas.top - canvas.bottom
                    });
                    element.draw();
                    options = element.getLayoutOptions();
                    if (options) {
                        length = getLength(options.cutLayoutSide);
                        (length === 'width' ? horizontalElements : verticalElements).push(element);
                        canvas[options.cutLayoutSide] += options[length];
                        setCanvasValues(canvas)
                    }
                });
                this._horizontalElements = horizontalElements;
                this._verticalElements = verticalElements;
                return this
            },
            placeDrawnElements: function(canvas) {
                correctElementsPosition(this._horizontalElements, 'width', canvas);
                placeElementAndCutCanvas(this._horizontalElements, canvas);
                correctElementsPosition(this._verticalElements, 'height', canvas);
                placeElementAndCutCanvas(this._verticalElements, canvas);
                return this
            },
            updatePanesCanvases: function(panes, canvas, rotated) {
                var weightSum = 0;
                _each(panes, function(_, pane) {
                    pane.weight = pane.weight || 1;
                    weightSum += pane.weight
                });
                var distributedSpace = 0,
                    padding = panes.padding || 10,
                    paneSpace = rotated ? canvas.width - canvas.left - canvas.right : canvas.height - canvas.top - canvas.bottom,
                    oneWeight = (paneSpace - padding * (panes.length - 1)) / weightSum,
                    startName = rotated ? "left" : "top",
                    endName = rotated ? "right" : "bottom";
                _each(panes, function(_, pane) {
                    var calcLength = _round(pane.weight * oneWeight);
                    pane.canvas = pane.canvas || {};
                    _extend(pane.canvas, {
                        deltaLeft: 0,
                        deltaRight: 0,
                        deltaTop: 0,
                        deltaBottom: 0
                    }, canvas);
                    pane.canvas[startName] = canvas[startName] + distributedSpace;
                    pane.canvas[endName] = canvas[endName] + (paneSpace - calcLength - distributedSpace);
                    distributedSpace = distributedSpace + calcLength + padding;
                    setCanvasValues(pane.canvas)
                })
            },
            applyVerticalAxesLayout: function(axes, panes, rotated) {
                this._applyAxesLayout(axes, panes, rotated)
            },
            applyHorizontalAxesLayout: function(axes, panes, rotated) {
                axes.reverse();
                this._applyAxesLayout(axes, panes, rotated);
                axes.reverse()
            },
            _applyAxesLayout: function(axes, panes, rotated) {
                var that = this,
                    canvas,
                    axisPanePosition,
                    axisPosition,
                    canvasCell,
                    box,
                    delta,
                    axis,
                    axisLength,
                    direction,
                    directionMultiplier,
                    someDirection = [],
                    pane,
                    i;
                _each(panes, function(_, pane) {
                    _extend(pane.canvas, {
                        deltaLeft: 0,
                        deltaRight: 0,
                        deltaTop: 0,
                        deltaBottom: 0
                    })
                });
                for (i = 0; i < axes.length; i++) {
                    axis = axes[i];
                    axisPosition = axis.getOptions().position || "left";
                    axis.delta = {};
                    box = axis.getBoundingRect();
                    pane = getPane(axis.pane, panes);
                    canvas = pane.canvas;
                    if (!isValidBox(box))
                        continue;
                    direction = "delta" + axisPosition.slice(0, 1).toUpperCase() + axisPosition.slice(1);
                    switch (axisPosition) {
                        case"right":
                            directionMultiplier = 1;
                            canvas.deltaLeft += axis.padding ? axis.padding.left : 0;
                            break;
                        case"left":
                            directionMultiplier = -1;
                            canvas.deltaRight += axis.padding ? axis.padding.right : 0;
                            break;
                        case"top":
                            directionMultiplier = -1;
                            canvas.deltaBottom += axis.padding ? axis.padding.bottom : 0;
                            break;
                        case"bottom":
                            directionMultiplier = 1;
                            canvas.deltaTop += axis.padding ? axis.padding.top : 0;
                            break
                    }
                    switch (axisPosition) {
                        case"right":
                        case"left":
                            if (!box.isEmpty) {
                                delta = box.y + box.height - (canvas.height - canvas.originalBottom);
                                if (delta > 0) {
                                    that.requireAxesRedraw = true;
                                    canvas.deltaBottom += delta
                                }
                                delta = canvas.originalTop - box.y;
                                if (delta > 0) {
                                    that.requireAxesRedraw = true;
                                    canvas.deltaTop += delta
                                }
                            }
                            axisLength = box.width;
                            someDirection = ["Left", "Right"];
                            break;
                        case"top":
                        case"bottom":
                            if (!box.isEmpty) {
                                delta = box.x + box.width - (canvas.width - canvas.originalRight);
                                if (delta > 0) {
                                    that.requireAxesRedraw = true;
                                    canvas.deltaRight += delta
                                }
                                delta = canvas.originalLeft - box.x;
                                if (delta > 0) {
                                    that.requireAxesRedraw = true;
                                    canvas.deltaLeft += delta
                                }
                            }
                            someDirection = ["Bottom", "Top"];
                            axisLength = box.height;
                            break
                    }
                    if (!axis.delta[axisPosition] && canvas[direction] > 0)
                        canvas[direction] += axis.getMultipleAxesSpacing();
                    axis.delta[axisPosition] = axis.delta[axisPosition] || 0;
                    axis.delta[axisPosition] += canvas[direction] * directionMultiplier;
                    canvas[direction] += axisLength
                }
                that.requireAxesRedraw = correctDeltaMarginValue(panes, someDirection) || that.requireAxesRedraw;
                that.stopDrawAxes = applyFoundExceedings(panes, rotated)
            },
            applyPieChartSeriesLayout: function(canvas, singleSeries, hideLayoutLabels) {
                var paneSpaceHeight = canvas.height - canvas.top - canvas.bottom,
                    paneSpaceWidth = canvas.width - canvas.left - canvas.right,
                    paneCenterX = paneSpaceWidth / 2 + canvas.left,
                    paneCenterY = paneSpaceHeight / 2 + canvas.top,
                    piePercentage = this._options.piePercentage,
                    accessibleRadius = _isNumber(piePercentage) ? piePercentage * _min(canvas.height, canvas.width) / 2 : _min(paneSpaceWidth, paneSpaceHeight) / 2,
                    minR = 0.7 * accessibleRadius,
                    innerRadius = getInnerRadius(singleSeries);
                if (!hideLayoutLabels && !_isNumber(piePercentage))
                    _each(singleSeries.getPoints(), function(_, point) {
                        if (point._label.hasText() && point.isVisible()) {
                            var labelBBox = point._label.getBoundingRect(),
                                nearestX = getNearestCoord(labelBBox.x, labelBBox.x + labelBBox.width, paneCenterX),
                                nearestY = getNearestCoord(labelBBox.y, labelBBox.y + labelBBox.height, paneCenterY),
                                minRadiusWithLabels = _max(getLengthFromCenter(nearestX, nearestY, paneCenterX, paneCenterY) - DX.viz.core.series.helpers.consts.pieLabelIndent, minR);
                            accessibleRadius = _min(accessibleRadius, minRadiusWithLabels)
                        }
                    });
                singleSeries.correctPosition({
                    centerX: _floor(paneCenterX),
                    centerY: _floor(paneCenterY),
                    radiusInner: _floor(accessibleRadius * innerRadius),
                    radiusOuter: _floor(accessibleRadius)
                })
            },
            updateDrawnElements: function(axes, canvas, dirtyCanvas, panes, rotated) {
                var needRemoveSpace,
                    saveDirtyCanvas = _extend({}, dirtyCanvas);
                needRemoveSpace = this.needMoreSpaceForPanesCanvas(panes, rotated);
                if (!needRemoveSpace)
                    return;
                needRemoveSpace.height = _decreaseGaps(dirtyCanvas, ["top", "bottom"], needRemoveSpace.height);
                needRemoveSpace.width = _decreaseGaps(dirtyCanvas, ["left", "right"], needRemoveSpace.width);
                canvas.top -= saveDirtyCanvas.top - dirtyCanvas.top;
                canvas.bottom -= saveDirtyCanvas.bottom - dirtyCanvas.bottom;
                canvas.left -= saveDirtyCanvas.left - dirtyCanvas.left;
                canvas.right -= saveDirtyCanvas.right - dirtyCanvas.right;
                updateElements(this._horizontalElements, "width", "height", dirtyCanvas, canvas, needRemoveSpace);
                updateElements(this._verticalElements, "height", "width", dirtyCanvas, canvas, needRemoveSpace);
                updateAxis(axes.verticalAxes, "width", needRemoveSpace);
                updateAxis(axes.horizontalAxes, "height", needRemoveSpace)
            },
            needMoreSpaceForPanesCanvas: function(panes, rotated) {
                var options = this._options,
                    width = options.width,
                    height = options.height,
                    piePercentage = options.piePercentage,
                    percentageIsValid = _isNumber(piePercentage),
                    needHorizontalSpace = 0,
                    needVerticalSpace = 0;
                _each(panes, function(_, pane) {
                    var paneCanvas = pane.canvas,
                        minSize = percentageIsValid ? _min(paneCanvas.width, paneCanvas.height) * piePercentage : undefined,
                        needPaneHorizonralSpace = (percentageIsValid ? minSize : width) - (paneCanvas.width - paneCanvas.left - paneCanvas.right),
                        needPaneVerticalSpace = (percentageIsValid ? minSize : height) - (paneCanvas.height - paneCanvas.top - paneCanvas.bottom);
                    if (rotated) {
                        needHorizontalSpace += needPaneHorizonralSpace > 0 ? needPaneHorizonralSpace : 0;
                        needVerticalSpace = _max(needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0, needVerticalSpace)
                    }
                    else {
                        needHorizontalSpace = _max(needPaneHorizonralSpace > 0 ? needPaneHorizonralSpace : 0, needHorizontalSpace);
                        needVerticalSpace += needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0
                    }
                });
                return needHorizontalSpace > 0 || needVerticalSpace > 0 ? {
                        width: needHorizontalSpace,
                        height: needVerticalSpace
                    } : false
            },
            correctSizeElement: function(element, canvas) {
                element.setSize({
                    width: canvas.width - canvas.right - canvas.left,
                    height: canvas.width - canvas.right - canvas.left
                });
                element.changeSize({
                    width: 0,
                    height: 0
                })
            }
        };
        DX.viz.charts._setCanvasValues = setCanvasValues;
        DX.viz.charts.LayoutManager = LayoutManager
    })(jQuery, DevExpress);
    /*! Module viz-charts, file multiAxesSynchronizer.js */
    (function($, DX, undefined) {
        var Range = DX.viz.core.Range,
            utils = DX.utils,
            _adjustValue = utils.adjustValue,
            _applyPrecisionByMinDelta = utils.applyPrecisionByMinDelta,
            _isDefined = utils.isDefined,
            _math = Math,
            _floor = _math.floor,
            _max = _math.max,
            _each = $.each,
            MIN_RANGE_FOR_ADJUST_BOUNDS = 0.1;
        var getValueAxesPerPanes = function(valueAxes) {
                var result = {};
                _each(valueAxes, function(_, axis) {
                    var pane = axis.pane;
                    if (!result[pane])
                        result[pane] = [];
                    result[pane].push(axis)
                });
                return result
            };
        var restoreOriginalBusinessRange = function(axis) {
                var businessRange,
                    translator = axis.getTranslator();
                if (!translator._originalBusinessRange)
                    translator._originalBusinessRange = new Range(translator.getBusinessRange());
                else {
                    businessRange = new Range(translator._originalBusinessRange);
                    translator.updateBusinessRange(businessRange);
                    axis.setRange(businessRange)
                }
            };
        var linearConvertor = {
                transform: function(v, b) {
                    return utils.getLog(v, b)
                },
                addInterval: function(v, i) {
                    return v + i
                },
                getInterval: function(base, tickInterval) {
                    return tickInterval
                },
                adjustValue: _floor
            };
        var logConvertor = {
                transform: function(v, b) {
                    return utils.raiseTo(v, b)
                },
                addInterval: function(v, i) {
                    return v * i
                },
                getInterval: function(base, tickInterval) {
                    return _math.pow(base, tickInterval)
                },
                adjustValue: _adjustValue
            };
        var convertAxisInfo = function(axisInfo, convertor) {
                if (!axisInfo.isLogarithmic)
                    return;
                var base = axisInfo.logarithmicBase,
                    tickValues = axisInfo.tickValues,
                    tick,
                    ticks = [],
                    interval;
                axisInfo.minValue = convertor.transform(axisInfo.minValue, base);
                axisInfo.oldMinValue = convertor.transform(axisInfo.oldMinValue, base);
                axisInfo.maxValue = convertor.transform(axisInfo.maxValue, base);
                axisInfo.oldMaxValue = convertor.transform(axisInfo.oldMaxValue, base);
                axisInfo.tickInterval = _math.round(axisInfo.tickInterval);
                if (axisInfo.tickInterval < 1)
                    axisInfo.tickInterval = 1;
                interval = convertor.getInterval(base, axisInfo.tickInterval);
                for (tick = convertor.adjustValue(convertor.transform(tickValues[0], base)); ticks.length < tickValues.length; tick = convertor.addInterval(tick, interval))
                    ticks.push(tick);
                ticks.tickInterval = axisInfo.tickInterval;
                axisInfo.tickValues = ticks
            };
        var populateAxesInfo = function(axes) {
                return $.map(axes, function(axis) {
                        restoreOriginalBusinessRange(axis);
                        var ticksValues = axis.getTicksValues(),
                            majorTicks = ticksValues.majorTicksValues,
                            options = axis.getOptions(),
                            minValue,
                            maxValue,
                            axisInfo = null,
                            businessRange,
                            tickInterval,
                            synchronizedValue;
                        if (majorTicks && majorTicks.length > 0 && utils.isNumber(majorTicks[0]) && options.type !== "discrete") {
                            businessRange = axis.getTranslator().getBusinessRange();
                            tickInterval = axis._tickManager.getTickInterval();
                            minValue = businessRange.minVisible;
                            maxValue = businessRange.maxVisible;
                            synchronizedValue = options.synchronizedValue;
                            if (minValue === maxValue && _isDefined(synchronizedValue)) {
                                minValue = majorTicks[0] - 1;
                                maxValue = majorTicks[0] + 1;
                                tickInterval = 1
                            }
                            axisInfo = {
                                axis: axis,
                                isLogarithmic: options.type === "logarithmic",
                                logarithmicBase: businessRange.base,
                                tickValues: majorTicks,
                                minorValues: ticksValues.minorTicksValues,
                                minValue: minValue,
                                oldMinValue: minValue,
                                maxValue: maxValue,
                                oldMaxValue: maxValue,
                                inverted: businessRange.invert,
                                tickInterval: tickInterval,
                                synchronizedValue: synchronizedValue
                            };
                            if (businessRange.stubData) {
                                axisInfo.stubData = true;
                                axisInfo.tickInterval = axisInfo.tickInterval || options.tickInterval;
                                axisInfo.isLogarithmic = false
                            }
                            convertAxisInfo(axisInfo, linearConvertor);
                            DX.utils.debug.assert(axisInfo.tickInterval !== undefined && axisInfo.tickInterval !== null, "tickInterval was not provided")
                        }
                        return axisInfo
                    })
            };
        var updateTickValues = function(axesInfo) {
                var maxTicksCount = 0;
                _each(axesInfo, function(_, axisInfo) {
                    maxTicksCount = _max(maxTicksCount, axisInfo.tickValues.length)
                });
                _each(axesInfo, function(_, axisInfo) {
                    var ticksMultiplier,
                        ticksCount,
                        additionalStartTicksCount = 0,
                        synchronizedValue = axisInfo.synchronizedValue,
                        tickValues = axisInfo.tickValues,
                        tickInterval = axisInfo.tickInterval;
                    if (_isDefined(synchronizedValue)) {
                        axisInfo.baseTickValue = axisInfo.invertedBaseTickValue = synchronizedValue;
                        axisInfo.tickValues = [axisInfo.baseTickValue]
                    }
                    else {
                        if (tickValues.length > 1 && tickInterval) {
                            ticksMultiplier = _floor((maxTicksCount + 1) / tickValues.length);
                            ticksCount = ticksMultiplier > 1 ? _floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;
                            additionalStartTicksCount = _floor((ticksCount - tickValues.length) / 2);
                            while (additionalStartTicksCount > 0 && tickValues[0] !== 0) {
                                tickValues.unshift(_applyPrecisionByMinDelta(tickValues[0], tickInterval, tickValues[0] - tickInterval));
                                additionalStartTicksCount--
                            }
                            while (tickValues.length < ticksCount)
                                tickValues.push(_applyPrecisionByMinDelta(tickValues[0], tickInterval, tickValues[tickValues.length - 1] + tickInterval));
                            axisInfo.tickInterval = tickInterval / ticksMultiplier
                        }
                        axisInfo.baseTickValue = tickValues[0];
                        axisInfo.invertedBaseTickValue = tickValues[tickValues.length - 1]
                    }
                })
            };
        var getAxisRange = function(axisInfo) {
                return axisInfo.maxValue - axisInfo.minValue || 1
            };
        var getMainAxisInfo = function(axesInfo) {
                for (var i = 0; i < axesInfo.length; i++)
                    if (!axesInfo[i].stubData)
                        return axesInfo[i];
                return null
            };
        var correctMinMaxValues = function(axesInfo) {
                var mainAxisInfo = getMainAxisInfo(axesInfo),
                    mainAxisInfoTickInterval = mainAxisInfo.tickInterval;
                _each(axesInfo, function(_, axisInfo) {
                    var scale,
                        move,
                        mainAxisBaseValueOffset,
                        valueFromAxisInfo;
                    if (axisInfo !== mainAxisInfo) {
                        if (mainAxisInfoTickInterval && axisInfo.tickInterval) {
                            if (axisInfo.stubData && _isDefined(axisInfo.synchronizedValue)) {
                                axisInfo.oldMinValue = axisInfo.minValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;
                                axisInfo.oldMaxValue = axisInfo.maxValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfoTickInterval * axisInfo.tickInterval
                            }
                            scale = mainAxisInfoTickInterval / getAxisRange(mainAxisInfo) / axisInfo.tickInterval * getAxisRange(axisInfo);
                            axisInfo.maxValue = axisInfo.minValue + getAxisRange(axisInfo) / scale
                        }
                        if (mainAxisInfo.inverted && !axisInfo.inverted || !mainAxisInfo.inverted && axisInfo.inverted)
                            mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue;
                        else
                            mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue;
                        valueFromAxisInfo = getAxisRange(axisInfo);
                        move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (axisInfo.baseTickValue - axisInfo.minValue) / valueFromAxisInfo) * valueFromAxisInfo;
                        axisInfo.minValue -= move;
                        axisInfo.maxValue -= move
                    }
                })
            };
        var calculatePaddings = function(axesInfo) {
                var minPadding,
                    maxPadding,
                    startPadding = 0,
                    endPadding = 0;
                _each(axesInfo, function(_, axisInfo) {
                    var inverted = axisInfo.inverted;
                    minPadding = axisInfo.minValue > axisInfo.oldMinValue ? (axisInfo.minValue - axisInfo.oldMinValue) / getAxisRange(axisInfo) : 0;
                    maxPadding = axisInfo.maxValue < axisInfo.oldMaxValue ? (axisInfo.oldMaxValue - axisInfo.maxValue) / getAxisRange(axisInfo) : 0;
                    startPadding = _max(startPadding, inverted ? maxPadding : minPadding);
                    endPadding = _max(endPadding, inverted ? minPadding : maxPadding)
                });
                return {
                        start: startPadding,
                        end: endPadding
                    }
            };
        var correctMinMaxValuesByPaddings = function(axesInfo, paddings) {
                _each(axesInfo, function(_, info) {
                    var range = getAxisRange(info),
                        inverted = info.inverted;
                    info.minValue -= paddings[inverted ? "end" : "start"] * range;
                    info.maxValue += paddings[inverted ? "start" : "end"] * range;
                    if (range > MIN_RANGE_FOR_ADJUST_BOUNDS) {
                        info.minValue = _math.min(info.minValue, _adjustValue(info.minValue));
                        info.maxValue = _max(info.maxValue, _adjustValue(info.maxValue))
                    }
                })
            };
        var updateTickValuesIfSyncronizedValueUsed = function(axesInfo) {
                var hasSyncronizedValue = false;
                _each(axesInfo, function(_, info) {
                    hasSyncronizedValue = hasSyncronizedValue || _isDefined(info.synchronizedValue)
                });
                _each(axesInfo, function(_, info) {
                    var lastTickValue,
                        tickInterval = info.tickInterval,
                        tickValues = info.tickValues,
                        maxValue = info.maxValue,
                        minValue = info.minValue;
                    if (hasSyncronizedValue && tickInterval) {
                        while (tickValues[0] - tickInterval >= minValue)
                            tickValues.unshift(_adjustValue(tickValues[0] - tickInterval));
                        lastTickValue = tickValues[tickValues.length - 1];
                        while ((lastTickValue = lastTickValue + tickInterval) <= maxValue)
                            tickValues.push(utils.isExponential(lastTickValue) ? _adjustValue(lastTickValue) : _applyPrecisionByMinDelta(minValue, tickInterval, lastTickValue))
                    }
                    while (tickValues[0] < minValue)
                        tickValues.shift();
                    while (tickValues[tickValues.length - 1] > maxValue)
                        tickValues.pop()
                })
            };
        var applyMinMaxValues = function(axesInfo) {
                _each(axesInfo, function(_, info) {
                    var axis = info.axis,
                        range = axis.getTranslator().getBusinessRange();
                    if (range.min === range.minVisible)
                        range.min = info.minValue;
                    if (range.max === range.maxVisible)
                        range.max = info.maxValue;
                    range.minVisible = info.minValue;
                    range.maxVisible = info.maxValue;
                    if (_isDefined(info.stubData))
                        range.stubData = info.stubData;
                    if (range.min > range.minVisible)
                        range.min = range.minVisible;
                    if (range.max < range.maxVisible)
                        range.max = range.maxVisible;
                    range.isSynchronized = true;
                    axis.getTranslator().updateBusinessRange(range);
                    axis.setRange(range);
                    axis.setTicks({
                        majorTicks: info.tickValues,
                        minorTicks: info.minorValues
                    })
                })
            };
        var correctAfterSynchronize = function(axesInfo) {
                var invalidAxisInfo = [],
                    correctValue,
                    validAxisInfo;
                _each(axesInfo, function(i, info) {
                    if (info.oldMaxValue - info.oldMinValue === 0)
                        invalidAxisInfo.push(info);
                    else if (!_isDefined(correctValue) && !_isDefined(info.synchronizedValue)) {
                        correctValue = _math.abs((info.maxValue - info.minValue) / (info.tickValues[_floor(info.tickValues.length / 2)] || info.maxValue));
                        validAxisInfo = info
                    }
                });
                if (!_isDefined(correctValue))
                    return;
                _each(invalidAxisInfo, function(i, info) {
                    var firstTick = info.tickValues[0],
                        correctedTick = firstTick * correctValue,
                        tickValues = validAxisInfo.tickValues,
                        centralTick = tickValues[_floor(tickValues.length / 2)];
                    if (firstTick > 0) {
                        info.maxValue = correctedTick;
                        info.minValue = 0
                    }
                    else if (firstTick < 0) {
                        info.minValue = correctedTick;
                        info.maxValue = 0
                    }
                    else if (firstTick === 0) {
                        info.maxValue = validAxisInfo.maxValue - centralTick;
                        info.minValue = validAxisInfo.minValue - centralTick
                    }
                })
            };
        DX.viz.charts.multiAxesSynchronizer = {synchronize: function(valueAxes) {
                _each(getValueAxesPerPanes(valueAxes), function(_, axes) {
                    var axesInfo,
                        paddings;
                    if (axes.length > 1) {
                        axesInfo = populateAxesInfo(axes);
                        if (axesInfo.length === 0 || !getMainAxisInfo(axesInfo))
                            return;
                        updateTickValues(axesInfo);
                        correctMinMaxValues(axesInfo);
                        paddings = calculatePaddings(axesInfo);
                        correctMinMaxValuesByPaddings(axesInfo, paddings);
                        correctAfterSynchronize(axesInfo);
                        updateTickValuesIfSyncronizedValueUsed(axesInfo);
                        _each(axesInfo, function() {
                            convertAxisInfo(this, logConvertor)
                        });
                        applyMinMaxValues(axesInfo)
                    }
                })
            }}
    })(jQuery, DevExpress);
    /*! Module viz-charts, file tracker.js */
    (function($, DX) {
        var charts = DX.viz.charts,
            eventsConsts = DX.viz.core.series.helpers.consts.events,
            utils = DX.utils,
            isFunction = utils.isFunction,
            isDefined = utils.isDefined,
            MULTIPLE_MODE = 'multiple',
            SINGLE_MODE = 'single',
            ALL_ARGUMENTS_POINTS_MODE = 'allargumentpoints',
            ALL_SERIES_POINTS_MODE = 'allseriespoints',
            NONE_MODE = 'none',
            POINTER_ACTION = "dxpointerdown dxpointermove";
        function processMode(mode) {
            return (mode + "").toLowerCase()
        }
        function getNonVirtualAxis(axisArray) {
            var axis;
            $.each(axisArray, function(_, a) {
                if (!a._virtual) {
                    axis = a;
                    return false
                }
            });
            return axis
        }
        var baseTrackerPrototype = {
                ctor: function(options) {
                    var that = this;
                    if (processMode(options.pointSelectionMode) === MULTIPLE_MODE) {
                        that._setSelectedPoint = that._selectPointMultipleMode;
                        that._releaseSelectedPoint = that._releaseSelectedPointMultipleMode
                    }
                    else {
                        that._setSelectedPoint = that._selectPointSingleMode;
                        that._releaseSelectedPoint = that._releaseSelectedPointSingleMode
                    }
                    if (processMode(options.seriesSelectionMode) === MULTIPLE_MODE) {
                        that._releaseSelectedSeries = that._releaseSelectedSeriesMultipleMode;
                        that._setSelectedSeries = that._setSelectedSeriesMultipleMode
                    }
                    else {
                        that._releaseSelectedSeries = that._releaseSelectedSeriesSingleMode;
                        that._setSelectedSeries = that._setSelectedSeriesSingleMode
                    }
                    that._renderer = options.renderer;
                    that._eventTrigger = options.eventTrigger;
                    $(options.seriesGroup.element).off().on(eventsConsts.selectSeries, {tracker: that}, that._selectSeries).on(eventsConsts.deselectSeries, {tracker: that}, that._deselectSeries).on(eventsConsts.selectPoint, {tracker: that}, that._selectPoint).on(eventsConsts.deselectPoint, {tracker: that}, that._deselectPoint).on(eventsConsts.showPointTooltip, {tracker: that}, that._showPointTooltip).on(eventsConsts.hidePointTooltip, {tracker: that}, that._hidePointTooltip)
                },
                update: function(options) {
                    var that = this;
                    if (that._storedSeries !== options.series) {
                        that._storedSeries = options.series || [];
                        that._clean()
                    }
                    else if (isDefined(that._storedSeries)) {
                        that._clearHover();
                        that._showTooltip(that.pointAtShownTooltip)
                    }
                    that._tooltip = options.tooltip;
                    that._tooltipEnabled = options.tooltip.enabled();
                    that._legend = options.legend;
                    that.legendCallback = options.legendCallback;
                    that._mainCanvas = options.mainCanvas;
                    that._prepare(that._renderer.root)
                },
                _prepare: function(root) {
                    var that = this,
                        data = {tracker: that};
                    $(root.element).off().on(POINTER_ACTION, data, that._pointerHandler).on("dxclick", data, that._clickHandler).on("dxhold", {timeout: 300}, $.noop)
                },
                _selectPointMultipleMode: function(point) {
                    var that = this;
                    that._selectedPoint = that._selectedPoint || [];
                    if ($.inArray(point, that._selectedPoint) < 0) {
                        that._selectedPoint.push(point);
                        that._setPointState(point, 'setPointSelectedState', processMode(point.getOptions().selectionMode), "pointSelectionChanged", that.legendCallback(point))
                    }
                },
                _releaseSelectedPointMultipleMode: function(point) {
                    var that = this,
                        points = that._selectedPoint || [],
                        pointIndex = $.inArray(point, points);
                    if (pointIndex >= 0) {
                        that._setPointState(point, 'releasePointSelectedState', processMode(point.getOptions().selectionMode), "pointSelectionChanged", that.legendCallback(point));
                        points.splice(pointIndex, 1)
                    }
                    else if (!point)
                        $.each(points, function(_, point) {
                            that._releaseSelectedPoint(point)
                        })
                },
                _selectPointSingleMode: function(point) {
                    var that = this;
                    if (that._selectedPoint !== point) {
                        that._releaseSelectedPoint();
                        that._selectedPoint = point;
                        that._setPointState(point, 'setPointSelectedState', processMode(point.getOptions().selectionMode), "pointSelectionChanged", that.legendCallback(point))
                    }
                },
                _releaseSelectedPointSingleMode: function() {
                    var that = this,
                        point = that._selectedPoint;
                    if (point) {
                        that._setPointState(point, 'releasePointSelectedState', processMode(point.getOptions().selectionMode), "pointSelectionChanged", that.legendCallback(point));
                        that._selectedPoint = null
                    }
                },
                _setPointState: function(point, action, mode, eventName, legendCallback) {
                    var that = this;
                    switch (mode) {
                        case ALL_ARGUMENTS_POINTS_MODE:
                            that._toAllArgumentPoints(point.argument, action, eventName);
                            break;
                        case ALL_SERIES_POINTS_MODE:
                            $.each(point.series.getPoints(), function(_, point) {
                                point.series[action](point);
                                that._eventTrigger(eventName, {target: point})
                            });
                            break;
                        case NONE_MODE:
                            break;
                        default:
                            point.series[action](point, legendCallback);
                            that._eventTrigger(eventName, {target: point})
                    }
                },
                _toAllArgumentPoints: function(argument, func, eventName) {
                    var that = this;
                    $.each(that._storedSeries, function(_, series) {
                        var neighborPoint = series.getPointByArg(argument);
                        if (neighborPoint) {
                            series[func](neighborPoint);
                            eventName && that._eventTrigger(eventName, {target: neighborPoint})
                        }
                    })
                },
                _setHoveredPoint: function(point, mode) {
                    var that = this;
                    var debug = DX.utils.debug;
                    debug.assert(point.series, 'series was not assigned to point or empty');
                    if (that.hoveredPoint === point && !point.series)
                        return;
                    that._releaseHoveredPoint();
                    if (point && point.getOptions() && mode !== NONE_MODE) {
                        that.hoveredPoint = point;
                        that._setPointState(point, 'setPointHoverState', mode || processMode(point.getOptions().hoverMode), "pointHoverChanged", that.legendCallback(point))
                    }
                },
                _releaseHoveredPoint: function() {
                    var that = this,
                        point = that.hoveredPoint,
                        mode;
                    if (!point || !point.getOptions())
                        return;
                    mode = processMode(point.getOptions().hoverMode);
                    if (mode === ALL_SERIES_POINTS_MODE)
                        $.each(point.series.getPoints(), function(_, point) {
                            point.series.releasePointHoverState(point);
                            that._eventTrigger("pointHoverChanged", {target: point})
                        });
                    else if (mode === ALL_ARGUMENTS_POINTS_MODE)
                        that._toAllArgumentPoints(point.argument, 'releasePointHoverState', "pointHoverChanged");
                    else {
                        point.releaseHoverState(that.legendCallback(point));
                        that._eventTrigger("pointHoverChanged", {target: point})
                    }
                    if (that._tooltipEnabled)
                        that._hideTooltip(point);
                    that.hoveredPoint = null
                },
                _setSelectedSeriesMultipleMode: function(series, mode) {
                    var that = this;
                    that._selectedSeries = that._selectedSeries || [];
                    if ($.inArray(series, that._selectedSeries) < 0) {
                        that._selectedSeries.push(series);
                        series.setSelectedState(true, mode, that.legendCallback(series));
                        that._eventTrigger("seriesSelectionChanged", {target: series})
                    }
                },
                _setSelectedSeriesSingleMode: function(series, mode) {
                    var that = this;
                    if (series !== that._selectedSeries || series.lastSelectionMode !== mode) {
                        this._releaseSelectedSeries();
                        that._selectedSeries = series;
                        series.setSelectedState(true, mode, that.legendCallback(series));
                        that._eventTrigger("seriesSelectionChanged", {target: series})
                    }
                },
                _releaseSelectedSeriesMultipleMode: function(series) {
                    var that = this,
                        selectedSeries = that._selectedSeries || [],
                        seriesIndex = $.inArray(series, selectedSeries);
                    if (seriesIndex >= 0) {
                        series.setSelectedState(false, undefined, that.legendCallback(series));
                        that._eventTrigger("seriesSelectionChanged", {target: series});
                        selectedSeries.splice(seriesIndex, 1)
                    }
                    else if (!series)
                        $.each(selectedSeries, function(_, series) {
                            that._releaseSelectedSeries(series)
                        })
                },
                _releaseSelectedSeriesSingleMode: function() {
                    var that = this,
                        series = that._selectedSeries;
                    if (series) {
                        series.setSelectedState(false, undefined, that.legendCallback(series));
                        that._eventTrigger("seriesSelectionChanged", {target: series});
                        that._selectedSeries = null
                    }
                },
                _setHoveredSeries: function(series, mode) {
                    var that = this;
                    if (mode !== NONE_MODE && that.hoveredSeries !== series || series.lastHoverMode !== mode) {
                        that._clearHover();
                        series.setHoverState(true, mode, that.legendCallback(series));
                        that._eventTrigger("seriesHoverChanged", {target: series})
                    }
                    that.hoveredSeries = series;
                    if (mode === NONE_MODE)
                        $(series).trigger('NoneMode')
                },
                _releaseHoveredSeries: function() {
                    var that = this;
                    if (that.hoveredSeries) {
                        that.hoveredSeries.setHoverState(false, undefined, that.legendCallback(that.hoveredSeries));
                        that._eventTrigger("seriesHoverChanged", {target: that.hoveredSeries});
                        that.hoveredSeries = null
                    }
                },
                _selectSeries: function(event, mode) {
                    event.data.tracker._setSelectedSeries(event.target, mode)
                },
                _deselectSeries: function(event, mode) {
                    event.data.tracker._releaseSelectedSeries(event.target, mode)
                },
                _selectPoint: function(event, point) {
                    event.data.tracker._setSelectedPoint(point)
                },
                _deselectPoint: function(event, point) {
                    event.data.tracker._releaseSelectedPoint(point)
                },
                _clearPointSelection: function() {
                    this._releaseSelectedPoint()
                },
                clearSelection: function() {
                    this._clearPointSelection();
                    this._releaseSelectedPoint()
                },
                _clean: function() {
                    var that = this;
                    that._selectedPoint = null;
                    that._selectedSeries = null;
                    that.hoveredPoint = null;
                    that.hoveredSeries = null;
                    that._hideTooltip(that.pointAtShownTooltip)
                },
                _clearHover: function() {
                    this._releaseHoveredSeries();
                    this._releaseHoveredPoint()
                },
                _hideTooltip: function(point) {
                    var tooltip = this._tooltip;
                    if (!tooltip || point && this.pointAtShownTooltip !== point)
                        return;
                    point = point || this.pointAtShownTooltip;
                    tooltip.hide();
                    if (this.pointAtShownTooltip) {
                        this.pointAtShownTooltip = null;
                        this._eventTrigger("tooltipHidden", {target: point})
                    }
                },
                _showTooltip: function(point) {
                    var tooltip = this._tooltip,
                        tooltipFormatObject;
                    if (point && point.getOptions()) {
                        tooltipFormatObject = point.getTooltipFormatObject(tooltip);
                        if (!isDefined(tooltipFormatObject.valueText) && !tooltipFormatObject.points || !point.isVisible())
                            return;
                        if (!tooltip.prepare(tooltipFormatObject, point.getTooltipParams(tooltip.getLocation())))
                            return;
                        tooltip.show();
                        !this.pointAtShownTooltip && this._eventTrigger("tooltipShown", {target: point});
                        this.pointAtShownTooltip = point
                    }
                },
                _showPointTooltip: function(event, point) {
                    event.data.tracker._showTooltip(point)
                },
                _hidePointTooltip: function(event, point) {
                    event.data.tracker._hideTooltip(point)
                },
                _enableOutHandler: function() {
                    if (this._outHandler)
                        return;
                    var that = this,
                        handler = function(e) {
                            var rootOffset = utils.getRootOffset(that._renderer),
                                x = parseInt(e.pageX - rootOffset.left),
                                y = parseInt(e.pageY - rootOffset.top);
                            if (!that._inCanvas(that._mainCanvas, x, y)) {
                                that._pointerOut();
                                that._disableOutHandler()
                            }
                        };
                    $(document).on(POINTER_ACTION, handler);
                    this._outHandler = handler
                },
                _disableOutHandler: function() {
                    this._outHandler && $(document).off(POINTER_ACTION, this._outHandler);
                    this._outHandler = null
                },
                _pointerOut: function() {
                    this._clearHover();
                    this._hideTooltip(this.pointAtShownTooltip)
                },
                _inCanvas: function(canvas, x, y) {
                    return x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom
                },
                dispose: function() {
                    var that = this;
                    that._disableOutHandler();
                    $.each(that, function(k) {
                        that[k] = null
                    })
                }
            };
        charts.ChartTracker = function(options) {
            this.ctor(options)
        };
        $.extend(charts.ChartTracker.prototype, baseTrackerPrototype, {
            ctor: function(options) {
                baseTrackerPrototype.ctor.call(this, options);
                this._crosshair = options.crosshair || []
            },
            _pointClick: function(point, event) {
                var that = this;
                that._eventTrigger("pointClick", {
                    target: point,
                    jQueryEvent: event
                }, function() {
                    !event.cancel && that._eventTrigger("seriesClick", {
                        target: point.series,
                        jQueryEvent: event
                    })
                })
            },
            _legendClick: function(series, event) {
                var that = this,
                    evetArgs = {
                        target: series,
                        jQueryEvent: event
                    };
                that._eventTrigger("legendClick", evetArgs, function() {
                    !event.cancel && that._eventTrigger("seriesClick", evetArgs)
                })
            },
            update: function(options) {
                var that = this;
                that._zoomingMode = (options.zoomingMode + '').toLowerCase();
                that._scrollingMode = (options.scrollingMode + '').toLowerCase();
                baseTrackerPrototype.update.call(this, options);
                that._argumentAxis = getNonVirtualAxis(options.argumentAxis || []);
                that._axisHoverEnabled = that._argumentAxis && processMode(that._argumentAxis.getOptions().hoverMode) === ALL_ARGUMENTS_POINTS_MODE;
                that._canvases = options.canvases;
                that._chart = options.chart;
                that._rotated = options.rotated
            },
            _getAxisArgument: function(event) {
                var $target = $(event.target);
                return event.target.tagName === "tspan" ? $target.parent().data('argument') : $target.data('argument')
            },
            _getCanvas: function(x, y) {
                var that = this,
                    canvases = that._canvases || [];
                for (var i = 0; i < canvases.length; i++) {
                    var c = canvases[i];
                    if (that._inCanvas(c, x, y))
                        return c
                }
                return null
            },
            _focusOnCanvas: function(canvas) {
                if (!canvas && this.hoveredSeries)
                    this._pointerOut()
            },
            _resetHoveredArgument: function() {
                if (isDefined(this.hoveredArgument)) {
                    this._toAllArgumentPoints(this.hoveredArgument, 'releasePointHoverState');
                    this.hoveredArgument = null
                }
            },
            _hideCrosshair: function() {
                $.each(this._crosshair, function(_, group) {
                    group.hide()
                })
            },
            _moveCrosshair: function(point, x, y) {
                if (point && this._crosshair) {
                    var coords = point.getCrosshairCoords(x, y);
                    $.each(this._crosshair, function(_, group) {
                        group.shift(coords.x, coords.y)
                    })
                }
            },
            _prepare: function(root) {
                var that = this,
                    touchScrollingEnabled = that._scrollingMode === 'all' || that._scrollingMode === 'touch',
                    touchZoomingEnabled = that._zoomingMode === 'all' || that._zoomingMode === 'touch',
                    cssValue = (!touchScrollingEnabled ? "pan-x pan-y " : '') + (!touchZoomingEnabled ? "pinch-zoom" : '') || "none",
                    rootStyles = {
                        'touch-action': cssValue,
                        '-ms-touch-action': cssValue
                    },
                    wheelzoomingEnabled = that._zoomingMode == "all" || that._zoomingMode == "mouse";
                baseTrackerPrototype._prepare.call(that, root);
                if (!that._gestureEndHandler) {
                    that._gestureEndHandler = function() {
                        that._gestureEnd()
                    };
                    $(document).on("dxpointerup", that._gestureEndHandler)
                }
                wheelzoomingEnabled && $(root.element).on("dxmousewheel", function(e) {
                    var rootOffset = utils.getRootOffset(that._renderer),
                        x = that._rotated ? e.pageY - rootOffset.top : e.pageX - rootOffset.left,
                        scale = that._argumentAxis.getTranslator().getMinScale(e.delta > 0),
                        translate = x - x * scale,
                        zoom = that._argumentAxis.getTranslator().zoom(-translate, scale);
                    that._pointerOut();
                    that._chart.zoomArgument(zoom.min, zoom.max, true);
                    e.preventDefault()
                });
                $(root.element).on("dxc-scroll-start", function(e) {
                    that._gestureStart(that._getGestureParams(e, {
                        left: 0,
                        top: 0
                    }))
                }).on("dxc-scroll-move", function(e) {
                    that._gestureChange(that._getGestureParams(e, {
                        left: 0,
                        top: 0
                    })) && e.preventDefault()
                });
                that._tooltip.off().on(POINTER_ACTION, {tracker: that}, that._tooltipPointerHandler);
                root.css(rootStyles)
            },
            _getGestureParams: function(e, offset) {
                var that = this,
                    x1,
                    x2,
                    touches = e.pointers.length,
                    left,
                    right,
                    eventCoordField = that._rotated ? "pageY" : "pageX";
                offset = that._rotated ? offset.top : offset.left;
                if (touches === 2)
                    x1 = e.pointers[0][eventCoordField] - offset,
                    x2 = e.pointers[1][eventCoordField] - offset;
                else if (touches === 1)
                    x1 = x2 = e.pointers[0][eventCoordField] - offset;
                left = Math.min(x1, x2);
                right = Math.max(x1, x2);
                return {
                        center: left + (right - left) / 2,
                        distance: right - left,
                        touches: touches,
                        scale: 1,
                        pointerType: e.pointerType
                    }
            },
            _gestureStart: function(gestureParams) {
                var that = this;
                that._startGesture = that._startGesture || gestureParams;
                if (that._startGesture.touches !== gestureParams.touches)
                    that._startGesture = gestureParams
            },
            _gestureChange: function(gestureParams) {
                var that = this,
                    startGesture = that._startGesture,
                    gestureChanged = false,
                    scrollingEnabled = that._scrollingMode === 'all' || that._scrollingMode !== 'none' && that._scrollingMode === gestureParams.pointerType,
                    zoommingEnabled = that._zoomingMode === 'all' || that._zoomingMode === 'touch';
                if (!startGesture)
                    return gestureChanged;
                if (startGesture.touches === 1 && Math.abs(startGesture.center - gestureParams.center) < 3) {
                    that._gestureStart(gestureParams);
                    return gestureChanged
                }
                if (startGesture.touches == 2 && zoommingEnabled) {
                    gestureChanged = true;
                    startGesture.scale = gestureParams.distance / startGesture.distance;
                    startGesture.scroll = gestureParams.center - startGesture.center + (startGesture.center - startGesture.center * startGesture.scale)
                }
                else if (startGesture.touches == 1 && scrollingEnabled) {
                    gestureChanged = true;
                    startGesture.scroll = gestureParams.center - startGesture.center
                }
                if (gestureChanged) {
                    startGesture.changed = gestureChanged;
                    that._chart._transformArgument(startGesture.scroll, startGesture.scale)
                }
                return gestureChanged
            },
            _gestureEnd: function() {
                var that = this,
                    startGesture = that._startGesture,
                    zoom,
                    renderer = that._renderer;
                that._startGesture = null;
                function complete() {
                    that._chart.zoomArgument(zoom.min, zoom.max, true)
                }
                if (startGesture && startGesture.changed) {
                    zoom = that._argumentAxis._translator.zoom(-startGesture.scroll, startGesture.scale);
                    if (renderer.animationEnabled() && (-startGesture.scroll !== zoom.translate || startGesture.scale !== zoom.scale)) {
                        var translateDelta = -(startGesture.scroll + zoom.translate),
                            scaleDelta = startGesture.scale - zoom.scale;
                        renderer.root.animate({_: 0}, {
                            step: function(pos) {
                                var translateValue = -startGesture.scroll - translateDelta * pos;
                                var scaleValue = startGesture.scale - scaleDelta * pos;
                                that._chart._transformArgument(-translateValue, scaleValue)
                            },
                            complete: complete,
                            duration: 250
                        })
                    }
                    else
                        complete()
                }
            },
            _getSeriesForShared: function(x, y) {
                var that = this,
                    points = [],
                    point = null,
                    distance = Infinity;
                if (that._tooltip.shared() && !that.hoveredSeries) {
                    $.each(that._storedSeries, function(_, series) {
                        var point = series.getNeighborPoint(x, y);
                        point && points.push(point)
                    });
                    $.each(points, function(_, p) {
                        var coords = p.getCrosshairCoords(x, y),
                            d = Math.sqrt((x - coords.x) * (x - coords.x) + (y - coords.y) * (y - coords.y));
                        if (d < distance) {
                            point = p;
                            distance = d
                        }
                    })
                }
                return point && point.series
            },
            _pointerHandler: function(e) {
                var that = e.data.tracker,
                    rootOffset = utils.getRootOffset(that._renderer),
                    x = parseInt(e.pageX - rootOffset.left),
                    y = parseInt(e.pageY - rootOffset.top),
                    point = $(e.target).data("point"),
                    canvas = that._getCanvas(x, y),
                    series = $(e.target).data("series") || point && point.series || that._getSeriesForShared(x, y);
                that._enableOutHandler();
                if (e.type === "dxpointerdown")
                    canvas && that._gestureStart(that._getGestureParams(e, rootOffset));
                else if (that._startGesture && canvas)
                    if (that._gestureChange(that._getGestureParams(e, rootOffset))) {
                        that._pointerOut();
                        e.preventDefault();
                        return
                    }
                if (that._legend.coordsIn(x, y)) {
                    var item = that._legend.getItemByCoord(x, y);
                    if (item) {
                        series = that._storedSeries[item.id];
                        that._setHoveredSeries(series, that._legend._options.hoverMode)
                    }
                    else
                        that._clearHover();
                    that._hideCrosshair();
                    return
                }
                if (that._axisHoverEnabled && that._argumentAxis.coordsIn(x, y)) {
                    var argument = that._getAxisArgument(e),
                        argumentDefined = isDefined(argument);
                    if (argumentDefined && that.hoveredArgument !== argument) {
                        that._clearHover();
                        that._resetHoveredArgument();
                        that._toAllArgumentPoints(argument, "setPointHoverState");
                        that.hoveredArgument = argument
                    }
                    else if (!argumentDefined)
                        that._resetHoveredArgument();
                    return
                }
                that._resetHoveredArgument();
                that._focusOnCanvas(canvas);
                if (!canvas && !point)
                    return;
                if (series && series !== that.hoveredSeries || that.hoveredSeries && that.hoveredSeries.lastHoverMode !== processMode(that.hoveredSeries.getOptions().hoverMode)) {
                    series = series || that.hoveredSeries;
                    that._setHoveredSeries(series, series.getOptions().hoverMode)
                }
                if (that.hoveredSeries) {
                    point = point || that.hoveredSeries.getNeighborPoint(x, y);
                    if (point && point != that.hoveredPoint) {
                        that._tooltipEnabled && that._showTooltip(point);
                        that._setHoveredPoint(point)
                    }
                    that._moveCrosshair(point, x, y)
                }
            },
            _pointerOut: function() {
                this._hideCrosshair();
                this._resetHoveredArgument();
                baseTrackerPrototype._pointerOut.call(this)
            },
            _clickHandler: function(e) {
                var that = e.data.tracker,
                    rootOffset = utils.getRootOffset(that._renderer),
                    x = parseInt(e.pageX - rootOffset.left),
                    y = parseInt(e.pageY - rootOffset.top),
                    point = $(e.target).data("point"),
                    series = that.hoveredSeries || $(e.target).data("series") || point && point.series,
                    axis = that._argumentAxis;
                if (that._legend.coordsIn(x, y)) {
                    var item = that._legend.getItemByCoord(x, y);
                    if (item) {
                        series = that._storedSeries[item.id];
                        that._legendClick(series, e)
                    }
                    return
                }
                if (axis && axis.coordsIn(x, y)) {
                    var argument = that._getAxisArgument(e);
                    if (isDefined(argument)) {
                        that._eventTrigger("argumentAxisClick", {
                            target: axis,
                            argument: argument,
                            jQueryEvent: e
                        });
                        return
                    }
                }
                if (series) {
                    point = point || series.getPointByCoord(x, y);
                    if (point)
                        that._pointClick(point, e);
                    else
                        $(e.target).data("series") && that._eventTrigger("seriesClick", {
                            target: series,
                            jQueryEvent: e
                        })
                }
            },
            _tooltipPointerHandler: function(e) {
                var that = e.data.tracker,
                    rootOffset = utils.getRootOffset(that._renderer),
                    x = parseInt(e.pageX - rootOffset.left),
                    y = parseInt(e.pageY - rootOffset.top),
                    series = that.hoveredSeries,
                    point;
                if (series && !series.getPointByCoord(x, y)) {
                    $.each(that._storedSeries, function(_, s) {
                        point = s.getPointByCoord(x, y);
                        if (point)
                            return false
                    });
                    point && that._tooltip.hide()
                }
            },
            dispose: function() {
                this._gestureEndHandler && $(document).off("dxpointerup", this._gestureEndHandler);
                baseTrackerPrototype.dispose.call(this)
            }
        });
        charts.PieTracker = function(options) {
            this.ctor(options)
        };
        $.extend(charts.PieTracker.prototype, baseTrackerPrototype, {
            _legendClick: function(point, event) {
                var that = this,
                    eventArg = {
                        target: point,
                        jQueryEvent: event
                    };
                that._eventTrigger("legendClick", eventArg, function() {
                    !event.cancel && that._eventTrigger("pointClick", eventArg)
                })
            },
            _pointerHandler: function(e) {
                var that = e.data.tracker,
                    rootOffset = utils.getRootOffset(that._renderer),
                    x = parseInt(e.pageX - rootOffset.left),
                    y = parseInt(e.pageY - rootOffset.top),
                    series = that._storedSeries[0],
                    point = $(e.target).data("point") || series && series.getPointByCoord(x, y),
                    item,
                    mode;
                that._enableOutHandler();
                if (that._legend.coordsIn(x, y)) {
                    var item = that._legend.getItemByCoord(x, y);
                    if (item) {
                        point = that._storedSeries[0].getPoints()[item.id];
                        mode = that._legend._options.hoverMode
                    }
                }
                if (point && point != that.hoveredPoint) {
                    that._tooltipEnabled && that._showTooltip(point);
                    that._setHoveredPoint(point, mode)
                }
                else if (!point)
                    that._pointerOut()
            },
            _clickHandler: function(e) {
                var that = e.data.tracker,
                    rootOffset = utils.getRootOffset(that._renderer),
                    x = parseInt(e.pageX - rootOffset.left),
                    y = parseInt(e.pageY - rootOffset.top),
                    storedSeries = that._storedSeries[0],
                    point;
                if (that._legend.coordsIn(x, y)) {
                    var item = that._legend.getItemByCoord(x, y);
                    if (item) {
                        point = storedSeries.getPoints()[item.id];
                        that._legendClick(point, e)
                    }
                }
                else {
                    point = $(e.target).data("point") || storedSeries && storedSeries.getPointByCoord(x, y);
                    point && that._eventTrigger("pointClick", {
                        target: point,
                        jQueryEvent: e
                    })
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module viz-charts, file crosshair.js */
    (function($, DX, undefined) {
        var mathMax = Math.max,
            HORIZONTAL_LINE = "horizontalLine",
            VERTICAL_LINE = "verticalLine",
            LABEL_BACKGROUND_PADDING_X = 8,
            LABEL_BACKGROUND_PADDING_Y = 4,
            CENTER = "center",
            RIGHT = "right",
            LEFT = "left",
            TOP = "top",
            BOTTOM = "bottom";
        function Crosshair() {
            this.ctor.apply(this, arguments)
        }
        DX.viz.charts.Crosshair = Crosshair;
        Crosshair.prototype = {
            ctor: function(renderer, options, isHorizontal, canvas, axes, group) {
                var that = this;
                that._isHorizontal = isHorizontal;
                that._renderer = renderer;
                that._crosshairGroup = group;
                that._init(options, canvas, axes)
            },
            dispose: function() {
                var that = this;
                that._renderer = null;
                that._crosshairGroup = null;
                that._options = null;
                that._axes = null;
                that._canvas = null;
                that._text = null;
                that._background = null;
                that._group = null
            },
            _init: function(options, canvas, axes) {
                var that = this;
                that._canvas = {
                    top: canvas.top,
                    bottom: canvas.height - canvas.bottom,
                    left: canvas.left,
                    right: canvas.width - canvas.right,
                    width: canvas.width,
                    height: canvas.height
                };
                that._axes = axes;
                that._prepareOptions(options, that._isHorizontal ? HORIZONTAL_LINE : VERTICAL_LINE)
            },
            _prepareOptions: function(options, direction) {
                this._options = {
                    visible: options[direction].visible,
                    line: {
                        stroke: options[direction].color || options.color,
                        "stroke-width": options[direction].width || options.width,
                        dashStyle: options[direction].dashStyle || options.dashStyle,
                        opacity: options[direction].opacity || options.opacity,
                        "stroke-linecap": "square"
                    },
                    label: $.extend(true, {}, options.label, options[direction].label)
                }
            },
            render: function() {
                var that = this,
                    renderer = that._renderer,
                    canvas = that._canvas,
                    options = that._options;
                if (!options.visible)
                    return;
                that._group = renderer.g().attr({visibility: "hidden"}).append(that._crosshairGroup);
                that._createLabel(options);
                renderer.path(that._isHorizontal ? [canvas.left, canvas.top, canvas.right, canvas.top] : [canvas.left, canvas.top, canvas.left, canvas.bottom], "line").attr(options.line).sharp().append(that._group)
            },
            _createLabel: function(options) {
                var that = this,
                    canvas = that._canvas,
                    isHorizontal = that._isHorizontal,
                    labelCanvas = isHorizontal ? {
                        left: 0,
                        right: canvas.width,
                        top: canvas.top,
                        bottom: canvas.bottom
                    } : {
                        left: canvas.left,
                        right: canvas.right,
                        top: 0,
                        bottom: canvas.height
                    },
                    renderer = that._renderer,
                    x,
                    y,
                    text,
                    background,
                    curentLabelPos,
                    bbox;
                if (!options.label || !options.label.visible)
                    return;
                that._text = [];
                that._background = [];
                $.each(that._axes, function(_, axis) {
                    var axisOptions = axis.getOptions();
                    if (axis._virtual || axisOptions.stubData) {
                        that._text.push(null);
                        that._background.push(null);
                        return
                    }
                    curentLabelPos = axis.getCurrentLabelPos();
                    if (isHorizontal) {
                        y = canvas.top;
                        x = curentLabelPos;
                        labelCanvas.left = labelCanvas.left < curentLabelPos && curentLabelPos < canvas.left ? curentLabelPos : labelCanvas.left;
                        labelCanvas.right = labelCanvas.right > curentLabelPos && curentLabelPos > canvas.right ? curentLabelPos : labelCanvas.right
                    }
                    else {
                        x = canvas.left;
                        y = curentLabelPos;
                        labelCanvas.top = labelCanvas.top < curentLabelPos && curentLabelPos < canvas.top ? curentLabelPos : labelCanvas.top;
                        labelCanvas.bottom = labelCanvas.bottom > curentLabelPos && curentLabelPos > canvas.bottom ? curentLabelPos : labelCanvas.bottom
                    }
                    text = renderer.text("0", x, y).css(DX.viz.core.utils.patchFontOptions(options.label.font)).attr({align: axisOptions.position === TOP || axisOptions.position === BOTTOM ? CENTER : axisOptions.position === RIGHT ? LEFT : RIGHT}).append(that._group);
                    bbox = text.getBBox();
                    text.attr({y: isHorizontal ? 2 * y - bbox.y - bbox.height / 2 : axisOptions.position === BOTTOM ? 2 * y - bbox.y : 2 * y - (bbox.y + bbox.height)});
                    background = renderer.rect(0, 0, 0, 0).attr({fill: options.label.backgroundColor || options.line.stroke}).append(that._group).toBackground();
                    that._text.push(text);
                    that._background.push(background)
                });
                canvas.left = labelCanvas.left || canvas.left;
                canvas.top = labelCanvas.top || canvas.top;
                canvas.right = labelCanvas.right !== canvas.width ? labelCanvas.right : canvas.right;
                canvas.bottom = labelCanvas.bottom !== canvas.height ? labelCanvas.bottom : canvas.bottom
            },
            _updateText: function(posX, posY) {
                var that = this,
                    bbox,
                    text,
                    textElement,
                    backgroundElement;
                if (!that._text)
                    return;
                $.each(that._axes, function(i, axis) {
                    textElement = that._text[i];
                    backgroundElement = that._background[i];
                    if (!textElement)
                        return;
                    text = axis.getUntranslatedValue(that._isHorizontal ? posY : posX);
                    if (DX.utils.isDefined(text)) {
                        textElement.attr({text: text});
                        bbox = textElement.getBBox();
                        backgroundElement.attr({
                            x: bbox.x - LABEL_BACKGROUND_PADDING_X,
                            y: bbox.y - LABEL_BACKGROUND_PADDING_Y,
                            width: bbox.width + LABEL_BACKGROUND_PADDING_X * 2,
                            height: bbox.height + LABEL_BACKGROUND_PADDING_Y * 2
                        })
                    }
                    else {
                        textElement.attr({text: ""});
                        backgroundElement.attr({
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        })
                    }
                })
            },
            show: function() {
                var group = this._group;
                group && group.attr({visibility: "visible"})
            },
            hide: function() {
                var group = this._group;
                group && group.attr({visibility: "hidden"})
            },
            shift: function(x, y) {
                var that = this,
                    canvas = that._canvas,
                    group = that._group,
                    translate;
                if (!group)
                    return;
                if (x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom) {
                    that.show();
                    if (that._isHorizontal) {
                        translate = y - canvas.top;
                        group.attr({translateY: translate})
                    }
                    else {
                        translate = x - canvas.left;
                        group.attr({translateX: translate})
                    }
                    that._updateText(x, y)
                }
                else
                    that.hide()
            }
        }
    })(jQuery, DevExpress);
    DevExpress.MOD_VIZ_CHARTS = true
}
if (!DevExpress.MOD_VIZ_GAUGES) {
    if (!DevExpress.MOD_VIZ_CORE)
        throw Error('Required module is not referenced: viz-core');
    /*! Module viz-gauges, file namespaces.js */
    (function(DX) {
        DX.viz.gauges = {__internals: {
                circularNeedles: {},
                circularMarkers: {},
                linearNeedles: {},
                linearMarkers: {}
            }};
        DX.viz.gauges.__tests = {}
    })(DevExpress);
    /*! Module viz-gauges, file factory.js */
    (function(DX, $, undefined) {
        var internals = DX.viz.gauges.__internals,
            circularNeedles = internals.circularNeedles,
            circularMarkers = internals.circularMarkers,
            linearNeedles = internals.linearNeedles,
            linearMarkers = internals.linearMarkers;
        var _String = window.String;
        DX.viz.gauges.__factory = {
            createCircularValueIndicator: function(type) {
                var indicatorType = circularNeedles.RectangleNeedle;
                switch (_String(type).toLowerCase()) {
                    case'rectangleneedle':
                        indicatorType = circularNeedles.RectangleNeedle;
                        break;
                    case'triangleneedle':
                        indicatorType = circularNeedles.TriangleNeedle;
                        break;
                    case'twocolorneedle':
                        indicatorType = circularNeedles.TwoColorRectangleNeedle;
                        break;
                    case'rangebar':
                        indicatorType = internals.CircularRangeBar;
                        break
                }
                return new indicatorType
            },
            createLinearValueIndicator: function(type) {
                var indicatorType = internals.LinearRangeBar;
                switch (_String(type).toLowerCase()) {
                    case'rectangle':
                        indicatorType = linearNeedles.RectangleNeedle;
                        break;
                    case'rhombus':
                        indicatorType = linearNeedles.RhombusNeedle;
                        break;
                    case'circle':
                        indicatorType = linearNeedles.CircleNeedle;
                        break;
                    case'rangebar':
                        indicatorType = internals.LinearRangeBar;
                        break
                }
                return new indicatorType
            },
            createCircularSubvalueIndicator: function(type) {
                var indicatorType = circularMarkers.TriangleMarker;
                switch (_String(type).toLowerCase()) {
                    case'trianglemarker':
                        indicatorType = circularMarkers.TriangleMarker;
                        break;
                    case'textcloud':
                        indicatorType = circularMarkers.TextCloudMarker;
                        break
                }
                return new indicatorType
            },
            createLinearSubvalueIndicator: function(type) {
                var indicatorType = linearMarkers.TriangleMarker;
                switch (_String(type).toLowerCase()) {
                    case'trianglemarker':
                        indicatorType = linearMarkers.TriangleMarker;
                        break;
                    case'textcloud':
                        indicatorType = linearMarkers.TextCloudMarker;
                        break
                }
                return new indicatorType
            },
            createCircularValueIndicatorInHardMode: function(type) {
                var indicatorType = null;
                switch (_String(type).toLowerCase()) {
                    case'rectangleneedle':
                        indicatorType = circularNeedles.RectangleNeedle;
                        break;
                    case'triangleneedle':
                        indicatorType = circularNeedles.TriangleNeedle;
                        break;
                    case'twocolorneedle':
                        indicatorType = circularNeedles.TwoColorRectangleNeedle;
                        break;
                    case'rangebar':
                        indicatorType = internals.CircularRangeBar;
                        break;
                    case'trianglemarker':
                        indicatorType = circularMarkers.TriangleMarker;
                        break;
                    case'textcloud':
                        indicatorType = circularMarkers.TextCloudMarker;
                        break
                }
                return indicatorType ? new indicatorType : null
            },
            createLinearValueIndicatorInHardMode: function(type) {
                var indicatorType = null;
                switch (_String(type).toLowerCase()) {
                    case'rectangle':
                        indicatorType = linearNeedles.RectangleNeedle;
                        break;
                    case'rhombus':
                        indicatorType = linearNeedles.RhombusNeedle;
                        break;
                    case'circle':
                        indicatorType = linearNeedles.CircleNeedle;
                        break;
                    case'rangebar':
                        indicatorType = internals.LinearRangeBar;
                        break;
                    case'trianglemarker':
                        indicatorType = linearMarkers.TriangleMarker;
                        break;
                    case'textcloud':
                        indicatorType = linearMarkers.TextCloudMarker;
                        break
                }
                return indicatorType ? new indicatorType : null
            },
            createCircularScale: function(parameters) {
                return new internals.CircularScale(parameters)
            },
            createLinearScale: function(parameters) {
                return new internals.LinearScale(parameters)
            },
            createCircularRangeContainer: function(parameters) {
                return new internals.CircularRangeContainer(parameters)
            },
            createLinearRangeContainer: function(parameters) {
                return new internals.LinearRangeContainer(parameters)
            },
            createTitle: function(parameters) {
                return new internals.Title(parameters)
            },
            createIndicator: function() {
                return internals.Indicator && new internals.Indicator || null
            },
            createLayoutManager: function() {
                return new internals.LayoutManager
            },
            createThemeManager: function(options) {
                return new internals.ThemeManager(options)
            },
            createTracker: function(parameters) {
                return new internals.Tracker(parameters)
            }
        };
        var _isFunction = DX.utils.isFunction,
            _String = window.String,
            _extend = $.extend;
        var _formatHelper = DX.formatHelper;
        internals.formatValue = function(value, options, extra) {
            options = options || {};
            var text = _formatHelper.format(value, options.format, options.precision),
                context;
            if (_isFunction(options.customizeText)) {
                var context = _extend({
                        value: value,
                        valueText: text
                    }, extra);
                return _String(options.customizeText.call(context, context))
            }
            return text
        };
        internals.getSampleText = function(translator, options) {
            var text1 = internals.formatValue(translator.getDomainStart(), options),
                text2 = internals.formatValue(translator.getDomainEnd(), options);
            return text1.length >= text2.length ? text1 : text2
        }
    })(DevExpress, jQuery);
    /*! Module viz-gauges, file scale.js */
    (function(DX, $, undefined) {
        var viz = DX.viz,
            core = viz.core,
            _Number = Number,
            _String = String,
            _isFinite = isFinite,
            _min = Math.min,
            _max = Math.max,
            _abs = Math.abs,
            _atan = Math.atan,
            _acos = Math.acos,
            _ceil = Math.ceil,
            _isFunction = DX.utils.isFunction,
            _isArray = DX.utils.isArray,
            _getCosAndSin = DX.utils.getCosAndSin,
            _convertAngleToRendererSpace = DX.utils.convertAngleToRendererSpace,
            _map = $.map;
        var _formatHelper = DX.formatHelper,
            _createTickManager = core.CoreFactory.createTickManager;
        var PI_DIV_180 = Math.PI / 180;
        function binarySearch(x, list) {
            var a = 0,
                b = list.length - 1,
                flag = list[a] - list[b] < 0,
                c,
                k = -1;
            if (list[a] === x)
                k = a;
            if (list[b] === x)
                k = b;
            while (k < 0 && a <= b) {
                c = ~~((a + b) / 2);
                if (list[c] === x)
                    k = c;
                else if (list[c] - x < 0 === flag)
                    a = c + 1;
                else
                    b = c - 1
            }
            return k
        }
        function sortAsc(x, y) {
            return x - y
        }
        function sortDes(x, y) {
            return y - x
        }
        viz.gauges.__internals.BaseScale = DX.Class.inherit({
            ctor: function(parameters) {
                var that = this;
                that._renderer = parameters.renderer;
                that._container = parameters.container;
                that._translator = parameters.translator;
                that._root = that._renderer.g().attr({'class': 'dxg-scale'});
                that._majorTicks = that._renderer.g().attr({'class': 'dxg-major-ticks'});
                that._minorTicks = that._renderer.g().attr({'class': 'dxg-minor-ticks'});
                that._labels = that._renderer.g().attr({'class': 'dxg-labels'})
            },
            dispose: function() {
                var that = this;
                that._renderer = that._container = that._renderer = that._root = that._majorTicks = that._minorTicks = that._labels = null;
                return that
            },
            clean: function() {
                var that = this;
                that._root.remove();
                that._majorTicks.remove().clear();
                that._minorTicks.remove().clear();
                that._labels.remove().clear();
                that._majorTicksEnabled = that._minorTicksEnabled = that._labelsEnabled = that._options = that.enabled = null;
                return that
            },
            render: function(options) {
                var that = this;
                that._options = options;
                that._processOptions(options);
                if (that._majorTicksEnabled || that._minorTicksEnabled || that._labelsEnabled) {
                    that.enabled = true;
                    that._root.append(that._container);
                    if (that._majorTicksEnabled)
                        that._majorTicks.append(that._root);
                    if (that._minorTicksEnabled)
                        that._minorTicks.append(that._root);
                    if (that._labelsEnabled) {
                        that._labels.append(that._root);
                        that._measureText()
                    }
                }
                return that
            },
            _processOptions: function(options) {
                var that = this;
                that._majorTicksEnabled = options.majorTick.visible && options.majorTick.length > 0 && options.majorTick.width > 0;
                that._minorTicksEnabled = options.minorTick.visible && options.minorTick.length > 0 && options.minorTick.width > 0;
                that._labelsEnabled = options.label.visible && _Number(options.label.indentFromTick) !== 0;
                that._setupOrientation()
            },
            _measureText: function() {
                var that = this,
                    domain = that._translator.getDomain(),
                    tickManager = _createTickManager({}, {
                        min: domain[0],
                        max: domain[1],
                        screenDelta: that._options.approximateScreenDelta
                    }, {
                        tickInterval: that._options.majorTick.tickInterval > 0 ? _Number(that._options.majorTick.tickInterval) : undefined,
                        stick: true,
                        textFontStyles: core.utils.patchFontOptions(that._options.label.font),
                        gridSpacingFactor: that._getGridSpacingFactor().majorTicks,
                        renderText: function(text, x, y, options) {
                            return that._renderer.text(text, x, y, options).append(that._renderer.root)
                        },
                        getText: function(value) {
                            return that._formatValue(value)
                        },
                        overlappingBehaviorType: that._overlappingBehaviorType
                    }),
                    maxTextParams = tickManager.getMaxLabelParams();
                that._textVerticalOffset = -maxTextParams.y - maxTextParams.height / 2;
                that._textWidth = maxTextParams.width;
                that._textHeight = maxTextParams.height;
                that._textLength = maxTextParams.length
            },
            _formatValue: function(value) {
                var options = this._options.label,
                    text = _formatHelper.format(value, options.format, options.precision);
                if (_isFunction(options.customizeText)) {
                    text = {
                        value: value,
                        valueText: text
                    };
                    text = _String(options.customizeText.call(text, text))
                }
                return text
            },
            _setupOrientation: null,
            _getCustomValues: function(values, compare) {
                var translator = this._translator,
                    result = [];
                if (_isArray(values)) {
                    result = _map(values, function(x) {
                        return _isFinite(translator.translate(x)) ? _Number(x) : null
                    }).sort(compare);
                    result = _map(result, function(x, i) {
                        return x !== result[i - 1] ? x : null
                    })
                }
                return result
            },
            _getLabelPosition: function(layout) {
                return this._getAxisLabelPosition(_Number(this._options.majorTick.length), _Number(this._options.label.indentFromTick), layout)
            },
            _generateTicks: function(layout) {
                var that = this,
                    scaleOptions = that._options,
                    translatorDomains = that._translator.getDomain(),
                    data = {
                        min: translatorDomains[0],
                        max: translatorDomains[1],
                        screenDelta: that._getScreenDelta(layout)
                    },
                    gridSpacingFactors = that._getGridSpacingFactor(),
                    options = {
                        tickInterval: scaleOptions.majorTick.tickInterval > 0 ? _Number(scaleOptions.majorTick.tickInterval) : undefined,
                        minorTickInterval: scaleOptions.minorTick.tickInterval > 0 ? _Number(scaleOptions.minorTick.tickInterval) : undefined,
                        gridSpacingFactor: gridSpacingFactors.majorTicks,
                        minorGridSpacingFactor: gridSpacingFactors.minorTicks,
                        numberMultipliers: [1, 2, 5],
                        textFontStyles: core.utils.patchFontOptions(that._options.label.font),
                        labelOptions: that._options.label,
                        getText: function(value) {
                            return that._formatValue(value)
                        },
                        isHorizontal: !that.vertical,
                        stick: true,
                        showMinorTicks: true
                    },
                    tickManager;
                if (scaleOptions.majorTick.useTicksAutoArrangement) {
                    options.useTicksAutoArrangement = true;
                    options.renderText = function(text, x, y, options) {
                        return that._renderer.text(text, x, y, options).append(that._renderer.root)
                    };
                    options.translate = that._getTranslateFunction(layout);
                    that._applyOverlappingOptions(options, layout)
                }
                tickManager = _createTickManager({}, data, options);
                return {
                        majorTicks: tickManager.getTicks(true),
                        minorTicks: tickManager.getMinorTicks()
                    }
            },
            _getTicks: function(layout) {
                var that = this,
                    options = that._options,
                    info = that._generateTicks(layout),
                    majorValues = options.majorTick.showCalculatedTicks ? info.majorTicks : [],
                    customMajorValues = _map(that._getCustomValues(options.majorTick.customTickValues, sortAsc), function(value) {
                        return binarySearch(value, majorValues) === -1 ? value : null
                    }),
                    minorValues = _map(options.minorTick.showCalculatedTicks ? info.minorTicks : [], function(value) {
                        return binarySearch(value, customMajorValues) === -1 ? value : null
                    }),
                    customMinorValues = that._getCustomValues(options.minorTick.customTickValues, sortAsc),
                    list = majorValues.concat(minorValues, customMajorValues).sort(sortAsc);
                customMinorValues = _map(customMinorValues, function(value) {
                    return binarySearch(value, list) === -1 ? value : null
                });
                return {
                        major: _map(majorValues.concat(customMajorValues), function(value) {
                            return {
                                    value: value,
                                    position: that._translator.translate(value)
                                }
                        }),
                        minor: _map(minorValues.concat(customMinorValues), function(value) {
                            return {
                                    value: value,
                                    position: that._translator.translate(value)
                                }
                        })
                    }
            },
            _createMajorTicks: function(ticks, layout) {
                var that = this;
                that._majorTicks.clear().attr({fill: that._options.majorTick.color});
                var points = that._getTickPoints(_Number(that._options.majorTick.length), _Number(that._options.majorTick.width), layout);
                if (points) {
                    var i = 0,
                        ii = ticks.length,
                        element;
                    that._options.hideFirstTick && ++i;
                    that._options.hideLastTick && --ii;
                    for (; i < ii; ++i) {
                        element = that._renderer.path(points, "area");
                        that._moveTick(element, ticks[i], layout);
                        element.append(that._majorTicks)
                    }
                }
            },
            _createMinorTicks: function(ticks, layout) {
                var that = this;
                that._minorTicks.clear().attr({fill: that._options.minorTick.color});
                var points = that._getTickPoints(_Number(that._options.minorTick.length), _Number(that._options.minorTick.width), layout);
                if (points) {
                    var i = 0,
                        ii = ticks.length,
                        element;
                    for (; i < ii; ++i) {
                        element = that._renderer.path(points, "area");
                        that._moveTick(element, ticks[i], layout);
                        element.append(that._minorTicks)
                    }
                }
            },
            _createLabels: function(ticks, layout) {
                var that = this,
                    indentFromTick = _Number(that._options.label.indentFromTick);
                that._labels.clear().attr({align: that._getLabelAlign(indentFromTick)}).css(core.utils.patchFontOptions(that._options.label.font));
                var textPosition = that._getLabelPosition(layout);
                if (textPosition) {
                    var i = 0,
                        ii = ticks.length,
                        points,
                        text,
                        fontStyles = {},
                        rangeContainer = that._options.label.useRangeColors ? that._options.rangeContainer : null;
                    that._options.hideFirstLabel && ++i;
                    that._options.hideLastLabel && --ii;
                    for (; i < ii; ++i) {
                        text = that._formatValue(ticks[i].value);
                        fontStyles.fill = rangeContainer ? rangeContainer.getColorForValue(ticks[i].value) : null;
                        points = that._getLabelOptions(text, textPosition, indentFromTick, ticks[i], layout);
                        that._renderer.text(text, points.x, points.y + that._textVerticalOffset).css(fontStyles).append(that._labels)
                    }
                }
            },
            resize: function(layout) {
                var that = this,
                    ticks = that._getTicks(layout);
                if (that._majorTicksEnabled)
                    that._createMajorTicks(ticks.major, layout);
                if (that._minorTicksEnabled)
                    that._createMinorTicks(ticks.minor, layout);
                if (that._labelsEnabled)
                    that._createLabels(ticks.major, layout);
                return that
            }
        });
        function getBasedAngle(startAngle, endAngle) {
            var startDelta,
                endDelta,
                tmp;
            if (startAngle > endAngle) {
                tmp = endAngle;
                endAngle = startAngle;
                startAngle = tmp
            }
            startDelta = 0 <= startAngle && startAngle <= 180 ? _abs(90 - startAngle) : _abs(270 - startAngle);
            startDelta = startAngle < 90 && 90 < endAngle || startAngle < 270 && 270 < endAngle ? 0 : startDelta;
            endDelta = 0 < endAngle && endAngle < 180 ? _abs(90 - endAngle) : _abs(270 - endAngle);
            return startDelta < endDelta ? startDelta : endDelta
        }
        viz.gauges.__internals.CircularScale = viz.gauges.__internals.BaseScale.inherit({
            _getGridSpacingFactor: function() {
                return {
                        majorTicks: 17,
                        minorTicks: 5
                    }
            },
            _getTranslateFunction: function(layout) {
                var that = this,
                    indent = _Number(that._options.label.indentFromTick),
                    translator = this._translator,
                    layout = layout || {
                        x: 0,
                        y: 0,
                        radius: 0
                    };
                return function(value) {
                        var position = that._getLabelPosition(layout),
                            text = that._formatValue(value);
                        return that._getLabelOptions(text, position, indent, {position: translator.translate(value)}, layout)
                    }
            },
            _overlappingBehaviorType: "circular",
            _getScreenDelta: function(layout) {
                return (this._translator.getCodomainStart() - this._translator.getCodomainEnd()) * layout.radius * PI_DIV_180
            },
            _setupOrientation: function() {
                var that = this;
                that._inner = that._outer = 0;
                switch (that._options.orientation) {
                    case'inside':
                        that._inner = 1;
                        break;
                    case'center':
                        that._inner = that._outer = 0.5;
                        break;
                    default:
                        that._outer = 1;
                        break
                }
            },
            _getTickPoints: function(length, width, layout) {
                var x1 = layout.x - width / 2,
                    x2 = layout.x + width / 2,
                    y1 = layout.y - layout.radius - length * this._outer,
                    y2 = layout.y - layout.radius + length * this._inner;
                return y1 > 0 && y2 > 0 ? [x1, y1, x2, y1, x2, y2, x1, y2] : null
            },
            _moveTick: function(element, tick, layout) {
                element.rotate(_convertAngleToRendererSpace(tick.position), layout.x, layout.y)
            },
            _getAxisLabelPosition: function(tickLength, textIndent, layout) {
                var position = layout.radius + tickLength * (textIndent >= 0 ? this._outer : -this._inner) + textIndent;
                return position > 0 ? position : null
            },
            _getLabelAlign: function() {
                return 'center'
            },
            _applyOverlappingOptions: function(options, layout) {
                options.circularRadius = this._getLabelPosition(layout);
                options.circularStartAngle = this._translator.getCodomainStart();
                options.circularEndAngle = this._translator.getCodomainEnd();
                options.overlappingBehaviorType = "circular"
            },
            _getLabelOptions: function(textValue, textPosition, textIndent, tick, layout) {
                var cossin = _getCosAndSin(tick.position),
                    x = layout.x + cossin.cos * textPosition,
                    y = layout.y - cossin.sin * textPosition,
                    dx = cossin.cos * (textValue.length / this._textLength) * this._textWidth / 2,
                    dy = cossin.sin * this._textHeight / 2;
                if (textIndent > 0) {
                    x += dx;
                    y -= dy
                }
                else {
                    x -= dx;
                    y += dy
                }
                return {
                        x: x,
                        y: y
                    }
            },
            measure: function(layout) {
                var that = this,
                    result = {
                        min: layout.radius,
                        max: layout.radius
                    };
                if (that._majorTicksEnabled) {
                    result.min = _min(result.min, layout.radius - that._inner * that._options.majorTick.length);
                    result.max = _max(result.max, layout.radius + that._outer * that._options.majorTick.length)
                }
                if (that._minorTicksEnabled) {
                    result.min = _min(result.min, layout.radius - that._inner * that._options.minorTick.length);
                    result.max = _max(result.max, layout.radius + that._outer * that._options.minorTick.length)
                }
                if (that._labelsEnabled) {
                    if (that._options.label.indentFromTick > 0) {
                        result.horizontalOffset = _Number(that._options.label.indentFromTick) + that._textWidth;
                        result.verticalOffset = _Number(that._options.label.indentFromTick) + that._textHeight
                    }
                    else {
                        result.horizontalOffset = result.verticalOffset = 0;
                        result.min -= -_Number(that._options.label.indentFromTick) + _max(that._textWidth, that._textHeight)
                    }
                    result.inverseHorizontalOffset = that._textWidth / 2;
                    result.inverseVerticalOffset = that._textHeight / 2
                }
                return result
            }
        });
        viz.gauges.__internals.LinearScale = viz.gauges.__internals.BaseScale.inherit({
            _getGridSpacingFactor: function() {
                return {
                        majorTicks: 25,
                        minorTicks: 5
                    }
            },
            _getTranslateFunction: function(layout) {
                var tr = this._translator;
                return function(value) {
                        return tr.translate(value)
                    }
            },
            _overlappingBehaviorType: "linear",
            _getScreenDelta: function(layout) {
                return _abs(this._translator.getCodomainEnd() - this._translator.getCodomainStart())
            },
            _setupOrientation: function() {
                var that = this;
                that.vertical = that._options.vertical;
                that._inner = that._outer = 0;
                if (that.vertical)
                    switch (that._options.horizontalOrientation) {
                        case'left':
                            that._inner = 1;
                            break;
                        case'center':
                            that._inner = that._outer = 0.5;
                            break;
                        default:
                            that._outer = 1;
                            break
                    }
                else
                    switch (that._options.verticalOrientation) {
                        case'top':
                            that._inner = 1;
                            break;
                        case'middle':
                            that._inner = that._outer = 0.5;
                            break;
                        default:
                            that._outer = 1;
                            break
                    }
            },
            _getTickPoints: function(length, width, layout) {
                var that = this,
                    x1,
                    x2,
                    y1,
                    y2;
                if (that.vertical) {
                    x1 = layout.x - length * that._inner;
                    x2 = layout.x + length * that._outer;
                    y1 = -width / 2;
                    y2 = +width / 2
                }
                else {
                    x1 = -width / 2;
                    x2 = +width / 2;
                    y1 = layout.y - length * that._inner;
                    y2 = layout.y + length * that._outer
                }
                return [x1, y1, x2, y1, x2, y2, x1, y2]
            },
            _moveTick: function(element, tick, layout) {
                var x = 0,
                    y = 0;
                if (this.vertical)
                    y = tick.position;
                else
                    x = tick.position;
                element.move(x, y)
            },
            _getAxisLabelPosition: function(tickLength, textIndent, layout) {
                var position = tickLength * (textIndent >= 0 ? this._outer : -this._inner) + textIndent;
                if (this.vertical)
                    position += layout.x;
                else
                    position += layout.y + (textIndent >= 0 ? 1 : -1) * (this._textVerticalOffset || 0);
                return position
            },
            _getLabelAlign: function(textIndent) {
                return this.vertical ? textIndent > 0 ? 'left' : 'right' : 'center'
            },
            _applyOverlappingOptions: function(options) {
                options.overlappingBehaviorType = "linear"
            },
            _getLabelOptions: function(textValue, textPosition, textIndent, tick) {
                var x,
                    y;
                if (this.vertical) {
                    x = textPosition;
                    y = tick.position
                }
                else {
                    x = tick.position;
                    y = textPosition
                }
                return {
                        x: x,
                        y: y
                    }
            },
            measure: function(layout) {
                var that = this,
                    p = layout[that.vertical ? 'x' : 'y'],
                    result = {
                        min: p,
                        max: p
                    };
                if (that._majorTicksEnabled) {
                    result.min = _min(result.min, p - that._inner * that._options.majorTick.length);
                    result.max = _max(result.max, p + that._outer * that._options.majorTick.length)
                }
                if (that._minorTicksEnabled) {
                    result.min = _min(result.min, p - that._inner * that._options.minorTick.length);
                    result.max = _max(result.max, p + that._outer * that._options.minorTick.length)
                }
                if (that._labelsEnabled) {
                    if (that._options.label.indentFromTick > 0)
                        result.max += +_Number(that._options.label.indentFromTick) + that[that.vertical ? '_textWidth' : '_textHeight'];
                    else
                        result.min -= -_Number(that._options.label.indentFromTick) + that[that.vertical ? '_textWidth' : '_textHeight'];
                    result.indent = that[that.vertical ? '_textHeight' : '_textWidth'] / 2
                }
                return result
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz-gauges, file baseIndicator.js */
    (function(DX, $, undefined) {
        var _isFinite = isFinite,
            _Number = Number,
            _extend = $.extend;
        DX.viz.gauges.__internals.BaseIndicator = DX.Class.inherit({
            setup: function(parameters) {
                var that = this;
                that._renderer = parameters.renderer;
                that._translator = parameters.translator;
                that._owner = parameters.owner;
                that._tracker = parameters.tracker;
                that._className = parameters.className;
                that._options = {};
                that._rootElement = that._createRoot();
                that._trackerElement = that._createTracker();
                return that
            },
            dispose: function() {
                var that = this;
                that._renderer = that._owner = that._translator = that._tracker = that._options = that._rootElement = that._trackerElement = null;
                return that
            },
            _setupAnimation: function() {
                var that = this;
                if (that._options.animation)
                    that._animation = {
                        step: function(pos) {
                            that._actualValue = that._animation.start + that._animation.delta * pos;
                            that._actualPosition = that._translator.translate(that._actualValue);
                            that._move()
                        },
                        duration: that._options.animation.duration > 0 ? _Number(that._options.animation.duration) : 0,
                        easing: that._options.animation.easing
                    }
            },
            _runAnimation: function(value) {
                var that = this,
                    animation = that._animation;
                animation.start = that._actualValue;
                animation.delta = value - that._actualValue;
                that._rootElement.animate({_: 0}, {
                    step: animation.step,
                    duration: animation.duration,
                    easing: animation.easing
                })
            },
            _createRoot: function() {
                return this._renderer.g().attr({'class': this._className})
            },
            _createTracker: function() {
                return this._renderer.path([], "area")
            },
            _getTrackerSettings: function(){},
            clean: function() {
                var that = this;
                that._animation && that._rootElement.stopAnimation();
                that._rootElement.remove();
                that._rootElement.clear();
                that._clear();
                that._tracker.detach(that._trackerElement);
                that._options = that.enabled = that._animation = null;
                return that
            },
            render: function(options) {
                var that = this;
                that.type = options.type;
                that._options = options;
                that._actualValue = that._currentValue = that._translator.adjust(that._options.currentValue);
                that.enabled = that._isEnabled();
                if (that.enabled) {
                    that._setupAnimation();
                    that._rootElement.attr({fill: that._options.color}).append(that._owner);
                    that._tracker.attach(that._trackerElement, that, that._trackerInfo)
                }
                return that
            },
            resize: function(layout) {
                var that = this;
                that._rootElement.clear();
                that._clear();
                that.visible = that._isVisible(layout);
                if (that.visible) {
                    _extend(that._options, layout);
                    that._actualPosition = that._translator.translate(that._actualValue);
                    that._render();
                    that._trackerElement.attr(that._getTrackerSettings());
                    that._move()
                }
                return that
            },
            value: function(arg, _noAnimation) {
                var that = this;
                if (arg !== undefined) {
                    var val = that._translator.adjust(arg);
                    if (that._currentValue !== val && _isFinite(val)) {
                        that._currentValue = val;
                        if (that.visible)
                            if (that._animation && !_noAnimation)
                                that._runAnimation(val);
                            else {
                                that._actualValue = val;
                                that._actualPosition = that._translator.translate(val);
                                that._move()
                            }
                    }
                    return that
                }
                return that._currentValue
            },
            _isEnabled: null,
            _isVisible: null,
            _render: null,
            _clear: null,
            _move: null
        })
    })(DevExpress, jQuery);
    /*! Module viz-gauges, file baseMarker.js */
    (function(DX, undefined) {
        var viz = DX.viz,
            core = viz.core,
            TextCloud = core.TextCloud;
        var formatValue = viz.gauges.__internals.formatValue,
            getSampleText = viz.gauges.__internals.getSampleText;
        viz.gauges.__internals.BaseTextCloudMarker = viz.gauges.__internals.BaseIndicator.inherit({
            _move: function() {
                var that = this,
                    bbox,
                    info = new TextCloud,
                    textCloudOptions = that._getTextCloudOptions();
                that._text.attr({text: formatValue(that._actualValue, that._options.text)});
                bbox = that._text.getBBox();
                info.setup({
                    x: textCloudOptions.x,
                    y: textCloudOptions.y,
                    textWidth: bbox.width,
                    textHeight: bbox.height,
                    horMargin: that._options.horizontalOffset,
                    verMargin: that._options.verticalOffset,
                    tailLength: that._options.arrowLength,
                    type: textCloudOptions.type
                });
                that._text.attr({
                    x: info.cx(),
                    y: info.cy() + that._textVerticalOffset
                });
                that._cloud.attr({points: info.points()}).sharp();
                that._trackerElement && that._trackerElement.attr({points: info.points()})
            },
            _measureText: function() {
                var that = this,
                    root,
                    text,
                    bbox;
                if (!that._textVerticalOffset) {
                    root = that._createRoot().append(that._owner);
                    text = that._renderer.text(getSampleText(that._translator, that._options.text), 0, 0).attr({align: 'center'}).css(core.utils.patchFontOptions(that._options.text.font)).append(root);
                    bbox = text.getBBox();
                    root.remove();
                    that._textVerticalOffset = -bbox.y - bbox.height / 2;
                    that._textWidth = bbox.width;
                    that._textHeight = bbox.height;
                    that._textFullWidth = that._textWidth + 2 * that._options.horizontalOffset;
                    that._textFullHeight = that._textHeight + 2 * that._options.verticalOffset
                }
            },
            _render: function() {
                var that = this;
                that._measureText();
                that._cloud = that._cloud || that._renderer.path([], "area").append(that._rootElement);
                that._text = that._text || that._renderer.text().append(that._rootElement);
                that._text.attr({align: 'center'}).css(core.utils.patchFontOptions(that._options.text.font))
            },
            _clear: function() {
                delete this._cloud;
                delete this._text
            },
            getTooltipParameters: function() {
                var position = this._getTextCloudOptions();
                return {
                        x: position.x,
                        y: position.y,
                        value: this._currentValue,
                        color: this._options.color
                    }
            }
        })
    })(DevExpress);
    /*! Module viz-gauges, file baseRangeBar.js */
    (function(DX, $, undefined) {
        var viz = DX.viz,
            core = viz.core,
            $extend = $.extend;
        var formatValue = viz.gauges.__internals.formatValue,
            getSampleText = viz.gauges.__internals.getSampleText;
        viz.gauges.__internals.BaseRangeBar = viz.gauges.__internals.BaseIndicator.inherit({
            _measureText: function() {
                var that = this,
                    root,
                    text,
                    bbox;
                that._hasText = that._isTextVisible();
                if (that._hasText && !that._textVerticalOffset) {
                    root = that._createRoot().append(that._owner);
                    text = that._renderer.text(getSampleText(that._translator, that._options.text), 0, 0).attr({
                        'class': 'dxg-text',
                        align: 'center'
                    }).css(core.utils.patchFontOptions(that._options.text.font)).append(root);
                    bbox = text.getBBox();
                    root.remove();
                    that._textVerticalOffset = -bbox.y - bbox.height / 2;
                    that._textWidth = bbox.width;
                    that._textHeight = bbox.height
                }
            },
            _move: function() {
                var that = this;
                that._updateBarItemsPositions();
                if (that._hasText) {
                    that._text.attr({text: formatValue(that._actualValue, that._options.text)});
                    that._updateTextPosition();
                    that._updateLinePosition()
                }
            },
            _updateBarItems: function() {
                var that = this,
                    options = that._options,
                    backgroundColor,
                    spaceColor;
                that._setBarSides();
                that._startPosition = that._translator.translate(that._translator.getDomainStart());
                that._endPosition = that._translator.translate(that._translator.getDomainEnd());
                that._basePosition = that._translator.translate(options.baseValue);
                that._space = that._getSpace();
                backgroundColor = options.backgroundColor || 'none';
                if (backgroundColor !== 'none' && that._space > 0)
                    spaceColor = options.containerBackgroundColor || 'none';
                else {
                    that._space = 0;
                    spaceColor = 'none'
                }
                that._backItem1.attr({fill: backgroundColor});
                that._backItem2.attr({fill: backgroundColor});
                that._spaceItem1.attr({fill: spaceColor});
                that._spaceItem2.attr({fill: spaceColor})
            },
            _getSpace: function() {
                return 0
            },
            _updateTextItems: function() {
                var that = this;
                if (that._hasText) {
                    that._line = that._line || that._renderer.path([], "line").attr({
                        'class': 'dxg-main-bar',
                        "stroke-linecap": "square"
                    }).append(that._rootElement);
                    that._text = that._text || that._renderer.text('', 0, 0).attr({'class': 'dxg-text'}).append(that._rootElement);
                    that._text.attr({align: that._getTextAlign()}).css(that._getFontOptions());
                    that._setTextItemsSides()
                }
                else {
                    if (that._line) {
                        that._line.remove();
                        delete that._line
                    }
                    if (that._text) {
                        that._text.remove();
                        delete that._text
                    }
                }
            },
            _isTextVisible: function() {
                return false
            },
            _getTextAlign: function() {
                return 'center'
            },
            _getFontOptions: function() {
                var options = this._options,
                    font = options.text.font;
                if (!font || !font.color)
                    font = $extend({}, font, {color: options.color});
                return core.utils.patchFontOptions(font)
            },
            _updateBarItemsPositions: function() {
                var that = this,
                    positions = that._getPositions();
                that._backItem1.attr(that._buildItemSettings(positions.start, positions.back1));
                that._backItem2.attr(that._buildItemSettings(positions.back2, positions.end));
                that._spaceItem1.attr(that._buildItemSettings(positions.back1, positions.main1));
                that._spaceItem2.attr(that._buildItemSettings(positions.main2, positions.back2));
                that._mainItem.attr(that._buildItemSettings(positions.main1, positions.main2));
                that._trackerElement && that._trackerElement.attr(that._buildItemSettings(positions.main1, positions.main2))
            },
            _render: function() {
                var that = this;
                that._measureText();
                if (!that._backItem1) {
                    that._backItem1 = that._createBarItem();
                    that._backItem1.attr({'class': 'dxg-back-bar'})
                }
                if (!that._backItem2) {
                    that._backItem2 = that._createBarItem();
                    that._backItem2.attr({'class': 'dxg-back-bar'})
                }
                if (!that._spaceItem1) {
                    that._spaceItem1 = that._createBarItem();
                    that._spaceItem1.attr({'class': 'dxg-space-bar'})
                }
                if (!that._spaceItem2) {
                    that._spaceItem2 = that._createBarItem();
                    that._spaceItem2.attr({'class': 'dxg-space-bar'})
                }
                if (!that._mainItem) {
                    that._mainItem = that._createBarItem();
                    that._mainItem.attr({'class': 'dxg-main-bar'})
                }
                that._updateBarItems();
                that._updateTextItems()
            },
            _clear: function() {
                var that = this;
                delete that._backItem1;
                delete that._backItem2;
                delete that._spaceItem1;
                delete that._spaceItem2;
                delete that._mainItem;
                delete that._hasText;
                delete that._line;
                delete that._text
            },
            getTooltipParameters: function() {
                var position = this._getTooltipPosition();
                return {
                        x: position.x,
                        y: position.y,
                        value: this._currentValue,
                        color: this._options.color,
                        offset: 0
                    }
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz-gauges, file circularNeedle.js */
    (function(DX, undefined) {
        var circularNeedles = DX.viz.gauges.__internals.circularNeedles;
        var _Number = Number;
        circularNeedles.SimpleIndicator = DX.viz.gauges.__internals.BaseIndicator.inherit({
            _move: function() {
                var that = this,
                    options = that._options,
                    angle = DX.utils.convertAngleToRendererSpace(that._actualPosition);
                that._rootElement.rotate(angle, options.x, options.y);
                that._trackerElement && that._trackerElement.rotate(angle, options.x, options.y)
            },
            _isEnabled: function() {
                return this._options.width > 0
            },
            _isVisible: function(layout) {
                return layout.radius - _Number(this._options.indentFromCenter) > 0
            },
            _getTrackerSettings: function() {
                var options = this._options,
                    x = options.x,
                    y = options.y - (options.radius + _Number(options.indentFromCenter)) / 2,
                    width = options.width / 2,
                    length = (options.radius - _Number(options.indentFromCenter)) / 2;
                width > 10 || (width = 10);
                length > 10 || (length = 10);
                return {points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]}
            },
            _renderSpindle: function() {
                var that = this,
                    options = that._options,
                    gapSize;
                if (options.spindleSize > 0) {
                    gapSize = _Number(options.spindleGapSize) || 0;
                    if (gapSize > 0)
                        gapSize = gapSize <= options.spindleSize ? gapSize : _Number(options.spindleSize);
                    that._spindleOuter = that._spindleOuter || that._renderer.circle().append(that._rootElement);
                    that._spindleInner = that._spindleInner || that._renderer.circle().append(that._rootElement);
                    that._spindleOuter.attr({
                        'class': 'dxg-spindle-border',
                        cx: options.x,
                        cy: options.y,
                        r: options.spindleSize / 2
                    });
                    that._spindleInner.attr({
                        'class': 'dxg-spindle-hole',
                        cx: options.x,
                        cy: options.y,
                        r: gapSize / 2,
                        fill: options.containerBackgroundColor
                    })
                }
            },
            _render: function() {
                var that = this;
                that._renderPointer();
                that._renderSpindle()
            },
            _clearSpindle: function() {
                delete this._spindleOuter;
                delete this._spindleInner
            },
            _clearPointer: function() {
                delete this._element
            },
            _clear: function() {
                this._clearPointer();
                this._clearSpindle()
            },
            measure: function(layout) {
                var result = {max: layout.radius};
                if (this._options.indentFromCenter < 0)
                    result.inverseHorizontalOffset = result.inverseVerticalOffset = -_Number(this._options.indentFromCenter);
                return result
            },
            getTooltipParameters: function() {
                var options = this._options,
                    cossin = DX.utils.getCosAndSin(this._actualPosition),
                    r = (options.radius + _Number(options.indentFromCenter)) / 2;
                return {
                        x: options.x + cossin.cos * r,
                        y: options.y - cossin.sin * r,
                        value: this._currentValue,
                        color: options.color,
                        offset: options.width / 2
                    }
            }
        });
        circularNeedles.RectangleNeedle = circularNeedles.SimpleIndicator.inherit({_renderPointer: function() {
                var that = this,
                    options = that._options,
                    y2 = options.y - options.radius,
                    y1 = options.y - _Number(options.indentFromCenter),
                    x1 = options.x - options.width / 2,
                    x2 = x1 + _Number(options.width);
                that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                that._element.attr({points: [x1, y1, x1, y2, x2, y2, x2, y1]})
            }});
        circularNeedles.TriangleNeedle = circularNeedles.SimpleIndicator.inherit({_renderPointer: function() {
                var that = this,
                    options = that._options,
                    y2 = options.y - options.radius,
                    y1 = options.y - _Number(options.indentFromCenter),
                    x1 = options.x - options.width / 2,
                    x2 = options.x + options.width / 2;
                that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                that._element.attr({points: [x1, y1, options.x, y2, x2, y1]})
            }});
        circularNeedles.TwoColorRectangleNeedle = circularNeedles.SimpleIndicator.inherit({
            _renderPointer: function() {
                var that = this,
                    options = that._options,
                    x1 = options.x - options.width / 2,
                    x2 = options.x + options.width / 2,
                    y4 = options.y - options.radius,
                    y1 = options.y - _Number(options.indentFromCenter),
                    fraction = _Number(options.secondFraction) || 0,
                    y2,
                    y3;
                if (fraction >= 1)
                    y2 = y3 = y1;
                else if (fraction <= 0)
                    y2 = y3 = y2;
                else {
                    y3 = y4 + (y1 - y4) * fraction;
                    y2 = y3 + options.space
                }
                that._firstElement = that._firstElement || that._renderer.path([], "area").append(that._rootElement);
                that._spaceElement = that._spaceElement || that._renderer.path([], "area").append(that._rootElement);
                that._secondElement = that._secondElement || that._renderer.path([], "area").append(that._rootElement);
                that._firstElement.attr({points: [x1, y1, x1, y2, x2, y2, x2, y1]});
                that._spaceElement.attr({
                    points: [x1, y2, x1, y3, x2, y3, x2, y2],
                    'class': 'dxg-hole',
                    fill: options.containerBackgroundColor
                });
                that._secondElement.attr({
                    points: [x1, y3, x1, y4, x2, y4, x2, y3],
                    'class': 'dxg-part',
                    fill: options.secondColor
                })
            },
            _clearPointer: function() {
                delete this._firstElement;
                delete this._secondElement;
                delete this._spaceElement
            }
        })
    })(DevExpress);
    /*! Module viz-gauges, file linearNeedle.js */
    (function(DX, undefined) {
        var linearNeedles = DX.viz.gauges.__internals.linearNeedles;
        var _Number = Number;
        linearNeedles.SimpleIndicator = DX.viz.gauges.__internals.BaseIndicator.inherit({
            _move: function() {
                var that = this,
                    delta = that._actualPosition - that._zeroPosition;
                that._rootElement.move(that.vertical ? 0 : delta, that.vertical ? delta : 0);
                that._trackerElement && that._trackerElement.move(that.vertical ? 0 : delta, that.vertical ? delta : 0)
            },
            _isEnabled: function() {
                this.vertical = this._options.vertical;
                return this._options.length > 0 && this._options.width > 0
            },
            _isVisible: function(layout) {
                return true
            },
            _getTrackerSettings: function() {
                var options = this._options,
                    x1,
                    x2,
                    y1,
                    y2,
                    width = options.width / 2,
                    length = options.length / 2,
                    p = this._zeroPosition;
                width > 10 || (width = 10);
                length > 10 || (length = 10);
                if (this.vertical) {
                    x1 = options.x - length;
                    x2 = options.x + length;
                    y1 = p + width;
                    y2 = p - width
                }
                else {
                    x1 = p - width;
                    x2 = p + width;
                    y1 = options.y + length;
                    y2 = options.y - length
                }
                return {points: [x1, y1, x1, y2, x2, y2, x2, y1]}
            },
            _render: function() {
                var that = this;
                that._zeroPosition = that._translator.getCodomainStart()
            },
            _clear: function() {
                delete this._element
            },
            measure: function(layout) {
                var p = this.vertical ? layout.x : layout.y;
                return {
                        min: p - this._options.length / 2,
                        max: p + this._options.length / 2
                    }
            },
            getTooltipParameters: function() {
                var that = this,
                    options = that._options,
                    p = that._actualPosition,
                    parameters = {
                        x: p,
                        y: p,
                        value: that._currentValue,
                        color: options.color,
                        offset: options.width / 2
                    };
                that.vertical ? parameters.x = options.x : parameters.y = options.y;
                return parameters
            }
        });
        linearNeedles.RectangleNeedle = linearNeedles.SimpleIndicator.inherit({_render: function() {
                var that = this,
                    options = that._options,
                    p,
                    x1,
                    x2,
                    y1,
                    y2;
                that.callBase();
                p = that._zeroPosition;
                if (that.vertical) {
                    x1 = options.x - options.length / 2;
                    x2 = options.x + options.length / 2;
                    y1 = p + options.width / 2;
                    y2 = p - options.width / 2
                }
                else {
                    x1 = p - options.width / 2;
                    x2 = p + options.width / 2;
                    y1 = options.y + options.length / 2;
                    y2 = options.y - options.length / 2
                }
                that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                that._element.attr({points: [x1, y1, x1, y2, x2, y2, x2, y1]})
            }});
        linearNeedles.RhombusNeedle = linearNeedles.SimpleIndicator.inherit({_render: function() {
                var that = this,
                    options = that._options,
                    x,
                    y,
                    dx,
                    dy;
                that.callBase();
                if (that.vertical) {
                    x = options.x;
                    y = that._zeroPosition;
                    dx = options.length / 2 || 0;
                    dy = options.width / 2 || 0
                }
                else {
                    x = that._zeroPosition;
                    y = options.y;
                    dx = options.width / 2 || 0;
                    dy = options.length / 2 || 0
                }
                that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                that._element.attr({points: [x - dx, y, x, y - dy, x + dx, y, x, y + dy]})
            }});
        linearNeedles.CircleNeedle = linearNeedles.SimpleIndicator.inherit({_render: function() {
                var that = this,
                    options = that._options,
                    x,
                    y,
                    r;
                that.callBase();
                if (that.vertical) {
                    x = options.x;
                    y = that._zeroPosition
                }
                else {
                    x = that._zeroPosition;
                    y = options.y
                }
                r = options.length / 2 || 0;
                that._element = that._element || that._renderer.circle().append(that._rootElement);
                that._element.attr({
                    cx: x,
                    cy: y,
                    r: r
                })
            }})
    })(DevExpress);
    /*! Module viz-gauges, file circularMarker.js */
    (function(DX, undefined) {
        var circularMarkers = DX.viz.gauges.__internals.circularMarkers;
        var _Number = Number;
        circularMarkers.TriangleMarker = DX.viz.gauges.__internals.circularNeedles.SimpleIndicator.inherit({
            _isEnabled: function() {
                return this._options.length > 0 && this._options.width > 0
            },
            _isVisible: function(layout) {
                return layout.radius > 0
            },
            _render: function() {
                var that = this,
                    options = that._options,
                    x = options.x,
                    y1 = options.y - options.radius,
                    dx = options.width / 2 || 0,
                    y2 = y1 - _Number(options.length),
                    settings;
                that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                settings = {
                    points: [x, y1, x - dx, y2, x + dx, y2],
                    stroke: 'none',
                    "stroke-width": 0,
                    "stroke-linecap": "square"
                };
                if (options.space > 0) {
                    settings["stroke-width"] = Math.min(options.space, options.width / 4) || 0;
                    settings.stroke = settings["stroke-width"] > 0 ? options.containerBackgroundColor || 'none' : 'none'
                }
                that._element.attr(settings).sharp()
            },
            _clear: function() {
                delete this._element
            },
            _getTrackerSettings: function() {
                var options = this._options,
                    x = options.x,
                    y = options.y - options.radius - options.length / 2,
                    width = options.width / 2,
                    length = options.length / 2;
                width > 10 || (width = 10);
                length > 10 || (length = 10);
                return {points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]}
            },
            measure: function(layout) {
                return {
                        min: layout.radius,
                        max: layout.radius + _Number(this._options.length)
                    }
            },
            getTooltipParameters: function() {
                var options = this._options,
                    cossin = DX.utils.getCosAndSin(this._actualPosition),
                    r = options.radius + options.length / 2,
                    parameters = this.callBase();
                parameters.x = options.x + cossin.cos * r;
                parameters.y = options.y - cossin.sin * r;
                parameters.offset = options.length / 2;
                return parameters
            }
        });
        circularMarkers.TextCloudMarker = DX.viz.gauges.__internals.BaseTextCloudMarker.inherit({
            _isEnabled: function() {
                return true
            },
            _isVisible: function(layout) {
                return layout.radius > 0
            },
            _getTextCloudOptions: function() {
                var that = this,
                    cossin = DX.utils.getCosAndSin(that._actualPosition),
                    nangle = DX.utils.normalizeAngle(that._actualPosition);
                return {
                        x: that._options.x + cossin.cos * that._options.radius,
                        y: that._options.y - cossin.sin * that._options.radius,
                        type: nangle > 270 ? 'left-top' : nangle > 180 ? 'top-right' : nangle > 90 ? 'right-bottom' : 'bottom-left'
                    }
            },
            measure: function(layout) {
                var that = this;
                that._measureText();
                return {
                        min: layout.radius,
                        max: layout.radius,
                        horizontalOffset: that._textFullWidth + (_Number(that._options.arrowLength) || 0),
                        verticalOffset: that._textFullHeight + (_Number(that._options.arrowLength) || 0)
                    }
            }
        })
    })(DevExpress);
    /*! Module viz-gauges, file linearMarker.js */
    (function(DX, undefined) {
        var linearMarkers = DX.viz.gauges.__internals.linearMarkers;
        var _Number = Number,
            _String = String;
        linearMarkers.TriangleMarker = DX.viz.gauges.__internals.linearNeedles.SimpleIndicator.inherit({
            _isEnabled: function() {
                var that = this;
                that.vertical = that._options.vertical;
                that._inverted = that.vertical ? _String(that._options.horizontalOrientation).toLowerCase() === 'right' : _String(that._options.verticalOrientation).toLowerCase() === 'bottom';
                return that._options.length > 0 && that._options.width > 0
            },
            _isVisible: function(layout) {
                return true
            },
            _render: function() {
                var that = this,
                    options = that._options,
                    x1,
                    x2,
                    y1,
                    y2,
                    settings = {
                        stroke: 'none',
                        "stroke-width": 0,
                        "stroke-linecap": "square"
                    };
                that.callBase();
                if (that.vertical) {
                    x1 = options.x;
                    y1 = that._zeroPosition;
                    x2 = x1 + _Number(that._inverted ? options.length : -options.length);
                    settings.points = [x1, y1, x2, y1 - options.width / 2, x2, y1 + options.width / 2]
                }
                else {
                    y1 = options.y;
                    x1 = that._zeroPosition;
                    y2 = y1 + _Number(that._inverted ? options.length : -options.length);
                    settings.points = [x1, y1, x1 - options.width / 2, y2, x1 + options.width / 2, y2]
                }
                if (options.space > 0) {
                    settings["stroke-width"] = Math.min(options.space, options.width / 4) || 0;
                    settings.stroke = settings["stroke-width"] > 0 ? options.containerBackgroundColor || 'none' : 'none'
                }
                that._element = that._element || that._renderer.path([], "area").append(that._rootElement);
                that._element.attr(settings).sharp()
            },
            _getTrackerSettings: function() {
                var that = this,
                    options = that._options,
                    width = options.width / 2,
                    length = _Number(options.length),
                    x1,
                    x2,
                    y1,
                    y2,
                    result;
                width > 10 || (width = 10);
                length > 20 || (length = 20);
                if (that.vertical) {
                    x1 = x2 = options.x;
                    x2 = x1 + (that._inverted ? length : -length);
                    y1 = that._zeroPosition + width;
                    y2 = that._zeroPosition - width;
                    result = [x1, y1, x2, y1, x2, y2, x1, y2]
                }
                else {
                    y1 = options.y;
                    y2 = y1 + (that._inverted ? length : -length);
                    x1 = that._zeroPosition - width;
                    x2 = that._zeroPosition + width;
                    result = [x1, y1, x1, y2, x2, y2, x2, y1]
                }
                return {points: result}
            },
            measure: function(layout) {
                var that = this,
                    length = _Number(that._options.length),
                    minbound,
                    maxbound;
                if (that.vertical) {
                    minbound = maxbound = layout.x;
                    if (that._inverted)
                        maxbound = minbound + length;
                    else
                        minbound = maxbound - length
                }
                else {
                    minbound = maxbound = layout.y;
                    if (that._inverted)
                        maxbound = minbound + length;
                    else
                        minbound = maxbound - length
                }
                return {
                        min: minbound,
                        max: maxbound,
                        indent: that._options.width / 2
                    }
            },
            getTooltipParameters: function() {
                var that = this,
                    options = that._options,
                    s = (that._inverted ? options.length : -options.length) / 2,
                    parameters = that.callBase();
                that.vertical ? parameters.x += s : parameters.y += s;
                parameters.offset = options.length / 2;
                return parameters
            }
        });
        linearMarkers.TextCloudMarker = DX.viz.gauges.__internals.BaseTextCloudMarker.inherit({
            _isEnabled: function() {
                var that = this;
                that.vertical = that._options.vertical;
                that._inverted = that.vertical ? _String(that._options.horizontalOrientation).toLowerCase() === 'right' : _String(that._options.verticalOrientation).toLowerCase() === 'bottom';
                return true
            },
            _isVisible: function(layout) {
                return true
            },
            _getTextCloudOptions: function() {
                var that = this,
                    x = that._actualPosition,
                    y = that._actualPosition,
                    type;
                if (that.vertical) {
                    x = that._options.x;
                    type = that._inverted ? 'top-left' : 'top-right'
                }
                else {
                    y = that._options.y;
                    type = that._inverted ? 'right-top' : 'right-bottom'
                }
                return {
                        x: x,
                        y: y,
                        type: type
                    }
            },
            measure: function(layout) {
                var that = this,
                    minbound,
                    maxbound,
                    arrowLength = _Number(that._options.arrowLength) || 0,
                    indent;
                that._measureText();
                if (that.vertical) {
                    indent = that._textFullHeight;
                    if (that._inverted) {
                        minbound = layout.x;
                        maxbound = layout.x + arrowLength + that._textFullWidth
                    }
                    else {
                        minbound = layout.x - arrowLength - that._textFullWidth;
                        maxbound = layout.x
                    }
                }
                else {
                    indent = that._textFullWidth;
                    if (that._inverted) {
                        minbound = layout.y;
                        maxbound = layout.y + arrowLength + that._textFullHeight
                    }
                    else {
                        minbound = layout.y - arrowLength - that._textFullHeight;
                        maxbound = layout.y
                    }
                }
                return {
                        min: minbound,
                        max: maxbound,
                        indent: indent
                    }
            }
        })
    })(DevExpress);
    /*! Module viz-gauges, file circularRangeBar.js */
    (function(DX, undefined) {
        var _Number = Number,
            getCosAndSin = DX.utils.getCosAndSin,
            convertAngleToRendererSpace = DX.utils.convertAngleToRendererSpace,
            max = Math.max,
            min = Math.min;
        DX.viz.gauges.__internals.CircularRangeBar = DX.viz.gauges.__internals.BaseRangeBar.inherit({
            _isEnabled: function() {
                return this._options.size > 0
            },
            _isVisible: function(layout) {
                return layout.radius - _Number(this._options.size) > 0
            },
            _createBarItem: function() {
                return this._renderer.arc().attr({"stroke-linejoin": "round"}).append(this._rootElement)
            },
            _createTracker: function() {
                return this._renderer.arc().attr({"stroke-linejoin": "round"})
            },
            _setBarSides: function() {
                var that = this;
                that._maxSide = that._options.radius;
                that._minSide = that._maxSide - _Number(that._options.size)
            },
            _getSpace: function() {
                var options = this._options;
                return options.space > 0 ? options.space * 180 / options.radius / Math.PI : 0
            },
            _isTextVisible: function() {
                var options = this._options.text || {};
                return options.indent > 0
            },
            _setTextItemsSides: function() {
                var that = this,
                    options = that._options;
                that._lineFrom = options.y - options.radius;
                that._lineTo = that._lineFrom - _Number(options.text.indent);
                that._textRadius = options.radius + _Number(options.text.indent)
            },
            _getPositions: function() {
                var that = this,
                    basePosition = that._basePosition,
                    actualPosition = that._actualPosition,
                    mainPosition1,
                    mainPosition2;
                if (basePosition >= actualPosition) {
                    mainPosition1 = basePosition;
                    mainPosition2 = actualPosition
                }
                else {
                    mainPosition1 = actualPosition;
                    mainPosition2 = basePosition
                }
                return {
                        start: that._startPosition,
                        end: that._endPosition,
                        main1: mainPosition1,
                        main2: mainPosition2,
                        back1: min(mainPosition1 + that._space, that._startPosition),
                        back2: max(mainPosition2 - that._space, that._endPosition)
                    }
            },
            _buildItemSettings: function(from, to) {
                var that = this;
                return {
                        x: that._options.x,
                        y: that._options.y,
                        innerRadius: that._minSide,
                        outerRadius: that._maxSide,
                        startAngle: to,
                        endAngle: from
                    }
            },
            _updateTextPosition: function() {
                var that = this,
                    cossin = getCosAndSin(that._actualPosition),
                    x = that._options.x + that._textRadius * cossin.cos,
                    y = that._options.y - that._textRadius * cossin.sin;
                x += cossin.cos * that._textWidth * 0.6;
                y -= cossin.sin * that._textHeight * 0.6;
                that._text.attr({
                    x: x,
                    y: y + that._textVerticalOffset
                })
            },
            _updateLinePosition: function() {
                var that = this,
                    x = that._options.x,
                    x1,
                    x2;
                if (that._basePosition > that._actualPosition) {
                    x1 = x - 2;
                    x2 = x
                }
                else if (that._basePosition < that._actualPosition) {
                    x1 = x;
                    x2 = x + 2
                }
                else {
                    x1 = x - 1;
                    x2 = x + 1
                }
                that._line.attr({points: [x1, that._lineFrom, x1, that._lineTo, x2, that._lineTo, x2, that._lineFrom]}).rotate(convertAngleToRendererSpace(that._actualPosition), x, that._options.y).sharp()
            },
            _getTooltipPosition: function() {
                var that = this,
                    cossin = getCosAndSin((that._basePosition + that._actualPosition) / 2),
                    r = (that._minSide + that._maxSide) / 2;
                return {
                        x: that._options.x + cossin.cos * r,
                        y: that._options.y - cossin.sin * r
                    }
            },
            measure: function(layout) {
                var that = this,
                    result = {
                        min: layout.radius - _Number(that._options.size),
                        max: layout.radius
                    };
                that._measureText();
                if (that._hasText) {
                    result.max += _Number(that._options.text.indent);
                    result.horizontalOffset = that._textWidth;
                    result.verticalOffset = that._textHeight
                }
                return result
            }
        })
    })(DevExpress);
    /*! Module viz-gauges, file linearRangeBar.js */
    (function(DX, undefined) {
        var _Number = Number,
            _String = String;
        DX.viz.gauges.__internals.LinearRangeBar = DX.viz.gauges.__internals.BaseRangeBar.inherit({
            _isEnabled: function() {
                var that = this;
                that.vertical = that._options.vertical;
                that._inverted = that.vertical ? _String(that._options.horizontalOrientation).toLowerCase() === 'right' : _String(that._options.verticalOrientation).toLowerCase() === 'bottom';
                return that._options.size > 0
            },
            _isVisible: function(layout) {
                return true
            },
            _createBarItem: function() {
                return this._renderer.path([], "area").append(this._rootElement)
            },
            _createTracker: function() {
                return this._renderer.path([], "area")
            },
            _setBarSides: function() {
                var that = this,
                    options = that._options,
                    size = _Number(options.size),
                    minSide,
                    maxSide;
                if (that.vertical)
                    if (that._inverted) {
                        minSide = options.x;
                        maxSide = options.x + size
                    }
                    else {
                        minSide = options.x - size;
                        maxSide = options.x
                    }
                else if (that._inverted) {
                    minSide = options.y;
                    maxSide = options.y + size
                }
                else {
                    minSide = options.y - size;
                    maxSide = options.y
                }
                that._minSide = minSide;
                that._maxSide = maxSide;
                that._minBound = minSide;
                that._maxBound = maxSide
            },
            _getSpace: function() {
                var options = this._options;
                return options.space > 0 ? _Number(options.space) : 0
            },
            _isTextVisible: function() {
                var textOptions = this._options.text || {};
                return textOptions.indent > 0 || textOptions.indent < 0
            },
            _getTextAlign: function() {
                return this.vertical ? this._options.text.indent > 0 ? 'left' : 'right' : 'center'
            },
            _setTextItemsSides: function() {
                var that = this,
                    indent = _Number(that._options.text.indent);
                if (indent > 0) {
                    that._lineStart = that._maxSide;
                    that._lineEnd = that._maxSide + indent;
                    that._textPosition = that._lineEnd + (that.vertical ? 2 : that._textHeight / 2);
                    that._maxBound = that._textPosition + (that.vertical ? that._textWidth : that._textHeight / 2)
                }
                else if (indent < 0) {
                    that._lineStart = that._minSide;
                    that._lineEnd = that._minSide + indent;
                    that._textPosition = that._lineEnd - (that.vertical ? 2 : that._textHeight / 2);
                    that._minBound = that._textPosition - (that.vertical ? that._textWidth : that._textHeight / 2)
                }
            },
            _getPositions: function() {
                var that = this,
                    options = that._options,
                    startPosition = that._startPosition,
                    endPosition = that._endPosition,
                    space = that._space,
                    basePosition = that._basePosition,
                    actualPosition = that._actualPosition,
                    mainPosition1,
                    mainPosition2,
                    backPosition1,
                    backPosition2;
                if (startPosition < endPosition) {
                    if (basePosition < actualPosition) {
                        mainPosition1 = basePosition;
                        mainPosition2 = actualPosition
                    }
                    else {
                        mainPosition1 = actualPosition;
                        mainPosition2 = basePosition
                    }
                    backPosition1 = mainPosition1 - space;
                    backPosition2 = mainPosition2 + space
                }
                else {
                    if (basePosition > actualPosition) {
                        mainPosition1 = basePosition;
                        mainPosition2 = actualPosition
                    }
                    else {
                        mainPosition1 = actualPosition;
                        mainPosition2 = basePosition
                    }
                    backPosition1 = mainPosition1 + space;
                    backPosition2 = mainPosition2 - space
                }
                return {
                        start: startPosition,
                        end: endPosition,
                        main1: mainPosition1,
                        main2: mainPosition2,
                        back1: backPosition1,
                        back2: backPosition2
                    }
            },
            _buildItemSettings: function(from, to) {
                var that = this,
                    side1 = that._minSide,
                    side2 = that._maxSide;
                var points = that.vertical ? [side1, from, side1, to, side2, to, side2, from] : [from, side1, from, side2, to, side2, to, side1];
                return {points: points}
            },
            _updateTextPosition: function() {
                var that = this;
                that._text.attr(that.vertical ? {
                    x: that._textPosition,
                    y: that._actualPosition + that._textVerticalOffset
                } : {
                    x: that._actualPosition,
                    y: that._textPosition + that._textVerticalOffset
                })
            },
            _updateLinePosition: function() {
                var that = this,
                    actualPosition = that._actualPosition,
                    side1,
                    side2,
                    points;
                if (that.vertical) {
                    if (that._basePosition >= actualPosition) {
                        side1 = actualPosition;
                        side2 = actualPosition + 2
                    }
                    else {
                        side1 = actualPosition - 2;
                        side2 = actualPosition
                    }
                    points = [that._lineStart, side1, that._lineStart, side2, that._lineEnd, side2, that._lineEnd, side1]
                }
                else {
                    if (that._basePosition <= actualPosition) {
                        side1 = actualPosition - 2;
                        side2 = actualPosition
                    }
                    else {
                        side1 = actualPosition;
                        side2 = actualPosition + 2
                    }
                    points = [side1, that._lineStart, side1, that._lineEnd, side2, that._lineEnd, side2, that._lineStart]
                }
                that._line.attr({points: points}).sharp()
            },
            _getTooltipPosition: function() {
                var that = this,
                    crossCenter = (that._minSide + that._maxSide) / 2,
                    alongCenter = (that._basePosition + that._actualPosition) / 2,
                    position = {};
                if (that.vertical)
                    position = {
                        x: crossCenter,
                        y: alongCenter
                    };
                else
                    position = {
                        x: alongCenter,
                        y: crossCenter
                    };
                return position
            },
            measure: function(layout) {
                var that = this,
                    size = _Number(that._options.size),
                    textIndent = _Number(that._options.text.indent),
                    minbound,
                    maxbound,
                    indent;
                that._measureText();
                if (that.vertical) {
                    minbound = maxbound = layout.x;
                    if (that._inverted)
                        maxbound = maxbound + size;
                    else
                        minbound = minbound - size;
                    if (that._hasText) {
                        indent = that._textHeight / 2;
                        if (textIndent > 0)
                            maxbound += textIndent + that._textWidth;
                        if (textIndent < 0)
                            minbound += textIndent - that._textWidth
                    }
                }
                else {
                    minbound = maxbound = layout.y;
                    if (that._inverted)
                        maxbound = maxbound + size;
                    else
                        minbound = minbound - size;
                    if (that._hasText) {
                        indent = that._textWidth / 2;
                        if (textIndent > 0)
                            maxbound += textIndent + that._textHeight;
                        if (textIndent < 0)
                            minbound += textIndent - that._textHeight
                    }
                }
                return {
                        min: minbound,
                        max: maxbound,
                        indent: indent
                    }
            }
        })
    })(DevExpress);
    /*! Module viz-gauges, file rangeContainer.js */
    (function(DX, $, undefined) {
        var _Number = Number,
            _String = String,
            _max = Math.max,
            _abs = Math.abs,
            _isString = DX.utils.isString,
            _isArray = DX.utils.isArray,
            _isFinite = isFinite,
            _each = $.each,
            _map = $.map;
        var _Palette = DX.viz.core.Palette;
        DX.viz.gauges.__internals.BaseRangeContainer = DX.Class.inherit({
            ctor: function(parameters) {
                var that = this;
                that._renderer = parameters.renderer;
                that._container = parameters.container;
                that._translator = parameters.translator;
                that._root = that._renderer.g().attr({'class': 'dxg-range-container'})
            },
            dispose: function() {
                var that = this;
                that._renderer = that._container = that._translator = that._root = null
            },
            clean: function() {
                this._root.remove().clear();
                this._options = this.enabled = null;
                return this
            },
            _getRanges: function() {
                var that = this,
                    options = that._options,
                    translator = that._translator,
                    totalStart = translator.getDomain()[0],
                    totalEnd = translator.getDomain()[1],
                    totalDelta = totalEnd - totalStart,
                    isNotEmptySegment = totalDelta >= 0 ? isNotEmptySegmentAsc : isNotEmptySegmentDes,
                    subtractSegment = totalDelta >= 0 ? subtractSegmentAsc : subtractSegmentDes,
                    list = [],
                    ranges = [],
                    backgroundRanges = [{
                            start: totalStart,
                            end: totalEnd
                        }],
                    threshold = _abs(totalDelta) / 1E4,
                    palette = new _Palette(options.palette, {
                        type: 'indicatingSet',
                        theme: options.themeName
                    }),
                    backgroundColor = _isString(options.backgroundColor) ? options.backgroundColor : 'none',
                    width = options.width || {},
                    startWidth = _Number(width > 0 ? width : width.start),
                    endWidth = _Number(width > 0 ? width : width.end),
                    deltaWidth = endWidth - startWidth;
                if (options.ranges !== undefined && !_isArray(options.ranges))
                    return null;
                if (!(startWidth >= 0 && endWidth >= 0 && startWidth + endWidth > 0))
                    return null;
                list = _map(_isArray(options.ranges) ? options.ranges : [], function(rangeOptions, i) {
                    rangeOptions = rangeOptions || {};
                    var start = translator.adjust(rangeOptions.startValue),
                        end = translator.adjust(rangeOptions.endValue);
                    return _isFinite(start) && _isFinite(end) && isNotEmptySegment(start, end, threshold) ? {
                            start: start,
                            end: end,
                            color: rangeOptions.color,
                            classIndex: i
                        } : null
                });
                _each(list, function(i, item) {
                    var paletteColor = palette.getNextColor();
                    item.color = _isString(item.color) && item.color || paletteColor || 'none';
                    item.className = 'dxg-range dxg-range-' + item.classIndex;
                    delete item.classIndex
                });
                _each(list, function(_, item) {
                    var i,
                        ii,
                        sub,
                        subs,
                        range,
                        newRanges = [],
                        newBackgroundRanges = [];
                    for (i = 0, ii = ranges.length; i < ii; ++i) {
                        range = ranges[i];
                        subs = subtractSegment(range.start, range.end, item.start, item.end);
                        (sub = subs[0]) && (sub.color = range.color) && (sub.className = range.className) && newRanges.push(sub);
                        (sub = subs[1]) && (sub.color = range.color) && (sub.className = range.className) && newRanges.push(sub)
                    }
                    newRanges.push(item);
                    ranges = newRanges;
                    for (i = 0, ii = backgroundRanges.length; i < ii; ++i) {
                        range = backgroundRanges[i];
                        subs = subtractSegment(range.start, range.end, item.start, item.end);
                        (sub = subs[0]) && newBackgroundRanges.push(sub);
                        (sub = subs[1]) && newBackgroundRanges.push(sub)
                    }
                    backgroundRanges = newBackgroundRanges
                });
                _each(backgroundRanges, function(_, range) {
                    range.color = backgroundColor;
                    range.className = 'dxg-range dxg-background-range';
                    ranges.push(range)
                });
                _each(ranges, function(_, range) {
                    range.startWidth = (range.start - totalStart) / totalDelta * deltaWidth + startWidth;
                    range.endWidth = (range.end - totalStart) / totalDelta * deltaWidth + startWidth
                });
                return ranges
            },
            render: function(options) {
                var that = this;
                that._options = options;
                that._processOptions();
                that._ranges = that._getRanges();
                if (that._ranges) {
                    that.enabled = true;
                    that._root.append(that._container)
                }
                return that
            },
            resize: function(layout) {
                var that = this;
                that._root.clear();
                if (that._isVisible(layout))
                    _each(that._ranges, function(_, range) {
                        that._createRange(range, layout).attr({
                            fill: range.color,
                            'class': range.className
                        }).append(that._root)
                    });
                return that
            },
            _processOptions: null,
            _isVisible: null,
            _createRange: null,
            getColorForValue: function(value) {
                var color = null;
                _each(this._ranges, function(_, range) {
                    if (range.start <= value && value <= range.end || range.start >= value && value >= range.end) {
                        color = range.color;
                        return false
                    }
                });
                return color
            }
        });
        function subtractSegmentAsc(segmentStart, segmentEnd, otherStart, otherEnd) {
            var result;
            if (otherStart > segmentStart && otherEnd < segmentEnd)
                result = [{
                        start: segmentStart,
                        end: otherStart
                    }, {
                        start: otherEnd,
                        end: segmentEnd
                    }];
            else if (otherStart >= segmentEnd || otherEnd <= segmentStart)
                result = [{
                        start: segmentStart,
                        end: segmentEnd
                    }];
            else if (otherStart <= segmentStart && otherEnd >= segmentEnd)
                result = [];
            else if (otherStart > segmentStart)
                result = [{
                        start: segmentStart,
                        end: otherStart
                    }];
            else if (otherEnd < segmentEnd)
                result = [{
                        start: otherEnd,
                        end: segmentEnd
                    }];
            return result
        }
        function subtractSegmentDes(segmentStart, segmentEnd, otherStart, otherEnd) {
            var result;
            if (otherStart < segmentStart && otherEnd > segmentEnd)
                result = [{
                        start: segmentStart,
                        end: otherStart
                    }, {
                        start: otherEnd,
                        end: segmentEnd
                    }];
            else if (otherStart <= segmentEnd || otherEnd >= segmentStart)
                result = [{
                        start: segmentStart,
                        end: segmentEnd
                    }];
            else if (otherStart >= segmentStart && otherEnd <= segmentEnd)
                result = [];
            else if (otherStart < segmentStart)
                result = [{
                        start: segmentStart,
                        end: otherStart
                    }];
            else if (otherEnd > segmentEnd)
                result = [{
                        start: otherEnd,
                        end: segmentEnd
                    }];
            return result
        }
        function isNotEmptySegmentAsc(start, end, threshold) {
            return end - start >= threshold
        }
        function isNotEmptySegmentDes(start, end, threshold) {
            return start - end >= threshold
        }
        DX.viz.gauges.__internals.CircularRangeContainer = DX.viz.gauges.__internals.BaseRangeContainer.inherit({
            _processOptions: function() {
                var that = this;
                that._inner = that._outer = 0;
                switch (_String(that._options.orientation).toLowerCase()) {
                    case'inside':
                        that._inner = 1;
                        break;
                    case'center':
                        that._inner = that._outer = 0.5;
                        break;
                    default:
                        that._outer = 1;
                        break
                }
            },
            _isVisible: function(layout) {
                var width = this._options.width;
                width = _Number(width) || _max(_Number(width.start), _Number(width.end));
                return layout.radius - this._inner * width > 0
            },
            _createRange: function(range, layout) {
                var that = this,
                    width = (range.startWidth + range.endWidth) / 2;
                return that._renderer.arc(layout.x, layout.y, layout.radius - that._inner * width, layout.radius + that._outer * width, that._translator.translate(range.end), that._translator.translate(range.start)).attr({"stroke-linejoin": "round"})
            },
            measure: function(layout) {
                var width = this._options.width;
                width = _Number(width) || _max(_Number(width.start), _Number(width.end));
                return {
                        min: layout.radius - this._inner * width,
                        max: layout.radius + this._outer * width
                    }
            }
        });
        DX.viz.gauges.__internals.LinearRangeContainer = DX.viz.gauges.__internals.BaseRangeContainer.inherit({
            _processOptions: function() {
                var that = this;
                that.vertical = that._options.vertical;
                that._inner = that._outer = 0;
                if (that.vertical)
                    switch (_String(that._options.horizontalOrientation).toLowerCase()) {
                        case'left':
                            that._inner = 1;
                            break;
                        case'center':
                            that._inner = that._outer = 0.5;
                            break;
                        default:
                            that._outer = 1;
                            break
                    }
                else
                    switch (_String(that._options.verticalOrientation).toLowerCase()) {
                        case'top':
                            that._inner = 1;
                            break;
                        case'middle':
                            that._inner = that._outer = 0.5;
                            break;
                        default:
                            that._outer = 1;
                            break
                    }
            },
            _isVisible: function(layout) {
                return true
            },
            _createRange: function(range, layout) {
                var that = this,
                    inner = that._inner,
                    outer = that._outer,
                    startPosition = that._translator.translate(range.start),
                    endPosition = that._translator.translate(range.end),
                    points;
                if (that.vertical)
                    points = [layout.x - range.startWidth * inner, startPosition, layout.x - range.endWidth * inner, endPosition, layout.x + range.endWidth * outer, endPosition, layout.x + range.startWidth * outer, startPosition];
                else
                    points = [startPosition, layout.y + range.startWidth * outer, startPosition, layout.y - range.startWidth * inner, endPosition, layout.y - range.endWidth * inner, endPosition, layout.y + range.endWidth * outer];
                return that._renderer.path(points, "area")
            },
            measure: function(layout) {
                var result = {};
                result.min = result.max = layout[this.vertical ? 'x' : 'y'];
                var width = this._options.width;
                width = _Number(width) || _max(_Number(width.start), _Number(width.end));
                result.min -= this._inner * width;
                result.max += this._outer * width;
                return result
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz-gauges, file title.js */
    (function(DX, $, undefined) {
        var viz = DX.viz,
            core = viz.core,
            _isString = DX.utils.isString,
            _max = Math.max,
            _extend = $.extend;
        viz.gauges.__internals.Title = DX.Class.inherit({
            ctor: function(parameters) {
                this._renderer = parameters.renderer;
                this._container = parameters.container
            },
            dispose: function() {
                this._renderer = this._container = null;
                return this
            },
            clean: function() {
                var that = this;
                if (that._root) {
                    that._root.remove().clear();
                    that._root = that._layout = null
                }
                return that
            },
            render: function(titleOptions, subtitleOptions) {
                var that = this,
                    hasTitle = _isString(titleOptions.text) && titleOptions.text.length > 0,
                    hasSubtitle = _isString(subtitleOptions.text) && subtitleOptions.text.length > 0;
                if (!hasTitle && !hasSubtitle)
                    return that;
                that._root = that._renderer.g().attr({'class': 'dxg-title'}).append(that._container);
                var title = hasTitle ? that._renderer.text(titleOptions.text, 0, 0).attr({align: 'center'}).css(core.utils.patchFontOptions(titleOptions.font)).append(that._root) : null,
                    subtitle = hasSubtitle ? that._renderer.text(subtitleOptions.text, 0, 0).attr({align: 'center'}).css(core.utils.patchFontOptions(subtitleOptions.font)).append(that._root) : null,
                    titleBox = title ? title.getBBox() : {},
                    subtitleBox = subtitle ? subtitle.getBBox() : {},
                    y = 0;
                if (title) {
                    y += -titleBox.y;
                    title.attr({
                        x: 0,
                        y: y
                    })
                }
                if (subtitle) {
                    y += -subtitleBox.y;
                    subtitle.attr({
                        x: 0,
                        y: y
                    })
                }
                that._layout = _extend({
                    position: titleOptions.position,
                    width: _max(titleBox.width || 0, subtitleBox.width || 0),
                    height: title && subtitle ? -titleBox.y + subtitleBox.height : titleBox.height || subtitleBox.height
                }, titleOptions.layout);
                return that
            },
            getLayoutOptions: function() {
                return this._layout
            },
            locate: function(left, top) {
                this._root.attr({
                    translateX: left + this._layout.width / 2,
                    translateY: top
                });
                return this
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz-gauges, file tooltip.js */
    (function(DX, $, undefined) {
        var _extend = $.extend;
        DX.viz.gauges.__internals.Tooltip = DX.viz.core.Tooltip.inherit({
            ctor: function(parameters) {
                var that = this;
                that._container = parameters.container;
                that._tracker = parameters.tracker;
                that._root = parameters.renderer.g().attr({'class': 'dxg-tooltip'});
                that.callBase(null, that._root, parameters.renderer);
                that._setTrackerCallbacks()
            },
            dispose: function() {
                var that = this;
                that._container = that._tracker = that._root = null;
                return that._shadow ? that.callBase.apply(that, arguments) : that
            },
            _setTrackerCallbacks: function() {
                var that = this;
                function prepareCallback(target, info) {
                    var tooltipParameters = target.getTooltipParameters(),
                        formatObject = _extend({
                            value: tooltipParameters.value,
                            valueText: that.formatValue(tooltipParameters.value),
                            color: tooltipParameters.color
                        }, info);
                    return that.prepare(formatObject, {
                            x: tooltipParameters.x,
                            y: tooltipParameters.y,
                            offset: tooltipParameters.offset
                        })
                }
                function showCallback() {
                    return that.show()
                }
                function hideCallback() {
                    return that.hide()
                }
                that._tracker.setCallbacks({
                    'tooltip-prepare': prepareCallback,
                    'tooltip-show': showCallback,
                    'tooltip-hide': hideCallback
                })
            },
            clean: function() {
                this._root.remove();
                return this
            },
            render: function(options, size) {
                var that = this;
                options.canvasWidth = size.width;
                options.canvasHeight = size.height;
                options.text = {'class': 'dxg-text'};
                that.update(options);
                that._tracker.setTooltipState(that.enabled());
                that.enabled() && that._root.append(that._container);
                return that
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz-gauges, file layoutManager.js */
    (function(DX, $, undefined) {
        var _Number = Number,
            _String = String,
            _min = Math.min,
            _max = Math.max,
            _each = $.each;
        function patchLayoutOptions(options) {
            if (options.position) {
                var position = _String(options.position).toLowerCase().split('-');
                options.verticalAlignment = position[0];
                options.horizontalAlignment = position[1]
            }
        }
        DX.viz.gauges.__internals.LayoutManager = DX.Class.inherit({
            setRect: function(rect) {
                this._currentRect = rect.clone();
                return this
            },
            getRect: function() {
                return this._currentRect.clone()
            },
            beginLayout: function(rect) {
                this._rootRect = rect.clone();
                this._currentRect = rect.clone();
                this._cache = [];
                return this
            },
            applyLayout: function(target) {
                var options = target.getLayoutOptions();
                if (!options)
                    return this;
                var currentRect = this._currentRect,
                    verticalOverlay = _Number(options.overlay) || 0;
                patchLayoutOptions(options);
                switch (_String(options.verticalAlignment).toLowerCase()) {
                    case'bottom':
                        currentRect.bottom -= _max(options.height - verticalOverlay, 0);
                        break;
                    default:
                        currentRect.top += _max(options.height - verticalOverlay, 0);
                        break
                }
                this._cache.push({
                    target: target,
                    options: options
                });
                return this
            },
            endLayout: function() {
                var that = this,
                    rootRect = that._rootRect,
                    currentRect = that._currentRect;
                _each(that._cache, function(_, cacheItem) {
                    var options = cacheItem.options,
                        left,
                        top,
                        verticalOverlay = _Number(options.overlay) || 0;
                    switch (_String(options.verticalAlignment).toLowerCase()) {
                        case'bottom':
                            top = currentRect.bottom - verticalOverlay;
                            currentRect.bottom += _max(options.height - verticalOverlay, 0);
                            break;
                        default:
                            top = currentRect.top - options.height + verticalOverlay;
                            currentRect.top -= _max(options.height - verticalOverlay, 0);
                            break
                    }
                    switch (_String(options.horizontalAlignment).toLowerCase()) {
                        case'left':
                            left = rootRect.left;
                            break;
                        case'right':
                            left = rootRect.right - options.width;
                            break;
                        default:
                            left = rootRect.horizontalMiddle() - options.width / 2;
                            break
                    }
                    cacheItem.target.locate(left, top)
                });
                that._cache = null;
                return that
            },
            selectRectByAspectRatio: function(aspectRatio, margins) {
                var rect = this._currentRect.clone(),
                    selfAspectRatio,
                    width = 0,
                    height = 0;
                margins = margins || {};
                if (aspectRatio > 0) {
                    rect.left += margins.left || 0;
                    rect.right -= margins.right || 0;
                    rect.top += margins.top || 0;
                    rect.bottom -= margins.bottom || 0;
                    if (rect.width() > 0 && rect.height() > 0) {
                        selfAspectRatio = rect.height() / rect.width();
                        if (selfAspectRatio > 1)
                            aspectRatio < selfAspectRatio ? width = rect.width() : height = rect.height();
                        else
                            aspectRatio > selfAspectRatio ? height = rect.height() : width = rect.width();
                        width > 0 || (width = height / aspectRatio);
                        height > 0 || (height = width * aspectRatio);
                        width = (rect.width() - width) / 2;
                        height = (rect.height() - height) / 2;
                        rect.left += width;
                        rect.right -= width;
                        rect.top += height;
                        rect.bottom -= height
                    }
                    else {
                        rect.left = rect.right = rect.horizontalMiddle();
                        rect.top = rect.bottom = rect.verticalMiddle()
                    }
                }
                return rect
            },
            selectRectBySizes: function(sizes, margins) {
                var rect = this._currentRect.clone(),
                    step;
                margins = margins || {};
                if (sizes) {
                    rect.left += margins.left || 0;
                    rect.right -= margins.right || 0;
                    rect.top += margins.top || 0;
                    rect.bottom -= margins.bottom || 0;
                    if (sizes.width > 0) {
                        step = (rect.width() - sizes.width) / 2;
                        if (step > 0) {
                            rect.left += step;
                            rect.right -= step
                        }
                    }
                    if (sizes.height > 0) {
                        step = (rect.height() - sizes.height) / 2;
                        if (step > 0) {
                            rect.top += step;
                            rect.bottom -= step
                        }
                    }
                }
                return rect
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz-gauges, file themeManager.js */
    (function(DX, $, undefined) {
        var _extend = $.extend;
        DX.viz.gauges.__internals.ThemeManager = DX.viz.core.BaseThemeManager.inherit({
            _themeSection: 'gauge',
            _fontFields: ['scale.label.font', 'valueIndicator.rangebar.text.font', 'subvalueIndicator.textcloud.text.font', 'valueIndicators.rangebar.text.font', 'valueIndicators.textcloud.text.font', 'title.font', 'subtitle.font', 'tooltip.font', 'indicator.text.font', 'loadingIndicator.font'],
            _initializeTheme: function() {
                var that = this;
                if (that._subTheme) {
                    var subTheme = _extend(true, {}, that._theme[that._subTheme], that._theme);
                    _extend(true, that._theme, subTheme)
                }
                that.callBase.apply(that, arguments)
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz-gauges, file presetManager.js */
    /*! Module viz-gauges, file baseGauge.js */
    (function(DX, $, undefined) {
        var _Number = Number,
            _isNumber = DX.utils.isNumber,
            _isString = DX.utils.isString,
            _getAppropriateFormat = DX.utils.getAppropriateFormat,
            _extend = $.extend,
            _each = $.each;
        DX.viz.gauges.dxBaseGauge = DX.viz.core.BaseWidget.inherit({
            _init: function() {
                var that = this;
                that._themeManager = that._factory.createThemeManager();
                that._themeManager.setTheme(that.option('theme'));
                that.callBase.apply(that, arguments);
                that._renderer = that._factory.createRenderer({
                    width: 1,
                    height: 1,
                    pathModified: that.option('pathModified'),
                    rtl: that.option('rtlEnabled'),
                    cssClass: 'dxg ' + that._rootClass
                });
                that._root = that._renderer.root;
                that._translator = that._factory.createTranslator();
                that._tracker = that._factory.createTracker({
                    renderer: that._renderer,
                    container: that._root
                });
                that._layoutManager = that._factory.createLayoutManager();
                that._tooltip = that._factory.createTooltip({
                    renderer: that._renderer,
                    container: that._root,
                    tracker: that._tracker
                });
                that._title = that._factory.createTitle({
                    renderer: that._renderer,
                    container: that._root
                });
                that._deltaIndicator = that._factory.createDeltaIndicator({
                    renderer: that._renderer,
                    container: that._root
                });
                that._setupDomain()
            },
            _dispose: function() {
                var that = this;
                that.callBase.apply(that, arguments);
                that._renderer.dispose();
                that._themeManager.dispose();
                that._tracker.dispose();
                that._title.dispose();
                that._deltaIndicator && that._deltaIndicator.dispose();
                that._tooltip.dispose();
                that._disposeLoadIndicator();
                that._renderer = that._root = that._translator = that._themeManager = that._tracker = that._layoutManager = that._title = that._tooltip = null
            },
            _refresh: function() {
                var that = this,
                    callBase = that.callBase;
                that._endLoading(function() {
                    callBase.call(that)
                })
            },
            _clean: function() {
                this._cleanCore()
            },
            _render: function() {
                var that = this;
                that._setupCodomain();
                that._setupAnimationSettings();
                if (that._checkVisibility()) {
                    that._renderer.draw(that.element()[0]);
                    that._setupDefaultFormat();
                    that._renderCore()
                }
                that._drawn()
            },
            _cleanCore: function() {
                var that = this;
                that._tooltip.clean();
                that._title.clean();
                that._deltaIndicator && that._deltaIndicator.clean();
                that._tracker.deactivate();
                that._cleanContent()
            },
            _renderCore: function() {
                var that = this;
                that._title.render(_extend(true, {}, that._themeManager.theme()['title'], processTitleOptions(that.option('title'))), _extend(true, {}, that._themeManager.theme()['subtitle'], processTitleOptions(that.option('subtitle'))));
                that._deltaIndicator && that._deltaIndicator.render(_extend(true, {}, that._themeManager.theme()['indicator'], that.option('indicator')));
                that._layoutManager.beginLayout(that._rootRect);
                _each([that._deltaIndicator, that._title], function(_, item) {
                    item && that._layoutManager.applyLayout(item)
                });
                that._mainRect = that._layoutManager.getRect();
                that._renderContent();
                that._layoutManager.endLayout();
                that._tooltip.render(_extend(true, {}, that._themeManager.theme()['tooltip'], that.option('tooltip')), {
                    width: that._width,
                    height: that._height
                });
                that._tracker.activate();
                that._updateLoadIndicator(undefined, that._width, that._height);
                that._noAnimation = null;
                that.option('debugMode') === true && that._renderDebugInfo();
                that._debug_rendered && that._debug_rendered()
            },
            _renderDebugInfo: function() {
                var that = this,
                    group = that._debugGroup || that._renderer.g().attr({'class': 'debug-info'}).append(that._renderer.root),
                    rect;
                group.clear();
                rect = that._rootRect;
                that._renderer.rect(rect.left, rect.top, rect.width(), rect.height()).attr({
                    stroke: '#000000',
                    "stroke-width": 1,
                    fill: 'none'
                }).append(group);
                rect = that._mainRect;
                that._renderer.rect(rect.left, rect.top, rect.width(), rect.height()).attr({
                    stroke: '#0000FF',
                    "stroke-width": 1,
                    fill: 'none'
                }).append(group);
                rect = that._layoutManager.getRect();
                rect && that._renderer.rect(rect.left, rect.top, rect.width(), rect.height()).attr({
                    stroke: '#FF0000',
                    "stroke-width": 1,
                    fill: 'none'
                }).append(group);
                rect = that._title.getLayoutOptions() ? that._title._root.getBBox() : null;
                rect && that._renderer.rect(rect.x, rect.y, rect.width, rect.height).attr({
                    stroke: '#00FF00',
                    "stroke-width": 1,
                    fill: 'none'
                }).append(group);
                rect = that._deltaIndicator && that._deltaIndicator.getLayoutOptions() ? that._deltaIndicator._root.getBBox() : null;
                rect && that._renderer.rect(rect.x, rect.y, rect.width, rect.height).attr({
                    stroke: '#00FF00',
                    "stroke-width": 1,
                    fill: 'none'
                }).append(group)
            },
            _resize: function() {
                var that = this;
                if (that._checkVisibility()) {
                    that._resizing = that._noAnimation = true;
                    that._cleanCore();
                    that._renderCore();
                    that._resizing = null
                }
            },
            render: function(options) {
                options && options.animate !== undefined && !options.animate && (this._noAnimation = true);
                this._refresh();
                return this
            },
            showLoadingIndicator: function() {
                this._showLoadIndicator(this._getLoadIndicatorOption(), {
                    width: this._width,
                    height: this._height
                })
            },
            _getLoadIndicatorOption: function() {
                return _extend(true, {}, this._themeManager.theme()['loadingIndicator'], this.option('loadingIndicator'))
            },
            _optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case'theme':
                        that._themeManager.setTheme(args.value);
                        that._invalidate();
                        break;
                    case'startValue':
                    case'endValue':
                        that._setupDomain();
                        that._invalidate();
                        break;
                    default:
                        that.callBase(args);
                        break
                }
            },
            _setupDomain: function() {
                var that = this;
                that._setupDomainCore();
                that._isValidDomain = isFinite(1 / (that._translator.getDomain()[1] - that._translator.getDomain()[0]));
                if (!that._isValidDomain)
                    that._incidentOccured('W2301')
            },
            _checkVisibility: function() {
                var that = this,
                    result = that._isValidDomain;
                if (result) {
                    that._calculateSize();
                    result = that._width > 0 && that._height > 0 && that.element().is(':visible');
                    if (result)
                        that._renderer.resize(that._width, that._height);
                    else
                        that._incidentOccured('W2001', [that.NAME])
                }
                return result
            },
            _setupAnimationSettings: function() {
                var that = this,
                    option = that.option('animation');
                that._animationSettings = null;
                if (option === undefined || option) {
                    option = _extend({
                        enabled: true,
                        duration: 1000,
                        easing: 'easeOutCubic'
                    }, option);
                    if (option.enabled && option.duration > 0)
                        that._animationSettings = {
                            duration: _Number(option.duration),
                            easing: option.easing
                        }
                }
                that._containerBackgroundColor = that.option('containerBackgroundColor') || that._themeManager.theme().containerBackgroundColor
            },
            _setupDefaultFormat: function() {
                var domain = this._translator.getDomain();
                this._defaultFormatOptions = _getAppropriateFormat(domain[0], domain[1], this._getApproximateScreenRange())
            },
            _setupDomainCore: null,
            _calculateSize: null,
            _cleanContent: null,
            _renderContent: null,
            _setupCodomain: null,
            _getApproximateScreenRange: null,
            _factory: {
                createRenderer: DX.viz.core.CoreFactory.createRenderer,
                createTranslator: function() {
                    return new DX.viz.core.Translator1D
                },
                createTracker: function(parameters) {
                    return new DX.viz.gauges.__internals.Tracker(parameters)
                },
                createLayoutManager: function() {
                    return new DX.viz.gauges.__internals.LayoutManager
                },
                createTitle: function(parameters) {
                    return new DX.viz.gauges.__internals.Title(parameters)
                },
                createDeltaIndicator: function(parameters) {
                    return DX.viz.gauges.__internals.DeltaIndicator ? new DX.viz.gauges.__internals.DeltaIndicator(parameters) : null
                },
                createTooltip: function(parameters) {
                    return new DX.viz.gauges.__internals.Tooltip(parameters)
                }
            }
        });
        function processTitleOptions(options) {
            return _isString(options) ? {text: options} : options || {}
        }
    })(DevExpress, jQuery);
    /*! Module viz-gauges, file gauge.js */
    (function(DX, $, undefined) {
        var _Rectangle = DX.viz.core.Rectangle;
        var _isDefined = DX.utils.isDefined,
            _isArray = DX.utils.isArray,
            _isNumber = DX.utils.isNumber,
            _isFinite = isFinite,
            _Number = Number,
            _String = String,
            _abs = Math.abs,
            _extend = $.extend,
            _each = $.each,
            _map = $.map,
            _noop = $.noop;
        var OPTION_VALUE = 'value',
            OPTION_SUBVALUES = 'subvalues';
        function processValue(value, fallbackValue) {
            return _isFinite(value) ? _Number(value) : fallbackValue
        }
        function parseArrayOfNumbers(arg) {
            return _isArray(arg) ? arg : _isNumber(arg) ? [arg] : null
        }
        DX.viz.gauges.dxGauge = DX.viz.gauges.dxBaseGauge.inherit({
            _init: function() {
                var that = this;
                that._setupValue(that.option(OPTION_VALUE));
                that.__subvalues = parseArrayOfNumbers(that.option(OPTION_SUBVALUES));
                that._setupSubvalues(that.__subvalues);
                that._selectMode();
                that.callBase.apply(that, arguments);
                that._scale = that._createScale({
                    renderer: that._renderer,
                    container: that._root,
                    translator: that._translator
                });
                that._rangeContainer = that._createRangeContainer({
                    renderer: that._renderer,
                    container: that._root,
                    translator: that._translator
                })
            },
            _dispose: function() {
                var that = this;
                that.callBase.apply(that, arguments);
                that._scale.dispose();
                that._rangeContainer.dispose();
                that._disposeValueIndicators();
                that._scale = that._rangeContainer = null
            },
            _disposeValueIndicators: function() {
                var that = this;
                that._valueIndicator && that._valueIndicator.dispose();
                that._subvalueIndicatorsSet && that._subvalueIndicatorsSet.dispose();
                that._valueIndicator = that._subvalueIndicatorsSet = null
            },
            _selectMode: function() {
                var that = this;
                if (that.option(OPTION_VALUE) === undefined && that.option(OPTION_SUBVALUES) === undefined)
                    if (that.option('valueIndicators') !== undefined) {
                        disableDefaultMode(that);
                        selectHardMode(that)
                    }
            },
            _setupDomainCore: function() {
                var that = this,
                    scaleOption = that.option('scale') || {},
                    startValue = that.option('startValue'),
                    endValue = that.option('endValue');
                startValue = _isNumber(startValue) ? _Number(startValue) : _isNumber(scaleOption.startValue) ? _Number(scaleOption.startValue) : 0;
                endValue = _isNumber(endValue) ? _Number(endValue) : _isNumber(scaleOption.endValue) ? _Number(scaleOption.endValue) : 100;
                that._baseValue = startValue < endValue ? startValue : endValue;
                that._translator.setDomain(startValue, endValue)
            },
            _calculateSize: function() {
                var that = this,
                    size = that.option('size') || {},
                    margin = that.option('margin') || {};
                if (_Number(size.width) === 0 || _Number(size.height) === 0) {
                    that._width = that._height = 0;
                    that._rootRect = new _Rectangle
                }
                else {
                    var width = size.width > 0 ? _Number(size.width) : that.element().width() || that._getDefaultContainerSize().width,
                        height = size.height > 0 ? _Number(size.height) : that.element().height() || that._getDefaultContainerSize().height,
                        marginL = margin.left > 0 ? _Number(margin.left) : 0,
                        marginR = margin.right > 0 ? _Number(margin.right) : 0,
                        marginT = margin.top > 0 ? _Number(margin.top) : 0,
                        marginB = margin.bottom > 0 ? _Number(margin.bottom) : 0;
                    marginL + marginR >= width && (marginL = marginR = 0);
                    marginT + marginB >= height && (marginT = marginB = 0);
                    that._width = width;
                    that._height = height;
                    that._rootRect = new _Rectangle({
                        left: marginL,
                        top: marginT,
                        right: width - marginR,
                        bottom: height - marginB
                    })
                }
            },
            _cleanContent: function() {
                var that = this;
                that._rangeContainer.clean();
                that._scale.clean();
                that._cleanValueIndicators()
            },
            _renderContent: function() {
                var that = this;
                that._rangeContainer.render(_extend(true, {}, that._themeManager.theme().rangeContainer, that.option('rangeContainer'), {
                    themeName: that._themeManager.themeName(),
                    vertical: that._area.vertical
                }));
                that._scale.render(_extend(true, {}, that._themeManager.theme().scale, that.option('scale'), {
                    rangeContainer: that._rangeContainer.enabled ? that._rangeContainer : null,
                    approximateScreenDelta: that._getApproximateScreenRange(),
                    offset: 0,
                    vertical: that._area.vertical
                }));
                var elements = that._prepareValueIndicators();
                elements = _map([that._scale, that._rangeContainer].concat(elements), function(element) {
                    return element && element.enabled ? element : null
                });
                that._applyMainLayout(elements);
                _each(elements, function(_, element) {
                    that._updateElementPosition(element)
                });
                that._updateActiveElements()
            },
            _updateIndicatorSettings: function(settings) {
                var that = this;
                settings.currentValue = settings.baseValue = _isFinite(that._translator.translate(settings.baseValue)) ? _Number(settings.baseValue) : that._baseValue;
                settings.vertical = that._area.vertical;
                if (settings.text && !settings.text.format && !settings.text.precision) {
                    settings.text.format = that._defaultFormatOptions.format;
                    settings.text.precision = that._defaultFormatOptions.precision
                }
            },
            _prepareValueIndicatorSettings: function() {
                var that = this,
                    options = that.option('valueIndicator') || {},
                    defaultOptions = _extend(true, {}, that._themeManager.theme().valueIndicator),
                    type = _String(options.type || defaultOptions.type).toLowerCase();
                that._valueIndicatorSettings = _extend(true, defaultOptions._default, defaultOptions[type], options, {
                    type: type,
                    animation: that._animationSettings,
                    containerBackgroundColor: that._containerBackgroundColor
                });
                that._updateIndicatorSettings(that._valueIndicatorSettings)
            },
            _prepareSubvalueIndicatorSettings: function() {
                var that = this,
                    options = that.option('subvalueIndicator') || {},
                    defaultOptions = _extend(true, {}, that._themeManager.theme().subvalueIndicator),
                    type = _String(options.type || defaultOptions.type).toLowerCase();
                that._subvalueIndicatorSettings = _extend(true, defaultOptions._default, defaultOptions[type], options, {
                    type: type,
                    animation: that._animationSettings,
                    containerBackgroundColor: that._containerBackgroundColor
                });
                that._updateIndicatorSettings(that._subvalueIndicatorSettings)
            },
            _cleanValueIndicators: function() {
                this._valueIndicator && this._valueIndicator.clean();
                this._subvalueIndicatorsSet && this._subvalueIndicatorsSet.clean()
            },
            _prepareValueIndicators: function() {
                var that = this;
                that._prepareValueIndicator();
                that.__subvalues !== null && that._prepareSubvalueIndicators();
                return [that._valueIndicator, that._subvalueIndicatorsSet]
            },
            _updateActiveElements: function() {
                this._updateValueIndicator();
                this._updateSubvalueIndicators()
            },
            _prepareValueIndicator: function() {
                var that = this,
                    indicator = that._valueIndicator,
                    currentValue;
                that._prepareValueIndicatorSettings();
                indicator && that._valueIndicatorType !== that._valueIndicatorSettings.type && indicator.dispose() && (indicator = null);
                that._valueIndicatorType = that._valueIndicatorSettings.type;
                if (!indicator) {
                    indicator = that._valueIndicator = that._createValueIndicator(that._valueIndicatorType);
                    if (indicator) {
                        indicator.setup({
                            renderer: that._renderer,
                            translator: that._translator,
                            owner: that._root,
                            tracker: that._tracker,
                            className: 'dxg-value-indicator'
                        });
                        indicator._trackerInfo = {type: 'value-indicator'}
                    }
                }
                indicator.render(that._valueIndicatorSettings)
            },
            _prepareSubvalueIndicators: function() {
                var that = this,
                    subvalueIndicatorsSet = that._subvalueIndicatorsSet;
                if (!subvalueIndicatorsSet)
                    subvalueIndicatorsSet = that._subvalueIndicatorsSet = new DX.viz.gauges.__internals.ValueIndicatorsSet({
                        renderer: that._renderer,
                        translator: that._translator,
                        owner: that._root,
                        tracker: that._tracker,
                        className: 'dxg-subvalue-indicators',
                        indicatorClassName: 'dxg-subvalue-indicator',
                        trackerType: 'subvalue-indicator',
                        createIndicator: function() {
                            return that._createSubvalueIndicator(that._subvalueIndicatorType)
                        }
                    });
                that._prepareSubvalueIndicatorSettings();
                var isRecreate = that._subvalueIndicatorSettings.type !== that._subvalueIndicatorType;
                that._subvalueIndicatorType = that._subvalueIndicatorSettings.type;
                if (that._createSubvalueIndicator(that._subvalueIndicatorType))
                    subvalueIndicatorsSet.render(that._subvalueIndicatorSettings, isRecreate)
            },
            _setupValue: function(value) {
                this.__value = processValue(value, this.__value)
            },
            _setupSubvalues: function(subvalues) {
                var vals = subvalues === undefined ? this.__subvalues : parseArrayOfNumbers(subvalues),
                    i,
                    ii,
                    list;
                if (vals === null)
                    return;
                for (i = 0, ii = vals.length, list = []; i < ii; ++i)
                    list.push(processValue(vals[i], this.__subvalues[i]));
                this.__subvalues = list
            },
            _updateValueIndicator: function() {
                var that = this;
                that._valueIndicator && that._valueIndicator.value(that.__value, that._noAnimation);
                that._resizing || that.hideLoadingIndicator()
            },
            _updateSubvalueIndicators: function() {
                var that = this;
                that._subvalueIndicatorsSet && that._subvalueIndicatorsSet.values(that.__subvalues, that._noAnimation);
                that._resizing || that.hideLoadingIndicator()
            },
            value: function(arg) {
                var that = this;
                if (arg !== undefined) {
                    that._setupValue(arg);
                    that._updateValueIndicator();
                    that.option(OPTION_VALUE, that.__value);
                    return that
                }
                return that.__value
            },
            subvalues: function(arg) {
                var that = this;
                if (arg !== undefined) {
                    if (that.__subvalues !== null) {
                        that._setupSubvalues(arg);
                        that._updateSubvalueIndicators();
                        that.option(OPTION_SUBVALUES, that.__subvalues)
                    }
                    return that
                }
                return that.__subvalues !== null ? that.__subvalues.slice() : undefined
            },
            _valueChangedHandler: function(name, val) {
                var that = this;
                switch (name) {
                    case OPTION_VALUE:
                        that._setupValue(val);
                        that._updateValueIndicator();
                        that.option(OPTION_VALUE, that.__value);
                        return true;
                    case OPTION_SUBVALUES:
                        if (that.__subvalues !== null) {
                            that._setupSubvalues(val);
                            that._updateSubvalueIndicators();
                            that.option(OPTION_SUBVALUES, that.__subvalues);
                            return true
                        }
                        return false;
                    default:
                        return false
                }
            },
            _optionChanged: function(args) {
                var that = this;
                if (that._valueChangedHandler(args.name, args.value, args.previousValue))
                    return;
                switch (args.name) {
                    case'scale':
                        that._setupDomain();
                        that._invalidate();
                        break;
                    default:
                        that.callBase.apply(that, arguments);
                        break
                }
            },
            _optionValuesEqual: function(name, oldValue, newValue) {
                switch (name) {
                    case OPTION_VALUE:
                        return oldValue === newValue;
                    case OPTION_SUBVALUES:
                        return compareArrays(oldValue, newValue);
                    default:
                        return this.callBase.apply(this, arguments)
                }
            },
            _getDefaultContainerSize: null,
            _applyMainLayout: null,
            _updateElementPosition: null,
            _createScale: null,
            _createRangeContainer: null,
            _createValueIndicator: null,
            _createSubvalueIndicator: null,
            _getApproximateScreenRange: null
        });
        DX.viz.gauges.dxGauge.prototype._factory = DX.utils.clone(DX.viz.gauges.dxBaseGauge.prototype._factory);
        DX.viz.gauges.dxGauge.prototype._factory.createThemeManager = function() {
            return new DX.viz.gauges.__internals.ThemeManager
        };
        function valueGetter(arg) {
            return arg ? arg.value : NaN
        }
        function setupValues(that, fieldName, optionItems) {
            var currentValues = that[fieldName],
                newValues = _isArray(optionItems) ? _map(optionItems, valueGetter) : [],
                i = 0,
                ii = newValues.length,
                list = [];
            for (; i < ii; ++i)
                list.push(processValue(newValues[i], currentValues[i]));
            that[fieldName] = list
        }
        function disableDefaultMode(that) {
            that.value = that.subvalues = _noop;
            that._setupValue = that._setupSubvalues = that._updateValueIndicator = that._updateSubvalueIndicators = null
        }
        function selectHardMode(that) {
            that._indicatorValues = [];
            setupValues(that, '_indicatorValues', that.option('valueIndicators'));
            that._valueIndicators = [];
            that._valueChangedHandler = function(name, val) {
                if (name === 'valueIndicators') {
                    setupValues(this, '_indicatorValues', val);
                    this._invalidate();
                    return true
                }
                return false
            };
            that._updateActiveElements = function() {
                var that = this;
                _each(that._valueIndicators, function(_, valueIndicator) {
                    valueIndicator.value(that._indicatorValues[valueIndicator._index], that._noAnimation)
                });
                that._resizing || that.hideLoadingIndicator()
            };
            that._prepareValueIndicators = function() {
                return prepareValueIndicatorsInHardMode(this)
            };
            that._disposeValueIndicators = function() {
                _each(this._valueIndicators, function(_, valueIndicator) {
                    valueIndicator.dispose()
                });
                this._valueIndicators = null
            };
            that._cleanValueIndicators = function() {
                _each(this._valueIndicators, function(_, valueIndicator) {
                    valueIndicator.clean()
                })
            };
            that.indicatorValue = function(index, value) {
                return accessPointerValue(this, this._valueIndicators, this._indicatorValues, index, value)
            }
        }
        function prepareValueIndicatorsInHardMode(that) {
            var valueIndicators = that._valueIndicators || [],
                userOptions = that.option('valueIndicators'),
                optionList = [],
                i = 0,
                ii;
            for (ii = _isArray(userOptions) ? userOptions.length : 0; i < ii; ++i)
                optionList.push(userOptions[i]);
            for (ii = valueIndicators.length; i < ii; ++i)
                optionList.push(null);
            var themeSettings = that._themeManager.theme().valueIndicators,
                parameters = {
                    renderer: that._renderer,
                    owner: that._root,
                    translator: that._translator,
                    tracker: that._tracker
                },
                newValueIndicators = [];
            _each(optionList, function(i, userSettings) {
                var valueIndicator = valueIndicators[i];
                if (!userSettings) {
                    valueIndicator && valueIndicator.dispose();
                    return
                }
                var type = _String(userSettings.type || themeSettings._type).toLowerCase();
                if (valueIndicator && type !== valueIndicator.type) {
                    valueIndicator.dispose();
                    valueIndicator = null
                }
                if (!valueIndicator) {
                    valueIndicator = that._createValueIndicatorInHardMode(type);
                    valueIndicator && valueIndicator.setup(parameters)
                }
                if (valueIndicator) {
                    var settings = _extend(true, {}, themeSettings._default, themeSettings[type], userSettings, {
                            type: type,
                            animation: that._animationSettings,
                            containerBackgroundColor: that._containerBackgroundColor
                        });
                    that._updateIndicatorSettings(settings);
                    valueIndicator.render(settings);
                    valueIndicator._index = i;
                    valueIndicator._trackerInfo = {index: i};
                    newValueIndicators.push(valueIndicator)
                }
            });
            that._valueIndicators = newValueIndicators;
            return that._valueIndicators
        }
        function accessPointerValue(that, pointers, values, index, value) {
            if (value !== undefined) {
                if (values[index] !== undefined) {
                    values[index] = processValue(value, values[index]);
                    pointers[index] && pointers[index].value(values[index]);
                    that._resizing || that.hideLoadingIndicator()
                }
                return that
            }
            else
                return values[index]
        }
        function compareArrays(array1, array2) {
            if (array1 === array2)
                return true;
            if (_isArray(array1) && _isArray(array2) && array1.length === array2.length) {
                for (var i = 0, ii = array1.length; i < ii; ++i)
                    if (_abs(array1[i] - array2[i]) > 1E-8)
                        return false;
                return true
            }
            return false
        }
        DX.viz.gauges.__internals.ValueIndicatorsSet = DX.Class.inherit({
            ctor: function(parameters) {
                var that = this;
                that._parameters = parameters;
                that._createIndicator = that._parameters.createIndicator || _noop;
                that._root = that._parameters.renderer.g().attr({'class': that._parameters.className});
                that._indicatorParameters = that._indicatorParameters || {
                    renderer: that._parameters.renderer,
                    translator: that._parameters.translator,
                    owner: that._root,
                    tracker: that._parameters.tracker,
                    className: that._parameters.indicatorClassName
                };
                that._indicators = []
            },
            dispose: function() {
                var that = this;
                _each(that._indicators, function(_, indicator) {
                    indicator.dispose()
                });
                that._parameters = that._createIndicator = that._root = that._options = that._indicators = that._colorPalette = that._palette = null;
                return that
            },
            clean: function() {
                var that = this;
                that._root.remove();
                that._sample && that._sample.clean().dispose();
                _each(that._indicators, function(_, indicator) {
                    indicator.clean()
                });
                that._sample = that._options = that._palette = null;
                return that
            },
            render: function(options, isRecreate) {
                var that = this;
                that._options = options;
                that._sample = that._createIndicator();
                that._sample && that._sample.setup(that._indicatorParameters).render(options);
                that.enabled = that._sample && that._sample.enabled;
                that._palette = _isDefined(options.palette) ? new DX.viz.core.Palette(options.palette) : null;
                if (that.enabled) {
                    that._root.append(that._parameters.owner);
                    that._generatePalette(that._indicators.length);
                    that._indicators = _map(that._indicators, function(indicator, i) {
                        if (isRecreate) {
                            indicator.dispose();
                            indicator = that._createIndicator();
                            indicator.setup(that._indicatorParameters);
                            indicator._trackerInfo = {
                                type: that._parameters.trackerType,
                                index: i
                            }
                        }
                        indicator.render(that._getIndicatorOptions(i));
                        return indicator
                    })
                }
                return that
            },
            resize: function(layout) {
                var that = this;
                that._layout = layout;
                _each(that._indicators, function(_, indicator) {
                    indicator.resize(layout)
                });
                return that
            },
            measure: function(layout) {
                return this._sample.measure(layout)
            },
            _getIndicatorOptions: function(index) {
                var result = this._options;
                if (this._colorPalette)
                    result = _extend({}, result, {color: this._colorPalette[index]});
                return result
            },
            _generatePalette: function(count) {
                var that = this,
                    colors = null;
                if (that._palette) {
                    colors = [];
                    that._palette.reset();
                    var i = 0;
                    for (; i < count; ++i)
                        colors.push(that._palette.getNextColor())
                }
                that._colorPalette = colors
            },
            _adjustIndicatorsCount: function(count) {
                var that = this,
                    indicators = that._indicators,
                    i,
                    ii,
                    indicatorOptions,
                    indicator,
                    indicatorsLen = indicators.length,
                    palette = that._parameters.palette;
                if (indicatorsLen > count) {
                    for (i = count, ii = indicatorsLen; i < ii; ++i)
                        indicators[i].clean().dispose();
                    that._indicators = indicators.slice(0, count);
                    that._generatePalette(indicators.length)
                }
                else if (indicatorsLen < count) {
                    that._generatePalette(count);
                    for (i = indicatorsLen, ii = count; i < ii; ++i) {
                        indicator = that._createIndicator();
                        indicator.setup(that._indicatorParameters);
                        indicator._trackerInfo = {
                            type: that._parameters.trackerType,
                            index: i
                        };
                        indicator.render(that._getIndicatorOptions(i)).resize(that._layout);
                        indicators.push(indicator)
                    }
                }
            },
            values: function(arg, _noAnimation) {
                var that = this;
                if (!that.enabled)
                    return;
                if (arg !== undefined) {
                    if (!_isArray(arg))
                        arg = _isFinite(arg) ? [Number(arg)] : null;
                    if (arg) {
                        that._adjustIndicatorsCount(arg.length);
                        _each(that._indicators, function(i, indicator) {
                            indicator.value(arg[i], _noAnimation)
                        })
                    }
                    return that
                }
                return _map(that._indicators, function(indicator) {
                        return indicator.value()
                    })
            }
        })
    })(DevExpress, jQuery);
    /*! Module viz-gauges, file circularGauge.js */
    (function(DX, $, undefined) {
        var factory = DX.viz.gauges.__factory;
        var isFinite = window.isFinite,
            Number = window.Number,
            normalizeAngle = DX.utils.normalizeAngle,
            getCosAndSin = DX.utils.getCosAndSin,
            abs = Math.abs,
            max = Math.max,
            min = Math.min,
            round = Math.round,
            slice = Array.prototype.slice,
            $extend = $.extend,
            $each = $.each;
        var PI = Math.PI;
        function getSides(startAngle, endAngle) {
            var startCosSin = getCosAndSin(startAngle),
                endCosSin = getCosAndSin(endAngle),
                startCos = startCosSin.cos,
                startSin = startCosSin.sin,
                endCos = endCosSin.cos,
                endSin = endCosSin.sin;
            return {
                    left: startSin <= 0 && endSin >= 0 || startSin <= 0 && endSin <= 0 && startCos <= endCos || startSin >= 0 && endSin >= 0 && startCos >= endCos ? -1 : min(startCos, endCos, 0),
                    right: startSin >= 0 && endSin <= 0 || startSin >= 0 && endSin >= 0 && startCos >= endCos || startSin <= 0 && endSin <= 0 && startCos <= endCos ? 1 : max(startCos, endCos, 0),
                    up: startCos <= 0 && endCos >= 0 || startCos <= 0 && endCos <= 0 && startSin >= endSin || startCos >= 0 && endCos >= 0 && startSin <= endSin ? -1 : -max(startSin, endSin, 0),
                    down: startCos >= 0 && endCos <= 0 || startCos >= 0 && endCos >= 0 && startSin <= endSin || startCos <= 0 && endCos <= 0 && startSin >= endSin ? 1 : -min(startSin, endSin, 0)
                }
        }
        DX.registerComponent("dxCircularGauge", DX.viz.gauges, DX.viz.gauges.dxGauge.inherit({
            _rootClass: 'dxg-circular-gauge',
            _selectMode: function() {
                this.callBase.apply(this, arguments);
                if (typeof this.indicatorValue === 'function')
                    this._createValueIndicatorInHardMode = function(type) {
                        return factory.createCircularValueIndicatorInHardMode(type)
                    }
            },
            _setupCodomain: function() {
                var that = this,
                    geometry = that.option('geometry') || {},
                    startAngle = geometry.startAngle,
                    endAngle = geometry.endAngle,
                    sides;
                startAngle = isFinite(startAngle) ? normalizeAngle(startAngle) : 225;
                endAngle = isFinite(endAngle) ? normalizeAngle(endAngle) : -45;
                if (abs(startAngle - endAngle) < 1) {
                    endAngle -= 360;
                    sides = {
                        left: -1,
                        up: -1,
                        right: 1,
                        down: 1
                    }
                }
                else {
                    startAngle < endAngle && (endAngle -= 360);
                    sides = getSides(startAngle, endAngle)
                }
                that._area = {
                    x: 0,
                    y: 0,
                    radius: 100,
                    startCoord: startAngle,
                    endCoord: endAngle,
                    scaleRadius: geometry.scaleRadius > 0 ? Number(geometry.scaleRadius) : undefined,
                    sides: sides
                };
                that._translator.setCodomain(startAngle, endAngle)
            },
            _measureMainElements: function(elements) {
                var that = this,
                    maxRadius = 0,
                    minRadius = Infinity,
                    maxHorizontalOffset = 0,
                    maxVerticalOffset = 0,
                    maxInverseHorizontalOffset = 0,
                    maxInverseVerticalOffset = 0;
                $each(elements, function(_, element) {
                    var bounds = element.measure({radius: that._area.radius - (Number(element._options.offset) || 0)});
                    bounds.min > 0 && (minRadius = min(minRadius, bounds.min));
                    bounds.max > 0 && (maxRadius = max(maxRadius, bounds.max));
                    bounds.horizontalOffset > 0 && (maxHorizontalOffset = max(maxHorizontalOffset, bounds.max + bounds.horizontalOffset));
                    bounds.verticalOffset > 0 && (maxVerticalOffset = max(maxVerticalOffset, bounds.max + bounds.verticalOffset));
                    bounds.inverseHorizontalOffset > 0 && (maxInverseHorizontalOffset = max(maxInverseHorizontalOffset, bounds.inverseHorizontalOffset));
                    bounds.inverseVerticalOffset > 0 && (maxInverseVerticalOffset = max(maxInverseVerticalOffset, bounds.inverseVerticalOffset))
                });
                maxHorizontalOffset = max(maxHorizontalOffset - maxRadius, 0);
                maxVerticalOffset = max(maxVerticalOffset - maxRadius, 0);
                return {
                        minRadius: minRadius,
                        maxRadius: maxRadius,
                        horizontalMargin: maxHorizontalOffset,
                        verticalMargin: maxVerticalOffset,
                        inverseHorizontalMargin: maxInverseHorizontalOffset,
                        inverseVerticalMargin: maxInverseVerticalOffset
                    }
            },
            _applyMainLayout: function(elements) {
                var that = this,
                    measurements = that._measureMainElements(elements),
                    area = that._area,
                    sides = area.sides,
                    margins = {
                        left: (sides.left < -0.1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
                        right: (sides.right > 0.1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
                        top: (sides.up < -0.1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0,
                        bottom: (sides.down > 0.1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0
                    },
                    rect = that._layoutManager.selectRectByAspectRatio((sides.down - sides.up) / (sides.right - sides.left), margins),
                    radius = min(rect.width() / (sides.right - sides.left), rect.height() / (sides.down - sides.up)),
                    x,
                    y;
                var scaler = (measurements.maxRadius - area.radius + area.scaleRadius) / radius;
                if (0 < scaler && scaler < 1) {
                    rect = rect.scale(scaler);
                    radius *= scaler
                }
                radius = radius - measurements.maxRadius + area.radius;
                x = rect.left - rect.width() * sides.left / (sides.right - sides.left);
                y = rect.top - rect.height() * sides.up / (sides.down - sides.up);
                area.x = round(x);
                area.y = round(y);
                area.radius = radius;
                rect.left -= margins.left;
                rect.right += margins.right;
                rect.top -= margins.top;
                rect.bottom += margins.bottom;
                that._layoutManager.setRect(rect)
            },
            _updateElementPosition: function(element) {
                element.resize({
                    x: this._area.x,
                    y: this._area.y,
                    radius: round(this._area.radius - (Number(element._options.offset) || 0))
                })
            },
            _createScale: function(parameters) {
                return factory.createCircularScale(parameters)
            },
            _createRangeContainer: function(parameters) {
                return factory.createCircularRangeContainer(parameters)
            },
            _createValueIndicator: function(type) {
                return factory.createCircularValueIndicator(type)
            },
            _createSubvalueIndicator: function(type) {
                return factory.createCircularSubvalueIndicator(type)
            },
            _getApproximateScreenRange: function() {
                var that = this,
                    area = that._area,
                    r = min(that._width / (area.sides.right - area.sides.left), that._height / (area.sides.down - area.sides.up));
                r > area.totalRadius && (r = area.totalRadius);
                r = 0.8 * r;
                return -that._translator.getCodomainRange() * r * PI / 180
            },
            _getDefaultContainerSize: function() {
                return {
                        width: 300,
                        height: 300
                    }
            }
        }));
        DX.viz.gauges.dxCircularGauge.prototype._factory = DX.utils.clone(DX.viz.gauges.dxBaseGauge.prototype._factory);
        DX.viz.gauges.dxCircularGauge.prototype._factory.createThemeManager = function() {
            var themeManager = new DX.viz.gauges.__internals.ThemeManager;
            themeManager._subTheme = '_circular';
            return themeManager
        }
    })(DevExpress, jQuery);
    /*! Module viz-gauges, file linearGauge.js */
    (function(DX, $, undefined) {
        var factory = DX.viz.gauges.__factory;
        var _String = String,
            _Number = Number,
            max = Math.max,
            min = Math.min,
            round = Math.round,
            slice = Array.prototype.slice,
            $extend = $.extend,
            $each = $.each;
        DX.registerComponent("dxLinearGauge", DX.viz.gauges, DX.viz.gauges.dxGauge.inherit({
            _rootClass: 'dxg-linear-gauge',
            _selectMode: function() {
                this.callBase.apply(this, arguments);
                if (typeof this.indicatorValue === 'function')
                    this._createValueIndicatorInHardMode = function(type) {
                        return factory.createLinearValueIndicatorInHardMode(type)
                    }
            },
            _setupCodomain: function() {
                var that = this,
                    geometry = that.option('geometry') || {},
                    vertical = _String(geometry.orientation).toLowerCase() === 'vertical';
                that._area = {
                    vertical: vertical,
                    x: 0,
                    y: 0,
                    startCoord: -100,
                    endCoord: 100,
                    scaleSize: geometry.scaleSize > 0 ? _Number(geometry.scaleSize) : undefined
                };
                that._scale.vertical = vertical;
                that._rangeContainer.vertical = vertical
            },
            _measureMainElements: function(elements) {
                var that = this,
                    minBound = 1000,
                    maxBound = 0,
                    indent = 0;
                $each(elements, function(_, element) {
                    var bounds = element.measure({
                            x: that._area.x + (_Number(element._options.offset) || 0),
                            y: that._area.y + (_Number(element._options.offset) || 0)
                        });
                    maxBound = max(maxBound, bounds.max);
                    minBound = min(minBound, bounds.min);
                    bounds.indent > 0 && (indent = max(indent, bounds.indent))
                });
                return {
                        minBound: minBound,
                        maxBound: maxBound,
                        indent: indent
                    }
            },
            _applyMainLayout: function(elements) {
                var that = this,
                    measurements = that._measureMainElements(elements),
                    area = that._area,
                    rect,
                    offset,
                    counterSize = area.scaleSize + 2 * measurements.indent;
                if (area.vertical) {
                    rect = that._layoutManager.selectRectBySizes({
                        width: measurements.maxBound - measurements.minBound,
                        height: counterSize
                    });
                    offset = rect.horizontalMiddle() - (measurements.minBound + measurements.maxBound) / 2;
                    area.startCoord = rect.bottom - measurements.indent;
                    area.endCoord = rect.top + measurements.indent;
                    area.x = round(area.x + offset)
                }
                else {
                    rect = that._layoutManager.selectRectBySizes({
                        height: measurements.maxBound - measurements.minBound,
                        width: counterSize
                    });
                    offset = rect.verticalMiddle() - (measurements.minBound + measurements.maxBound) / 2;
                    area.startCoord = rect.left + measurements.indent;
                    area.endCoord = rect.right - measurements.indent;
                    area.y = round(area.y + offset)
                }
                that._translator.setCodomain(area.startCoord, area.endCoord);
                that._layoutManager.setRect(rect)
            },
            _updateElementPosition: function(element) {
                element.resize({
                    x: round(this._area.x + (_Number(element._options.offset) || 0)),
                    y: round(this._area.y + (_Number(element._options.offset) || 0))
                })
            },
            _createScale: function(parameters) {
                return factory.createLinearScale(parameters)
            },
            _createRangeContainer: function(parameters) {
                return factory.createLinearRangeContainer(parameters)
            },
            _createValueIndicator: function(type) {
                return factory.createLinearValueIndicator(type)
            },
            _createSubvalueIndicator: function(type) {
                return factory.createLinearSubvalueIndicator(type)
            },
            _getApproximateScreenRange: function() {
                var that = this,
                    area = that._area,
                    s = area.vertical ? that._height : that._width;
                s > area.totalSize && (s = area.totalSize);
                s = s * 0.8;
                return s
            },
            _getDefaultContainerSize: function() {
                var geometry = this.option('geometry') || {};
                if (geometry.orientation === 'vertical')
                    return {
                            width: 100,
                            height: 300
                        };
                else
                    return {
                            width: 300,
                            height: 100
                        }
            }
        }));
        DX.viz.gauges.dxLinearGauge.prototype._factory = DX.utils.clone(DX.viz.gauges.dxBaseGauge.prototype._factory);
        DX.viz.gauges.dxLinearGauge.prototype._factory.createThemeManager = function() {
            var themeManager = new DX.viz.gauges.__internals.ThemeManager;
            themeManager._subTheme = '_linear';
            return themeManager
        }
    })(DevExpress, jQuery);
    /*! Module viz-gauges, file barGauge.js */
    (function(DX, $, undefined) {
        var viz = DX.viz,
            core = viz.core,
            PI = Math.PI;
        var gauges = viz.gauges,
            _Number = window.Number,
            _isFinite = window.isFinite,
            _abs = Math.abs,
            _round = Math.round,
            _floor = Math.floor,
            _min = Math.min,
            _max = Math.max,
            _isArray = DX.utils.isArray,
            _convertAngleToRendererSpace = DX.utils.convertAngleToRendererSpace,
            _getCosAndSin = DX.utils.getCosAndSin,
            _noop = $.noop,
            _extend = $.extend,
            _getSampleText = viz.gauges.__internals.getSampleText,
            _formatValue = viz.gauges.__internals.formatValue;
        var _Rectangle = core.Rectangle,
            _Palette = core.Palette;
        var dxBarGauge = gauges.dxBaseGauge.inherit({
                _rootClass: 'dxbg-bar-gauge',
                _init: function() {
                    var that = this;
                    that.callBase.apply(that, arguments);
                    that._barsGroup = that._renderer.g().attr({'class': 'dxbg-bars'});
                    that._values = [];
                    that._context = {
                        renderer: that._renderer,
                        translator: that._translator,
                        tracker: that._tracker,
                        group: that._barsGroup
                    };
                    that._animateStep = function(pos) {
                        var bars = that._bars,
                            i = 0,
                            ii = bars.length;
                        for (; i < ii; ++i)
                            bars[i].animate(pos)
                    };
                    that._animateComplete = function() {
                        var bars = that._bars,
                            i = 0,
                            ii = bars.length;
                        for (; i < ii; ++i)
                            bars[i].endAnimation()
                    }
                },
                _dispose: function() {
                    var that = this;
                    that.callBase.apply(that, arguments);
                    that._barsGroup = that._values = that._context = that._animateStep = that._animateComplete = null
                },
                _setupDomainCore: function() {
                    var that = this,
                        startValue = that.option('startValue'),
                        endValue = that.option('endValue');
                    _isFinite(startValue) || (startValue = 0);
                    _isFinite(endValue) || (endValue = 100);
                    that._translator.setDomain(startValue, endValue);
                    that._baseValue = that._translator.adjust(that.option('baseValue'));
                    _isFinite(that._baseValue) || (that._baseValue = startValue < endValue ? startValue : endValue)
                },
                _calculateSize: function() {
                    var that = this,
                        size = that.option('size') || {};
                    if (_Number(size.width) === 0 || _Number(size.height) === 0) {
                        that._width = that._height = 0;
                        that._rootRect = new _Rectangle
                    }
                    else {
                        that._width = size.width > 0 ? _Number(size.width) : that.element().width() || 300;
                        that._height = size.height > 0 ? _Number(size.height) : that.element().height() || 300;
                        that._rootRect = new _Rectangle({
                            left: 0,
                            top: 0,
                            right: that._width,
                            bottom: that._height
                        })
                    }
                },
                _setupCodomain: gauges.dxCircularGauge.prototype._setupCodomain,
                _getApproximateScreenRange: function() {
                    var that = this,
                        sides = that._area.sides,
                        width = that._width / (sides.right - sides.left),
                        height = that._height / (sides.down - sides.up),
                        r = width < height ? width : height;
                    return -that._translator.getCodomainRange() * r * PI / 180
                },
                _setupAnimationSettings: function() {
                    this.callBase();
                    if (this._animationSettings)
                        _extend(this._animationSettings, {
                            step: this._animateStep,
                            complete: this._animateComplete
                        })
                },
                _cleanContent: function() {
                    var that = this;
                    that._barsGroup.remove();
                    that._animationSettings && that._barsGroup.stopAnimation();
                    var i = 0,
                        ii = that._bars ? that._bars.length : 0;
                    for (; i < ii; ++i)
                        that._bars[i].dispose();
                    that._palette = that._bars = null
                },
                _renderContent: function() {
                    var that = this,
                        labelOptions = that.option('label');
                    that._barsGroup.append(that._root);
                    that._context.textEnabled = labelOptions === undefined || labelOptions && (!('visible' in labelOptions) || labelOptions.visible);
                    if (that._context.textEnabled) {
                        that._context.textColor = labelOptions && labelOptions.font && labelOptions.font.color || null;
                        labelOptions = _extend(true, {}, that._themeManager.theme().label, labelOptions);
                        that._context.formatOptions = {
                            format: labelOptions.format !== undefined || labelOptions.precision !== undefined ? labelOptions.format : that._defaultFormatOptions.format,
                            precision: labelOptions.format !== undefined || labelOptions.precision !== undefined ? labelOptions.precision : that._defaultFormatOptions.precision,
                            customizeText: labelOptions.customizeText
                        };
                        that._context.textOptions = {align: 'center'};
                        that._context.fontStyles = core.utils.patchFontOptions(_extend({}, that._themeManager.theme().label.font, labelOptions.font, {color: null}));
                        that._textIndent = labelOptions.indent > 0 ? _Number(labelOptions.indent) : 0;
                        that._context.lineWidth = labelOptions.connectorWidth > 0 ? _Number(labelOptions.connectorWidth) : 0;
                        that._context.lineColor = labelOptions.connectorColor || null;
                        var text = that._renderer.text(_getSampleText(that._translator, that._context.formatOptions), 0, 0).attr(that._context.textOptions).css(that._context.fontStyles).append(that._barsGroup),
                            bbox = text.getBBox();
                        text.remove();
                        that._context.textVerticalOffset = -bbox.y - bbox.height / 2;
                        that._context.textWidth = bbox.width;
                        that._context.textHeight = bbox.height
                    }
                    gauges.dxCircularGauge.prototype._applyMainLayout.call(that);
                    that._renderBars()
                },
                _measureMainElements: function() {
                    var result = {maxRadius: this._area.radius};
                    if (this._context.textEnabled) {
                        result.horizontalMargin = this._context.textWidth;
                        result.verticalMargin = this._context.textHeight
                    }
                    return result
                },
                _renderBars: function() {
                    var that = this,
                        options = _extend({}, that._themeManager.theme(), that.option());
                    that._palette = new _Palette(options.palette, {
                        stepHighlight: 50,
                        theme: that._themeManager.themeName()
                    });
                    var relativeInnerRadius = options.relativeInnerRadius > 0 && options.relativeInnerRadius < 1 ? _Number(options.relativeInnerRadius) : 0.1,
                        radius = that._area.radius;
                    if (that._context.textEnabled) {
                        that._textIndent = _round(_min(that._textIndent, radius / 2));
                        radius -= that._textIndent
                    }
                    that._outerRadius = _round(radius);
                    that._innerRadius = _round(radius * relativeInnerRadius);
                    that._barSpacing = options.barSpacing > 0 ? _Number(options.barSpacing) : 0;
                    _extend(that._context, {
                        backgroundColor: options.backgroundColor,
                        x: that._area.x,
                        y: that._area.y,
                        startAngle: that._area.startCoord,
                        endAngle: that._area.endCoord,
                        baseAngle: that._translator.translate(that._baseValue)
                    });
                    that._bars = [];
                    that._updateValues(that.option('values'))
                },
                _arrangeBars: function(count) {
                    var that = this,
                        radius = that._outerRadius - that._innerRadius;
                    that._context.barSize = count > 0 ? _max((radius - (count - 1) * that._barSpacing) / count, 1) : 0;
                    var spacing = count > 1 ? _max(_min((radius - count * that._context.barSize) / (count - 1), that._barSpacing), 0) : 0,
                        _count = _min(_floor((radius + spacing) / that._context.barSize), count);
                    that._setBarsCount(_count);
                    radius = that._outerRadius;
                    that._context.textRadius = radius + that._textIndent;
                    that._palette.reset();
                    var unitOffset = that._context.barSize + spacing,
                        i = 0;
                    for (; i < _count; ++i, radius -= unitOffset)
                        that._bars[i].arrange({
                            radius: radius,
                            color: that._palette.getNextColor()
                        })
                },
                _setBarsCount: function(count) {
                    var that = this,
                        i,
                        ii;
                    if (that._bars.length > count) {
                        for (i = count, ii = that._bars.length; i < ii; ++i)
                            that._bars[i].dispose();
                        that._bars.splice(count, ii - count)
                    }
                    else if (that._bars.length < count)
                        for (i = that._bars.length, ii = count; i < ii; ++i)
                            that._bars.push(new BarWrapper(i, that._context));
                    if (that._bars.length > 0) {
                        if (that._dummyBackground) {
                            that._dummyBackground.remove();
                            that._dummyBackground = null
                        }
                    }
                    else {
                        if (!that._dummyBackground)
                            that._dummyBackground = that._renderer.arc().attr({"stroke-linejoin": "round"}).append(that._barsGroup);
                        that._dummyBackground.attr({
                            x: that._context.x,
                            y: that._context.y,
                            outerRadius: that._outerRadius,
                            innerRadius: that._innerRadius,
                            startAngle: that._context.endAngle,
                            endAngle: that._context.startAngle,
                            fill: that._context.backgroundColor
                        })
                    }
                },
                _updateBars: function() {
                    var that = this,
                        i = 0,
                        ii = that._bars.length;
                    for (; i < ii; ++i)
                        that._bars[i].setValue(that._values[i])
                },
                _animateBars: function() {
                    var that = this,
                        i = 0,
                        ii = that._bars.length;
                    if (ii > 0) {
                        for (; i < ii; ++i)
                            that._bars[i].beginAnimation(that._values[i]);
                        that._barsGroup.animate({_: 0}, that._animationSettings)
                    }
                },
                _updateValues: function(values, noAnimation) {
                    var that = this,
                        list = _isArray(values) && values || _isFinite(values) && [values] || [],
                        i = 0,
                        ii = list.length,
                        value;
                    that._values = [];
                    for (; i < ii; ++i) {
                        value = that._translator.adjust(list[i]);
                        _isFinite(value) && that._values.push(value)
                    }
                    that._animationSettings && that._barsGroup.stopAnimation();
                    if (that._bars) {
                        that._arrangeBars(that._values.length);
                        if (that._animationSettings && !that._noAnimation)
                            that._animateBars();
                        else
                            that._updateBars()
                    }
                    if (!that._resizing) {
                        that.option('values', that._values);
                        that.hideLoadingIndicator()
                    }
                },
                values: function(arg) {
                    if (arg !== undefined) {
                        this._updateValues(arg);
                        return this
                    }
                    else
                        return this._values.slice(0)
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case'values':
                            this._updateValues(args.value);
                            break;
                        default:
                            this.callBase(args);
                            break
                    }
                },
                _optionValuesEqual: function(name, oldValue, newValue) {
                    switch (name) {
                        case'values':
                            return compareArrays(oldValue, newValue);
                        default:
                            return this.callBase.apply(this, arguments)
                    }
                }
            });
        DX.registerComponent('dxBarGauge', gauges, dxBarGauge);
        var ThemeManager = gauges.__internals.ThemeManager.inherit({
                _themeSection: 'barGauge',
                _fontFields: ['label.font', 'title.font', 'tooltip.font', 'loadingIndicator.font']
            });
        dxBarGauge.prototype._factory = DX.utils.clone(gauges.dxBaseGauge.prototype._factory);
        dxBarGauge.prototype._factory.createThemeManager = function() {
            return new ThemeManager
        };
        function BarWrapper(index, context) {
            var that = this;
            that._context = context;
            that._background = context.renderer.arc().attr({
                "stroke-linejoin": "round",
                fill: context.backgroundColor
            }).append(context.group);
            that._bar = context.renderer.arc().attr({"stroke-linejoin": "round"}).append(context.group);
            if (context.textEnabled) {
                that._line = context.renderer.path([], "line").attr({"stroke-width": context.lineWidth}).append(context.group);
                that._text = context.renderer.text('', 0, 0).css(context.fontStyles).attr(context.textOptions).append(context.group)
            }
            that._tracker = context.renderer.arc().attr({"stroke-linejoin": "round"});
            context.tracker.attach(that._tracker, that, {index: index});
            that._index = index;
            that._angle = context.baseAngle;
            that._settings = {
                x: context.x,
                y: context.y,
                startAngle: context.baseAngle,
                endAngle: context.baseAngle
            }
        }
        _extend(BarWrapper.prototype, {
            dispose: function() {
                var that = this;
                that._background.remove();
                that._bar.remove();
                if (that._context.textEnabled) {
                    that._line.remove();
                    that._text.remove()
                }
                that._context.tracker.detach(that._tracker);
                that._context = that._settings = that._background = that._bar = that._line = that._text = that._tracker = null;
                return that
            },
            arrange: function(options) {
                var that = this,
                    context = that._context;
                that._settings.outerRadius = options.radius;
                that._settings.innerRadius = options.radius - context.barSize;
                that._background.attr(_extend({}, that._settings, {
                    startAngle: context.endAngle,
                    endAngle: context.startAngle
                }));
                that._bar.attr(that._settings);
                that._tracker.attr(that._settings);
                that._color = options.color;
                that._bar.attr({fill: options.color});
                if (context.textEnabled) {
                    that._line.attr({
                        points: [context.x, context.y - that._settings.innerRadius, context.x, context.y - context.textRadius],
                        stroke: context.lineColor || options.color
                    }).sharp();
                    that._text.css({fill: context.textColor || options.color})
                }
                return that
            },
            getTooltipParameters: function() {
                var that = this,
                    cossin = _getCosAndSin((that._angle + that._context.baseAngle) / 2);
                return {
                        x: _round(that._context.x + (that._settings.outerRadius + that._settings.innerRadius) / 2 * cossin.cos),
                        y: _round(that._context.y - (that._settings.outerRadius + that._settings.innerRadius) / 2 * cossin.sin),
                        offset: 0,
                        color: that._color,
                        value: that._value
                    }
            },
            setAngle: function(angle) {
                var that = this;
                that._angle = angle;
                setAngles(that._settings, that._context.baseAngle, that._angle);
                that._bar.attr(that._settings);
                that._tracker.attr(that._settings);
                if (that._context.textEnabled) {
                    that._line.rotate(_convertAngleToRendererSpace(that._angle), that._context.x, that._context.y);
                    var cossin = _getCosAndSin(that._angle);
                    that._text.attr({
                        text: _formatValue(that._value, that._context.formatOptions, {index: that._index}),
                        x: that._context.x + (that._context.textRadius + that._context.textWidth * 0.6) * cossin.cos,
                        y: that._context.y - (that._context.textRadius + that._context.textHeight * 0.6) * cossin.sin + that._context.textVerticalOffset
                    })
                }
                return that
            },
            setValue: function(value) {
                this._value = value;
                return this.setAngle(this._context.translator.translate(value))
            },
            beginAnimation: function(value) {
                var that = this;
                that._value = value;
                var angle = that._context.translator.translate(value);
                if (!compareFloats(that._angle, angle)) {
                    that._start = that._angle;
                    that._delta = angle - that._angle;
                    that._tracker.attr({visibility: 'hidden'});
                    if (that._context.textEnabled) {
                        that._line.attr({visibility: 'hidden'});
                        that._text.attr({visibility: 'hidden'})
                    }
                }
                else
                    that.animate = _noop
            },
            animate: function(pos) {
                var that = this;
                that._angle = that._start + that._delta * pos;
                setAngles(that._settings, that._context.baseAngle, that._angle);
                that._bar.attr(that._settings)
            },
            endAnimation: function() {
                var that = this;
                if (that._delta !== undefined) {
                    if (compareFloats(that._angle, that._start + that._delta)) {
                        that._tracker.attr({visibility: null});
                        if (that._context.textEnabled) {
                            that._line.attr({visibility: null});
                            that._text.attr({visibility: null})
                        }
                        that.setAngle(that._angle)
                    }
                }
                else
                    delete that.animate;
                delete that._start;
                delete that._delta
            }
        });
        function setAngles(target, angle1, angle2) {
            target.startAngle = angle1 < angle2 ? angle1 : angle2;
            target.endAngle = angle1 < angle2 ? angle2 : angle1
        }
        function compareFloats(value1, value2) {
            return _abs(value1 - value2) < 0.0001
        }
        function compareArrays(array1, array2) {
            if (array1 === array2)
                return true;
            if (_isArray(array1) && _isArray(array2) && array1.length === array2.length) {
                for (var i = 0, ii = array1.length; i < ii; ++i)
                    if (!compareFloats(array1[i], array2[i]))
                        return false;
                return true
            }
            return false
        }
        var __BarWrapper = BarWrapper;
        gauges.__tests.BarWrapper = __BarWrapper;
        gauges.__tests.stubBarWrapper = function(barWrapperType) {
            BarWrapper = barWrapperType
        };
        gauges.__tests.restoreBarWrapper = function() {
            BarWrapper = __BarWrapper
        }
    })(DevExpress, jQuery);
    /*! Module viz-gauges, file tracker.js */
    (function(DX, $, undefined) {
        var _setTimeout = window.setTimeout,
            _clearTimeout = window.clearTimeout,
            _extend = $.extend,
            _abs = Math.abs;
        var TOOLTIP_SHOW_DELAY = 300,
            TOOLTIP_HIDE_DELAY = 300,
            TOOLTIP_TOUCH_SHOW_DELAY = 400,
            TOOLTIP_TOUCH_HIDE_DELAY = 300;
        DX.viz.gauges.__internals.Tracker = DX.Class.inherit({
            ctor: function(parameters) {
                DX.utils.debug.assertParam(parameters, 'parameters');
                DX.utils.debug.assertParam(parameters.renderer, 'parameters.renderer');
                DX.utils.debug.assertParam(parameters.container, 'parameters.container');
                var that = this;
                that._container = parameters.container;
                that._element = parameters.renderer.g().attr({
                    'class': 'dxg-tracker',
                    stroke: 'none',
                    "stroke-width": 0,
                    fill: '#000000',
                    opacity: 0.0001
                });
                that._showTooltipCallback = function() {
                    that._showTooltipTimeout = null;
                    var target = that._tooltipEvent.target;
                    that._targetEvent = null;
                    if (that._tooltipTarget !== target) {
                        that._tooltipTarget = target;
                        that._callbacks['tooltip-show']()
                    }
                };
                that._hideTooltipCallback = function() {
                    that._hideTooltipTimeout = null;
                    that._targetEvent = null;
                    if (that._tooltipTarget) {
                        that._callbacks['tooltip-hide']();
                        that._tooltipTarget = null
                    }
                };
                that._dispose = function() {
                    that._showTooltipCallback = that._hideTooltipCallback = that._dispose = null
                };
                that._DEBUG_showTooltipTimeoutSet = that._DEBUG_showTooltipTimeoutCleared = that._DEBUG_hideTooltipTimeoutSet = that._DEBUG_hideTooltipTimeoutCleared = 0
            },
            dispose: function() {
                var that = this;
                that._dispose();
                that.deactivate();
                $(that._element.element).off();
                that._container = that._element = that._context = that._callbacks = null;
                return that
            },
            activate: function() {
                this._element.append(this._container);
                return this
            },
            deactivate: function() {
                this._element.remove();
                this._element.clear();
                return this
            },
            attach: function(element, target, info) {
                $(element.element).data({
                    target: target,
                    info: info
                });
                element.append(this._element);
                return this
            },
            detach: function(element) {
                element.remove();
                $(element.element).removeData();
                return this
            },
            setTooltipState: function(state) {
                var that = this,
                    data;
                $(that._element.element).off(tooltipMouseEvents).off(tooltipTouchEvents);
                if (state) {
                    data = {tracker: that};
                    $(that._element.element).on(tooltipMouseEvents, data).on(tooltipTouchEvents, data)
                }
                return that
            },
            setCallbacks: function(callbacks) {
                this._callbacks = callbacks;
                return this
            },
            _showTooltip: function(event, delay) {
                var that = this,
                    data = $(event.target).data();
                if (that._tooltipTarget === event.target || that._callbacks['tooltip-prepare'](data.target, data.info)) {
                    that._hideTooltipTimeout && ++that._DEBUG_hideTooltipTimeoutCleared;
                    _clearTimeout(that._hideTooltipTimeout);
                    that._hideTooltipTimeout = null;
                    _clearTimeout(that._showTooltipTimeout);
                    that._tooltipEvent = event;
                    ++that._DEBUG_showTooltipTimeoutSet;
                    that._showTooltipTimeout = _setTimeout(that._showTooltipCallback, delay)
                }
            },
            _hideTooltip: function(delay) {
                var that = this;
                that._showTooltipTimeout && ++that._DEBUG_showTooltipTimeoutCleared;
                _clearTimeout(that._showTooltipTimeout);
                that._showTooltipTimeout = null;
                _clearTimeout(that._hideTooltipTimeout);
                ++that._DEBUG_hideTooltipTimeoutSet;
                that._hideTooltipTimeout = _setTimeout(that._hideTooltipCallback, delay)
            }
        });
        var tooltipMouseEvents = {
                'mouseover.gauge-tooltip': handleTooltipMouseOver,
                'mouseout.gauge-tooltip': handleTooltipMouseOut
            };
        var tooltipMouseMoveEvents = {'mousemove.gauge-tooltip': handleTooltipMouseMove};
        var tooltipTouchEvents = {'touchstart.gauge-tooltip': handleTooltipTouchStart};
        function handleTooltipMouseOver(event) {
            var tracker = event.data.tracker;
            tracker._x = event.pageX;
            tracker._y = event.pageY;
            $(tracker._element.element).off(tooltipMouseMoveEvents).on(tooltipMouseMoveEvents, event.data);
            tracker._showTooltip(event, TOOLTIP_SHOW_DELAY)
        }
        function handleTooltipMouseMove(event) {
            var tracker = event.data.tracker;
            if (tracker._showTooltipTimeout && _abs(event.pageX - tracker._x) > 4 || _abs(event.pageY - tracker._y) > 4) {
                tracker._x = event.pageX;
                tracker._y = event.pageY;
                tracker._showTooltip(event, TOOLTIP_SHOW_DELAY)
            }
        }
        function handleTooltipMouseOut(event) {
            var tracker = event.data.tracker;
            $(tracker._element.element).off(tooltipMouseMoveEvents);
            tracker._hideTooltip(TOOLTIP_HIDE_DELAY)
        }
        var active_touch_tooltip_tracker = null;
        DX.viz.gauges.__internals.Tracker._DEBUG_reset = function() {
            active_touch_tooltip_tracker = null
        };
        function handleTooltipTouchStart(event) {
            event.preventDefault();
            var tracker = active_touch_tooltip_tracker;
            if (tracker && tracker !== event.data.tracker)
                tracker._hideTooltip(TOOLTIP_TOUCH_HIDE_DELAY);
            tracker = active_touch_tooltip_tracker = event.data.tracker;
            tracker._showTooltip(event, TOOLTIP_TOUCH_SHOW_DELAY);
            tracker._touch = true
        }
        function handleTooltipDocumentTouchStart(event) {
            var tracker = active_touch_tooltip_tracker;
            if (tracker) {
                if (!tracker._touch) {
                    tracker._hideTooltip(TOOLTIP_TOUCH_HIDE_DELAY);
                    active_touch_tooltip_tracker = null
                }
                tracker._touch = null
            }
        }
        function handleTooltipDocumentTouchEnd(event) {
            var tracker = active_touch_tooltip_tracker;
            if (tracker)
                if (tracker._showTooltipTimeout) {
                    tracker._hideTooltip(TOOLTIP_TOUCH_HIDE_DELAY);
                    active_touch_tooltip_tracker = null
                }
        }
        $(window.document).on({
            'touchstart.gauge-tooltip': handleTooltipDocumentTouchStart,
            'touchend.gauge-tooltip': handleTooltipDocumentTouchEnd
        })
    })(DevExpress, jQuery);
    DevExpress.MOD_VIZ_GAUGES = true
}
if (!DevExpress.MOD_VIZ_RANGESELECTOR) {
    if (!DevExpress.MOD_VIZ_CORE)
        throw Error('Required module is not referenced: viz-core');
    /*! Module viz-rangeselector, file namespaces.js */
    (function(DevExpress) {
        DevExpress.viz.rangeSelector = {utils: {}}
    })(DevExpress);
    /*! Module viz-rangeselector, file utils.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            utils = rangeSelector.utils,
            dxUtils = DX.utils,
            INVISIBLE_POS = -1000;
        var findLessOrEqualValueIndex = function(values, value) {
                if (!values || values.length === 0)
                    return -1;
                var minIndex = 0,
                    maxIndex = values.length - 1,
                    index = 0;
                while (maxIndex - minIndex > 1) {
                    var index = minIndex + maxIndex >> 1;
                    if (values[index] > value)
                        maxIndex = index;
                    else
                        minIndex = index
                }
                return values[maxIndex] <= value ? maxIndex : minIndex
            };
        var findLessOrEqualValue = function(values, value) {
                var index = findLessOrEqualValueIndex(values, value);
                if (values && index >= 0 && index < values.length)
                    return values[index];
                return value
            };
        var findNearValue = function(values, value) {
                var index = findLessOrEqualValueIndex(values, value);
                if (values && index >= 0 && index < values.length) {
                    if (index + 1 < values.length)
                        if (dxUtils.isDate(value)) {
                            if (values[index + 1].getTime() - value.getTime() < value.getTime() - values[index].getTime())
                                index++
                        }
                        else if (values[index + 1] - value < value - values[index])
                            index++;
                    return values[index]
                }
                return value
            };
        var findGreaterOrEqualValue = function(values, value) {
                var index = findLessOrEqualValueIndex(values, value);
                if (values && index >= 0 && index < values.length) {
                    if (values[index] < value && index + 1 < values.length)
                        index++;
                    return values[index]
                }
                return value
            };
        var getRootOffsetLeft = function(renderer) {
                return dxUtils.getRootOffset(renderer).left || 0
            };
        var getEventPageX = function(eventArgs) {
                var result = 0;
                if (eventArgs.pageX)
                    result = eventArgs.pageX;
                else if (eventArgs.originalEvent && eventArgs.originalEvent.pageX)
                    result = eventArgs.originalEvent.pageX;
                if (eventArgs.originalEvent && eventArgs.originalEvent.touches)
                    if (eventArgs.originalEvent.touches.length > 0)
                        result = eventArgs.originalEvent.touches[0].pageX;
                    else if (eventArgs.originalEvent.changedTouches.length > 0)
                        result = eventArgs.originalEvent.changedTouches[0].pageX;
                return result
            };
        var getTextBBox = function(renderer, text, fontOptions) {
                var textElement = renderer.text(text, INVISIBLE_POS, INVISIBLE_POS).css(fontOptions).append(renderer.root);
                var textBBox = textElement.getBBox();
                textElement.remove();
                return textBBox
            };
        var truncateSelectedRange = function(value, scaleOptions) {
                var isDiscrete = scaleOptions.type === 'discrete',
                    categories = isDiscrete ? scaleOptions._categoriesInfo.categories : undefined,
                    startValue = scaleOptions.startValue,
                    endValue = scaleOptions.endValue,
                    min,
                    max,
                    valueIndex;
                if (isDiscrete) {
                    valueIndex = $.inArray(value, categories);
                    return valueIndex < 0 ? startValue : value
                }
                else
                    min = startValue > endValue ? endValue : startValue,
                    max = startValue > endValue ? startValue : endValue;
                if (value < min)
                    value = min;
                if (value > max)
                    value = max;
                return value
            };
        utils.findLessOrEqualValue = findLessOrEqualValue;
        utils.findNearValue = findNearValue;
        utils.findGreaterOrEqualValue = findGreaterOrEqualValue;
        utils.getRootOffsetLeft = getRootOffsetLeft;
        utils.getEventPageX = getEventPageX;
        utils.getTextBBox = getTextBBox;
        utils.truncateSelectedRange = truncateSelectedRange
    })(jQuery, DevExpress);
    /*! Module viz-rangeselector, file baseVisualElement.js */
    (function(DX) {
        DevExpress.viz.rangeSelector.BaseVisualElement = DX.Class.inherit({
            ctor: function(renderer) {
                this._renderer = renderer;
                this._isDrawn = false
            },
            applyOptions: function(options) {
                this._options = options || {};
                this._applyOptions(this._options)
            },
            _applyOptions: function(options){},
            redraw: function(group) {
                var that = this;
                if (!that._isDrawn) {
                    that._isDrawn = !(that._draw(group || that._group) === false);
                    if (group)
                        that._group = group
                }
                else
                    that._update(group || that._group)
            },
            isDrawn: function() {
                return !!this._isDrawn
            },
            isInitialized: function() {
                return !!this._options
            },
            _draw: function(group){},
            _update: function(group) {
                group.clear();
                this._draw(group)
            }
        })
    })(DevExpress);
    /*! Module viz-rangeselector, file rangeSelector.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            utils = DX.utils,
            dataUtils = DX.data.utils,
            rangeSelectorUtils = rangeSelector.utils,
            ParseUtils = DX.viz.core.ParseUtils,
            formatHelper = DX.formatHelper,
            core = DX.viz.core,
            SCALE_TEXT_SPACING = 5,
            _isDefined = utils.isDefined,
            _isNumber = utils.isNumber,
            _isDate = utils.isDate,
            _max = Math.max,
            _ceil = Math.ceil,
            _extend = $.extend,
            START_VALUE = 'startValue',
            END_VALUE = 'endValue',
            DATETIME = 'datetime',
            SELECTED_RANGE = 'selectedRange',
            DISCRETE = 'discrete',
            STRING = 'string',
            defaultRangeSelectorOptions = {
                size: undefined,
                margin: {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0
                },
                scale: {
                    showCustomBoundaryTicks: true,
                    showMinorTicks: true,
                    startValue: undefined,
                    endValue: undefined,
                    minorTickCount: undefined,
                    minorTickInterval: undefined,
                    majorTickInterval: undefined,
                    useTicksAutoArrangement: true,
                    setTicksAtUnitBeginning: true,
                    minRange: undefined,
                    maxRange: undefined,
                    placeholderHeight: undefined,
                    valueType: undefined,
                    label: {
                        visible: true,
                        format: undefined,
                        precision: undefined,
                        customizeText: undefined
                    },
                    marker: {
                        visible: true,
                        label: {
                            format: undefined,
                            precision: undefined,
                            customizeText: undefined
                        }
                    },
                    logarithmBase: 10
                },
                selectedRange: undefined,
                sliderMarker: {
                    visible: true,
                    format: undefined,
                    precision: undefined,
                    customizeText: undefined,
                    placeholderSize: undefined
                },
                behavior: {
                    snapToTicks: true,
                    animationEnabled: true,
                    moveSelectedRangeByClick: true,
                    manualRangeSelectionEnabled: true,
                    allowSlidersSwap: true,
                    callSelectedRangeChanged: "onMovingComplete"
                },
                background: {
                    color: "#C0BAE1",
                    visible: true,
                    image: {
                        url: undefined,
                        location: 'full'
                    }
                },
                dataSource: undefined,
                dataSourceField: 'arg',
                redrawOnResize: true,
                theme: undefined,
                selectedRangeChanged: null
            };
        rangeSelector.consts = {
            fontHeightRatio: 0.55,
            emptySliderMarkerText: '. . .'
        };
        rangeSelector.formatValue = function(value, formatOptions) {
            var formatObject = {
                    value: value,
                    valueText: formatHelper.format(value, formatOptions.format, formatOptions.precision)
                };
            return String(utils.isFunction(formatOptions.customizeText) ? formatOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText)
        };
        var createRangeContainer = function(rangeContainerOptions) {
                return rangeSelector.rangeSelectorFactory.createRangeContainer(rangeContainerOptions)
            };
        var createTranslator = function(range, canvas) {
                return {
                        x: core.CoreFactory.createTranslator2D(range.arg, canvas, {direction: "horizontal"}),
                        y: core.CoreFactory.createTranslator2D(range.val, canvas)
                    }
            };
        var createTranslatorCanvas = function(sizeOptions, rangeContainerCanvas, scaleLabelsAreaHeight) {
                return {
                        left: rangeContainerCanvas.left,
                        top: rangeContainerCanvas.top,
                        right: sizeOptions.width - rangeContainerCanvas.width - rangeContainerCanvas.left,
                        bottom: sizeOptions.height - rangeContainerCanvas.height - rangeContainerCanvas.top + scaleLabelsAreaHeight,
                        width: sizeOptions.width,
                        height: sizeOptions.height
                    }
            };
        var calculateMarkerSize = function(renderer, value, sliderMarkerOptions) {
                var formattedText = value === undefined ? rangeSelector.consts.emptySliderMarkerText : rangeSelector.formatValue(value, sliderMarkerOptions),
                    textBBox = rangeSelectorUtils.getTextBBox(renderer, formattedText, sliderMarkerOptions.font);
                return {
                        width: _ceil(textBBox.width) + 2 * sliderMarkerOptions.padding,
                        height: _ceil(textBBox.height * rangeSelector.consts.fontHeightRatio) + 2 * sliderMarkerOptions.padding + sliderMarkerOptions.pointerSize
                    }
            };
        var calculateScaleLabelHalfWidth = function(renderer, value, scaleOptions) {
                var formattedText = rangeSelector.formatValue(value, scaleOptions.label),
                    textBBox = rangeSelectorUtils.getTextBBox(renderer, formattedText, scaleOptions.label.font);
                return _ceil(textBBox.width / 2)
            };
        var calculateRangeContainerCanvas = function(size, margin, sliderMarkerSpacing) {
                var canvas = {
                        left: margin.left + sliderMarkerSpacing.left,
                        top: margin.top + sliderMarkerSpacing.top,
                        width: size.width - margin.left - margin.right - sliderMarkerSpacing.left - sliderMarkerSpacing.right,
                        height: size.height - margin.top - margin.bottom - sliderMarkerSpacing.top - sliderMarkerSpacing.bottom
                    };
                if (canvas.width <= 0)
                    canvas.width = 1;
                return canvas
            };
        var parseSliderMarkersPlaceholderSize = function(placeholderSize) {
                var placeholderWidthLeft,
                    placeholderWidthRight,
                    placeholderHeight;
                if (_isNumber(placeholderSize))
                    placeholderWidthLeft = placeholderWidthRight = placeholderHeight = placeholderSize;
                else if (placeholderSize) {
                    if (_isNumber(placeholderSize.height))
                        placeholderHeight = placeholderSize.height;
                    if (_isNumber(placeholderSize.width))
                        placeholderWidthLeft = placeholderWidthRight = placeholderSize.width;
                    else if (placeholderSize.width) {
                        if (_isNumber(placeholderSize.width.left))
                            placeholderWidthLeft = placeholderSize.width.left;
                        if (_isNumber(placeholderSize.width.right))
                            placeholderWidthRight = placeholderSize.width.right
                    }
                }
                return {
                        widthLeft: placeholderWidthLeft,
                        widthRight: placeholderWidthRight,
                        height: placeholderHeight
                    }
            };
        var calculateSliderMarkersSpacing = function(renderer, size, scale, sliderMarkerOptions) {
                var leftMarkerSize,
                    leftScaleLabelWidth = 0,
                    rightScaleLabelWidth = 0,
                    rightMarkerSize,
                    placeholderWidthLeft = 0,
                    placeholderWidthRight = 0,
                    placeholderHeight = 0,
                    parsedPlaceholderSize,
                    markerMaxWidth;
                parsedPlaceholderSize = parseSliderMarkersPlaceholderSize(sliderMarkerOptions.placeholderSize);
                placeholderWidthLeft = parsedPlaceholderSize.widthLeft || 0;
                placeholderWidthRight = parsedPlaceholderSize.widthRight || 0;
                placeholderHeight = parsedPlaceholderSize.height || 0;
                if (sliderMarkerOptions.visible) {
                    leftMarkerSize = calculateMarkerSize(renderer, scale.startValue, sliderMarkerOptions);
                    rightMarkerSize = calculateMarkerSize(renderer, scale.endValue, sliderMarkerOptions);
                    markerMaxWidth = _max(leftMarkerSize.width, rightMarkerSize.width);
                    if (!placeholderWidthLeft)
                        placeholderWidthLeft = markerMaxWidth;
                    if (!placeholderWidthRight)
                        placeholderWidthRight = markerMaxWidth;
                    if (!placeholderHeight)
                        placeholderHeight = _max(leftMarkerSize.height, rightMarkerSize.height)
                }
                if (scale.label.visible) {
                    leftScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, scale.startValue, scale);
                    rightScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, scale.endValue, scale)
                }
                placeholderWidthLeft = _max(placeholderWidthLeft, leftScaleLabelWidth);
                placeholderWidthRight = _max(placeholderWidthRight, rightScaleLabelWidth);
                return {
                        left: placeholderWidthLeft,
                        right: placeholderWidthRight,
                        top: placeholderHeight,
                        bottom: 0
                    }
            };
        var clearContainer = function(container) {
                if (container)
                    container.empty()
            };
        var createThemeManager = function(theme) {
                return rangeSelector.rangeSelectorFactory.createThemeManager(theme)
            };
        var calculateValueType = function(firstValue, secondValue) {
                var typeFirstValue = $.type(firstValue),
                    typeSecondValue = $.type(secondValue),
                    validType = function(type) {
                        return typeFirstValue === type || typeSecondValue === type
                    };
                return validType('date') ? DATETIME : validType('number') ? 'numeric' : validType(STRING) ? STRING : ''
            };
        var showScaleMarkers = function(scaleOptions) {
                return scaleOptions.valueType == DATETIME && scaleOptions.marker.visible
            };
        var updateTranslatorRangeInterval = function(translatorRange, scaleOptions) {
                var intervalX = scaleOptions.minorTickInterval || scaleOptions.majorTickInterval;
                if (scaleOptions.valueType === "datetime")
                    intervalX = utils.convertDateTickIntervalToMilliseconds(intervalX);
                translatorRange = translatorRange.arg.addRange({interval: intervalX})
            };
        var createRange = function(options) {
                return new core.Range(options)
            };
        var checkLogarithmicOptions = function(options, logarithmBase, incidentOccured) {
                if (!options)
                    return;
                if (options.type === 'logarithmic' && options.logarithmBase <= 0 || options.logarithmBase && !_isNumber(options.logarithmBase)) {
                    options.logarithmBase = logarithmBase;
                    incidentOccured('E2104')
                }
                else if (options.type !== 'logarithmic')
                    options.logarithmBase = undefined
            };
        var calculateScaleAreaHeight = function(renderer, scaleOptions, visibleMarkers) {
                var textBBox,
                    visibleLabels = scaleOptions.label.visible;
                if (scaleOptions.placeholderHeight)
                    return scaleOptions.placeholderHeight;
                else {
                    textBBox = rangeSelectorUtils.getTextBBox(renderer, '0', scaleOptions.label.font);
                    return (visibleLabels ? scaleOptions.label.topIndent + textBBox.height : 0) + (visibleMarkers ? scaleOptions.marker.topIndent + scaleOptions.marker.separatorHeight : 0)
                }
            };
        var updateTickIntervals = function(scaleOptions, screenDelta, incidentOccured, stick, min, max) {
                var tickManager = core.CoreFactory.createTickManager({
                        axisType: scaleOptions.type,
                        dataType: scaleOptions.valueType
                    }, {
                        min: min,
                        max: max,
                        screenDelta: screenDelta
                    }, {
                        labelOptions: {},
                        boundCoef: 1,
                        minorTickInterval: scaleOptions.minorTickInterval,
                        tickInterval: scaleOptions.majorTickInterval,
                        incidentOccured: incidentOccured,
                        base: scaleOptions.logarithmBase,
                        showMinorTicks: true,
                        withMinorCorrection: true,
                        stick: stick !== false
                    });
                tickManager.getTicks(true);
                return {
                        majorTickInterval: tickManager.getTickInterval(),
                        minorTickInterval: tickManager.getMinorTickInterval(),
                        bounds: tickManager.getTickBounds()
                    }
            };
        var calculateTranslatorRange = function(seriesDataSource, scaleOptions) {
                var minValue,
                    maxValue,
                    inverted = false,
                    isEqualDates,
                    startValue = scaleOptions.startValue,
                    endValue = scaleOptions.endValue,
                    categories,
                    categoriesInfo,
                    translatorRange = seriesDataSource ? seriesDataSource.getBoundRange() : {
                        arg: createRange(),
                        val: createRange({isValueRange: true})
                    },
                    rangeForCategories;
                if (scaleOptions.type === DISCRETE) {
                    rangeForCategories = createRange({
                        categories: scaleOptions.categories || (!seriesDataSource && startValue && endValue ? [startValue, endValue] : undefined),
                        startCategories: startValue,
                        endCategories: endValue
                    });
                    rangeForCategories.addRange(translatorRange.arg);
                    translatorRange.arg = rangeForCategories;
                    categories = rangeForCategories.categories || [];
                    scaleOptions._categoriesInfo = categoriesInfo = utils.getCategoriesInfo(categories, startValue || categories[0], endValue || categories[categories.length - 1])
                }
                if (_isDefined(startValue) && _isDefined(endValue)) {
                    inverted = scaleOptions.inverted = categoriesInfo ? categoriesInfo.inverted : startValue > endValue;
                    minValue = categoriesInfo ? categoriesInfo.start : inverted ? endValue : startValue;
                    maxValue = categoriesInfo ? categoriesInfo.end : inverted ? startValue : endValue
                }
                else if (_isDefined(startValue) || _isDefined(endValue)) {
                    minValue = startValue;
                    maxValue = endValue
                }
                else if (categoriesInfo) {
                    minValue = categoriesInfo.start;
                    maxValue = categoriesInfo.end
                }
                isEqualDates = _isDate(minValue) && _isDate(maxValue) && minValue.getTime() === maxValue.getTime();
                if (minValue !== maxValue && !isEqualDates)
                    translatorRange.arg.addRange({
                        invert: inverted,
                        min: minValue,
                        max: maxValue,
                        minVisible: minValue,
                        maxVisible: maxValue,
                        dataType: scaleOptions.valueType
                    });
                translatorRange.arg.addRange({
                    base: scaleOptions.logarithmBase,
                    axisType: scaleOptions.type
                });
                if (!translatorRange.arg.isDefined()) {
                    if (isEqualDates)
                        scaleOptions.valueType = 'numeric';
                    translatorRange.arg.setStubData(scaleOptions.valueType)
                }
                return translatorRange
            };
        var startEndNotDefined = function(start, end) {
                return !_isDefined(start) || !_isDefined(end)
            };
        DX.registerComponent("dxRangeSelector", rangeSelector, core.BaseWidget.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option(defaultRangeSelectorOptions)
            },
            _eventsMap: $.extend({}, core.BaseWidget.prototype._eventsMap, {
                onSelectedRangeChanged: {
                    name: 'selectedRangeChanged',
                    deprecated: 'selectedRangeChanged',
                    deprecatedContext: function() {
                        return null
                    },
                    deprecatedArgs: function(arg) {
                        return [{
                                    startValue: arg.startValue,
                                    endValue: arg.endValue
                                }]
                    }
                },
                selectedRangeChanged: {newName: 'onSelectedRangeChanged'}
            }),
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {selectedRangeChanged: {
                        since: '14.2',
                        message: "Use the 'onSelectedRangeChanged' option instead"
                    }})
            },
            _dataSourceOptions: function() {
                return {
                        paginate: false,
                        _preferSync: true
                    }
            },
            _init: function() {
                var that = this;
                that.container = that._getContainer();
                clearContainer(that.container);
                that.renderer = that._createRenderer();
                that.rangeContainer = createRangeContainer(that.renderer);
                that.callBase();
                that._reinitDataSource()
            },
            _reinitDataSource: function() {
                this._refreshDataSource()
            },
            _dispose: function() {
                var that = this,
                    disposeObject = function(propName) {
                        that[propName] && that[propName].dispose(),
                        that[propName] = null
                    };
                that.callBase();
                disposeObject("renderer");
                that.translators = null;
                disposeObject("rangeContainer")
            },
            _initOptions: function(options) {
                var that = this,
                    themeManager;
                that._optionsInitializing = true;
                options = options || {};
                that._userOptions = _extend(true, {}, options);
                themeManager = createThemeManager(options.theme);
                themeManager.setBackgroundColor(options.containerBackgroundColor);
                that.option(themeManager.applyRangeSelectorTheme(options));
                that._prepareChartThemeOptions(options);
                if (options.background)
                    that._userBackgroundColor = options.background.color
            },
            _refresh: function() {
                var that = this,
                    callBase = that.callBase;
                that._endLoading(function() {
                    callBase.call(that)
                })
            },
            _render: function(isResizing) {
                var that = this,
                    currentAnimationEnabled,
                    behaviorOptions;
                that._optionsInitializing = false;
                that._applyOptions();
                if (!that.stopRedraw) {
                    if (isResizing) {
                        behaviorOptions = that.option('behavior');
                        currentAnimationEnabled = behaviorOptions.animationEnabled;
                        behaviorOptions.animationEnabled = false;
                        that.rangeContainer.redraw();
                        behaviorOptions.animationEnabled = currentAnimationEnabled
                    }
                    else
                        that.rangeContainer.redraw();
                    !isResizing && (!that._dataSource || that._dataSource && that._dataSource.isLoaded()) && that.hideLoadingIndicator()
                }
                that._drawn();
                that.__rendered && that.__rendered()
            },
            _optionChanged: function(args) {
                var that = this,
                    name = args.name;
                if (!that._optionsInitializing)
                    dataUtils.compileSetter(name)(that._userOptions, args.value, {
                        functionsAsIs: true,
                        merge: true
                    });
                if (name === "dataSource") {
                    that._reinitDataSource();
                    that._invalidate()
                }
                else if (name === "selectedRange")
                    that.setSelectedRange(that.option(SELECTED_RANGE));
                else if (name === 'containerBackgroundColor' || name === 'theme') {
                    that._initOptions(that._userOptions);
                    that._invalidate()
                }
                else
                    that.callBase(args)
            },
            _resize: function() {
                if (this._isSizeChanged())
                    this._render(true)
            },
            _dataSourceChangedHandler: function() {
                var that = this;
                that._endLoading(function() {
                    that._render()
                })
            },
            _isSizeChanged: function() {
                var actualSize = this._actualSize,
                    newSize = this._calculateSize();
                return actualSize && (actualSize.width !== newSize.width || actualSize.height !== newSize.height)
            },
            _applyOptions: function() {
                var that = this,
                    rangeContainerCanvas,
                    seriesDataSource,
                    translatorRange,
                    scaleLabelsAreaHeight,
                    sizeOptions = that._actualSize = that._calculateSize(),
                    sliderMarkerSpacing,
                    sliderMarkerOptions,
                    selectedRange,
                    $container = that.container,
                    scaleOptions;
                that._isUpdating = true;
                seriesDataSource = that._createSeriesDataSource();
                scaleOptions = that._scaleOptions = that._prepareScaleOptions(seriesDataSource);
                that._correctSizeOptions(sizeOptions);
                if (!sizeOptions.width || !sizeOptions.height || !$container.is(':visible')) {
                    that.stopRedraw = true;
                    that._incidentOccured("W2001", [that.NAME]);
                    return
                }
                else
                    that.stopRedraw = false;
                that._updateRendererSize(sizeOptions);
                that._updateLoadIndicator(undefined, that.canvas.width, that.canvas.height);
                translatorRange = calculateTranslatorRange(seriesDataSource, scaleOptions);
                that._updateScaleOptions(seriesDataSource, translatorRange, sizeOptions.width);
                updateTranslatorRangeInterval(translatorRange, scaleOptions);
                sliderMarkerOptions = that._prepareSliderMarkersOptions(sizeOptions.width);
                selectedRange = that._initSelection();
                sliderMarkerSpacing = calculateSliderMarkersSpacing(that.renderer, sizeOptions, scaleOptions, sliderMarkerOptions);
                rangeContainerCanvas = calculateRangeContainerCanvas(sizeOptions, that.option('margin'), sliderMarkerSpacing);
                scaleLabelsAreaHeight = calculateScaleAreaHeight(that.renderer, scaleOptions, showScaleMarkers(scaleOptions));
                that.translators = createTranslator(translatorRange, createTranslatorCanvas(sizeOptions, rangeContainerCanvas, scaleLabelsAreaHeight));
                scaleOptions.ticksInfo = that._getTicksInfo(rangeContainerCanvas.width);
                that._testTicksInfo = scaleOptions.ticksInfo;
                that._selectedRange = selectedRange;
                if (seriesDataSource)
                    seriesDataSource.adjustSeriesDimensions(that.translators);
                that.rangeContainer.applyOptions({
                    canvas: rangeContainerCanvas,
                    scaleLabelsAreaHeight: scaleLabelsAreaHeight,
                    sliderMarkerSpacing: sliderMarkerSpacing,
                    translators: that.translators,
                    selectedRange: selectedRange,
                    scale: scaleOptions,
                    behavior: that.option('behavior'),
                    background: that.option('background'),
                    chart: that.option('chart'),
                    seriesDataSource: seriesDataSource,
                    sliderMarker: sliderMarkerOptions,
                    sliderHandle: that.option('sliderHandle'),
                    shutter: that.option('shutter'),
                    selectedRangeChanged: that._createSelectedRangeChangedFunction(),
                    setSelectedRange: function(selectedRange) {
                        that.setSelectedRange(selectedRange)
                    }
                });
                that._isUpdating = false
            },
            _initSelection: function() {
                var that = this,
                    scaleOptions = that._scaleOptions,
                    selectedRangeOptions = that.option(SELECTED_RANGE),
                    startValue,
                    endValue,
                    parser = scaleOptions.parser || function() {
                        return null
                    },
                    parseValue = function(value, entity) {
                        var parsedValue,
                            result = scaleOptions[entity];
                        if (_isDefined(value))
                            parsedValue = parser(value);
                        if (!_isDefined(parsedValue))
                            that._incidentOccured("E2203", [entity]);
                        else
                            result = parsedValue;
                        return result
                    };
                if (!selectedRangeOptions)
                    return {
                            startValue: scaleOptions.startValue,
                            endValue: scaleOptions.endValue
                        };
                else {
                    startValue = parseValue(selectedRangeOptions.startValue, START_VALUE);
                    startValue = rangeSelectorUtils.truncateSelectedRange(startValue, scaleOptions);
                    endValue = parseValue(selectedRangeOptions.endValue, END_VALUE);
                    endValue = rangeSelectorUtils.truncateSelectedRange(endValue, scaleOptions);
                    return {
                            startValue: startValue,
                            endValue: endValue
                        }
                }
            },
            _prepareChartThemeOptions: function(options) {
                var chartTheme,
                    chartOption = this.option('chart') || {};
                if (!chartOption.theme && options && options.theme) {
                    chartTheme = options.theme;
                    if (chartTheme) {
                        if (typeof chartTheme === 'object') {
                            chartTheme = chartTheme.chart || {};
                            chartTheme.name = options.theme.name
                        }
                        chartOption.theme = chartTheme
                    }
                }
            },
            _updateRendererSize: function(size) {
                this.renderer.resize(size.width, size.height).draw(this.container[0])
            },
            _createSeriesDataSource: function() {
                var that = this,
                    seriesDataSource,
                    dataSource = that._dataSource && that._dataSource.items(),
                    scaleOptions = that.option('scale'),
                    chartOptions = that.option('chart') || {},
                    valueType = scaleOptions.valueType;
                if (!valueType)
                    valueType = calculateValueType(scaleOptions.startValue, scaleOptions.endValue);
                if (dataSource || chartOptions.series) {
                    seriesDataSource = new rangeSelector.SeriesDataSource({
                        renderer: that.renderer,
                        dataSource: dataSource,
                        valueType: (valueType || '').toLowerCase(),
                        axisType: scaleOptions.type,
                        chart: chartOptions,
                        dataSourceField: that.option('dataSourceField'),
                        backgroundColor: that._userBackgroundColor,
                        incidentOccured: that._incidentOccured,
                        categories: scaleOptions.categories
                    });
                    checkLogarithmicOptions(chartOptions.valueAxis, seriesDataSource.themeManager.theme().valueAxis.logarithmBase, that._incidentOccured)
                }
                return seriesDataSource
            },
            _calculateSize: function() {
                var $container = this.container,
                    size = this.option('size') || {},
                    result = {
                        width: size.width,
                        height: size.height
                    };
                if ($container) {
                    if (!result.width)
                        result.width = $container.width();
                    if (!result.height)
                        result.height = $container.height()
                }
                this.canvas = result;
                return result
            },
            _createSelectedRangeChangedFunction: function() {
                var that = this;
                return function(selectedRange, blockSelectedRangeChanged) {
                        that.option(SELECTED_RANGE, selectedRange);
                        if (!blockSelectedRangeChanged)
                            that._eventTrigger('selectedRangeChanged', selectedRange)
                    }
            },
            _correctSizeOptions: function(sizeOptions) {
                var scaleOptions = this._scaleOptions,
                    size = this.option('size') || {};
                if (!sizeOptions.height && size.height !== 0)
                    if (scaleOptions.valueType === DATETIME && scaleOptions.marker.visible !== false)
                        sizeOptions.height = 160;
                    else
                        sizeOptions.height = 120;
                if (!sizeOptions.width && size.width !== 0)
                    sizeOptions.width = 400
            },
            _prepareScaleOptions: function(seriesDataSource) {
                var that = this,
                    scaleOptions = $.extend(true, {}, that.option('scale')),
                    incidentOccured = that._incidentOccured,
                    parsedValue = 0,
                    parseUtils = new ParseUtils({incidentOccured: incidentOccured}),
                    valueType = parseUtils.correctValueType((scaleOptions.valueType || '').toLowerCase()),
                    parser,
                    validateStartEndValues = function(field, parser) {
                        var messageToIncidentOccured = field === START_VALUE ? 'start' : 'end';
                        if (_isDefined(scaleOptions[field])) {
                            parsedValue = parser(scaleOptions[field]);
                            if (_isDefined(parsedValue))
                                scaleOptions[field] = parsedValue;
                            else {
                                scaleOptions[field] = undefined;
                                that._incidentOccured("E2202", [messageToIncidentOccured])
                            }
                        }
                    };
                if (seriesDataSource)
                    valueType = seriesDataSource.getCalculatedValueType() || valueType;
                if (!valueType)
                    valueType = calculateValueType(scaleOptions.startValue, scaleOptions.endValue) || 'numeric';
                if (valueType === STRING || scaleOptions.categories) {
                    scaleOptions.type = DISCRETE;
                    valueType = STRING
                }
                scaleOptions.valueType = valueType;
                parser = parseUtils.getParser(valueType, 'scale');
                validateStartEndValues(START_VALUE, parser);
                validateStartEndValues(END_VALUE, parser);
                checkLogarithmicOptions(scaleOptions, defaultRangeSelectorOptions.scale.logarithmBase, that._incidentOccured);
                if (!scaleOptions.type)
                    scaleOptions.type = 'continuous';
                scaleOptions.parser = parser;
                return scaleOptions
            },
            _prepareSliderMarkersOptions: function(screenDelta) {
                var that = this,
                    scaleOptions = that._scaleOptions,
                    sliderMarkerOptions = _extend(true, {}, that.option('sliderMarker')),
                    businessInterval;
                if (!sliderMarkerOptions.format) {
                    if (!that.option('behavior').snapToTicks && _isNumber(scaleOptions.startValue)) {
                        businessInterval = Math.abs(scaleOptions.endValue - scaleOptions.startValue);
                        sliderMarkerOptions.format = 'fixedPoint';
                        sliderMarkerOptions.precision = utils.getSignificantDigitPosition(businessInterval / screenDelta)
                    }
                    if (scaleOptions.valueType === DATETIME)
                        if (!scaleOptions.marker.visible) {
                            if (_isDefined(scaleOptions.startValue) && _isDefined(scaleOptions.endValue))
                                sliderMarkerOptions.format = formatHelper.getDateFormatByTickInterval(scaleOptions.startValue, scaleOptions.endValue, scaleOptions.minorTickInterval !== 0 ? scaleOptions.minorTickInterval : scaleOptions.majorTickInterval)
                        }
                        else
                            sliderMarkerOptions.format = utils.getDateUnitInterval(_isDefined(scaleOptions.minorTickInterval) && scaleOptions.minorTickInterval !== 0 ? scaleOptions.minorTickInterval : scaleOptions.majorTickInterval)
                }
                return sliderMarkerOptions
            },
            _updateScaleOptions: function(seriesDataSource, translatorRange, screenDelta) {
                var argumentTranslator = translatorRange.arg,
                    scaleOptions = this._scaleOptions,
                    min = _isDefined(argumentTranslator.minVisible) ? argumentTranslator.minVisible : argumentTranslator.min,
                    max = _isDefined(argumentTranslator.maxVisible) ? argumentTranslator.maxVisible : argumentTranslator.max,
                    tickIntervalsInfo = updateTickIntervals(scaleOptions, screenDelta, this._incidentOccured, argumentTranslator.stick, min, max),
                    bounds,
                    isEmptyInterval,
                    categoriesInfo = scaleOptions._categoriesInfo;
                if (seriesDataSource && !seriesDataSource.isEmpty()) {
                    bounds = tickIntervalsInfo.bounds;
                    argumentTranslator.addRange(bounds);
                    scaleOptions.startValue = scaleOptions.inverted ? bounds.maxVisible : bounds.minVisible;
                    scaleOptions.endValue = scaleOptions.inverted ? bounds.minVisible : bounds.maxVisible
                }
                if (categoriesInfo) {
                    scaleOptions.startValue = categoriesInfo.start;
                    scaleOptions.endValue = categoriesInfo.end
                }
                isEmptyInterval = _isDate(scaleOptions.startValue) && _isDate(scaleOptions.endValue) && scaleOptions.startValue.getTime() === scaleOptions.endValue.getTime() || scaleOptions.startValue === scaleOptions.endValue;
                scaleOptions.isEmpty = startEndNotDefined(scaleOptions.startValue, scaleOptions.endValue) || isEmptyInterval;
                if (scaleOptions.isEmpty)
                    scaleOptions.startValue = scaleOptions.endValue = undefined;
                else {
                    scaleOptions.minorTickInterval = tickIntervalsInfo.minorTickInterval;
                    scaleOptions.majorTickInterval = tickIntervalsInfo.majorTickInterval;
                    if (scaleOptions.valueType === DATETIME && !_isDefined(scaleOptions.label.format))
                        if (!scaleOptions.marker.visible)
                            scaleOptions.label.format = formatHelper.getDateFormatByTickInterval(scaleOptions.startValue, scaleOptions.endValue, scaleOptions.majorTickInterval);
                        else
                            scaleOptions.label.format = utils.getDateUnitInterval(scaleOptions.majorTickInterval)
                }
            },
            _getStubTicks: function(scaleOptions) {
                scaleOptions.isEmpty = true;
                return ["canvas_position_left", "canvas_position_center", "canvas_position_right"]
            },
            _getTicksInfo: function(screenDelta) {
                var that = this,
                    scaleOptions = that._scaleOptions,
                    translators = that.translators,
                    isEmpty = scaleOptions.isEmpty,
                    businessRange = translators.x.getBusinessRange(),
                    categoriesInfo = scaleOptions._categoriesInfo,
                    tickManagerTypes = {
                        axisType: scaleOptions.type,
                        dataType: scaleOptions.valueType
                    },
                    tickManagerData,
                    startValue = scaleOptions.startValue,
                    endValue = scaleOptions.endValue,
                    tickManagerOptions = {
                        labelOptions: {},
                        minorTickInterval: isEmpty ? 0 : that.option('scale').minorTickInterval,
                        tickInterval: scaleOptions.majorTickInterval,
                        addMinMax: {
                            min: true,
                            max: true
                        },
                        minorTickCount: scaleOptions.minorTickCount,
                        textOptions: {
                            align: 'center',
                            font: scaleOptions.label.font
                        },
                        textFontStyles: core.utils.patchFontOptions(scaleOptions.label.font),
                        incidentOccured: that._incidentOccured,
                        isHorizontal: true,
                        renderText: function(text, x, y, options) {
                            return that.renderer.text(text, x, y, options).append(that.renderer.root)
                        },
                        getText: startEndNotDefined(startValue, endValue) ? function(value) {
                            return value
                        } : function(value) {
                            return rangeSelector.formatValue(value, scaleOptions.label)
                        },
                        translate: function(value) {
                            return translators.x.translate(value)
                        },
                        textSpacing: SCALE_TEXT_SPACING,
                        setTicksAtUnitBeginning: scaleOptions.setTicksAtUnitBeginning,
                        useTicksAutoArrangement: scaleOptions.useTicksAutoArrangement,
                        base: scaleOptions.logarithmBase,
                        stick: true,
                        showMinorTicks: true,
                        withMinorCorrection: true
                    },
                    majorTicks,
                    customBoundaryTicks,
                    decimatedTicks,
                    tickManager,
                    fullTicks;
                tickManagerData = {
                    min: isEmpty ? businessRange.min : startValue,
                    max: isEmpty ? businessRange.max : endValue,
                    screenDelta: screenDelta,
                    customTicks: categoriesInfo && categoriesInfo.categories
                };
                tickManager = core.CoreFactory.createTickManager(tickManagerTypes, tickManagerData, tickManagerOptions);
                majorTicks = !_isDefined(tickManagerData.min) && !_isDefined(tickManagerData.max) && !_isDefined(tickManagerData.customTicks) ? that._getStubTicks() : tickManager.getTicks(true);
                customBoundaryTicks = tickManager.getBoundaryTicks();
                fullTicks = tickManager.getFullTicks();
                if (customBoundaryTicks.length) {
                    if (majorTicks[0].valueOf() === customBoundaryTicks[0].valueOf())
                        majorTicks.splice(0, 1);
                    if (majorTicks[majorTicks.length - 1].valueOf() === customBoundaryTicks[customBoundaryTicks.length - 1].valueOf())
                        majorTicks.pop()
                }
                return {
                        majorTicks: majorTicks,
                        minorTicks: tickManager.getMinorTicks(),
                        majorTickInterval: tickManager.getTickInterval(),
                        fullTicks: fullTicks,
                        customBoundaryTicks: customBoundaryTicks
                    }
            },
            _createRenderer: function() {
                var renderer = this.option('renderer');
                if (renderer)
                    return renderer;
                return core.CoreFactory.createRenderer({
                        pathModified: this.option('pathModified'),
                        rtl: this.option('rtlEnabled')
                    })
            },
            _getContainer: function() {
                return this.element()
            },
            getSelectedRange: function() {
                var that = this;
                var selectedRange = that.rangeContainer.slidersContainer.getSelectedRange();
                return {
                        startValue: selectedRange.startValue,
                        endValue: selectedRange.endValue
                    }
            },
            setSelectedRange: function(selectedRange) {
                var that = this;
                if (that._isUpdating || !selectedRange)
                    return;
                var oldSelectedRange = that.rangeContainer.slidersContainer.getSelectedRange();
                if (oldSelectedRange && oldSelectedRange.startValue === selectedRange.startValue && oldSelectedRange.endValue === selectedRange.endValue)
                    return;
                that.rangeContainer.slidersContainer.setSelectedRange(selectedRange)
            },
            resetSelectedRange: function(blockSelectedRangeChanged) {
                var that = this;
                that.setSelectedRange({
                    startValue: that._scaleOptions.startValue,
                    endValue: that._scaleOptions.endValue,
                    blockSelectedRangeChanged: blockSelectedRangeChanged
                })
            },
            render: function(isResizing) {
                this._render(isResizing);
                return this
            },
            isSizeChanged: function() {
                return this._isSizeChanged()
            }
        }).include(DX.ui.DataHelperMixin))
    })(jQuery, DevExpress);
    /*! Module viz-rangeselector, file rangeContainer.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector;
        rangeSelector.RangeContainer = rangeSelector.BaseVisualElement.inherit(function() {
            var ctor = function(renderer) {
                    this.callBase(renderer);
                    this.slidersContainer = createSlidersContainer(renderer);
                    this.rangeView = createRangeView(renderer);
                    this.scale = createScale(renderer)
                };
            var _applyOptions = function(options) {
                    var that = this,
                        isEmpty = options.scale.isEmpty,
                        viewCanvas = {
                            left: options.canvas.left,
                            top: options.canvas.top,
                            width: options.canvas.width,
                            height: options.canvas.height >= options.scaleLabelsAreaHeight ? options.canvas.height - options.scaleLabelsAreaHeight : 0
                        };
                    that._viewCanvas = viewCanvas;
                    that.slidersContainer.applyOptions({
                        canvas: viewCanvas,
                        translator: options.translators.x,
                        scale: options.scale,
                        selectedRange: options.selectedRange,
                        sliderMarker: options.sliderMarker,
                        sliderHandle: options.sliderHandle,
                        shutter: options.shutter,
                        behavior: options.behavior,
                        selectedRangeChanged: options.selectedRangeChanged,
                        isEmpty: isEmpty
                    });
                    that.rangeView.applyOptions({
                        canvas: viewCanvas,
                        translators: options.translators,
                        background: options.background,
                        chart: options.chart,
                        seriesDataSource: options.seriesDataSource,
                        behavior: options.behavior,
                        isEmpty: isEmpty
                    });
                    that.scale.applyOptions({
                        canvas: options.canvas,
                        translator: options.translators.x,
                        scale: options.scale,
                        hideLabels: isEmpty,
                        scaleLabelsAreaHeight: options.scaleLabelsAreaHeight,
                        setSelectedRange: options.setSelectedRange
                    })
                };
            var createSlidersContainer = function(options) {
                    return rangeSelector.rangeSelectorFactory.createSlidersContainer(options)
                };
            var createScale = function(options) {
                    return rangeSelector.rangeSelectorFactory.createScale(options)
                };
            var createRangeView = function(options) {
                    return rangeSelector.rangeSelectorFactory.createRangeView(options)
                };
            var _createClipRectCanvas = function(canvas, sliderMarkerSpacing) {
                    return {
                            left: canvas.left - sliderMarkerSpacing.left,
                            top: canvas.top - sliderMarkerSpacing.top,
                            width: canvas.width + sliderMarkerSpacing.right + sliderMarkerSpacing.left,
                            height: canvas.height + sliderMarkerSpacing.bottom + sliderMarkerSpacing.top
                        }
                };
            var _draw = function() {
                    var that = this,
                        containerGroup,
                        rangeViewGroup,
                        slidersContainerGroup,
                        scaleGroup,
                        trackersGroup,
                        clipRectCanvas = _createClipRectCanvas(that._options.canvas, that._options.sliderMarkerSpacing),
                        viewCanvas = that._viewCanvas;
                    that._clipRect = that._renderer.clipRect(clipRectCanvas.left, clipRectCanvas.top, clipRectCanvas.width, clipRectCanvas.height);
                    containerGroup = that._renderer.g().attr({
                        'class': 'rangeContainer',
                        clipId: that._clipRect.id
                    }).append(that._renderer.root);
                    that._viewClipRect = that._renderer.clipRect(viewCanvas.left, viewCanvas.top, viewCanvas.width, viewCanvas.height);
                    rangeViewGroup = that._renderer.g().attr({
                        'class': 'view',
                        clipId: that._viewClipRect.id
                    }).append(containerGroup);
                    that.rangeView.redraw(rangeViewGroup);
                    slidersContainerGroup = that._renderer.g().attr({'class': 'slidersContainer'}).append(containerGroup);
                    that.slidersContainer.redraw(slidersContainerGroup);
                    scaleGroup = that._renderer.g().attr({'class': 'scale'}).append(containerGroup);
                    that.scale.redraw(scaleGroup);
                    trackersGroup = that._renderer.g().attr({'class': 'trackers'}).append(containerGroup);
                    that._trackersGroup = trackersGroup;
                    that.slidersContainer.appendTrackers(trackersGroup)
                };
            var _update = function() {
                    var that = this,
                        clipRectCanvas = _createClipRectCanvas(that._options.canvas, that._options.sliderMarkerSpacing),
                        viewCanvas = that._viewCanvas;
                    that._clipRect.attr({
                        x: clipRectCanvas.left,
                        y: clipRectCanvas.top,
                        width: clipRectCanvas.width,
                        height: clipRectCanvas.height
                    });
                    that._viewClipRect.attr({
                        x: viewCanvas.left,
                        y: viewCanvas.top,
                        width: viewCanvas.width,
                        height: viewCanvas.height
                    });
                    that.rangeView.redraw();
                    that.slidersContainer.redraw();
                    that.slidersContainer.appendTrackers(that._trackersGroup);
                    that.scale.redraw()
                };
            var dispose = function() {
                    this.slidersContainer.dispose();
                    this.slidersContainer = null
                };
            var prototypeObject = {
                    createSlidersContainer: createSlidersContainer,
                    createScale: createScale,
                    ctor: ctor,
                    dispose: dispose,
                    _applyOptions: _applyOptions,
                    _draw: _draw,
                    _update: _update
                };
            return prototypeObject
        }())
    })(jQuery, DevExpress);
    /*! Module viz-rangeselector, file scale.js */
    (function($, DX, undefined) {
        var viz = DX.viz,
            rangeSelector = viz.rangeSelector,
            formatHelper = DX.formatHelper,
            utils = DX.utils;
        var SCALE_TEXT_SPACING = 5;
        function calculateRangeByMarkerPosition(posX, markerDatePositions, scaleOptions) {
            var selectedRange = {},
                index,
                position,
                i;
            for (i = 0; i < markerDatePositions.length; i++) {
                position = markerDatePositions[i];
                if (!scaleOptions.inverted) {
                    if (posX >= position.posX)
                        selectedRange.startValue = position.date;
                    else if (!selectedRange.endValue)
                        selectedRange.endValue = position.date
                }
                else if (posX < position.posX)
                    selectedRange.endValue = position.date;
                else if (!selectedRange.startValue)
                    selectedRange.startValue = position.date
            }
            selectedRange.startValue = selectedRange.startValue || scaleOptions.startValue;
            selectedRange.endValue = selectedRange.endValue || scaleOptions.endValue;
            return selectedRange
        }
        function getMarkerDate(date, tickInterval) {
            var markerDate = new Date(date.getTime()),
                month = 0;
            switch (tickInterval) {
                case'quarter':
                    month = formatHelper.getFirstQuarterMonth(date.getMonth());
                case'month':
                    markerDate.setMonth(month);
                case'week':
                case'day':
                    markerDate.setDate(1);
                case'hour':
                    markerDate.setHours(0, 0, 0, 0);
                    break;
                case'millisecond':
                    markerDate.setMilliseconds(0);
                    break;
                case'second':
                    markerDate.setSeconds(0, 0);
                    break;
                case'minute':
                    markerDate.setMinutes(0, 0, 0);
                    break
            }
            return markerDate
        }
        function prepareDatesDifferences(datesDifferences, tickInterval) {
            var deleteDifferent = tickInterval,
                dateUnitInterval,
                i;
            if (deleteDifferent === 'week')
                deleteDifferent = 'day';
            if (deleteDifferent === 'quarter')
                deleteDifferent = 'month';
            if (datesDifferences[deleteDifferent])
                for (i = 0; i < utils.dateUnitIntervals.length; i++) {
                    dateUnitInterval = utils.dateUnitIntervals[i];
                    if (datesDifferences[dateUnitInterval]) {
                        datesDifferences[dateUnitInterval] = false;
                        datesDifferences.count--
                    }
                    if (dateUnitInterval === deleteDifferent)
                        break
                }
        }
        function getLabel(value, options) {
            var formatObject = {
                    value: value,
                    valueText: formatHelper.format(value, options.format, options.precision)
                };
            return String(utils.isFunction(options.customizeText) ? options.customizeText.call(formatObject, formatObject) : formatObject.valueText)
        }
        rangeSelector.Scale = rangeSelector.BaseVisualElement.inherit({
            _setupDateUnitInterval: function(scaleOptions) {
                var key,
                    hasObjectSingleField = function(object) {
                        var fieldsCounter = 0;
                        $.each(object, function() {
                            return ++fieldsCounter < 2
                        });
                        return fieldsCounter === 1
                    },
                    millisecTickInterval,
                    majorTickInterval = scaleOptions.ticksInfo.majorTickInterval,
                    majorTicks = scaleOptions.ticksInfo.majorTicks;
                if (scaleOptions.valueType === 'datetime') {
                    if (utils.isObject(majorTickInterval) && !hasObjectSingleField(majorTickInterval))
                        utils.logger.warn('More than one field is specified within the object assigned to the "tickInterval" option. Assign an object with a single field specified (days, hours or a similar one).');
                    if (majorTicks && majorTicks.autoArrangementStep > 1) {
                        if (utils.isString(majorTickInterval))
                            majorTickInterval = utils.getDateIntervalByString(majorTickInterval);
                        for (key in majorTickInterval)
                            if (majorTickInterval.hasOwnProperty(key)) {
                                majorTickInterval[key] *= majorTicks.autoArrangementStep;
                                millisecTickInterval = utils.convertDateTickIntervalToMilliseconds(majorTickInterval)
                            }
                        majorTickInterval = utils.convertMillisecondsToDateUnits(millisecTickInterval)
                    }
                    this.dateUnitInterval = utils.getDateUnitInterval(majorTickInterval)
                }
            },
            _drawDateMarker: function(date, options) {
                var labelPosX,
                    labelPosY,
                    dateFormated,
                    scaleOptions,
                    textElement;
                if (options.x === null)
                    return;
                scaleOptions = this._options.scale;
                this._renderer.path([options.x, options.y, options.x, options.y + scaleOptions.marker.separatorHeight], "line").attr(this.lineOptions).sharp().append(options.group);
                dateFormated = getLabel(date, options.label);
                labelPosX = options.x + scaleOptions.tick.width + scaleOptions.marker.textLeftIndent;
                labelPosY = options.y + scaleOptions.marker.textTopIndent + this.fontOptions["font-size"];
                this.textOptions.align = 'left';
                textElement = this._renderer.text(dateFormated, labelPosX, labelPosY).attr(this.textOptions).css(this.fontOptions).css(this.textStyles).append(options.group);
                return labelPosX + textElement.getBBox().width
            },
            _drawDateMarkers: function(dates, group) {
                var dateMarker,
                    i,
                    datesDifferences,
                    markerDate,
                    posX,
                    prevMarkerRightX = -1;
                if (this._options.scale.valueType !== 'datetime' || !this.visibleMarkers)
                    return;
                var markerDatePositions = [];
                if (dates.length > 1) {
                    for (i = 1; i < dates.length; i++) {
                        datesDifferences = utils.getDatesDifferences(dates[i - 1], dates[i]);
                        prepareDatesDifferences(datesDifferences, this.dateUnitInterval);
                        if (datesDifferences.count > 0) {
                            markerDate = getMarkerDate(dates[i], this.dateUnitInterval);
                            this.markerDates = this.markerDates || [];
                            this.markerDates.push(markerDate);
                            posX = this.translator.translate(markerDate);
                            if (posX > prevMarkerRightX) {
                                posX !== null && markerDatePositions.push({
                                    date: markerDate,
                                    posX: posX
                                });
                                prevMarkerRightX = this._drawDateMarker(markerDate, {
                                    group: group,
                                    y: this._options.canvas.top + this._options.canvas.height - this.markersAreaHeight + this._options.scale.marker.topIndent,
                                    x: posX,
                                    label: this._getLabelFormatOptions(formatHelper.getDateFormatByDifferences(datesDifferences))
                                })
                            }
                        }
                    }
                    this._initializeMarkersEvents(markerDatePositions, group)
                }
            },
            _getLabelFormatOptions: function(formatString) {
                if (!utils.isDefined(this._options.scale.marker.label.format))
                    return $.extend({}, this._options.scale.marker.label, {format: formatString});
                return this._options.scale.marker.label
            },
            _initializeMarkersEvents: function(markerDatePositions, group) {
                var that = this,
                    markersAreaTop = this._options.canvas.top + this._options.canvas.height - this.markersAreaHeight + this._options.scale.marker.topIndent,
                    markersTracker,
                    svgOffsetLeft,
                    index,
                    posX,
                    selectedRange;
                if (markerDatePositions.length > 0) {
                    markersTracker = that._renderer.rect(that._options.canvas.left, markersAreaTop, that._options.canvas.width, that._options.scale.marker.separatorHeight).attr({
                        fill: 'grey',
                        stroke: 'grey',
                        opacity: 0.0001
                    }).append(group);
                    $(markersTracker.element).on(rangeSelector.events.start, function(e) {
                        svgOffsetLeft = rangeSelector.utils.getRootOffsetLeft(that._renderer);
                        posX = rangeSelector.utils.getEventPageX(e) - svgOffsetLeft;
                        selectedRange = calculateRangeByMarkerPosition(posX, markerDatePositions, that._options.scale);
                        that._options.setSelectedRange(selectedRange)
                    });
                    that._markersTracker = markersTracker
                }
            },
            _drawLabel: function(value, group) {
                var textY = this._options.canvas.top + this._options.canvas.height - this.markersAreaHeight,
                    textElement = this._renderer.text(getLabel(value, this._options.scale.label), this.translator.translate(value), textY).attr(this.textOptions).css(this.fontOptions).css(this.textStyles);
                textElement.append(group);
                this.textElements = this.textElements || [];
                this.textElements.push(textElement)
            },
            _drawTick: function(value, group, directionOffset) {
                var that = this,
                    secondY = that._options.canvas.top + that._options.canvas.height - that.scaleLabelsAreaHeight,
                    posX = that.translator.translate(value, directionOffset),
                    tickElement = that._renderer.path([posX, that._options.canvas.top, posX, secondY], "line").attr(that.lineOptions).sharp().append(group);
                this.tickElements = this.tickElements || [];
                this.tickElements.push(tickElement)
            },
            _redraw: function(group) {
                var that = this,
                    scaleOptions = that._options.scale,
                    ticksGroup = that._renderer.g(),
                    labelsGroup = that._renderer.g().append(group),
                    majorTicks = scaleOptions.ticksInfo.majorTicks,
                    minorTicks = scaleOptions.ticksInfo.minorTicks,
                    customBoundaryTicks = scaleOptions.ticksInfo.customBoundaryTicks,
                    hideLabels = that._options.hideLabels || scaleOptions.isEmpty || !scaleOptions.label.visible,
                    isDiscrete = scaleOptions.type === "discrete",
                    directionOffset = isDiscrete ? -1 : 0,
                    i;
                for (i = 0; i < majorTicks.length; i++) {
                    !hideLabels && that._drawLabel(majorTicks[i], labelsGroup);
                    that._drawTick(majorTicks[i], ticksGroup, directionOffset)
                }
                if (scaleOptions.showMinorTicks || isDiscrete)
                    for (i = 0; i < minorTicks.length; i++)
                        that._drawTick(minorTicks[i], ticksGroup, directionOffset);
                for (i = 0; i < customBoundaryTicks.length; i++)
                    that._drawTick(customBoundaryTicks[i], ticksGroup);
                if (isDiscrete)
                    that._drawTick(scaleOptions._categoriesInfo.end, ticksGroup, 1);
                ticksGroup.append(group);
                that._drawDateMarkers(majorTicks, labelsGroup)
            },
            _applyOptions: function(options) {
                var scaleOptions = options.scale,
                    labelsAreaHeight;
                this.textOptions = {align: 'center'};
                this.textStyles = {'-webkit-user-select': 'none'};
                this.fontOptions = viz.core.utils.patchFontOptions(scaleOptions.label.font);
                this.lineOptions = {
                    "stroke-width": scaleOptions.tick.width,
                    stroke: scaleOptions.tick.color,
                    "stroke-opacity": scaleOptions.tick.opacity,
                    "stroke-linecap": "square"
                };
                this._setupDateUnitInterval(scaleOptions);
                this.visibleMarkers = scaleOptions.marker.visible === undefined ? true : scaleOptions.marker.visible;
                labelsAreaHeight = scaleOptions.label.visible ? scaleOptions.label.topIndent + this.fontOptions["font-size"] : 0;
                this.scaleLabelsAreaHeight = options.scaleLabelsAreaHeight;
                this.markersAreaHeight = this.scaleLabelsAreaHeight - labelsAreaHeight;
                this.translator = options.translator
            },
            _draw: function(group) {
                this._redraw(group)
            },
            _update: function(group) {
                var callBase = this.callBase;
                if (this._markersTracker)
                    $(this._markersTracker.element).off(rangeSelector.events.start, '**');
                this.callBase = callBase;
                this.callBase(group)
            },
            _calculateRangeByMarkerPosition: calculateRangeByMarkerPosition,
            _prepareDatesDifferences: prepareDatesDifferences
        })
    })(jQuery, DevExpress);
    /*! Module viz-rangeselector, file rangeFactory.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            renderers = DX.viz.renderers;
        rangeSelector.rangeSelectorFactory = function() {
            return {
                    createRangeContainer: function(rangeContainerOptions) {
                        return new rangeSelector.RangeContainer(rangeContainerOptions)
                    },
                    createSlidersContainer: function(options) {
                        return new rangeSelector.SlidersContainer(options)
                    },
                    createScale: function(options) {
                        return new rangeSelector.Scale(options)
                    },
                    createSliderMarker: function(options) {
                        return new rangeSelector.SliderMarker(options)
                    },
                    createRangeView: function(options) {
                        return new rangeSelector.RangeView(options)
                    },
                    createThemeManager: function(options) {
                        return new rangeSelector.ThemeManager(options)
                    },
                    createSlider: function(renderer, sliderIndex) {
                        return new rangeSelector.Slider(renderer, sliderIndex)
                    },
                    createSlidersEventsManager: function(renderer, slidersController, processSelectionChanged) {
                        return new rangeSelector.SlidersEventsManager(renderer, slidersController, processSelectionChanged)
                    },
                    createSlidersController: function(sliders) {
                        return new rangeSelector.SlidersController(sliders)
                    }
                }
        }()
    })(jQuery, DevExpress);
    /*! Module viz-rangeselector, file slidersContainer.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            utils = DX.utils,
            msPointerEnabled = window.navigator.msPointerEnabled || window.navigator.pointerEnabled,
            isNumber = utils.isNumber,
            isDate = utils.isDate,
            isString = utils.isString,
            START_VALUE_INDEX = 0,
            END_VALUE_INDEX = 1,
            rangeSelectorUtils = rangeSelector.utils;
        rangeSelector.SlidersContainer = rangeSelector.BaseVisualElement.inherit(function() {
            var prototypeObject = {
                    getController: function() {
                        return this._controller
                    },
                    _drawAreaTracker: function(group) {
                        var that = this,
                            areaTracker,
                            selectedAreaTracker;
                        areaTracker = that._renderer.rect(that._options.canvas.left, that._options.canvas.top, that._options.canvas.width, that._options.canvas.height).attr({
                            fill: 'grey',
                            stroke: 'grey',
                            opacity: 0.0001
                        }).append(group);
                        selectedAreaTracker = that._renderer.rect(that._options.canvas.left, that._options.canvas.top, that._options.canvas.width, that._options.canvas.height).attr({
                            fill: 'grey',
                            stroke: 'grey',
                            opacity: 0.0001
                        }).css({cursor: 'pointer'}).append(group);
                        that._controller.setAreaTrackers(areaTracker, selectedAreaTracker)
                    },
                    dispose: function() {
                        this._eventsManager.dispose();
                        this._eventManager = null
                    },
                    _processSelectionChanged: function(moving, blockSelectedRangeChanged) {
                        var that = this,
                            equalLastSelectedRange = function(selectedRange) {
                                return selectedRange && that._lastSelectedRange.startValue === selectedRange.startValue && that._lastSelectedRange.endValue === selectedRange.endValue
                            },
                            selectedRange = that.getSelectedRange();
                        if ((!moving || (that._options.behavior.callSelectedRangeChanged || '').toLowerCase() === "onmoving") && that._options.selectedRangeChanged && !equalLastSelectedRange(selectedRange)) {
                            that._updateLastSelectedRange(selectedRange);
                            if (utils.isFunction(that._options.selectedRangeChanged))
                                that._options.selectedRangeChanged.call(null, selectedRange, blockSelectedRangeChanged);
                            if (!moving && !equalLastSelectedRange(selectedRange))
                                that.setSelectedRange(selectedRange)
                        }
                    },
                    _updateLastSelectedRange: function(selectedRange) {
                        selectedRange = selectedRange || this._options.selectedRange;
                        this._lastSelectedRange = {
                            startValue: selectedRange.startValue,
                            endValue: selectedRange.endValue
                        }
                    },
                    _createSlider: function(sliderIndex) {
                        return rangeSelector.rangeSelectorFactory.createSlider(this._renderer, sliderIndex)
                    },
                    _createSlidersController: function(sliders) {
                        return rangeSelector.rangeSelectorFactory.createSlidersController(sliders)
                    },
                    _createSlidersEventsManager: function(controller) {
                        var that = this;
                        return rangeSelector.rangeSelectorFactory.createSlidersEventsManager(that._renderer, controller, function(moving) {
                                that._processSelectionChanged(moving)
                            })
                    },
                    ctor: function(renderer) {
                        var that = this,
                            sliders;
                        that.callBase(renderer);
                        sliders = [that._createSlider(START_VALUE_INDEX), that._createSlider(END_VALUE_INDEX)];
                        that._controller = that._createSlidersController(sliders);
                        that._eventsManager = that._createSlidersEventsManager(that._controller);
                        that._lastSelectedRange = {}
                    },
                    getSelectedRange: function() {
                        return this._controller.getSelectedRange()
                    },
                    setSelectedRange: function(selectedRange) {
                        var that = this,
                            scale = that._options.scale,
                            startValue,
                            endValue,
                            currentSelectedRange = that._options.selectedRange,
                            checkTypes = function(valueName, value) {
                                var valueFromScale = scale[valueName];
                                if (isNumber(valueFromScale) && isNumber(value) || isDate(valueFromScale) && isDate(value) || isString(valueFromScale) && isString(value))
                                    currentSelectedRange[valueName] = value
                            };
                        if (selectedRange) {
                            startValue = selectedRange.startValue;
                            endValue = selectedRange.endValue
                        }
                        checkTypes('startValue', startValue);
                        checkTypes('endValue', endValue);
                        currentSelectedRange.startValue = rangeSelectorUtils.truncateSelectedRange(currentSelectedRange.startValue, scale);
                        currentSelectedRange.endValue = rangeSelectorUtils.truncateSelectedRange(currentSelectedRange.endValue, scale);
                        that._controller.applySelectedRange(currentSelectedRange);
                        that._controller.applyPosition();
                        that._processSelectionChanged(false, selectedRange && selectedRange.blockSelectedRangeChanged)
                    },
                    appendTrackers: function(group) {
                        this._controller.appendTrackers(group)
                    },
                    _applyOptions: function(options) {
                        var that = this;
                        that._controller.applyOptions({
                            translator: options.translator,
                            canvas: options.canvas,
                            sliderMarker: options.sliderMarker,
                            sliderHandle: options.sliderHandle,
                            shutter: options.shutter,
                            scale: options.scale,
                            behavior: options.behavior
                        });
                        that._eventsManager.applyOptions({behavior: options.behavior})
                    },
                    _draw: function(group) {
                        var that = this,
                            rootElement;
                        if (msPointerEnabled) {
                            rootElement = that._renderer.root;
                            rootElement && rootElement.css({msTouchAction: "pinch-zoom"})
                        }
                        that._controller.redraw(group);
                        that._drawAreaTracker(group);
                        that._eventsManager.initialize();
                        that._update()
                    },
                    _update: function() {
                        var that = this,
                            isEmpty = that._options.isEmpty;
                        that._eventsManager.setEnabled(!isEmpty);
                        that._controller.applySelectedRange(isEmpty ? {} : that._options.selectedRange);
                        that._controller.applyPosition(that.isDrawn());
                        that._updateLastSelectedRange();
                        that._controller.redraw()
                    }
                };
            return prototypeObject
        }())
    })(jQuery, DevExpress);
    /*! Module viz-rangeselector, file slidersController.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            utils = DX.utils,
            rangeSelectorUtils = rangeSelector.utils,
            _SliderController,
            START_VALUE_INDEX = 0,
            END_VALUE_INDEX = 1,
            DISCRETE = 'discrete';
        _SliderController = rangeSelector.SlidersController = function(sliders) {
            this._sliders = sliders;
            sliders[START_VALUE_INDEX].setAnotherSlider(sliders[END_VALUE_INDEX]);
            sliders[END_VALUE_INDEX].setAnotherSlider(sliders[START_VALUE_INDEX])
        };
        _SliderController.prototype = {
            constructor: _SliderController,
            setAreaTrackers: function(areaTracker, selectedAreaTracker) {
                this._areaTracker = areaTracker;
                this._selectedAreaTracker = selectedAreaTracker
            },
            applyOptions: function(options) {
                var that = this,
                    values = null,
                    startSlider = that.getSlider(START_VALUE_INDEX),
                    endSlider = that.getSlider(END_VALUE_INDEX),
                    scaleOptions = options.scale;
                that._options = options;
                startSlider.applyOptions(options);
                endSlider.applyOptions(options);
                if (options.behavior.snapToTicks && scaleOptions.type !== DISCRETE) {
                    values = scaleOptions.ticksInfo.fullTicks;
                    if (values.length > 1 && values[0] > values[values.length - 1])
                        values = values.reverse()
                }
                startSlider.setAvailableValues(values);
                endSlider.setAvailableValues(values)
            },
            processDocking: function(sliderIndex) {
                var that = this;
                if (sliderIndex !== undefined)
                    that.getSlider(sliderIndex).processDocking();
                else {
                    that.getSlider(START_VALUE_INDEX).processDocking();
                    that.getSlider(END_VALUE_INDEX).processDocking()
                }
                that.setTrackersCursorStyle('default');
                that.applyAreaTrackersPosition()
            },
            getSelectedRangeInterval: function() {
                var that = this;
                return that.getSlider(END_VALUE_INDEX).getPosition() - that.getSlider(START_VALUE_INDEX).getPosition()
            },
            moveSliders: function(postitionDelta, selectedRangeInterval) {
                var that = this,
                    startSlider = that.getSlider(START_VALUE_INDEX),
                    endSlider;
                startSlider.setPosition(startSlider.getPosition() + postitionDelta, false, selectedRangeInterval);
                that.applyPosition(true)
            },
            moveSlider: function(sliderIndex, fastSwap, position, offsetPosition, startOffsetPosition, startOffsetPositionChangedCallback) {
                var that = this,
                    slider = that.getSlider(sliderIndex),
                    anotherSlider = slider.getAnotherSlider(),
                    doSwap;
                if (slider.canSwap())
                    if (sliderIndex === START_VALUE_INDEX ? position > anotherSlider.getPosition() : position < anotherSlider.getPosition()) {
                        doSwap = fastSwap;
                        if (!fastSwap)
                            if (Math.abs(offsetPosition) >= Math.abs(startOffsetPosition) && offsetPosition * startOffsetPosition < 0) {
                                doSwap = true;
                                position += 2 * startOffsetPosition;
                                startOffsetPositionChangedCallback(-startOffsetPosition)
                            }
                        if (doSwap) {
                            that.swapSliders();
                            anotherSlider.applyPosition(true)
                        }
                    }
                slider.setPosition(position, true);
                slider.applyPosition(true);
                that.applyAreaTrackersPosition();
                that.setTrackersCursorStyle('w-resize')
            },
            applySelectedAreaCenterPosition: function(pos) {
                var that = this,
                    startSlider = that.getSlider(START_VALUE_INDEX),
                    slidersContainerHalfWidth = (that.getSlider(END_VALUE_INDEX).getPosition() - startSlider.getPosition()) / 2,
                    selectedRangeInterval = that.getSelectedRangeInterval();
                startSlider.setPosition(pos - slidersContainerHalfWidth, false, selectedRangeInterval);
                that.applyPosition();
                that.processDocking()
            },
            processManualSelection: function(startPosition, endPosition, eventArgs) {
                var that = this,
                    animateSliderIndex,
                    movingSliderIndex,
                    positionRange = [Math.min(startPosition, endPosition), Math.max(startPosition, endPosition)];
                animateSliderIndex = startPosition < endPosition ? START_VALUE_INDEX : END_VALUE_INDEX;
                movingSliderIndex = startPosition < endPosition ? END_VALUE_INDEX : START_VALUE_INDEX;
                that.getSlider(movingSliderIndex).setPosition(positionRange[movingSliderIndex]);
                that.getSlider(animateSliderIndex).setPosition(positionRange[animateSliderIndex]);
                that.getSlider(movingSliderIndex).setPosition(positionRange[movingSliderIndex], true);
                that.getSlider(movingSliderIndex).startEventHandler(eventArgs);
                that.getSlider(animateSliderIndex).processDocking();
                that.getSlider(movingSliderIndex).applyPosition(true)
            },
            applySelectedRange: function(selectedRange) {
                utils.debug.assertParam(selectedRange, 'selectedRange not passed');
                var that = this,
                    scaleoptions = that._options.scale,
                    inverted = scaleoptions.inverted,
                    startSlider = that.getSlider(START_VALUE_INDEX),
                    endSlider = that.getSlider(END_VALUE_INDEX),
                    startValue = selectedRange.startValue,
                    endValue = selectedRange.endValue,
                    categoriesInfo,
                    setValues = function(startValue, endValue, isInverted) {
                        (isInverted ? endSlider : startSlider).setValue(startValue);
                        (isInverted ? startSlider : endSlider).setValue(endValue)
                    };
                if (scaleoptions.type !== DISCRETE)
                    if (!inverted && startValue > endValue || inverted && startValue < endValue)
                        setValues(startValue, endValue, true);
                    else
                        setValues(startValue, endValue);
                else {
                    categoriesInfo = utils.getCategoriesInfo(scaleoptions._categoriesInfo.categories, startValue, endValue);
                    setValues(categoriesInfo.start, categoriesInfo.end, categoriesInfo.inverted ^ scaleoptions.inverted)
                }
            },
            getSelectedRange: function() {
                var that = this;
                return {
                        startValue: that.getSlider(START_VALUE_INDEX).getValue(),
                        endValue: that.getSlider(END_VALUE_INDEX).getValue()
                    }
            },
            swapSliders: function() {
                var that = this;
                that._sliders.reverse();
                that.getSlider(START_VALUE_INDEX).changeLocation();
                that.getSlider(END_VALUE_INDEX).changeLocation()
            },
            applyAreaTrackersPosition: function() {
                var that = this,
                    selectedRange = that.getSelectedRange(),
                    scaleOptions = that._options.scale,
                    startSlider = that.getSlider(START_VALUE_INDEX),
                    width = that.getSlider(END_VALUE_INDEX).getPosition() - startSlider.getPosition(),
                    options = {
                        x: startSlider.getPosition(),
                        width: width < 0 ? 0 : width,
                        y: that._options.canvas.top,
                        height: that._options.canvas.height
                    },
                    style = {cursor: scaleOptions.endValue - scaleOptions.startValue === selectedRange.endValue - selectedRange.startValue ? 'default' : 'pointer'};
                that._selectedAreaTracker.attr(options).css(style);
                that._areaTracker.attr({
                    x: that._options.canvas.left,
                    width: that._options.canvas.width,
                    y: that._options.canvas.top,
                    height: that._options.canvas.height
                })
            },
            applyPosition: function(disableAnimation) {
                var that = this;
                that.getSlider(START_VALUE_INDEX).applyPosition(disableAnimation);
                that.getSlider(END_VALUE_INDEX).applyPosition(disableAnimation);
                that.applyAreaTrackersPosition()
            },
            redraw: function(group) {
                var that = this;
                that.getSlider(START_VALUE_INDEX).redraw(group);
                that.getSlider(END_VALUE_INDEX).redraw(group)
            },
            appendTrackers: function(group) {
                var that = this;
                if (that._areaTracker && that._selectedAreaTracker) {
                    that._areaTracker.append(group);
                    that._selectedAreaTracker.append(group)
                }
                that.getSlider(START_VALUE_INDEX).appendTrackers(group);
                that.getSlider(END_VALUE_INDEX).appendTrackers(group)
            },
            getSlider: function(sliderIndex) {
                return this._sliders[sliderIndex]
            },
            getAreaTracker: function() {
                return this._areaTracker
            },
            getSelectedAreaTracker: function() {
                return this._selectedAreaTracker
            },
            setTrackersCursorStyle: function(style) {
                var that = this;
                that._selectedAreaTracker.css({cursor: style});
                that._areaTracker.css({cursor: style})
            }
        }
    })(jQuery, DevExpress);
    /*! Module viz-rangeselector, file slidersEventsManager.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            utils = DX.utils,
            MIN_MANUAL_SELECTING_WIDTH = 10,
            START_VALUE_INDEX = 0,
            END_VALUE_INDEX = 1,
            addNamespace = DX.ui.events.addNamespace,
            setEvents = function() {
                var win = window;
                win = DX.viz.rangeSelector.mockWindow || window;
                var touchSupport = "ontouchstart" in win,
                    msPointerEnabled = win.navigator.msPointerEnabled,
                    pointerEnabled = win.navigator.pointerEnabled;
                rangeSelector.events = {
                    start: pointerEnabled ? "pointerdown" : msPointerEnabled ? "MSPointerDown" : touchSupport ? "touchstart mousedown" : "mousedown",
                    move: pointerEnabled ? "pointermove" : msPointerEnabled ? "MSPointerMove" : touchSupport ? "touchmove mousemove" : "mousemove",
                    end: pointerEnabled ? "pointerup pointercancel" : msPointerEnabled ? "MSPointerUp MSPointerCancel" : touchSupport ? "touchend mouseup" : "mouseup"
                }
            },
            _SlidersEventManager,
            getEventPageX = rangeSelector.utils.getEventPageX,
            rangeSelectorCount = 0;
        setEvents();
        var isLeftButtonPressed = function(event) {
                var e = event || window.event,
                    originalEvent = e.originalEvent,
                    touches = e.touches,
                    pointerType = originalEvent ? originalEvent.pointerType : false,
                    eventTouches = originalEvent ? originalEvent.touches : false,
                    isIE8LeftClick = e.which === undefined && e.button === 1,
                    isMSPointerLeftClick = originalEvent && pointerType !== undefined && (pointerType === (originalEvent.MSPOINTER_TYPE_TOUCH || 'touch') || pointerType === (originalEvent.MSPOINTER_TYPE_MOUSE || 'mouse') && originalEvent.buttons === 1),
                    isLeftClick = isIE8LeftClick || e.which === 1,
                    isTouches = touches && touches.length > 0 || eventTouches && eventTouches.length > 0;
                return isLeftClick || isMSPointerLeftClick || isTouches
            };
        var isMultiTouches = function(event) {
                var originalEvent = event.originalEvent,
                    touches = event.touches,
                    eventTouches = originalEvent ? originalEvent.touches : false;
                return touches && touches.length > 1 || eventTouches && eventTouches.length > 1 || null
            };
        var isTouchEventArgs = function(e) {
                return e && e.type && e.type.indexOf('touch') === 0
            };
        _SlidersEventManager = rangeSelector.SlidersEventsManager = function(renderer, slidersController, processSelectionChanged) {
            var that = this,
                uniqueNS = that._uniqueNS = 'dx-range-selector_' + rangeSelectorCount++,
                rangeSelectorEvents = rangeSelector.events;
            that._renderer = renderer;
            that._slidersController = slidersController;
            that._processSelectionChanged = processSelectionChanged;
            that._enabled = true;
            that._eventsNames = {
                start: addNamespace(rangeSelectorEvents.start, uniqueNS),
                move: addNamespace(rangeSelectorEvents.move, uniqueNS),
                end: addNamespace(rangeSelectorEvents.end, uniqueNS)
            }
        };
        _SlidersEventManager.prototype = {
            constructor: _SlidersEventManager,
            _getRootOffsetLeft: function() {
                return rangeSelector.utils.getRootOffsetLeft(this._renderer)
            },
            _initializeSliderEvents: function(sliderIndex) {
                var that = this,
                    isTouchEvent,
                    slidersController = that._slidersController,
                    processSelectionChanged = that._processSelectionChanged,
                    slider = slidersController.getSlider(sliderIndex),
                    anotherSlider = slider.getAnotherSlider(),
                    fastSwap,
                    startOffsetPosition,
                    splitterMoving,
                    sliderEndHandler = function(e) {
                        if (splitterMoving) {
                            splitterMoving = false;
                            slidersController.processDocking();
                            processSelectionChanged(false)
                        }
                    },
                    sliderMoveHandler = function(e) {
                        var doSwap,
                            pageX,
                            offsetPosition,
                            svgOffsetLeft = that._getRootOffsetLeft(),
                            position,
                            sliderIndex = slider.getIndex();
                        if (isTouchEvent !== isTouchEventArgs(e))
                            return;
                        if (!isLeftButtonPressed(e, true) && splitterMoving) {
                            splitterMoving = false;
                            slidersController.processDocking();
                            processSelectionChanged(false)
                        }
                        else if (splitterMoving) {
                            if (!isMultiTouches(e)) {
                                this.preventedDefault = true;
                                e.preventDefault()
                            }
                            pageX = getEventPageX(e);
                            position = pageX - startOffsetPosition - svgOffsetLeft;
                            offsetPosition = pageX - slider.getPosition() - svgOffsetLeft;
                            slidersController.moveSlider(sliderIndex, fastSwap, position, offsetPosition, startOffsetPosition, function(newStartOffsetPosition) {
                                startOffsetPosition = newStartOffsetPosition
                            });
                            processSelectionChanged(true)
                        }
                    },
                    eventsNames = that._eventsNames;
                slider.startEventHandler = function(e) {
                    if (!that._enabled || !isLeftButtonPressed(e) || splitterMoving)
                        return;
                    fastSwap = this === slider.getSliderTracker().element;
                    splitterMoving = true;
                    isTouchEvent = isTouchEventArgs(e);
                    startOffsetPosition = getEventPageX(e) - slider.getPosition() - that._getRootOffsetLeft();
                    if (!isMultiTouches(e)) {
                        this.preventedDefault = true;
                        e.stopPropagation();
                        e.preventDefault()
                    }
                };
                slider.on(eventsNames.start, slider.startEventHandler);
                $(document).on(eventsNames.end, sliderEndHandler).on(eventsNames.move, sliderMoveHandler);
                slider.__moveEventHandler = sliderMoveHandler
            },
            _initializeAreaEvents: function() {
                var that = this,
                    isTouchEvent,
                    slidersController = that._slidersController,
                    processSelectionChanged = that._processSelectionChanged,
                    areaTracker = slidersController.getAreaTracker(),
                    unselectedAreaProcessing = false,
                    splitterMoving = false,
                    startPageX,
                    areaEndHandler = function(e) {
                        var pageX;
                        if (unselectedAreaProcessing) {
                            pageX = getEventPageX(e);
                            if (that._options.behavior.moveSelectedRangeByClick && Math.abs(startPageX - pageX) < MIN_MANUAL_SELECTING_WIDTH)
                                slidersController.applySelectedAreaCenterPosition(pageX - that._getRootOffsetLeft());
                            unselectedAreaProcessing = false;
                            processSelectionChanged(false)
                        }
                    },
                    areaMoveHandler = function(e) {
                        var pageX,
                            startPosition,
                            endPosition,
                            svgOffsetLeft = that._getRootOffsetLeft();
                        if (isTouchEvent !== isTouchEventArgs(e))
                            return;
                        if (unselectedAreaProcessing && !isLeftButtonPressed(e)) {
                            unselectedAreaProcessing = false;
                            processSelectionChanged(false)
                        }
                        if (unselectedAreaProcessing) {
                            pageX = getEventPageX(e);
                            if (that._options.behavior.manualRangeSelectionEnabled && Math.abs(startPageX - pageX) >= MIN_MANUAL_SELECTING_WIDTH) {
                                startPosition = startPageX - svgOffsetLeft;
                                endPosition = pageX - svgOffsetLeft;
                                slidersController.processManualSelection(startPosition, endPosition, e);
                                unselectedAreaProcessing = false;
                                processSelectionChanged(true)
                            }
                        }
                    },
                    eventsNames = that._eventsNames;
                $(areaTracker.element).on(eventsNames.start, function(e) {
                    if (!that._enabled || !isLeftButtonPressed(e) || unselectedAreaProcessing)
                        return;
                    unselectedAreaProcessing = true;
                    isTouchEvent = isTouchEventArgs(e);
                    startPageX = getEventPageX(e)
                });
                $(document).on(eventsNames.end, areaEndHandler).on(eventsNames.move, areaMoveHandler);
                that.__areaMoveEventHandler = areaMoveHandler
            },
            _initializeSelectedAreaEvents: function() {
                var that = this,
                    isTouchEvent,
                    slidersController = that._slidersController,
                    processSelectionChanged = that._processSelectionChanged,
                    selectedAreaTracker = slidersController.getSelectedAreaTracker(),
                    selectedAreaMoving = false,
                    offsetStartPosition,
                    selectedRangeInterval,
                    selectedAreaEndHandler = function(e) {
                        if (selectedAreaMoving) {
                            selectedAreaMoving = false;
                            slidersController.processDocking();
                            processSelectionChanged(false)
                        }
                    },
                    selectedAreaMoveHandler = function(e) {
                        var positionDelta,
                            pageX;
                        if (isTouchEvent !== isTouchEventArgs(e))
                            return;
                        if (selectedAreaMoving && !isLeftButtonPressed(e)) {
                            selectedAreaMoving = false;
                            slidersController.processDocking();
                            processSelectionChanged(false)
                        }
                        if (selectedAreaMoving) {
                            if (!isMultiTouches(e)) {
                                this.preventedDefault = true;
                                e.preventDefault()
                            }
                            pageX = getEventPageX(e);
                            positionDelta = pageX - slidersController.getSlider(START_VALUE_INDEX).getPosition() - offsetStartPosition;
                            slidersController.moveSliders(positionDelta, selectedRangeInterval);
                            processSelectionChanged(true)
                        }
                    },
                    eventsNames = that._eventsNames;
                $(selectedAreaTracker.element).on(eventsNames.start, function(e) {
                    if (!that._enabled || !isLeftButtonPressed(e) || selectedAreaMoving)
                        return;
                    selectedAreaMoving = true;
                    isTouchEvent = isTouchEventArgs(e);
                    offsetStartPosition = getEventPageX(e) - slidersController.getSlider(START_VALUE_INDEX).getPosition();
                    selectedRangeInterval = slidersController.getSelectedRangeInterval();
                    if (!isMultiTouches(e)) {
                        this.preventedDefault = true;
                        e.stopPropagation();
                        e.preventDefault()
                    }
                });
                $(document).on(eventsNames.end, selectedAreaEndHandler).on(eventsNames.move, selectedAreaMoveHandler);
                that.__selectedAreaMoveEventHandler = selectedAreaMoveHandler
            },
            applyOptions: function(options) {
                this._options = options
            },
            dispose: function() {
                $(document).off('.' + this._uniqueNS)
            },
            initialize: function() {
                var that = this;
                that._initializeSelectedAreaEvents(that);
                that._initializeAreaEvents();
                that._initializeSliderEvents(START_VALUE_INDEX);
                that._initializeSliderEvents(END_VALUE_INDEX)
            },
            setEnabled: function(enabled) {
                this._enabled = enabled
            }
        };
        rangeSelector.__setEvents = setEvents
    })(jQuery, DevExpress);
    /*! Module viz-rangeselector, file slider.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            utils = DX.utils,
            rangeSelectorUtils = rangeSelector.utils,
            _inArray = $.inArray,
            touchSupport = "ontouchstart" in window,
            msPointerEnabled = window.navigator.msPointerEnabled || window.navigator.pointerEnabled,
            animationOptions = {duration: 250},
            SPLITTER_WIDTH = 8,
            TOUCH_SPLITTER_WIDTH = 20,
            START_VALUE_INDEX = 0,
            END_VALUE_INDEX = 1,
            DISCRETE = 'discrete';
        function checkItemsSpacing(firstSliderPosition, secondSliderPosition, distance) {
            return Math.abs(secondSliderPosition - firstSliderPosition) < distance
        }
        function getValidCategories(categories, curValue, anotherSliderValue, offset) {
            var curValueindex = _inArray(curValue, categories);
            if (curValueindex === 0 || curValueindex === categories.length - 1)
                return anotherSliderValue;
            return categories[curValueindex - offset]
        }
        rangeSelector.Slider = rangeSelector.BaseVisualElement.inherit(function() {
            return {
                    getText: function() {
                        if (this._marker)
                            return this._marker.getText()
                    },
                    getAvailableValues: function() {
                        return this._values
                    },
                    getShutter: function() {
                        return this._shutter
                    },
                    getMarker: function() {
                        return this._marker
                    },
                    _createSlider: function() {
                        var that = this,
                            sliderHandle,
                            sliderGroup,
                            sliderHandleOptions = that._options.sliderHandle;
                        sliderGroup = that._renderer.g().attr({
                            'class': 'slider',
                            translateX: that._options.canvas.left,
                            translateY: that._options.canvas.top
                        });
                        sliderHandle = that._renderer.path([0, 0, 0, that._options.canvas.height], "line").attr({
                            'class': 'dx-range-selector-slider',
                            "stroke-width": sliderHandleOptions.width,
                            stroke: sliderHandleOptions.color,
                            "stroke-opacity": sliderHandleOptions.opacity,
                            "stroke-linecap": "square"
                        }).sharp().append(sliderGroup);
                        sliderGroup.setValid = function(correct) {
                            sliderHandle.attr({stroke: correct ? that._options.sliderHandle.color : that._options.sliderMarker.invalidRangeColor})
                        };
                        sliderGroup.updateHeight = function() {
                            sliderHandle.attr({points: [0, 0, 0, that._options.canvas.height]}).sharp()
                        };
                        sliderGroup.applyOptions = function(options) {
                            sliderHandle.attr(options).sharp()
                        };
                        sliderGroup.__line = sliderHandle;
                        return sliderGroup
                    },
                    _createSliderTracker: function() {
                        var that = this,
                            sliderHandleWidth = that._options.sliderHandle.width,
                            splitterWidth = SPLITTER_WIDTH < sliderHandleWidth ? sliderHandleWidth : SPLITTER_WIDTH,
                            sliderWidth = touchSupport || msPointerEnabled ? TOUCH_SPLITTER_WIDTH : splitterWidth,
                            sliderTracker,
                            sliderTrackerGroup;
                        sliderTrackerGroup = that._renderer.g().attr({
                            'class': 'sliderTracker',
                            translateX: 0,
                            translateY: that._options.canvas.top
                        });
                        sliderTracker = that._renderer.rect(-sliderWidth / 2, 0, sliderWidth, that._options.canvas.height).attr({
                            fill: 'grey',
                            stroke: 'grey',
                            opacity: 0.0001
                        }).css({cursor: 'w-resize'}).append(sliderTrackerGroup);
                        sliderTrackerGroup.updateHeight = function() {
                            sliderTracker.attr({height: that._options.canvas.height})
                        };
                        sliderTrackerGroup.__rect = sliderTracker;
                        return sliderTrackerGroup
                    },
                    _drawSliderTracker: function(group) {
                        var that = this,
                            sliderTracker = that._createSliderTracker();
                        if (sliderTracker) {
                            sliderTracker.append(group);
                            that._sliderTracker = sliderTracker
                        }
                    },
                    _createSliderMarker: function(options) {
                        return rangeSelector.rangeSelectorFactory.createSliderMarker(options)
                    },
                    _setPosition: function(position, correctByMinMaxRange) {
                        var that = this,
                            correctedPosition = that._correctPosition(position),
                            value = that._options.translator.untranslate(correctedPosition, that._getValueDirection());
                        that.setValue(value, correctByMinMaxRange, false);
                        that._position = correctedPosition
                    },
                    _getValueDirection: function() {
                        return this._options.scale.type === DISCRETE ? this.getIndex() === START_VALUE_INDEX ? -1 : 1 : 0
                    },
                    _setPositionForBothSliders: function(startPosition, interval) {
                        var that = this,
                            anotherSlider = that.getAnotherSlider(),
                            startValue,
                            endValue,
                            endPosition,
                            options = that._options,
                            scale = options.scale,
                            canvas = options.canvas,
                            rightBorderCoords = canvas.left + canvas.width,
                            translator = options.translator,
                            valueDirection = that._getValueDirection(),
                            valueDirectionAnotherSlider = anotherSlider._getValueDirection(),
                            getNextValue = function(value, isNegative, reverseValueDirection) {
                                var curValueDirection = !reverseValueDirection ? valueDirection : valueDirectionAnotherSlider,
                                    curAnotherValueDirection = reverseValueDirection ? valueDirection : valueDirectionAnotherSlider;
                                return translator.untranslate(that._correctBounds(utils.addInterval(translator.translate(value, curValueDirection), interval, isNegative)), curAnotherValueDirection)
                            };
                        startPosition = that._correctBounds(startPosition);
                        startValue = translator.untranslate(startPosition, valueDirection);
                        endValue = getNextValue(startValue);
                        endPosition = startPosition + interval;
                        if (endPosition > rightBorderCoords) {
                            endValue = scale.endValue;
                            endPosition = rightBorderCoords;
                            startValue = getNextValue(endValue, true, true);
                            startPosition = that._correctBounds(endPosition - interval)
                        }
                        else
                            endPosition = that._correctBounds(endPosition);
                        if (that._values)
                            if (!scale.inverted ? startValue < that._values[0] : startValue > that._values[that._values.length - 1]) {
                                startValue = that._correctByAvailableValues(startValue, false);
                                endValue = getNextValue(startValue)
                            }
                            else {
                                endValue = that._correctByAvailableValues(endValue, false);
                                startValue = getNextValue(endValue, true)
                            }
                        anotherSlider.setValue(endValue, undefined, false);
                        that.setValue(startValue, undefined, false);
                        that._position = startPosition;
                        anotherSlider._position = endPosition
                    },
                    _correctPosition: function(position) {
                        var that = this,
                            correctedPosition = that._correctInversion(position);
                        correctedPosition = that._correctBounds(correctedPosition);
                        return correctedPosition
                    },
                    _correctInversion: function(position) {
                        var that = this,
                            correctedPosition = position,
                            anotherSliderPosition = that.getAnotherSlider().getPosition(),
                            slidersInverted = that.getIndex() === START_VALUE_INDEX ? position > anotherSliderPosition : position < anotherSliderPosition;
                        if (slidersInverted)
                            correctedPosition = anotherSliderPosition;
                        return correctedPosition
                    },
                    _correctBounds: function(position) {
                        var that = this,
                            correctedPosition = position,
                            canvas = that._options.canvas;
                        if (position < canvas.left)
                            correctedPosition = canvas.left;
                        if (position > canvas.left + canvas.width)
                            correctedPosition = canvas.left + canvas.width;
                        return correctedPosition
                    },
                    _correctValue: function(businessValue, correctByMinMaxRange, skipCorrection) {
                        var that = this,
                            result = that._correctByAvailableValues(businessValue, skipCorrection);
                        if (correctByMinMaxRange)
                            result = that._correctByMinMaxRange(result);
                        if (that._options.scale.type !== DISCRETE)
                            result = that.correctByMinRange(result);
                        return result
                    },
                    _correctByAvailableValues: function(businessValue, skipCorrection) {
                        var values = this._values;
                        if (!skipCorrection && values)
                            return rangeSelectorUtils.findNearValue(values, businessValue);
                        return businessValue
                    },
                    _correctByMinMaxRange: function(businessValue) {
                        var that = this,
                            result = businessValue,
                            scale = that._options.scale,
                            values = that._values,
                            sliderIndex = that.getIndex(),
                            anotherSlider = that.getAnotherSlider(),
                            anotherBusinessValue = anotherSlider.getValue(),
                            isValid = true,
                            minValue,
                            maxValue,
                            maxRange = scale.maxRange,
                            minRange = scale.minRange,
                            categoriesInfo;
                        if (scale.type === DISCRETE) {
                            categoriesInfo = scale._categoriesInfo;
                            if (checkItemsSpacing(that.getPosition(), anotherSlider.getPosition(), that._options.translator.getInterval() / 2)) {
                                isValid = false;
                                result = getValidCategories(categoriesInfo.categories, businessValue, anotherSlider.getValue(), sliderIndex === START_VALUE_INDEX ? 1 : -1)
                            }
                        }
                        else {
                            if (!scale.inverted && sliderIndex === START_VALUE_INDEX || scale.inverted && sliderIndex === END_VALUE_INDEX) {
                                if (maxRange)
                                    minValue = that._addInterval(anotherBusinessValue, maxRange, true);
                                if (minRange)
                                    maxValue = that._addInterval(anotherBusinessValue, minRange, true)
                            }
                            else {
                                if (maxRange)
                                    maxValue = that._addInterval(anotherBusinessValue, maxRange);
                                if (minRange)
                                    minValue = that._addInterval(anotherBusinessValue, minRange)
                            }
                            if (maxValue !== undefined && result > maxValue) {
                                result = values ? rangeSelectorUtils.findLessOrEqualValue(values, maxValue) : maxValue;
                                isValid = false
                            }
                            else if (minValue !== undefined && result < minValue) {
                                result = values ? rangeSelectorUtils.findGreaterOrEqualValue(values, minValue) : minValue;
                                isValid = false
                            }
                        }
                        that._setValid(isValid);
                        return result
                    },
                    _addInterval: function(value, interval, isNegative) {
                        var result,
                            type = this._options.scale.type,
                            base = type === "logarithmic" && this._options.scale.logarithmBase,
                            power;
                        if (base) {
                            power = utils.addInterval(utils.getLog(value, base), interval, isNegative);
                            result = Math.pow(base, power)
                        }
                        else
                            result = utils.addInterval(value, interval, isNegative);
                        return result
                    },
                    correctByMinRange: function(businessValue) {
                        var that = this,
                            values = that._values,
                            startValue,
                            endValue,
                            isValid = true,
                            scale = that._options.scale,
                            result = businessValue;
                        if (scale.minRange)
                            if (that.getIndex() === END_VALUE_INDEX) {
                                startValue = that._addInterval(scale.startValue, scale.minRange, scale.inverted);
                                if (!scale.inverted && result < startValue || scale.inverted && result > startValue)
                                    result = startValue
                            }
                            else if (that.getIndex() === START_VALUE_INDEX) {
                                endValue = that._addInterval(scale.endValue, scale.minRange, !scale.inverted);
                                if (!scale.inverted && result > endValue || scale.inverted && result < endValue)
                                    result = endValue
                            }
                        return result
                    },
                    _applySliderPosition: function(position, disableAnimation) {
                        var that = this,
                            isAnimation = that._options.behavior.animationEnabled && !disableAnimation,
                            top = that._options.canvas.top,
                            slider = that._slider;
                        if (isAnimation || slider.inAnimation) {
                            slider.inAnimation = true;
                            slider.animate({
                                translateX: position,
                                translateY: top
                            }, isAnimation ? animationOptions : {duration: 0}, function() {
                                slider.inAnimation = false
                            });
                            that._sliderTracker.animate({
                                translateX: position,
                                translateY: top
                            }, isAnimation ? animationOptions : {duration: 0})
                        }
                        else {
                            that._slider.attr({
                                translateX: position,
                                translateY: top
                            });
                            that._sliderTracker.attr({
                                translateX: position,
                                translateY: top
                            })
                        }
                        that._sliderTracker.updateHeight();
                        that._slider.updateHeight()
                    },
                    _applyShutterPosition: function(position, disableAnimation) {
                        var that = this,
                            shutterSettings,
                            shutter = that._shutter,
                            isAnimation = that._options.behavior.animationEnabled && !disableAnimation,
                            sliderIndex = that.getIndex();
                        if (sliderIndex == START_VALUE_INDEX)
                            shutterSettings = {
                                x: that._options.canvas.left,
                                y: that._options.canvas.top,
                                width: position - that._options.canvas.left,
                                height: that._options.canvas.height
                            };
                        else if (sliderIndex == END_VALUE_INDEX)
                            shutterSettings = {
                                x: position + 1,
                                y: that._options.canvas.top,
                                width: that._options.canvas.left + that._options.canvas.width - position,
                                height: that._options.canvas.height
                            };
                        if (shutterSettings)
                            if (isAnimation || shutter.inAnimation) {
                                shutter.inAnimation = true;
                                shutter.animate(shutterSettings, isAnimation ? animationOptions : {duration: 0}, function() {
                                    shutter.inAnimation = false
                                })
                            }
                            else
                                shutter.attr(shutterSettings)
                    },
                    _setValid: function(isValid) {
                        var that = this;
                        if (that._marker)
                            that._marker.setValid(isValid);
                        that._slider.setValid(isValid)
                    },
                    _setText: function(text) {
                        var that = this;
                        if (that._marker)
                            that._marker.setText(text)
                    },
                    _update: function() {
                        var that = this,
                            options = that._options,
                            shutterOptions = options.shutter,
                            sliderHandleOptions = options.sliderHandle;
                        that._marker && that._marker.applyOptions(options.sliderMarker);
                        that._shutter && that._shutter.attr({
                            fill: shutterOptions.color,
                            "fill-opacity": shutterOptions.opacity
                        });
                        that._slider && that._slider.applyOptions({
                            "stroke-width": sliderHandleOptions.width,
                            stroke: sliderHandleOptions.color,
                            "stroke-opacity": sliderHandleOptions.opacity
                        })
                    },
                    _draw: function(group) {
                        var that = this,
                            slider,
                            marker,
                            sliderAreaGroup,
                            shutter,
                            startPos,
                            startWidth,
                            index = that.getIndex();
                        sliderAreaGroup = that._renderer.g().attr({'class': 'sliderArea'}).append(group);
                        if (index === START_VALUE_INDEX)
                            shutter = that._renderer.rect(that._options.canvas.left, that._options.canvas.top, 0, that._options.canvas.height);
                        else if (index === END_VALUE_INDEX)
                            shutter = that._renderer.rect(that._options.canvas.left, that._options.canvas.top, that._options.canvas.width, that._options.canvas.height);
                        if (shutter) {
                            shutter.append(sliderAreaGroup);
                            slider = that._createSlider();
                            if (slider)
                                slider.append(sliderAreaGroup);
                            if (that._options.sliderMarker.visible) {
                                marker = that._createSliderMarker({
                                    renderer: that._renderer,
                                    isLeftPointer: index === END_VALUE_INDEX,
                                    sliderMarkerOptions: that._options.sliderMarker
                                });
                                marker.draw(slider)
                            }
                            that._shutter = shutter;
                            that._slider = slider;
                            that._marker = marker
                        }
                        that._drawSliderTracker(group)
                    },
                    _applyOptions: function(options) {
                        this._lastPosition = null
                    },
                    ctor: function(renderer, index) {
                        var that = this;
                        that.callBase(renderer);
                        that._index = index
                    },
                    getIndex: function() {
                        return this._index
                    },
                    setAvailableValues: function(values) {
                        this._values = values
                    },
                    setAnotherSlider: function(slider) {
                        this._anotherSlider = slider
                    },
                    getAnotherSlider: function() {
                        return this._anotherSlider
                    },
                    appendTrackers: function(group) {
                        var that = this;
                        if (that._sliderTracker)
                            that._sliderTracker.append(group)
                    },
                    getSliderTracker: function() {
                        return this._sliderTracker
                    },
                    changeLocation: function() {
                        var that = this;
                        if (that._marker)
                            that._marker.changeLocation();
                        that._index = that._index === START_VALUE_INDEX ? END_VALUE_INDEX : START_VALUE_INDEX;
                        if (that._options.scale.type === DISCRETE)
                            that.setPosition(that._position);
                        that._lastPosition = null
                    },
                    setPosition: function(position, correctByMinMaxRange, selectedRangeInterval) {
                        var that = this,
                            slider;
                        if (selectedRangeInterval !== undefined) {
                            slider = that.getIndex() === START_VALUE_INDEX ? that : that.getAnotherSlider();
                            slider._setPositionForBothSliders(position, selectedRangeInterval)
                        }
                        else
                            that._setPosition(position, correctByMinMaxRange)
                    },
                    getPosition: function() {
                        return this._position
                    },
                    setValue: function(value, correctByMinMaxRange, skipCorrection) {
                        var that = this,
                            options = that._options,
                            canvas = options.canvas;
                        if (value === undefined) {
                            that._value = undefined;
                            that._valuePosition = that._position = that.getIndex() === START_VALUE_INDEX ? canvas.left : canvas.left + canvas.width;
                            that._setText(rangeSelector.consts.emptySliderMarkerText)
                        }
                        else {
                            that._value = that._correctValue(value, correctByMinMaxRange, utils.isDefined(skipCorrection) ? !!skipCorrection : true);
                            that._valuePosition = that._position = options.translator.translate(that._value, that._getValueDirection());
                            that._setText(rangeSelector.formatValue(that._value, options.sliderMarker))
                        }
                    },
                    getValue: function() {
                        return this._value
                    },
                    canSwap: function() {
                        var that = this,
                            scale = that._options.scale,
                            startValue,
                            endValue,
                            anotherSliderValue;
                        if (that._options.behavior.allowSlidersSwap) {
                            if (scale.minRange) {
                                anotherSliderValue = that.getAnotherSlider().getValue();
                                if (that.getIndex() === START_VALUE_INDEX) {
                                    endValue = utils.addInterval(scale.endValue, scale.minRange, !scale.inverted);
                                    if (!scale.inverted && anotherSliderValue > endValue || scale.inverted && anotherSliderValue < endValue)
                                        return false
                                }
                                else {
                                    startValue = utils.addInterval(scale.startValue, scale.minRange, scale.inverted);
                                    if (!scale.inverted && anotherSliderValue < startValue || scale.inverted && anotherSliderValue > startValue)
                                        return false
                                }
                            }
                            return true
                        }
                        return false
                    },
                    processDocking: function() {
                        var that = this;
                        that._position = that._valuePosition;
                        that.applyPosition(false);
                        that._setValid(true)
                    },
                    applyPosition: function(disableAnimation) {
                        var that = this,
                            position = that.getPosition();
                        if (that._lastPosition !== position) {
                            that._applySliderPosition(position, disableAnimation);
                            that._applyShutterPosition(position, disableAnimation);
                            that._lastPosition = position
                        }
                    },
                    on: function(event, handler) {
                        var that = this,
                            tracker = that._marker && that._marker.getTracker();
                        that._sliderTracker && $(that._sliderTracker.element).on(event, handler);
                        tracker && $(tracker.element).on(event, handler)
                    }
                }
        }())
    })(jQuery, DevExpress);
    /*! Module viz-rangeselector, file sliderMarker.js */
    (function($, DX, undefined) {
        var viz = DX.viz,
            core = viz.core,
            rangeSelector = viz.rangeSelector,
            _SliderMarker;
        _SliderMarker = rangeSelector.SliderMarker = function(options) {
            var that = this;
            that._renderer = options.renderer;
            that._text = options.text;
            that._isLeftPointer = options.isLeftPointer;
            that._options = $.extend(true, {}, options.sliderMarkerOptions);
            that._options.textFontStyles = core.utils.patchFontOptions(that._options.font);
            that._isValid = true;
            initializeAreaPoints(that, {
                width: 10,
                height: 10
            })
        };
        var applyOptions = function(options) {
                this._options = $.extend(true, {}, options);
                this._options.textFontStyles = core.utils.patchFontOptions(this._options.font);
                this.update()
            };
        var getRectSize = function(that, textSize) {
                return {
                        width: Math.round(2 * that._options.padding + textSize.width),
                        height: Math.round(2 * that._options.padding + textSize.height * rangeSelector.consts.fontHeightRatio)
                    }
            };
        var initializeAreaPoints = function(that, textSize) {
                var rectSize = getRectSize(that, textSize);
                if (that._isLeftPointer)
                    that._points = [0, 0, rectSize.width, 0, rectSize.width, rectSize.height, that._options.pointerSize, rectSize.height, 0, rectSize.height + that._options.pointerSize];
                else
                    that._points = [0, 0, rectSize.width, 0, rectSize.width, rectSize.height + that._options.pointerSize, rectSize.width - that._options.pointerSize, rectSize.height, 0, rectSize.height]
            };
        var getPointerPosition = function(that, textSize) {
                var rectSize = getRectSize(that, textSize);
                if (that._isLeftPointer)
                    return {
                            x: 0,
                            y: rectSize.height + that._options.pointerSize
                        };
                else
                    return {
                            x: rectSize.width - 1,
                            y: rectSize.height + that._options.pointerSize
                        }
            };
        var draw = function(group) {
                var that = this;
                var padding = that._options.padding;
                that._sliderMarkerGroup = that._renderer.g().attr({'class': 'sliderMarker'}).append(group);
                that._area = that._renderer.path(that.points, "area").attr({fill: that._options.color}).append(that._sliderMarkerGroup);
                that._label = that._renderer.text(that._text, padding, padding).attr({align: 'left'}).css($.extend({'-webkit-user-select': 'none'}, that._options.textFontStyles)).append(that._sliderMarkerGroup);
                that._tracker = that._renderer.rect(0, 0, 2 * padding, 2 * padding + that._options.pointerSize).attr({
                    fill: 'grey',
                    stroke: 'grey',
                    opacity: 0.0001
                }).css({cursor: 'pointer'}).append(that._sliderMarkerGroup);
                that._drawn = true;
                that.update()
            };
        var getTextSize = function(that) {
                var textSize = that._label.getBBox();
                if (!that._textHeight && isFinite(textSize.height))
                    that._textHeight = textSize.height;
                return {
                        width: textSize.width,
                        height: that._textHeight
                    }
            };
        var update = function(stop) {
                var that = this,
                    textSize,
                    rectSize,
                    pointerPosition;
                that._interval && clearInterval(that._interval);
                delete that._interval;
                if (!that._drawn)
                    return;
                that._label.attr({text: that._text || ""});
                textSize = getTextSize(that);
                if (!stop) {
                    that._textSize = that._textSize || textSize;
                    that._textSize = textSize.width > that._textSize.width || textSize.height > that._textSize.height ? textSize : that._textSize;
                    textSize = that._textSize;
                    that._interval = setInterval(function() {
                        update.call(that, true)
                    }, 75)
                }
                else {
                    delete that._textSize;
                    that._textSize = textSize
                }
                rectSize = getRectSize(that, textSize);
                pointerPosition = getPointerPosition(that, textSize);
                that._sliderMarkerGroup.attr({
                    translateX: -pointerPosition.x,
                    translateY: -pointerPosition.y
                });
                initializeAreaPoints(that, textSize);
                that._area.attr({
                    points: that._points,
                    fill: that._isValid ? that._options.color : that._options.invalidRangeColor
                });
                that._tracker.attr({
                    width: rectSize.width,
                    height: rectSize.height + that._options.pointerSize
                });
                that._label.attr({
                    x: that._options.padding,
                    y: rectSize.height - that._options.padding
                })
            };
        var getText = function() {
                var that = this;
                return that._text
            };
        var setText = function(value) {
                var that = this;
                if (that._text !== value) {
                    that._text = value;
                    that.update()
                }
            };
        var setValid = function(isValid) {
                var that = this;
                that._isValid = isValid;
                that.update()
            };
        var changeLocation = function() {
                var that = this;
                that._isLeftPointer = !that._isLeftPointer;
                that.update()
            };
        var getTracker = function() {
                return this._tracker
            };
        _SliderMarker.prototype = {
            constructor: _SliderMarker,
            draw: draw,
            update: update,
            getText: getText,
            setText: setText,
            changeLocation: changeLocation,
            applyOptions: applyOptions,
            getTracker: getTracker,
            setValid: setValid
        }
    })(jQuery, DevExpress);
    /*! Module viz-rangeselector, file rangeView.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector;
        rangeSelector.RangeView = rangeSelector.BaseVisualElement.inherit(function() {
            return {_draw: function(group) {
                        var that = this,
                            viewRect,
                            viewImage,
                            backgroundColor,
                            series,
                            i,
                            showChart,
                            canvas,
                            options = that._options,
                            seriesOptions,
                            isEmpty = options.isEmpty,
                            renderer = that._renderer;
                        showChart = options.seriesDataSource && options.seriesDataSource.isShowChart() && !isEmpty;
                        canvas = options.canvas;
                        if (showChart)
                            backgroundColor = options.seriesDataSource.getBackgroundColor();
                        else if (!isEmpty && options.background.visible)
                            backgroundColor = options.background.color;
                        if (options.background.visible && backgroundColor)
                            viewRect = renderer.rect(canvas.left, canvas.top, canvas.width + 1, canvas.height).attr({
                                fill: backgroundColor,
                                'class': 'dx-range-selector-background'
                            }).append(group);
                        if (options.background.visible && options.background.image && options.background.image.url)
                            viewImage = renderer.image(canvas.left, canvas.top, canvas.width + 1, canvas.height, options.background.image.url, options.background.image.location).append(group);
                        if (showChart) {
                            series = options.seriesDataSource.getSeries();
                            options.seriesDataSource.adjustSeriesDimensions(options.translators, options.chart.useAggregation);
                            for (i = 0; i < series.length; i++) {
                                series[i]._extGroups.seriesGroup = group;
                                series[i]._extGroups.labelsGroup = group;
                                series[i].draw(options.translators, options.behavior && options.behavior.animationEnabled && renderer.animationEnabled())
                            }
                        }
                    }}
        }())
    })(jQuery, DevExpress);
    /*! Module viz-rangeselector, file seriesDataSource.js */
    (function($, DX, undefined) {
        var rangeSelector = DX.viz.rangeSelector,
            charts = DX.viz.charts,
            core = DX.viz.core,
            coreFactory = core.CoreFactory,
            utils = DX.utils,
            _SeriesDatasource;
        var createThemeManager = function(chartOptions) {
                return charts.factory.createThemeManager(chartOptions, 'rangeSelector.chart')
            };
        var isArrayOfSimpleTypes = function(data) {
                return $.isArray(data) && data.length > 0 && (utils.isNumber(data[0]) || utils.isDate(data[0]))
            };
        var convertToArrayOfObjects = function(data) {
                return $.map(data, function(item, i) {
                        return {
                                arg: item,
                                val: i
                            }
                    })
            };
        var processSeriesFamilies = function(series, equalBarWidth, minBubbleSize, maxBubbleSize) {
                var families = [],
                    types = [];
                $.each(series, function(i, item) {
                    if ($.inArray(item.type, types) === -1)
                        types.push(item.type)
                });
                $.each(types, function(_, type) {
                    var family = new coreFactory.createSeriesFamily({
                            type: type,
                            equalBarWidth: equalBarWidth,
                            minBubbleSize: minBubbleSize,
                            maxBubbleSize: maxBubbleSize
                        });
                    family.add(series);
                    family.adjustSeriesValues();
                    families.push(family)
                });
                return families
            };
        var isStickType = function(type) {
                var nonStickTypes = ["bar", "candlestick", "stock", "bubble"],
                    stickType = true;
                type = type.toLowerCase();
                $.each(nonStickTypes, function(_, item) {
                    if (type.indexOf(item) !== -1) {
                        stickType = false;
                        return false
                    }
                });
                return stickType
            };
        _SeriesDatasource = rangeSelector.SeriesDataSource = function(options) {
            var that = this,
                templatedSeries,
                seriesTemplate,
                themeManager = that.themeManager = createThemeManager(options.chart),
                topIndent = themeManager.getOptions('topIndent'),
                bottomIndent = themeManager.getOptions('bottomIndent');
            that._indent = {
                top: topIndent >= 0 && topIndent < 1 ? topIndent : 0,
                bottom: bottomIndent >= 0 && bottomIndent < 1 ? bottomIndent : 0
            };
            that._valueAxis = themeManager.getOptions('valueAxisRangeSelector') || {};
            that._hideChart = false;
            seriesTemplate = themeManager.getOptions('seriesTemplate');
            if (options.dataSource && seriesTemplate)
                templatedSeries = utils.processSeriesTemplate(seriesTemplate, options.dataSource);
            that._series = that._calculateSeries(options, templatedSeries);
            that._seriesFamilies = processSeriesFamilies(that._series, themeManager.getOptions('equalBarWidth'), themeManager.getOptions('minBubbleSize'), themeManager.getOptions('maxBubbleSize'))
        };
        _SeriesDatasource.prototype = {
            constructor: _SeriesDatasource,
            _calculateSeries: function(options, templatedSeries) {
                var that = this,
                    series = [],
                    particularSeriesOptions,
                    seriesTheme,
                    data,
                    parsedData,
                    chartThemeManager = that.themeManager,
                    hasSeriesTemplate = !!chartThemeManager.getOptions('seriesTemplate'),
                    allSeriesOptions = hasSeriesTemplate ? templatedSeries : options.chart.series,
                    seriesValueType = options.chart.valueAxis && options.chart.valueAxis.valueType,
                    dataSourceField,
                    i,
                    newSeries,
                    particularSeries;
                that.teamplateData = [];
                if (options.dataSource && !allSeriesOptions) {
                    if (isArrayOfSimpleTypes(options.dataSource))
                        options.dataSource = convertToArrayOfObjects(options.dataSource);
                    dataSourceField = options.dataSourceField || 'arg';
                    allSeriesOptions = {
                        argumentField: dataSourceField,
                        valueField: dataSourceField
                    };
                    that._hideChart = true
                }
                allSeriesOptions = $.isArray(allSeriesOptions) ? allSeriesOptions : allSeriesOptions ? [allSeriesOptions] : [];
                that._backgroundColor = options.backgroundColor !== undefined ? options.backgroundColor : chartThemeManager.getOptions("backgroundColor");
                for (i = 0; i < allSeriesOptions.length; i++) {
                    particularSeriesOptions = $.extend(true, {
                        argumentType: options.valueType,
                        argumentAxisType: options.axisType,
                        valueType: dataSourceField ? options.valueType : seriesValueType,
                        incidentOccured: options.incidentOccured
                    }, allSeriesOptions[i]);
                    particularSeriesOptions.rotated = false;
                    particularSeriesOptions.argumentCategories = options.categories;
                    data = particularSeriesOptions.data || options.dataSource;
                    seriesTheme = chartThemeManager.getOptions("series", particularSeriesOptions);
                    seriesTheme.argumentField = seriesTheme.argumentField || options.dataSourceField;
                    if (data && data.length > 0) {
                        newSeries = coreFactory.createSeries({renderer: options.renderer}, seriesTheme);
                        series.push(newSeries)
                    }
                    if (hasSeriesTemplate) {
                        $.each(data, function(_, data) {
                            $.each(newSeries.getTeamplatedFields(), function(_, field) {
                                data[field.teamplateField] = data[field.originalField]
                            });
                            that.teamplateData.push(data)
                        });
                        newSeries.updateTeamplateFieldNames()
                    }
                }
                data = hasSeriesTemplate ? that.teamplateData : data;
                that._dataValidator = charts.factory.createDataValidator(data, [series], options.incidentOccured, chartThemeManager.getOptions("dataPrepareSettings"));
                parsedData = that._dataValidator.validate();
                for (i = 0; i < series.length; i++) {
                    particularSeries = series[i];
                    particularSeries.updateData(parsedData)
                }
                return series
            },
            adjustSeriesDimensions: function(translators, useAggregation) {
                var that = this;
                if (useAggregation)
                    $.each(that._series || [], function(_, s) {
                        s.resamplePoints(translators)
                    });
                $.each(that._seriesFamilies, function() {
                    this.adjustSeriesDimensions({
                        arg: translators.x,
                        val: translators.y
                    })
                })
            },
            getBoundRange: function() {
                var that = this,
                    rangeData,
                    valueAxisMin = that._valueAxis.min,
                    valueAxisMax = that._valueAxis.max,
                    valRange = new core.Range({
                        isValueRange: true,
                        min: valueAxisMin,
                        minVisible: valueAxisMin,
                        max: valueAxisMax,
                        maxVisible: valueAxisMax,
                        axisType: that._valueAxis.type,
                        base: that._valueAxis.logarithmBase
                    }),
                    argRange = new core.Range({}),
                    rangeYSize,
                    rangeVisibleSizeY,
                    i,
                    minIndent,
                    maxIndent;
                $.each(that._series, function(_, series) {
                    rangeData = series.getRangeData();
                    valRange.addRange(rangeData.val);
                    argRange.addRange(rangeData.arg);
                    if (!isStickType(series.type))
                        argRange.addRange({stick: false})
                });
                if (valRange.isDefined() && argRange.isDefined()) {
                    minIndent = that._valueAxis.inverted ? that._indent.top : that._indent.bottom;
                    maxIndent = that._valueAxis.inverted ? that._indent.bottom : that._indent.top;
                    rangeYSize = valRange.max - valRange.min;
                    rangeVisibleSizeY = ($.isNumeric(valRange.maxVisible) ? valRange.maxVisible : valRange.max) - ($.isNumeric(valRange.minVisible) ? valRange.minVisible : valRange.min);
                    if (utils.isDate(valRange.min))
                        valRange.min = new Date(valRange.min.valueOf() - rangeYSize * minIndent);
                    else
                        valRange.min -= rangeYSize * minIndent;
                    if (utils.isDate(valRange.max))
                        valRange.max = new Date(valRange.max.valueOf() + rangeYSize * maxIndent);
                    else
                        valRange.max += rangeYSize * maxIndent;
                    if ($.isNumeric(rangeVisibleSizeY)) {
                        valRange.maxVisible = valRange.maxVisible ? valRange.maxVisible + rangeVisibleSizeY * maxIndent : undefined;
                        valRange.minVisible = valRange.minVisible ? valRange.minVisible - rangeVisibleSizeY * minIndent : undefined
                    }
                    valRange.invert = that._valueAxis.inverted
                }
                return {
                        arg: argRange,
                        val: valRange
                    }
            },
            getSeries: function() {
                var that = this;
                return that._series
            },
            getBackgroundColor: function() {
                var that = this;
                return that._backgroundColor
            },
            isEmpty: function() {
                var that = this;
                return that.getSeries().length === 0
            },
            isShowChart: function() {
                var that = this;
                return !that.isEmpty() && !that._hideChart
            },
            getCalculatedValueType: function() {
                var that = this,
                    result;
                if (that._series.length)
                    result = that._series[0].argumentType;
                return result
            }
        }
    })(jQuery, DevExpress);
    /*! Module viz-rangeselector, file themeManager.js */
    (function($, DX, undefined) {
        DX.viz.rangeSelector = DX.viz.rangeSelector;
        DX.viz.rangeSelector.ThemeManager = DX.viz.core.BaseThemeManager.inherit({
            _themeSection: 'rangeSelector',
            _fontFields: ['scale.label.font', 'sliderMarker.font', 'loadingIndicator.font'],
            ctor: function(userTheme) {
                this.setTheme(userTheme)
            },
            applyRangeSelectorTheme: function(userOptions) {
                var that = this,
                    chart = userOptions.chart,
                    dataSource = userOptions.dataSource,
                    result;
                delete userOptions.dataSource;
                delete userOptions.chart;
                result = $.extend(true, {}, that._theme, userOptions);
                userOptions.dataSource = result.dataSource = dataSource;
                if (chart)
                    userOptions.chart = result.chart = chart;
                return result
            },
            setBackgroundColor: function(containerBackgroundColor) {
                var theme = this._theme;
                if (containerBackgroundColor)
                    theme.containerBackgroundColor = containerBackgroundColor;
                theme.shutter.color = theme.shutter.color || theme.containerBackgroundColor
            }
        })
    })(jQuery, DevExpress);
    DevExpress.MOD_VIZ_RANGESELECTOR = true
}
if (!DevExpress.MOD_VIZ_VECTORMAP) {
    if (!DevExpress.MOD_VIZ_CORE)
        throw Error('Required module is not referenced: viz-core');
    /*! Module viz-vectormap, file map.js */
    (function(DX, $, undefined) {
        DX.viz.map = {};
        var _Number = window.Number,
            _isFunction = DX.utils.isFunction,
            _getRootOffset = DX.utils.getRootOffset,
            _parseBool = DX.viz.core.utils.parseBool;
        var DEFAULT_WIDTH = 800,
            DEFAULT_HEIGHT = 400;
        var _extend = $.extend;
        var nextDataKey = 1;
        function generateDataKey() {
            return 'vectormap-data-' + nextDataKey++
        }
        var Map = DX.viz.core.BaseWidget.inherit({
                _eventsMap: _extend({}, DX.viz.core.BaseWidget.prototype._eventsMap, {
                    onClick: {
                        name: 'click',
                        deprecated: 'click',
                        deprecatedContext: function(arg) {
                            return arg.component
                        },
                        deprecatedArgs: function(arg) {
                            return [arg.jQueryEvent]
                        }
                    },
                    click: {newName: 'onClick'},
                    onCenterChanged: {
                        name: 'centerChanged',
                        deprecated: 'centerChanged',
                        deprecatedContext: function(arg) {
                            return arg.component
                        },
                        deprecatedArgs: function(arg) {
                            return [arg.center]
                        }
                    },
                    centerChanged: {newName: 'onCenterChanged'},
                    onZoomFactorChanged: {
                        name: 'zoomFactorChanged',
                        deprecated: 'zoomFactorChanged',
                        deprecatedContext: function(arg) {
                            return arg.component
                        },
                        deprecatedArgs: function(arg) {
                            return [arg.zoomFactor]
                        }
                    },
                    zoomFactorChanged: {newName: 'onZoomFactorChanged'},
                    onAreaClick: {
                        name: 'areaClick',
                        deprecated: 'areaSettings.click',
                        deprecatedContext: function(arg) {
                            return arg.target
                        },
                        deprecatedArgs: function(arg) {
                            return [arg.target, arg.jQueryEvent]
                        }
                    },
                    onAreaHoverChanged: {name: 'areaHoverChanged'},
                    onAreaSelectionChanged: {
                        name: 'areaSelectionChanged',
                        deprecated: 'areaSettings.selectionChanged',
                        deprecatedContext: function(arg) {
                            return arg.target
                        },
                        deprecatedArgs: function(arg) {
                            return [arg.target]
                        }
                    },
                    onMarkerClick: {
                        name: 'markerClick',
                        deprecated: 'markerSettings.click',
                        deprecatedContext: function(arg) {
                            return arg.target
                        },
                        deprecatedArgs: function(arg) {
                            return [arg.target, arg.jQueryEvent]
                        }
                    },
                    onMarkerHoverChanged: {name: 'markerHoverChanged'},
                    onMarkerSelectionChanged: {
                        name: 'markerSelectionChanged',
                        deprecated: 'markerSettings.selectionChanged',
                        deprecatedContext: function(arg) {
                            return arg.target
                        },
                        deprecatedArgs: function(arg) {
                            return [arg.target]
                        }
                    }
                }),
                _setDeprecatedOptions: function() {
                    this.callBase();
                    $.extend(this._deprecatedOptions, {
                        click: {
                            since: '14.2',
                            message: "Use the 'onClick' option instead"
                        },
                        centerChanged: {
                            since: '14.2',
                            message: "Use the 'onCenterChanged' option instead"
                        },
                        zoomFactorChanged: {
                            since: '14.2',
                            message: "Use the 'onZoomFactorChanged' option instead"
                        },
                        'areaSettings.click': {
                            since: '14.2',
                            message: "Use the 'onAreaClick' option instead"
                        },
                        'areaSettings.selectionChanged': {
                            since: '14.2',
                            message: "Use the 'onAreaSelectionChanged' option instead"
                        },
                        'markerSettings.click': {
                            since: '14.2',
                            message: "Use the 'onMarkerClick' option instead"
                        },
                        'markerSettings.selectionChanged': {
                            since: '14.2',
                            message: "Use the 'onMarkerSelectionChanged' option instead"
                        }
                    })
                },
                _init: function() {
                    var that = this;
                    that._themeManager = that._factory.createThemeManager();
                    that._themeManager.setTheme(that.option('theme'), that.option('rtlEnabled'));
                    that.callBase.apply(that, arguments);
                    that._dataExchanger = new DataExchanger;
                    that._initCenterHandler();
                    that._renderer = that._factory.createRenderer({
                        width: 1,
                        height: 1,
                        pathModified: that.option('pathModified'),
                        rtl: that.option('rtlEnabled')
                    });
                    that._renderer.draw(that.element().get(0));
                    that._root = that._renderer.root;
                    that._root.attr({
                        'class': 'dxm',
                        stroke: 'none',
                        "stroke-width": 0,
                        fill: 'none',
                        align: 'center',
                        cursor: 'default'
                    }).css({overflow: 'hidden'});
                    that._projection = that._factory.createProjection();
                    var dataKey = generateDataKey();
                    that._tracker = that._factory.createTracker({
                        root: that._root,
                        dataKey: dataKey
                    });
                    that._layoutControl = that._factory.createLayoutControl();
                    that._background = that._renderer.rect(0, 0, 0, 0).attr({'class': 'dxm-background'});
                    $(that._background.element).data(dataKey, {type: 'background'});
                    that._areasManager = that._factory.createAreasManager({
                        container: that._root,
                        renderer: that._renderer,
                        projection: that._projection,
                        themeManager: that._themeManager,
                        tracker: that._tracker,
                        dataKey: dataKey,
                        eventTrigger: that._eventTrigger,
                        dataExchanger: that._dataExchanger,
                        ready: function() {
                            that.hideLoadingIndicator()
                        }
                    });
                    that._markersManager = that._factory.createMarkersManager({
                        container: that._root,
                        renderer: that._renderer,
                        projection: that._projection,
                        themeManager: that._themeManager,
                        tracker: that._tracker,
                        eventTrigger: that._eventTrigger,
                        dataExchanger: that._dataExchanger,
                        dataKey: dataKey
                    });
                    that._legendsControl = that._factory.createLegendsControl({
                        container: that._root,
                        renderer: that._renderer,
                        layoutControl: that._layoutControl,
                        dataExchanger: that._dataExchanger
                    });
                    that._controlBar = that._factory.createControlBar({
                        container: that._root,
                        renderer: that._renderer,
                        layoutControl: that._layoutControl,
                        projection: that._projection,
                        dataKey: dataKey
                    });
                    that._tooltip = that._factory.createTooltip({
                        container: that._root,
                        renderer: that._renderer,
                        tracker: that._tracker
                    });
                    that._setThemeDependentOptions();
                    that._areasManager.setData(that.option('mapData'));
                    that._markersManager.setData(that.option('markers'));
                    that._projection.setBounds(that.option('bounds')).setMaxZoom(that.option('maxZoomFactor')).setZoom(that.option('zoomFactor'), true).setCenter(that.option('center'), true);
                    that._setTrackerOptions();
                    that._setupInteraction();
                    that._setTrackerCallbacks();
                    that._setControlBarCallbacks();
                    that._setProjectionCallbacks()
                },
                _dispose: function() {
                    var that = this;
                    that.callBase.apply(that, arguments);
                    that._resetProjectionCallbacks();
                    that._resetTrackerCallbacks();
                    that._resetControlBarCallbacks();
                    that._themeManager.dispose();
                    that._tracker.dispose();
                    that._legendsControl.dispose();
                    that._areasManager.dispose();
                    that._markersManager.dispose();
                    that._controlBar.dispose();
                    that._tooltip.dispose();
                    that._layoutControl.dispose();
                    that._disposeCenterHandler();
                    that._dataExchanger.dispose();
                    that._projection.dispose();
                    that._renderer.dispose();
                    that._disposeLoadIndicator();
                    that._renderer = that._themeManager = that._dataExchanger = that._projection = that._tracker = that._layoutControl = that._root = that._background = that._areasManager = that._markersManager = that._controlBar = that._legendsControl = that._tooltip = null
                },
                _getOption: function(name, isScalar) {
                    var theme = this._themeManager.theme(name),
                        option = this.option(name);
                    return isScalar ? option !== undefined ? option : theme : _extend(true, {}, theme, option)
                },
                _initCenterHandler: function() {
                    var that = this,
                        xdrag,
                        ydrag,
                        isCursorChanged = false;
                    that._centerHandler = {
                        processStart: function(arg) {
                            if (that._centeringEnabled) {
                                xdrag = arg.x;
                                ydrag = arg.y;
                                that._noCenterChanged = true
                            }
                        },
                        processMove: function(arg) {
                            if (that._centeringEnabled) {
                                if (!isCursorChanged) {
                                    that._root.attr({cursor: 'move'});
                                    isCursorChanged = true
                                }
                                that._projection.moveCenter(xdrag - arg.x, ydrag - arg.y);
                                xdrag = arg.x;
                                ydrag = arg.y
                            }
                        },
                        processEnd: function() {
                            if (that._centeringEnabled) {
                                that._root.attr({cursor: 'default'});
                                that._noCenterChanged = null;
                                isCursorChanged && that._raiseCenterChanged();
                                isCursorChanged = false
                            }
                        }
                    }
                },
                _disposeCenterHandler: function() {
                    this._centerHandler = null
                },
                _setProjectionCallbacks: function() {
                    var that = this;
                    that._projection.on({
                        center: function() {
                            that._raiseCenterChanged()
                        },
                        zoom: function() {
                            that._raiseZoomFactorChanged()
                        }
                    });
                    that._resetProjectionCallbacks = function() {
                        that._resetProjectionCallbacks = that = null
                    }
                },
                _setTrackerCallbacks: function() {
                    var that = this,
                        centerHandler = that._centerHandler,
                        renderer = that._renderer,
                        managers = {
                            area: that._areasManager,
                            marker: that._markersManager
                        },
                        controlBar = that._controlBar,
                        tooltip = that._tooltip,
                        isControlDrag = false;
                    that._tracker.setCallbacks({
                        click: function(arg) {
                            var offset = _getRootOffset(renderer);
                            arg.$event.x = arg.x - offset.left;
                            arg.$event.y = arg.y - offset.top;
                            var manager = managers[arg.data.type];
                            if (manager)
                                manager.raiseClick(arg.data.index, arg.$event);
                            if (manager || arg.data.type === 'background')
                                that._eventTrigger('click', {jQueryEvent: arg.$event})
                        },
                        start: function(arg) {
                            isControlDrag = arg.data.type === 'control-bar';
                            if (isControlDrag) {
                                arg.data = arg.data.index;
                                controlBar.processStart(arg)
                            }
                            else
                                centerHandler.processStart(arg)
                        },
                        move: function(arg) {
                            if (isControlDrag) {
                                arg.data = arg.data.index;
                                controlBar.processMove(arg)
                            }
                            else
                                centerHandler.processMove(arg)
                        },
                        end: function(arg) {
                            if (isControlDrag) {
                                arg.data = arg.data.index;
                                controlBar.processEnd(arg);
                                isControlDrag = false
                            }
                            else
                                centerHandler.processEnd()
                        },
                        zoom: function(arg) {
                            controlBar.processZoom(arg)
                        },
                        'hover-on': function(arg) {
                            var manager = managers[arg.data.type];
                            if (manager)
                                manager.hoverItem(arg.data.index, true)
                        },
                        'hover-off': function(arg) {
                            var manager = managers[arg.data.type];
                            if (manager)
                                manager.hoverItem(arg.data.index, false)
                        },
                        'focus-on': function(arg, done) {
                            var result = false;
                            if (tooltip.enabled()) {
                                var proxy = managers[arg.data.type] ? managers[arg.data.type].getProxyItem(arg.data.index) : null;
                                if (!!proxy && tooltip.prepare(proxy, {offset: 12})) {
                                    var offset = _getRootOffset(renderer);
                                    tooltip.show().move(arg.x - offset.left, arg.y - offset.top);
                                    result = true
                                }
                            }
                            done(result)
                        },
                        'focus-move': function(arg) {
                            var offset = _getRootOffset(renderer);
                            tooltip.move(arg.x - offset.left, arg.y - offset.top)
                        },
                        'focus-off': function(arg) {
                            tooltip.hide()
                        }
                    });
                    that._resetTrackerCallbacks = function() {
                        that._resetTrackerCallbacks = that = centerHandler = renderer = managers = controlBar = tooltip = null
                    }
                },
                _setControlBarCallbacks: function() {
                    var that = this,
                        projection = that._projection,
                        isZoomChanged;
                    that._projection.on({zoom: function() {
                            isZoomChanged = true
                        }});
                    that._controlBar.setCallbacks({
                        reset: function(isCenter, isZoom) {
                            if (isCenter)
                                projection.setCenter(null);
                            if (isZoom)
                                projection.setZoom(null)
                        },
                        beginMove: function() {
                            that._noCenterChanged = true
                        },
                        endMove: function() {
                            that._noCenterChanged = null;
                            that._raiseCenterChanged()
                        },
                        move: function(dx, dy) {
                            projection.moveCenter(dx, dy)
                        },
                        zoom: function(zoom, center) {
                            var coords,
                                screenPosition;
                            if (center) {
                                screenPosition = _getRootOffset(that._renderer);
                                screenPosition = [center[0] - screenPosition.left, center[1] - screenPosition.top];
                                coords = projection.fromScreenPoint(screenPosition[0], screenPosition[1])
                            }
                            isZoomChanged = false;
                            projection.setScaledZoom(zoom);
                            if (isZoomChanged && center)
                                projection.setCenterByPoint(coords, screenPosition)
                        }
                    });
                    that._resetControlBarCallbacks = function() {
                        that._resetControlBarCallbacks = that = projection = null
                    }
                },
                _setupInteraction: function() {
                    var that = this;
                    that._centerHandler.processEnd();
                    that._centeringEnabled = _parseBool(this._getOption('panningEnabled', true), true);
                    that._zoomingEnabled = _parseBool(this._getOption('zoomingEnabled', true), true);
                    that._controlBar.setInteraction({
                        centeringEnabled: that._centeringEnabled,
                        zoomingEnabled: that._zoomingEnabled
                    })
                },
                _resize: function(_forceResize) {
                    var that = this,
                        size = that.option('size') || {},
                        width = size.width >= 0 ? _Number(size.width) : that.element().width(),
                        height = size.height >= 0 ? _Number(size.height) : that.element().height(),
                        hidden = false;
                    if (width === 0)
                        if (_Number(size.width) === 0)
                            hidden = true;
                        else
                            width = DEFAULT_WIDTH;
                    if (height === 0)
                        if (_Number(size.height) === 0)
                            hidden = true;
                        else
                            height = DEFAULT_HEIGHT;
                    if (hidden || !that.element().is(':visible')) {
                        that._incidentOccured("W2001", [that.NAME]);
                        that._width = that._height = 0;
                        return false
                    }
                    var needResize = that._width !== width || that._height !== height || _forceResize;
                    if (needResize) {
                        that._width = width;
                        that._height = height;
                        that._renderer.resize(width, height);
                        that._projection.setSize(width, height);
                        that._layoutControl.setSize(width, height);
                        that._tooltip.setSize(width, height);
                        that._background.attr({
                            x: 0,
                            y: 0,
                            width: width,
                            height: height
                        });
                        that._updateLoadIndicator(undefined, width, height)
                    }
                    return needResize
                },
                _clean: function() {
                    var that = this;
                    that._tracker.reset();
                    that._layoutControl.stop();
                    that._background.remove();
                    that._areasManager.clean();
                    that._markersManager.clean();
                    that._controlBar.clean();
                    that._legendsControl.clean();
                    that._tooltip.clean()
                },
                _render: function() {
                    var that = this;
                    if (!that._resize(true))
                        return;
                    that._background.append(that._root);
                    that._areasManager.render();
                    that._markersManager.render();
                    that._controlBar.render();
                    that._legendsControl.render();
                    that._layoutControl.start();
                    that._tooltip.render();
                    that._drawn()
                },
                _optionChanged: function(args) {
                    var that = this,
                        value = args.value;
                    switch (args.name) {
                        case'size':
                            that._resize();
                            break;
                        case'theme':
                            that._themeManager.setTheme(value, that.option('rtlEnabled'));
                            that._setThemeDependentOptions();
                            break;
                        case'mapData':
                            that._areasManager.setData(value);
                            break;
                        case'markers':
                            that._markersManager.setData(value);
                            break;
                        case'bounds':
                            that._projection.setBounds(value);
                            break;
                        case'maxZoomFactor':
                            that._projection.setMaxZoom(value);
                            break;
                        case'zoomFactor':
                            that._projection.setZoom(value);
                            break;
                        case'center':
                            that._projection.setCenter(value);
                            break;
                        case'background':
                            that._setBackgroundOptions();
                            break;
                        case'areaSettings':
                            that._setAreasManagerOptions();
                            break;
                        case'markerSettings':
                            that._setMarkersManagerOptions();
                            break;
                        case'controlBar':
                            that._setControlBarOptions();
                            break;
                        case'legends':
                            that._setLegendsOptions();
                            break;
                        case'tooltip':
                            that._setTooltipOptions();
                            break;
                        case'touchEnabled':
                        case'wheelEnabled':
                            that._setTrackerOptions();
                            break;
                        case'panningEnabled':
                        case'zoomingEnabled':
                            that._setupInteraction();
                            break;
                        default:
                            that.callBase.apply(that, arguments);
                            break
                    }
                },
                _setThemeDependentOptions: function() {
                    var that = this;
                    that._setBackgroundOptions();
                    that._setAreasManagerOptions();
                    that._setMarkersManagerOptions();
                    that._setControlBarOptions();
                    that._setLegendsOptions();
                    that._setTooltipOptions()
                },
                _setBackgroundOptions: function() {
                    var settings = this._getOption('background');
                    this._background.attr({
                        "stroke-width": settings.borderWidth,
                        stroke: settings.borderColor,
                        fill: settings.color
                    })
                },
                _setAreasManagerOptions: function() {
                    this._areasManager.setOptions(this.option('areaSettings'));
                    this._createEventTrigger('onAreaClick');
                    this._createEventTrigger('onAreaSelectionChanged')
                },
                _setMarkersManagerOptions: function() {
                    this._markersManager.setOptions(this.option('markerSettings'));
                    this._createEventTrigger('onMarkerClick');
                    this._createEventTrigger('onMarkerSelectionChanged')
                },
                _setControlBarOptions: function() {
                    this._controlBar.setOptions(this._getOption('controlBar'))
                },
                _setLegendsOptions: function() {
                    this._legendsControl.setOptions(this.option('legends'), this._themeManager.theme('legend'))
                },
                _setTooltipOptions: function() {
                    this._tooltip.setOptions(this._getOption('tooltip'))
                },
                _setTrackerOptions: function() {
                    this._tracker.setOptions({
                        touchEnabled: this._getOption('touchEnabled', true),
                        wheelEnabled: this._getOption('wheelEnabled', true)
                    })
                },
                _raiseCenterChanged: function() {
                    !this._noCenterChanged && this._eventTrigger('centerChanged', {center: this._projection.getCenter()})
                },
                _raiseZoomFactorChanged: function() {
                    !this._noZoomFactorChanged && this._eventTrigger('zoomFactorChanged', {zoomFactor: this._projection.getZoom()})
                },
                _refresh: function() {
                    var that = this,
                        callBase = that.callBase;
                    that._endLoading(function() {
                        callBase.call(that)
                    })
                },
                render: function() {
                    var that = this;
                    if (that._width === 0 && that._height === 0)
                        that._refresh();
                    else
                        that._resize();
                    return that
                },
                getAreas: function() {
                    return this._areasManager.getProxyItems()
                },
                getMarkers: function() {
                    return this._markersManager.getProxyItems()
                },
                clearAreaSelection: function(_noEvent) {
                    this._areasManager.clearSelection(_noEvent);
                    return this
                },
                clearMarkerSelection: function(_noEvent) {
                    this._markersManager.clearSelection(_noEvent);
                    return this
                },
                clearSelection: function(_noEvent) {
                    return this.clearAreaSelection(_noEvent).clearMarkerSelection(_noEvent)
                },
                center: function(value, _noEvent) {
                    var that = this;
                    if (value === undefined)
                        return that._projection.getCenter();
                    else {
                        that._noCenterChanged = _noEvent;
                        that._projection.setCenter(value);
                        that._noCenterChanged = null;
                        return that
                    }
                },
                zoomFactor: function(value, _noEvent) {
                    var that = this;
                    if (value === undefined)
                        return that._projection.getZoom();
                    else {
                        that._noZoomFactorChanged = _noEvent;
                        that._projection.setZoom(value);
                        that._noZoomFactorChanged = null;
                        return that
                    }
                },
                viewport: function(value, _noEvent) {
                    var that = this;
                    if (value === undefined)
                        return that._projection.getViewport();
                    else {
                        that._noCenterChanged = that._noZoomFactorChanged = _noEvent;
                        that._projection.setViewport(value);
                        that._noCenterChanged = that._noZoomFactorChanged = null;
                        return that
                    }
                },
                convertCoordinates: function(x, y) {
                    return this._projection.fromScreenPointStrict(x, y)
                },
                _getLoadIndicatorOption: function() {
                    return this._getOption('loadingIndicator')
                },
                showLoadingIndicator: function() {
                    this._showLoadIndicator(this._getLoadIndicatorOption(), {
                        width: this._width,
                        height: this._height
                    })
                },
                _factory: {}
            });
        Map.prototype._factory.createRenderer = function(parameters) {
            return new DX.viz.renderers.Renderer(parameters)
        };
        function DataExchanger() {
            this._store = {}
        }
        DataExchanger.prototype = {
            constructor: DataExchanger,
            dispose: function() {
                this._store = null;
                return this
            },
            _get: function(category, name) {
                var store = this._store[category] || (this._store[category] = {});
                return store[name] || (store[name] = {})
            },
            set: function(category, name, data) {
                var item = this._get(category, name);
                item.data = data;
                item.callback && item.callback(data);
                return this
            },
            bind: function(category, name, callback) {
                var item = this._get(category, name);
                item.callback = callback;
                item.data && callback(item.data);
                return this
            },
            unbind: function(category, name) {
                var item = this._get(category, name);
                item.data = item.callback = null;
                return this
            }
        };
        DX.registerComponent('dxVectorMap', DX.viz.map, Map);
        DX.viz.map._internal = {};
        DX.viz.map.sources = {};
        DX.viz.map._tests = {};
        DX.viz.map._tests.DataExchanger = DataExchanger;
        DX.viz.map._tests.stubDataExchanger = function(stub) {
            DataExchanger = stub
        }
    })(DevExpress, jQuery);
    /*! Module viz-vectormap, file projection.js */
    (function(DX, $, undefined) {
        var _Number = Number,
            _isFinite = isFinite,
            _min = Math.min,
            _max = Math.max,
            _abs = Math.abs,
            _tan = Math.tan,
            _atan = Math.atan,
            _exp = Math.exp,
            _round = Math.round,
            _ln = Math.log,
            _pow = Math.pow,
            _isArray = DX.utils.isArray,
            _buildPath = DX.viz.renderers.buildPath;
        var PI = Math.PI,
            QUARTER_PI = PI / 4,
            PI_TO_360 = PI / 360,
            TWO_TO_LN2 = 2 / Math.LN2;
        var DEFAULT_MIN_ZOOM = 1,
            DEFAULT_MAX_ZOOM = 1 << 8;
        var MERCATOR_MIN_LON = -180,
            MERCATOR_MAX_LON = 180,
            MERCATOR_MIN_LAT = -85.0511,
            MERCATOR_MAX_LAT = 85.0511;
        var mercator = {
                aspectRatio: 1,
                project: function(coordinates) {
                    var lon = coordinates[0],
                        lat = coordinates[1];
                    return [lon <= MERCATOR_MIN_LON ? -1 : lon >= MERCATOR_MAX_LON ? +1 : lon / 180, lat <= MERCATOR_MIN_LAT ? +1 : lat >= MERCATOR_MAX_LAT ? -1 : -_ln(_tan(QUARTER_PI + lat * PI_TO_360)) / PI]
                },
                unproject: function(coordinates) {
                    var x = coordinates[0],
                        y = coordinates[1];
                    return [x <= -1 ? MERCATOR_MIN_LON : x >= +1 ? MERCATOR_MAX_LON : 180 * x, y <= -1 ? MERCATOR_MAX_LAT : y >= +1 ? MERCATOR_MIN_LAT : (_atan(_exp(-PI * coordinates[1])) - QUARTER_PI) / PI_TO_360]
                }
            };
        function createProjectUnprojectMethods(p1, p2, delta) {
            var x0 = (p1[0] + p2[0]) / 2 - delta / 2,
                y0 = (p1[1] + p2[1]) / 2 - delta / 2,
                k = 2 / delta;
            return {
                    project: function(coordinates) {
                        var p = mercator.project(coordinates);
                        return [-1 + (p[0] - x0) * k, -1 + (p[1] - y0) * k]
                    },
                    unproject: function(coordinates) {
                        var p = [x0 + (coordinates[0] + 1) / k, y0 + (coordinates[1] + 1) / k];
                        return mercator.unproject(p)
                    }
                }
        }
        function floatsEqual(f1, f2) {
            return _abs(f1 - f2) < 1E-8
        }
        function truncate(value, min, max, fallback) {
            var _value = _Number(value);
            if (_value < min)
                _value = min;
            else if (_value > max)
                _value = max;
            else if (!(min <= _value && _value <= max))
                _value = fallback;
            return _value
        }
        function truncateQuad(quad, min, max) {
            return {
                    lt: [truncate(quad[0], min[0], max[0], min[0]), truncate(quad[1], min[1], max[1], min[1])],
                    rb: [truncate(quad[2], min[0], max[0], max[0]), truncate(quad[3], min[1], max[1], max[1])]
                }
        }
        function parseBounds(bounds) {
            var p1 = mercator.unproject([-1, -1]),
                p2 = mercator.unproject([+1, +1]),
                min = [_min(p1[0], p2[0]), _min(p1[1], p2[1])],
                max = [_max(p1[0], p2[0]), _max(p1[1], p2[1])],
                quad = bounds;
            if (quad && quad.minLon)
                quad = [quad.minLon, quad.minLat, quad.maxLon, quad.maxLat];
            if (quad)
                quad = truncateQuad(quad, min, max);
            return {
                    minBase: min,
                    maxBase: max,
                    min: quad ? [_min(quad.lt[0], quad.rb[0]), _min(quad.lt[1], quad.rb[1])] : min,
                    max: quad ? [_max(quad.lt[0], quad.rb[0]), _max(quad.lt[1], quad.rb[1])] : max
                }
        }
        function selectCenterValue(value1, value2, center1, center2) {
            var result;
            if (value1 > -1 && value2 >= +1)
                result = center1;
            else if (value1 <= -1 && value2 < +1)
                result = center2;
            else
                result = (center1 + center2) / 2;
            return result
        }
        function Projection() {
            this._events = {
                project: $.Callbacks(),
                transform: $.Callbacks(),
                center: $.Callbacks(),
                zoom: $.Callbacks(),
                'max-zoom': $.Callbacks()
            };
            this.setBounds(null)
        }
        Projection.prototype = {
            constructor: Projection,
            _minZoom: DEFAULT_MIN_ZOOM,
            _maxZoom: DEFAULT_MAX_ZOOM,
            _zoom: DEFAULT_MIN_ZOOM,
            _center: [NaN, NaN],
            dispose: function() {
                this._events = null;
                return this
            },
            setSize: function(width, height) {
                var that = this;
                that._x0 = width / 2;
                that._y0 = height / 2;
                if (width / height <= mercator.aspectRatio) {
                    that._xradius = width / 2;
                    that._yradius = width / 2 / mercator.aspectRatio
                }
                else {
                    that._xradius = height / 2 * mercator.aspectRatio;
                    that._yradius = height / 2
                }
                that._events['transform'].fire(that.getTransform());
                return that
            },
            setBounds: function(bounds) {
                var that = this,
                    _bounds = parseBounds(bounds);
                that._minBase = _bounds.minBase;
                that._maxBase = _bounds.maxBase;
                that._minBound = _bounds.min;
                that._maxBound = _bounds.max;
                var p1 = mercator.project(_bounds.min),
                    p2 = mercator.project(_bounds.max),
                    delta = _min(truncate(_abs(p2[0] - p1[0]), 0.1, 2, 2), truncate(_abs(p2[1] - p1[1]), 0.1, 2, 2)),
                    methods = delta < 2 ? createProjectUnprojectMethods(p1, p2, delta) : mercator;
                that._project = methods.project;
                that._unproject = methods.unproject;
                var minv = that._project(_bounds.minBase),
                    maxv = that._project(_bounds.maxBase);
                that._minv = [_min(minv[0], maxv[0]), _min(minv[1], maxv[1])];
                that._maxv = [_max(minv[0], maxv[0]), _max(minv[1], maxv[1])];
                that._defaultCenter = that._unproject([0, 0]);
                that.setCenter(that._defaultCenter);
                that._events['project'].fire();
                return that
            },
            _toScreen: function(coordinates) {
                return [this._x0 + this._xradius * coordinates[0], this._y0 + this._yradius * coordinates[1]]
            },
            _fromScreen: function(coordinates) {
                return [(coordinates[0] - this._x0) / this._xradius, (coordinates[1] - this._y0) / this._yradius]
            },
            _toTransformed: function(coordinates) {
                return [coordinates[0] * this._zoom + this._dxcenter, coordinates[1] * this._zoom + this._dycenter, ]
            },
            _toTransformedFast: function(coordinates) {
                return [coordinates[0] * this._zoom, coordinates[1] * this._zoom]
            },
            _fromTransformed: function(coordinates) {
                return [(coordinates[0] - this._dxcenter) / this._zoom, (coordinates[1] - this._dycenter) / this._zoom]
            },
            _adjustCenter: function() {
                var that = this,
                    center = that._project(that._center);
                that._dxcenter = -center[0] * that._zoom;
                that._dycenter = -center[1] * that._zoom
            },
            projectArea: function(coordinates) {
                var i = 0,
                    ii = _isArray(coordinates) ? coordinates.length : 0,
                    subcoords,
                    j,
                    jj,
                    subresult,
                    result = [];
                for (; i < ii; ++i) {
                    subcoords = coordinates[i];
                    subresult = [];
                    for (j = 0, jj = _isArray(subcoords) ? subcoords.length : 0; j < jj; ++j)
                        subresult.push(this._project(subcoords[j]));
                    result.push(subresult)
                }
                return result
            },
            projectPoint: function(coordinates) {
                return coordinates ? this._project(coordinates) : []
            },
            getAreaCoordinates: function(data) {
                var k = 0,
                    kk = data.length,
                    partialData,
                    i,
                    ii,
                    list = [],
                    partialPath,
                    point;
                for (; k < kk; ++k) {
                    partialData = data[k];
                    partialPath = [];
                    for (i = 0, ii = partialData.length; i < ii; ++i) {
                        point = this._toScreen(this._toTransformedFast(partialData[i]));
                        partialPath.push(point[0], point[1])
                    }
                    list.push(_buildPath(partialPath, "area"))
                }
                return list.join(' ')
            },
            getPointCoordinates: function(data) {
                var point = this._toScreen(this._toTransformedFast(data));
                return {
                        x: _round(point[0]),
                        y: _round(point[1])
                    }
            },
            getSquareSize: function(size) {
                return [size[0] * this._zoom * this._xradius, size[1] * this._zoom * this._yradius]
            },
            getZoom: function() {
                return this._zoom
            },
            setZoom: function(zoom, _forceEvent) {
                var that = this,
                    zoom__ = that._zoom;
                that._zoom = truncate(zoom, that._minZoom, that._maxZoom, that._minZoom);
                that._adjustCenter();
                if (!floatsEqual(zoom__, that._zoom) || _forceEvent)
                    that._events['zoom'].fire(that.getZoom(), that.getTransform());
                return that
            },
            getScaledZoom: function() {
                return _round((this._scale.length - 1) * _ln(this._zoom) / _ln(this._maxZoom))
            },
            setScaledZoom: function(scaledZoom) {
                return this.setZoom(this._scale[_round(scaledZoom)])
            },
            getZoomScalePartition: function() {
                return this._scale.length - 1
            },
            _setupScaling: function() {
                var that = this,
                    k = _round(TWO_TO_LN2 * _ln(that._maxZoom));
                k = k > 4 ? k : 4;
                var step = _pow(that._maxZoom, 1 / k),
                    zoom = that._minZoom,
                    i = 1;
                that._scale = [zoom];
                for (; i <= k; ++i)
                    that._scale.push(zoom *= step)
            },
            setMaxZoom: function(maxZoom) {
                var that = this;
                that._minZoom = DEFAULT_MIN_ZOOM;
                that._maxZoom = truncate(maxZoom, that._minZoom, _Number.MAX_VALUE, DEFAULT_MAX_ZOOM);
                that._setupScaling();
                if (that._zoom > that._maxZoom)
                    that.setZoom(that._maxZoom);
                that._events['max-zoom'].fire(that._maxZoom);
                return that
            },
            getMinZoom: function() {
                return this._minZoom
            },
            getMaxZoom: function() {
                return this._maxZoom
            },
            getCenter: function() {
                return [this._center[0], this._center[1]]
            },
            setCenter: function(center, _forceEvent) {
                var _center = _isArray(center) ? center : null;
                _center = _center || center && (center.lon || center.lat) && [center.lon, center.lat] || [];
                var that = this,
                    center__ = that._center;
                that._center = [truncate(_center[0], that._minBound[0], that._maxBound[0], that._defaultCenter[0]), truncate(_center[1], that._minBound[1], that._maxBound[1], that._defaultCenter[1])];
                that._adjustCenter();
                if (!floatsEqual(center__[0], that._center[0]) || !floatsEqual(center__[1], that._center[1]) || _forceEvent)
                    that._events['center'].fire(that.getCenter(), that.getTransform());
                return that
            },
            setCenterByPoint: function(coordinates, screenPosition) {
                var that = this,
                    p = that._project(coordinates),
                    q = that._fromScreen(screenPosition);
                return that.setCenter(that._unproject([-q[0] / that._zoom + p[0], -q[1] / that._zoom + p[1]]))
            },
            moveCenter: function(screenDx, screenDy) {
                var that = this,
                    current = that._toScreen(that._toTransformed(that._project(that._center))),
                    center = that._unproject(that._fromTransformed(that._fromScreen([current[0] + screenDx, current[1] + screenDy])));
                return that.setCenter(center)
            },
            getViewport: function() {
                var p1 = this._unproject(this._fromTransformed([-1, -1])),
                    p2 = this._unproject(this._fromTransformed([+1, +1]));
                return [p1[0], p1[1], p2[0], p2[1]]
            },
            setViewport: function(viewport) {
                var that = this;
                if (!_isArray(viewport))
                    return that.setZoom(that._minZoom).setCenter(that._defaultCenter);
                var _viewport = truncateQuad(viewport, that._minBase, that._maxBase),
                    lt = that._project(_viewport.lt),
                    rb = that._project(_viewport.rb),
                    l = _min(lt[0], rb[0]),
                    t = _min(lt[1], rb[1]),
                    r = _max(lt[0], rb[0]),
                    b = _max(lt[1], rb[1]),
                    zoom = 2 / _max(r - l, b - t),
                    xc = selectCenterValue(l, r, -1 - zoom * l, +1 - zoom * r),
                    yc = selectCenterValue(t, b, -1 - zoom * t, +1 - zoom * b);
                return that.setZoom(zoom).setCenter(that._unproject([-xc / zoom, -yc / zoom]))
            },
            getTransform: function() {
                return {
                        translateX: this._dxcenter * this._xradius,
                        translateY: this._dycenter * this._yradius
                    }
            },
            fromScreenPoint: function(x, y) {
                return this._unproject(this._fromTransformed(this._fromScreen([x, y])))
            },
            fromScreenPointStrict: function(x, y) {
                var that = this,
                    p = that._fromTransformed(that._fromScreen([x, y])),
                    q = that._unproject(p);
                return [p[0] >= that._minv[0] && p[0] <= that._maxv[0] ? q[0] : NaN, p[1] >= that._minv[1] && p[1] <= that._maxv[1] ? q[1] : NaN]
            },
            on: function(obj) {
                $.each(this._events, function(name, list) {
                    obj[name] && list.add(obj[name])
                });
                return this
            }
        };
        DX.viz.map._tests.Projection = Projection;
        DX.viz.map._tests.mercator = mercator;
        DX.viz.map._tests._DEBUG_stubMercator = function(stub) {
            mercator = stub
        };
        DX.viz.map._tests._DEBUG_restoreMercator = function() {
            mercator = DX.viz.map._tests.mercator
        };
        DX.viz.map.dxVectorMap.prototype._factory.createProjection = function() {
            return new Projection
        }
    })(DevExpress, jQuery);
    /*! Module viz-vectormap, file controlBar.js */
    (function(DX, undefined) {
        var _Number = Number,
            _String = String,
            _round = Math.round,
            _pow = Math.pow,
            _ln = Math.log,
            _parseBool = DX.viz.core.utils.parseBool,
            _parseEnum = DX.viz.core.utils.parseEnum;
        var _LN2 = Math.LN2;
        var COMMAND_RESET = 'command-reset',
            COMMAND_MOVE_UP = 'command-move-up',
            COMMAND_MOVE_RIGHT = 'command-move-right',
            COMMAND_MOVE_DOWN = 'command-move-down',
            COMMAND_MOVE_LEFT = 'command-move-left',
            COMMAND_ZOOM_IN = 'command-zoom-in',
            COMMAND_ZOOM_OUT = 'command-zoom-out',
            COMMAND_ZOOM_DRAG_LINE = 'command-zoom-drag-line',
            COMMAND_ZOOM_DRAG = 'command-zoom-drag';
        var EVENT_TARGET_TYPE = 'control-bar';
        var FLAG_CENTERING = 1,
            FLAG_ZOOMING = 2;
        var SIZE_OPTIONS = {
                bigCircleSize: 58,
                smallCircleSize: 28,
                buttonSize: 10,
                arrowButtonOffset: 20,
                incdecButtonSize: 11,
                incButtonOffset: 66,
                decButtonOffset: 227,
                sliderLineStartOffset: 88.5,
                sliderLineEndOffset: 205.5,
                sliderLength: 20,
                sliderWidth: 8,
                trackerGap: 4
            };
        var OFFSET_X = 30.5,
            OFFSET_Y = 30.5,
            TOTAL_WIDTH = 61,
            TOTAL_HEIGHT = 274;
        var COMMAND_TO_TYPE_MAP = {};
        COMMAND_TO_TYPE_MAP[COMMAND_RESET] = ResetCommand;
        COMMAND_TO_TYPE_MAP[COMMAND_MOVE_UP] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_RIGHT] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_DOWN] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_LEFT] = MoveCommand;
        COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_IN] = COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_OUT] = ZoomCommand;
        COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_DRAG] = ZoomDragCommand;
        var ControlBar = DX.Class.inherit({
                _flags: 0,
                ctor: function(parameters) {
                    var that = this;
                    that._params = parameters;
                    that._createElements(parameters.renderer, parameters.dataKey);
                    parameters.layoutControl.addItem(that);
                    that._subscribeToProjection(parameters.projection);
                    that._setVisibility(false)
                },
                setCallbacks: function(callbacks) {
                    this._callbacks = callbacks;
                    return this
                },
                _createElements: function(renderer, dataKey) {
                    var that = this;
                    that._root = renderer.g().attr({'class': 'dxm-control-bar'});
                    var buttonsGroups = that._buttonsGroup = renderer.g().attr({'class': 'dxm-control-buttons'}).append(that._root),
                        trackersGroup = renderer.g().attr({
                            stroke: 'none',
                            "stroke-width": 0,
                            fill: '#000000',
                            opacity: 0.0001
                        }).css({cursor: 'pointer'}).append(that._root);
                    that._createButtons(renderer, SIZE_OPTIONS, dataKey, buttonsGroups);
                    that._createTrackers(renderer, SIZE_OPTIONS, dataKey, trackersGroup)
                },
                _createButtons: function(renderer, options, dataKey, group) {
                    var size = options.buttonSize / 2,
                        offset1 = options.arrowButtonOffset - size,
                        offset2 = options.arrowButtonOffset,
                        incdecButtonSize = options.incdecButtonSize / 2;
                    renderer.circle(0, 0, options.bigCircleSize / 2).append(group);
                    renderer.circle(0, 0, size).append(group);
                    renderer.path([-size, -offset1, 0, -offset2, size, -offset1], "line").attr({"stroke-linecap": "square"}).append(group);
                    renderer.path([offset1, -size, offset2, 0, offset1, size], "line").attr({"stroke-linecap": "square"}).append(group);
                    renderer.path([size, offset1, 0, offset2, -size, offset1], "line").attr({"stroke-linecap": "square"}).append(group);
                    renderer.path([-offset1, size, -offset2, 0, -offset1, -size], "line").attr({"stroke-linecap": "square"}).append(group);
                    renderer.circle(0, options.incButtonOffset, options.smallCircleSize / 2).append(group);
                    renderer.path([[-incdecButtonSize, options.incButtonOffset, incdecButtonSize, options.incButtonOffset], [0, options.incButtonOffset - incdecButtonSize, 0, options.incButtonOffset + incdecButtonSize]], "area").append(group);
                    renderer.circle(0, options.decButtonOffset, options.smallCircleSize / 2).append(group);
                    renderer.path([-incdecButtonSize, options.decButtonOffset, incdecButtonSize, options.decButtonOffset], "area").append(group);
                    renderer.path([0, options.sliderLineStartOffset, 0, options.sliderLineEndOffset], "area").append(group);
                    this._zoomDrag = renderer.rect(-options.sliderLength / 2, options.sliderLineEndOffset - options.sliderWidth / 2, options.sliderLength, options.sliderWidth).append(group);
                    this._sliderLineLength = options.sliderLineEndOffset - options.sliderLineStartOffset
                },
                _createTrackers: function(renderer, options, dataKey, group) {
                    var size = _round((options.arrowButtonOffset - options.trackerGap) / 2),
                        offset1 = options.arrowButtonOffset - size,
                        offset2 = _round(_pow(options.bigCircleSize * options.bigCircleSize / 4 - size * size, 0.5)),
                        size2 = offset2 - offset1;
                    $(renderer.rect(-size, -size, size * 2, size * 2).append(group).element).data(dataKey, {
                        index: COMMAND_RESET,
                        type: EVENT_TARGET_TYPE
                    });
                    $(renderer.rect(-size, -offset2, size * 2, size2).append(group).element).data(dataKey, {
                        index: COMMAND_MOVE_UP,
                        type: EVENT_TARGET_TYPE
                    });
                    $(renderer.rect(offset1, -size, size2, size * 2).append(group).element).data(dataKey, {
                        index: COMMAND_MOVE_RIGHT,
                        type: EVENT_TARGET_TYPE
                    });
                    $(renderer.rect(-size, offset1, size * 2, size2).append(group).element).data(dataKey, {
                        index: COMMAND_MOVE_DOWN,
                        type: EVENT_TARGET_TYPE
                    });
                    $(renderer.rect(-offset2, -size, size2, size * 2).append(group).element).data(dataKey, {
                        index: COMMAND_MOVE_LEFT,
                        type: EVENT_TARGET_TYPE
                    });
                    $(renderer.circle(0, options.incButtonOffset, options.smallCircleSize / 2).append(group).element).data(dataKey, {
                        index: COMMAND_ZOOM_IN,
                        type: EVENT_TARGET_TYPE
                    });
                    $(renderer.circle(0, options.decButtonOffset, options.smallCircleSize / 2).append(group).element).data(dataKey, {
                        index: COMMAND_ZOOM_OUT,
                        type: EVENT_TARGET_TYPE
                    });
                    $(renderer.rect(-2, options.sliderLineStartOffset - 2, 4, options.sliderLineEndOffset - options.sliderLineStartOffset + 4).append(group).element).data(dataKey, {
                        index: COMMAND_ZOOM_DRAG_LINE,
                        type: EVENT_TARGET_TYPE
                    });
                    this._zoomDragCover = renderer.rect(-options.sliderLength / 2, options.sliderLineEndOffset - options.sliderWidth / 2, options.sliderLength, options.sliderWidth).append(group);
                    $(this._zoomDragCover.element).data(dataKey, {
                        index: COMMAND_ZOOM_DRAG,
                        type: EVENT_TARGET_TYPE
                    })
                },
                _subscribeToProjection: function(projection) {
                    var that = this;
                    projection.on({
                        zoom: function() {
                            that._adjustZoom(projection.getScaledZoom())
                        },
                        'max-zoom': function() {
                            that._zoomPartition = projection.getZoomScalePartition();
                            that._sliderUnitLength = that._sliderLineLength / that._zoomPartition;
                            that._adjustZoom(projection.getScaledZoom())
                        }
                    })
                },
                dispose: function() {
                    var that = this;
                    that._params.layoutControl.removeItem(that);
                    that._root.clear();
                    that._params = that._callbacks = that._root = that._buttonsGroup = that._zoomDrag = that._zoomDragCover = null;
                    return that
                },
                resize: function(size) {
                    this._setVisibility(size !== null && this._options.enabled && this._flags);
                    return this
                },
                _setVisibility: function(state) {
                    this._root.attr({visibility: state ? null : 'hidden'})
                },
                getLayoutOptions: function() {
                    var options = this._options;
                    return this._rendered && options.enabled && this._flags ? {
                            width: 2 * options.margin + TOTAL_WIDTH,
                            height: 2 * options.margin + TOTAL_HEIGHT,
                            horizontalAlignment: options.horizontalAlignment,
                            verticalAlignment: options.verticalAlignment
                        } : null
                },
                locate: function(x, y) {
                    this._root.attr({
                        translateX: x + this._options.margin + OFFSET_X,
                        translateY: y + this._options.margin + OFFSET_Y
                    });
                    return this
                },
                setInteraction: function(interaction) {
                    var that = this;
                    that.processEnd();
                    if (_parseBool(interaction.centeringEnabled, true))
                        that._flags |= FLAG_CENTERING;
                    else
                        that._flags &= ~FLAG_CENTERING;
                    if (_parseBool(interaction.zoomingEnabled, true))
                        that._flags |= FLAG_ZOOMING;
                    else
                        that._flags &= ~FLAG_ZOOMING;
                    if (that._rendered)
                        that._refresh();
                    return that
                },
                setOptions: function(options) {
                    var that = this;
                    that.processEnd();
                    that._buttonsGroup.attr({
                        'stroke-width': options.borderWidth,
                        stroke: options.borderColor,
                        fill: options.color
                    });
                    that._options = {
                        enabled: _parseBool(options.enabled, true),
                        margin: options.margin > 0 ? _Number(options.margin) : 0,
                        horizontalAlignment: _parseEnum(options.horizontalAlignment, ['left', 'center', 'right'], 'left'),
                        verticalAlignment: _parseEnum(options.verticalAlignment, ['top', 'bottom'], 'top')
                    };
                    if (that._rendered)
                        that._refresh();
                    return that
                },
                _refresh: function() {
                    var isVisible = this._flags && this._options.enabled;
                    this._setVisibility(isVisible);
                    if (isVisible)
                        this.updateLayout()
                },
                clean: function() {
                    var that = this;
                    that._rendered = null;
                    that._root.remove();
                    return that
                },
                render: function() {
                    var that = this;
                    that._rendered = true;
                    that._root.append(that._params.container);
                    that._refresh();
                    return that
                },
                _adjustZoom: function(zoom) {
                    var that = this;
                    that._zoomFactor = _round(zoom);
                    that._zoomFactor >= 0 || (that._zoomFactor = 0);
                    that._zoomFactor <= that._zoomPartition || (that._zoomFactor = that._zoomPartition);
                    var transform = {translateY: -that._zoomFactor * that._sliderUnitLength};
                    that._zoomDrag.attr(transform);
                    that._zoomDragCover.attr(transform)
                },
                _applyZoom: function(center) {
                    this._callbacks.zoom(this._zoomFactor, this._flags & FLAG_CENTERING ? center : undefined)
                },
                processStart: function(arg) {
                    var commandType = COMMAND_TO_TYPE_MAP[arg.data];
                    this._command = commandType && this._options.enabled && commandType.flags & this._flags ? new commandType(this, arg) : null;
                    return this
                },
                processMove: function(arg) {
                    this._command && this._command.update(arg);
                    return this
                },
                processEnd: function() {
                    this._command && this._command.finish();
                    this._command = null;
                    return this
                },
                processZoom: function(arg) {
                    var that = this,
                        zoomFactor;
                    if (that._flags & FLAG_ZOOMING) {
                        if (arg.delta)
                            zoomFactor = arg.delta;
                        else if (arg.ratio)
                            zoomFactor = _ln(arg.ratio) / _LN2;
                        that._adjustZoom(that._zoomFactor + zoomFactor);
                        that._applyZoom([arg.x, arg.y])
                    }
                    return that
                }
            });
        function disposeCommand(command) {
            delete command._owner;
            command.update = function(){};
            command.finish = function(){}
        }
        function ResetCommand(owner, arg) {
            this._owner = owner;
            this._command = arg.data
        }
        ResetCommand.flags = FLAG_CENTERING | FLAG_ZOOMING;
        ResetCommand.prototype.update = function(arg) {
            arg.data !== this._command && disposeCommand(this)
        };
        ResetCommand.prototype.finish = function() {
            var flags = this._owner._flags;
            this._owner._callbacks.reset(!!(flags & FLAG_CENTERING), !!(flags & FLAG_ZOOMING));
            if (flags & FLAG_ZOOMING)
                this._owner._adjustZoom(0);
            disposeCommand(this)
        };
        function MoveCommand(owner, arg) {
            this._command = arg.data;
            var timeout = null,
                interval = 100,
                dx = 0,
                dy = 0;
            switch (this._command) {
                case COMMAND_MOVE_UP:
                    dy = -10;
                    break;
                case COMMAND_MOVE_RIGHT:
                    dx = 10;
                    break;
                case COMMAND_MOVE_DOWN:
                    dy = 10;
                    break;
                case COMMAND_MOVE_LEFT:
                    dx = -10;
                    break
            }
            function callback() {
                owner._callbacks.move(dx, dy);
                timeout = setTimeout(callback, interval)
            }
            this._stop = function() {
                clearTimeout(timeout);
                owner._callbacks.endMove();
                this._stop = owner = callback = null;
                return this
            };
            arg = null;
            owner._callbacks.beginMove();
            callback()
        }
        MoveCommand.flags = FLAG_CENTERING;
        MoveCommand.prototype.update = function(arg) {
            this._command !== arg.data && this.finish()
        };
        MoveCommand.prototype.finish = function() {
            disposeCommand(this._stop())
        };
        function ZoomCommand(owner, arg) {
            this._owner = owner;
            this._command = arg.data;
            var timeout = null,
                interval = 150,
                dzoom = this._command === COMMAND_ZOOM_IN ? 1 : -1;
            function callback() {
                owner._adjustZoom(owner._zoomFactor + dzoom);
                timeout = setTimeout(callback, interval)
            }
            this._stop = function() {
                clearTimeout(timeout);
                this._stop = owner = callback = null;
                return this
            };
            arg = null;
            callback()
        }
        ZoomCommand.flags = FLAG_ZOOMING;
        ZoomCommand.prototype.update = function(arg) {
            this._command !== arg.data && this.finish()
        };
        ZoomCommand.prototype.finish = function() {
            this._owner._applyZoom();
            disposeCommand(this._stop())
        };
        function ZoomDragCommand(owner, arg) {
            this._owner = owner;
            this._zoomFactor = owner._zoomFactor;
            this._pos = arg.y
        }
        ZoomDragCommand.flags = FLAG_ZOOMING;
        ZoomDragCommand.prototype.update = function(arg) {
            var owner = this._owner;
            owner._adjustZoom(this._zoomFactor + owner._zoomPartition * (this._pos - arg.y) / owner._sliderLineLength)
        };
        ZoomDragCommand.prototype.finish = function() {
            this._owner._applyZoom();
            disposeCommand(this)
        };
        DX.viz.map._tests.ControlBar = ControlBar;
        var COMMAND_TO_TYPE_MAP__ORIGINAL = COMMAND_TO_TYPE_MAP;
        DX.viz.map._tests.stubCommandToTypeMap = function(map) {
            COMMAND_TO_TYPE_MAP = map
        };
        DX.viz.map._tests.restoreCommandToTypeMap = function() {
            COMMAND_TO_TYPE_MAP = COMMAND_TO_TYPE_MAP__ORIGINAL
        };
        DX.viz.map.dxVectorMap.prototype._factory.createControlBar = function(parameters) {
            return new ControlBar(parameters)
        }
    })(DevExpress);
    /*! Module viz-vectormap, file tracker.js */
    (function(DX, $, undefined) {
        var _abs = Math.abs,
            _sqrt = Math.sqrt,
            _round = Math.round,
            _max = Math.max,
            _min = Math.min,
            _addNamespace = DX.ui.events.addNamespace,
            _parseBool = DX.viz.core.utils.parseBool,
            _now = $.now;
        var _NAME = DX.viz.map.dxVectorMap.prototype.NAME;
        var EVENTS = {};
        setupEvents();
        var EVENT_START = 'start',
            EVENT_MOVE = 'move',
            EVENT_END = 'end',
            EVENT_ZOOM = 'zoom',
            EVENT_HOVER_ON = 'hover-on',
            EVENT_HOVER_OFF = 'hover-off',
            EVENT_CLICK = 'click',
            EVENT_FOCUS_ON = 'focus-on',
            EVENT_FOCUS_MOVE = 'focus-move',
            EVENT_FOCUS_OFF = 'focus-off';
        var CLICK_TIME_THRESHOLD = 500,
            CLICK_COORD_THRESHOLD = 5,
            DRAG_COORD_THRESHOLD_MOUSE = 5,
            DRAG_COORD_THRESHOLD_TOUCH = 10,
            FOCUS_ON_DELAY_MOUSE = 300,
            FOCUS_OFF_DELAY_MOUSE = 300,
            FOCUS_ON_DELAY_TOUCH = 300,
            FOCUS_OFF_DELAY_TOUCH = 400,
            FOCUS_COORD_THRESHOLD_MOUSE = 5,
            WHEEL_COOLDOWN = 150,
            WHEEL_DIRECTION_COOLDOWN = 300;
        function Tracker(parameters) {
            var that = this;
            that._root = parameters.root;
            that._callbacks = {};
            that._createEventHandlers(parameters.dataKey);
            that._focus = new Focus(that._callbacks);
            that._attachHandlers()
        }
        Tracker.prototype = {
            constructor: Tracker,
            dispose: function() {
                var that = this;
                that._detachHandlers();
                that._focus.dispose();
                that._root = that._callbacks = that._focus = that._handlers = null;
                return that
            },
            _startClick: function(event, data) {
                if (!data)
                    return;
                var coords = getEventCoords(event);
                this._clickState = {
                    x: coords.x,
                    y: coords.y,
                    time: _now()
                }
            },
            _endClick: function(event, data) {
                var state = this._clickState;
                if (!state)
                    return;
                if (_now() - state.time <= CLICK_TIME_THRESHOLD) {
                    var coords = getEventCoords(event);
                    if (_abs(coords.x - state.x) <= CLICK_COORD_THRESHOLD && _abs(coords.y - state.y) <= CLICK_COORD_THRESHOLD)
                        this._callbacks[EVENT_CLICK]({
                            data: data,
                            x: coords.x,
                            y: coords.y,
                            $event: event
                        })
                }
                this._clickState = null
            },
            _startDrag: function(event, data) {
                if (!data)
                    return;
                var coords = getEventCoords(event),
                    state = this._dragState = {
                        x: coords.x,
                        y: coords.y,
                        data: data
                    };
                this._callbacks[EVENT_START]({
                    x: state.x,
                    y: state.y,
                    data: state.data
                })
            },
            _moveDrag: function(event, data) {
                var state = this._dragState;
                if (!state)
                    return;
                var coords = getEventCoords(event),
                    threshold = isTouchEvent(event) ? DRAG_COORD_THRESHOLD_TOUCH : DRAG_COORD_THRESHOLD_MOUSE;
                if (state.active || _abs(coords.x - state.x) > threshold || _abs(coords.y - state.y) > threshold) {
                    state.x = coords.x;
                    state.y = coords.y;
                    state.active = true;
                    state.data = data || {};
                    this._callbacks[EVENT_MOVE]({
                        x: state.x,
                        y: state.y,
                        data: state.data
                    })
                }
            },
            _endDrag: function(event, data) {
                var state = this._dragState;
                if (!state)
                    return;
                this._dragState = null;
                this._callbacks[EVENT_END]({
                    x: state.x,
                    y: state.y,
                    data: state.data
                })
            },
            _wheelZoom: function(event, data) {
                if (!data)
                    return;
                var that = this,
                    lock = that._wheelLock,
                    time = _now();
                if (time - lock.time <= WHEEL_COOLDOWN)
                    return;
                if (time - lock.dirTime > WHEEL_DIRECTION_COOLDOWN)
                    lock.dir = 0;
                var delta = adjustWheelDelta(event.originalEvent.wheelDelta / 120 || event.originalEvent.detail / -3 || 0, lock);
                if (delta === 0)
                    return;
                var coords = getEventCoords(event);
                that._callbacks[EVENT_ZOOM]({
                    delta: delta,
                    x: coords.x,
                    y: coords.y
                });
                lock.time = lock.dirTime = time
            },
            _startZoom: function(event, data) {
                if (!isTouchEvent(event))
                    return;
                if (!data)
                    return;
                var state = this._zoomState = this._zoomState || {};
                if (state.pointer1 && state.pointer2)
                    return;
                var coords;
                if (state.pointer1 === undefined) {
                    state.pointer1 = getPointerId(event) || 0;
                    coords = getMultitouchEventCoords(event, state.pointer1);
                    state.x1 = state.x1_0 = coords.x;
                    state.y1 = state.y1_0 = coords.y
                }
                if (state.pointer2 === undefined) {
                    var pointer2 = getPointerId(event) || 1;
                    if (pointer2 !== state.pointer1) {
                        coords = getMultitouchEventCoords(event, pointer2);
                        if (coords) {
                            state.x2 = state.x2_0 = coords.x;
                            state.y2 = state.y2_0 = coords.y;
                            state.pointer2 = pointer2;
                            state.ready = true;
                            this._endDrag()
                        }
                    }
                }
            },
            _moveZoom: function(event, data) {
                var state = this._zoomState;
                if (!state)
                    return;
                if (!isTouchEvent(event))
                    return;
                var coords;
                if (state.pointer1 !== undefined) {
                    coords = getMultitouchEventCoords(event, state.pointer1);
                    if (coords) {
                        state.x1 = coords.x;
                        state.y1 = coords.y
                    }
                }
                if (state.pointer2 !== undefined) {
                    coords = getMultitouchEventCoords(event, state.pointer2);
                    if (coords) {
                        state.x2 = coords.x;
                        state.y2 = coords.y
                    }
                }
            },
            _endZoom: function(event, data) {
                var state = this._zoomState;
                if (!state)
                    return;
                if (!isTouchEvent(event))
                    return;
                if (state.ready) {
                    var startDistance = getDistance(state.x1_0, state.y1_0, state.x2_0, state.y2_0),
                        currentDistance = getDistance(state.x1, state.y1, state.x2, state.y2);
                    this._callbacks[EVENT_ZOOM]({
                        ratio: currentDistance / startDistance,
                        x: (state.x1_0 + state.x2_0) / 2,
                        y: (state.y1_0 + state.y2_0) / 2
                    })
                }
                this._zoomState = null
            },
            _startHover: function(event, data) {
                this._doHover(event, data, true)
            },
            _moveHover: function(event, data) {
                this._doHover(event, data, false)
            },
            _doHover: function(event, data, isTouch) {
                var that = this;
                if (that._dragState && that._dragState.active || that._zoomState && that._zoomState.ready) {
                    that._cancelHover();
                    return
                }
                if (isTouchEvent(event) !== isTouch)
                    return;
                if (that._hoverTarget === event.target)
                    return;
                if (that._hoverState && that._hoverState.data === data)
                    return;
                that._cancelHover();
                if (data) {
                    that._hoverState = {data: data};
                    that._callbacks[EVENT_HOVER_ON]({data: data})
                }
                that._hoverTarget = event.target
            },
            _cancelHover: function() {
                var state = this._hoverState;
                this._hoverState = this._hoverTarget = null;
                if (state)
                    this._callbacks[EVENT_HOVER_OFF]({data: state.data})
            },
            _startFocus: function(event, data) {
                this._doFocus(event, data, true)
            },
            _moveFocus: function(event, data) {
                this._doFocus(event, data, false)
            },
            _doFocus: function(event, data, isTouch) {
                var that = this;
                if (that._dragState && that._dragState.active || that._zoomState && that._zoomState.ready) {
                    that._cancelFocus();
                    return
                }
                if (isTouchEvent(event) !== isTouch)
                    return;
                that._focus.turnOff(isTouch ? FOCUS_OFF_DELAY_TOUCH : FOCUS_OFF_DELAY_MOUSE);
                if (data)
                    that._focus.turnOn(data, getEventCoords(event), isTouch ? FOCUS_ON_DELAY_TOUCH : FOCUS_ON_DELAY_MOUSE, isTouch)
            },
            _endFocus: function(event, data) {
                if (!isTouchEvent(event))
                    return;
                this._focus.cancelOn()
            },
            _cancelFocus: function() {
                this._focus.cancel()
            },
            _createEventHandlers: function(DATA_KEY) {
                var that = this;
                that._handlers = {};
                that._handlers[EVENTS.start] = function(event) {
                    var isTouch = isTouchEvent(event),
                        data = $(event.target).data(DATA_KEY);
                    if (isTouch && !that._isTouchEnabled)
                        return;
                    if (data)
                        event.preventDefault();
                    that._startClick(event, data);
                    that._startDrag(event, data);
                    that._startZoom(event, data);
                    that._startHover(event, data);
                    that._startFocus(event, data)
                };
                that._handlers[EVENTS.move] = function(event) {
                    var isTouch = isTouchEvent(event),
                        data = $(event.target).data(DATA_KEY);
                    if (isTouch && !that._isTouchEnabled)
                        return;
                    that._moveDrag(event, data);
                    that._moveZoom(event, data);
                    that._moveHover(event, data);
                    that._moveFocus(event, data)
                };
                that._handlers[EVENTS.end] = function(event) {
                    var isTouch = isTouchEvent(event),
                        data = $(event.target).data(DATA_KEY);
                    if (isTouch && !that._isTouchEnabled)
                        return;
                    that._endClick(event, data);
                    that._endDrag(event, data);
                    that._endZoom(event, data);
                    that._endFocus(event, data)
                };
                that._handlers[EVENTS.wheel] = function(event) {
                    if (!that._isWheelEnabled)
                        return;
                    var data = $(event.target).data(DATA_KEY);
                    if (data)
                        event.preventDefault();
                    that._wheelZoom(event, data)
                };
                that._wheelLock = {dir: 0}
            },
            reset: function() {
                var that = this;
                that._clickState = null;
                that._endDrag();
                that._cancelHover();
                that._cancelFocus();
                return that
            },
            setCallbacks: function(callbacks) {
                $.extend(this._callbacks, callbacks);
                return this
            },
            setOptions: function(options) {
                var that = this;
                that.reset();
                that._detachHandlers();
                that._isTouchEnabled = _parseBool(options.touchEnabled, true);
                that._isWheelEnabled = _parseBool(options.wheelEnabled, true);
                that._attachHandlers();
                return that
            },
            _detachHandlers: function() {
                if (this._isTouchEnabled) {
                    this._root.css({
                        'touch-action': '',
                        '-ms-touch-action': '',
                        '-webkit-user-select': ''
                    });
                    $(this._root.element).off(_addNamespace('MSHoldVisual', _NAME)).off(_addNamespace('contextmenu', _NAME))
                }
                $(document).off(this._handlers)
            },
            _attachHandlers: function() {
                if (this._isTouchEnabled) {
                    this._root.css({
                        'touch-action': 'none',
                        '-ms-touch-action': 'none',
                        '-webkit-user-select': 'none'
                    });
                    $(this._root.element).on(_addNamespace('MSHoldVisual', _NAME), function(event) {
                        event.preventDefault()
                    }).on(_addNamespace('contextmenu', _NAME), function(event) {
                        isTouchEvent(event) && event.preventDefault()
                    })
                }
                $(document).on(this._handlers)
            }
        };
        function Focus(callbacks) {
            var that = this,
                _activeData = null,
                _data = null,
                _disabled = false,
                _onTimer = null,
                _offTimer = null,
                _x,
                _y;
            that.dispose = function() {
                clearTimeout(_onTimer);
                clearTimeout(_offTimer);
                that.turnOn = that.turnOff = that.cancel = that.cancelOn = that.dispose = that = callbacks = _activeData = _data = _onTimer = _offTimer = null
            };
            that.turnOn = function(data, coords, timeout, forceTimeout) {
                if (data === _data && _disabled)
                    return;
                _disabled = false;
                _data = data;
                if (_activeData) {
                    _x = coords.x;
                    _y = coords.y;
                    clearTimeout(_onTimer);
                    _onTimer = setTimeout(function() {
                        _onTimer = null;
                        if (_data === _activeData) {
                            callbacks[EVENT_FOCUS_MOVE]({
                                data: _data,
                                x: _x,
                                y: _y
                            });
                            onCheck(true)
                        }
                        else
                            callbacks[EVENT_FOCUS_ON]({
                                data: _data,
                                x: _x,
                                y: _y
                            }, onCheck)
                    }, forceTimeout ? timeout : 0)
                }
                else if (!_onTimer || _abs(coords.x - _x) > FOCUS_COORD_THRESHOLD_MOUSE || _abs(coords.y - _y) > FOCUS_COORD_THRESHOLD_MOUSE || forceTimeout) {
                    _x = coords.x;
                    _y = coords.y;
                    clearTimeout(_onTimer);
                    _onTimer = setTimeout(function() {
                        _onTimer = null;
                        callbacks[EVENT_FOCUS_ON]({
                            data: _data,
                            x: _x,
                            y: _y
                        }, onCheck)
                    }, timeout)
                }
                function onCheck(result) {
                    _disabled = !result;
                    if (result) {
                        _activeData = _data;
                        clearTimeout(_offTimer);
                        _offTimer = null
                    }
                }
            };
            that.turnOff = function(timeout) {
                clearTimeout(_onTimer);
                _onTimer = null;
                _data = null;
                if (_activeData && !_disabled)
                    _offTimer = _offTimer || setTimeout(function() {
                        _offTimer = null;
                        callbacks[EVENT_FOCUS_OFF]({data: _activeData});
                        _activeData = null
                    }, timeout)
            };
            that.cancel = function() {
                clearTimeout(_onTimer);
                clearTimeout(_offTimer);
                if (_activeData)
                    callbacks[EVENT_FOCUS_OFF]({data: _activeData});
                _activeData = _data = _onTimer = _offTimer = null
            };
            that.cancelOn = function() {
                clearTimeout(_onTimer);
                _onTimer = null
            }
        }
        DX.viz.map._tests.Tracker = Tracker;
        DX.viz.map._tests._DEBUG_forceEventMode = function(mode) {
            setupEvents(mode)
        };
        DX.viz.map._tests.Focus = Focus;
        DX.viz.map._tests._DEBUG_stubFocusType = function(focusType) {
            Focus = focusType
        };
        DX.viz.map._tests._DEBUG_restoreFocusType = function() {
            Focus = DX.viz.map._tests.Focus
        };
        DX.viz.map.dxVectorMap.prototype._factory.createTracker = function(parameters) {
            return new Tracker(parameters)
        };
        function getDistance(x1, y1, x2, y2) {
            return _sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))
        }
        function isTouchEvent(event) {
            var type = event.originalEvent.type,
                pointerType = event.originalEvent.pointerType;
            return /^touch/.test(type) || /^MSPointer/.test(type) && pointerType !== 4 || /^pointer/.test(type) && pointerType !== 'mouse'
        }
        function selectItem(flags, items) {
            var i = 0,
                ii = flags.length,
                item;
            for (; i < ii; ++i)
                if (flags[i]) {
                    item = items[i];
                    break
                }
            return _addNamespace(item || items[i], _NAME)
        }
        function setupEvents() {
            var flags = [navigator.pointerEnabled, navigator.msPointerEnabled, 'ontouchstart' in window];
            if (arguments.length)
                flags = [arguments[0] === 'pointer', arguments[0] === 'MSPointer', arguments[0] === 'touch'];
            EVENTS = {
                start: selectItem(flags, ['pointerdown', 'MSPointerDown', 'touchstart mousedown', 'mousedown']),
                move: selectItem(flags, ['pointermove', 'MSPointerMove', 'touchmove mousemove', 'mousemove']),
                end: selectItem(flags, ['pointerup', 'MSPointerUp', 'touchend mouseup', 'mouseup']),
                wheel: selectItem([], ['mousewheel DOMMouseScroll'])
            }
        }
        function getEventCoords(event) {
            var originalEvent = event.originalEvent,
                touch = originalEvent.touches && originalEvent.touches[0] || {};
            return {
                    x: touch.pageX || originalEvent.pageX || event.pageX,
                    y: touch.pageY || originalEvent.pageY || event.pageY
                }
        }
        function getPointerId(event) {
            return event.originalEvent.pointerId
        }
        function getMultitouchEventCoords(event, pointerId) {
            var originalEvent = event.originalEvent;
            if (originalEvent.pointerId !== undefined)
                originalEvent = originalEvent.pointerId === pointerId ? originalEvent : null;
            else
                originalEvent = originalEvent.touches[pointerId];
            return originalEvent ? {
                    x: originalEvent.pageX || event.pageX,
                    y: originalEvent.pageY || event.pageY
                } : null
        }
        function adjustWheelDelta(delta, lock) {
            if (delta === 0)
                return 0;
            var _delta = _abs(delta),
                sign = _round(delta / _delta);
            if (lock.dir && sign !== lock.dir)
                return 0;
            lock.dir = sign;
            if (_delta < 0.1)
                _delta = 0;
            else if (_delta < 1)
                _delta = 1;
            else if (_delta > 4)
                _delta = 4;
            else
                _delta = _round(_delta);
            return sign * _delta
        }
    })(DevExpress, jQuery);
    /*! Module viz-vectormap, file themeManager.js */
    (function(DX, $, undefined) {
        var _Number = Number,
            _parseBool = DX.viz.core.utils.parseBool,
            _extend = $.extend,
            _each = $.each;
        var ThemeManager = DX.viz.core.BaseThemeManager.inherit({
                _themeSection: 'map',
                _fontFields: ['areaSettings.label.font', 'markerSettings.label.font', 'tooltip.font', 'legend.font', 'loadingIndicator.font'],
                getCommonAreaSettings: function(options) {
                    var settings = _extend(true, {}, this._theme.areaSettings, options),
                        palette,
                        i,
                        colors;
                    if (settings.paletteSize > 0) {
                        palette = new DX.viz.core.GradientPalette(settings.palette, settings.paletteSize);
                        for (i = 0, colors = []; i < settings.paletteSize; ++i)
                            colors.push(palette.getColor(i));
                        settings._colors = colors
                    }
                    return settings
                },
                getAreaSettings: function(commonSettings, options) {
                    var settings = _extend(true, {}, commonSettings, options);
                    settings.borderWidth = _Number(settings.borderWidth) || 0;
                    settings.borderColor = settings.borderColor || null;
                    if (options.color === undefined && options.paletteIndex >= 0)
                        settings.color = commonSettings._colors[options.paletteIndex];
                    settings.color = settings.color || null;
                    settings.hoveredBorderWidth = _Number(settings.hoveredBorderWidth) || settings.borderWidth;
                    settings.hoveredBorderColor = settings.hoveredBorderColor || settings.borderColor;
                    settings.hoveredColor = settings.hoveredColor || settings.color;
                    settings.selectedBorderWidth = _Number(settings.selectedBorderWidth) || settings.borderWidth;
                    settings.selectedBorderColor = settings.selectedBorderColor || settings.borderColor;
                    settings.selectedColor = settings.selectedColor || settings.color;
                    return settings
                },
                getCommonMarkerSettings: function(options) {
                    options && !options.label && options.font && (options.label = {font: options.font}) && (options.font = undefined);
                    var theme = _extend({}, this._theme.markerSettings),
                        _options = _extend({}, options),
                        themeParts = {},
                        optionsParts = {},
                        settings;
                    _each(theme, function(name, themePart) {
                        if (name[0] === '_') {
                            themeParts[name] = themePart;
                            optionsParts[name] = _options[name];
                            theme[name] = _options[name] = undefined
                        }
                    });
                    settings = _extend(true, {}, theme, _options);
                    _each(themeParts, function(name, themePart) {
                        settings[name] = _extend(true, {}, theme, themePart, _options, optionsParts[name])
                    });
                    return settings
                },
                getMarkerSettings: function(commonSettings, options, type) {
                    var settings = _extend(true, {}, commonSettings['_' + type], options);
                    settings.borderWidth = _Number(settings.borderWidth) || 0;
                    settings.borderColor = settings.borderColor || null;
                    settings.color = settings.color || null;
                    settings.opacity = settings.opacity || null;
                    settings.hoveredBorderWidth = _Number(settings.hoveredBorderWidth) || settings.borderWidth;
                    settings.hoveredBorderColor = settings.hoveredBorderColor || settings.borderColor;
                    settings.hoveredColor = settings.hoveredColor || settings.color;
                    settings.hoveredOpacity = settings.hoveredOpacity || settings.opacity;
                    settings.selectedBorderWidth = _Number(settings.selectedBorderWidth) || settings.borderWidth;
                    settings.selectedBorderColor = settings.selectedBorderColor || settings.borderColor;
                    settings.selectedColor = settings.selectedColor || settings.color;
                    settings.selectedOpacity = settings.selectedOpacity || settings.opacity;
                    return settings
                },
                getPieColors: function(commonSettings, count) {
                    var colors = commonSettings._pie._colors || [],
                        palette,
                        i,
                        _count = count > 8 ? count : 8;
                    if (colors.length < _count) {
                        palette = new DX.viz.core.Palette(commonSettings._pie.palette, {
                            stepHighlight: 50,
                            theme: this.themeName()
                        });
                        for (i = 0, colors = []; i < _count; ++i)
                            colors.push(palette.getNextColor());
                        commonSettings._pie._colors = colors
                    }
                    return colors
                },
                setTheme: function(theme, rtlEnabledOption) {
                    var that = this;
                    that.callBase(theme);
                    if (_parseBool(rtlEnabledOption, that._theme.rtlEnabled))
                        _extend(true, that._theme, that._theme._rtl);
                    return that
                }
            });
        DX.viz.map._tests.ThemeManager = ThemeManager;
        DX.viz.map.dxVectorMap.prototype._factory.createThemeManager = function() {
            return new ThemeManager
        }
    })(DevExpress, jQuery);
    /*! Module viz-vectormap, file legend.js */
    (function(DX, $, undefined) {
        var _String = String,
            _isArray = DX.utils.isArray,
            _extend = $.extend,
            _each = $.each,
            _BaseLegend = DX.viz.core.Legend;
        function Legend(parameters) {
            var that = this;
            that._params = parameters;
            that._root = parameters.renderer.g().attr({'class': 'dxm-legend'});
            parameters.layoutControl.addItem(that);
            _BaseLegend.apply(that, [null, null, parameters.renderer, that._root]);
            that._onDataChanged = function(items) {
                var itemsForUpdate = $.map(items, function(item) {
                        return _extend(true, {states: {normal: {fill: item.color}}}, item)
                    });
                that.update(itemsForUpdate, that._options);
                that._refresh()
            }
        }
        var legendPrototype = Legend.prototype = DX.utils.clone(_BaseLegend.prototype);
        legendPrototype.constructor = Legend;
        legendPrototype._backgroundClass = null;
        legendPrototype._itemGroupClass = null;
        legendPrototype._defaults = {
            customizeText: function(arg) {
                return arg.text
            },
            customizeHint: $.noop
        };
        legendPrototype._createLabelFormatObject = function(data) {
            return data
        };
        legendPrototype.dispose = function() {
            var that = this;
            that._params.layoutControl.removeItem(that);
            that._unbindData();
            that._params = that._root = that._onDataChanged = null;
            return _BaseLegend.prototype.dispose.apply(that, arguments)
        };
        legendPrototype.clean = function() {
            this._rendered = false;
            this._root.remove();
            return this
        };
        legendPrototype.render = function() {
            var that = this;
            that._root.append(that._params.container);
            that._rendered = true;
            that._refresh();
            return that
        };
        legendPrototype.resize = function(size) {
            if (size === null)
                this.erase();
            else
                this.setSize(size).draw();
            return this
        };
        legendPrototype.locate = _BaseLegend.prototype.shift;
        legendPrototype._unbindData = function() {
            if (this._dataCategory)
                this._params.dataExchanger.unbind(this._dataCategory, this._dataName)
        };
        legendPrototype._bindData = function(info) {
            this._params.dataExchanger.bind(this._dataCategory = info.category, this._dataName = info.name, this._onDataChanged)
        };
        var sourceMap = {
                areacolorgroups: {
                    category: 'areas',
                    name: 'color'
                },
                markercolorgroups: {
                    category: 'markers',
                    name: 'color'
                },
                markersizegroups: {
                    category: 'markers',
                    name: 'size'
                }
            };
        var unknownSource = {
                category: 'UNKNOWN',
                name: 'UNKNOWN'
            };
        legendPrototype.setOptions = function(options) {
            var that = this;
            that.update(that._data, options);
            that._unbindData();
            that._bindData(sourceMap[_String(options.source).toLowerCase()] || unknownSource);
            that._refresh();
            return that
        };
        legendPrototype._refresh = function() {
            if (this._rendered)
                this.updateLayout()
        };
        function LegendsControl(parameters) {
            this._parameters = parameters;
            this._items = []
        }
        LegendsControl.prototype = {
            constructor: LegendsControl,
            dispose: function() {
                _each(this._items, function(_, item) {
                    item.dispose()
                });
                this._parameters = this._items = null;
                return this
            },
            setOptions: function(options, theme) {
                var optionList = _isArray(options) ? options : [],
                    i = 0,
                    ii = optionList.length,
                    item,
                    newItems = [],
                    items = this._items;
                for (ii = optionList.length; i < ii; ++i) {
                    item = (items[i] || new Legend(this._parameters)).setOptions(_extend(true, {}, theme, optionList[i]));
                    newItems.push(item)
                }
                for (ii = items.length; i < ii; ++i)
                    items[i].clean().dispose();
                this._items = newItems
            },
            clean: function() {
                _each(this._items, function(_, item) {
                    item.clean()
                });
                return this
            },
            render: function() {
                _each(this._items, function(_, item) {
                    item.render()
                });
                return this
            }
        };
        DX.viz.map.dxVectorMap.prototype._factory.createLegendsControl = function(parameters) {
            return new LegendsControl(parameters)
        };
        DX.viz.map._tests.Legend = Legend;
        DX.viz.map._tests.LegendsControl = LegendsControl;
        DX.viz.map._tests.stubLegendType = function(stub) {
            Legend = stub
        };
        DX.viz.map._tests.restoreLegendType = function() {
            Legend = DX.viz.map._tests.Legend
        };
        DX.viz.map._tests.extendLegendSourceMap = function(name, value) {
            sourceMap[name] = value
        }
    })(DevExpress, jQuery);
    /*! Module viz-vectormap, file tooltip.js */
    (function(DX, undefined) {
        var Tooltip = DX.viz.core.Tooltip.inherit({
                ctor: function(parameters) {
                    var that = this;
                    that._container = parameters.container;
                    that._root = parameters.renderer.g().attr({'class': 'dxm-tooltip'});
                    that.callBase(null, that._root, parameters.renderer)
                },
                dispose: function() {
                    var that = this;
                    that._container = that._root = null;
                    return that.callBase.apply(that, arguments)
                },
                clean: function() {
                    this._root.remove();
                    return this
                },
                setOptions: function(options) {
                    options.border.color = options.borderColor || options.border.color;
                    this.update(options);
                    return this
                },
                render: function() {
                    this._root.append(this._container);
                    return this
                }
            });
        DX.viz.map.dxVectorMap.prototype._factory.createTooltip = function(parameters) {
            return new Tooltip(parameters)
        };
        DX.viz.map._tests.Tooltip = Tooltip
    })(DevExpress);
    /*! Module viz-vectormap, file layout.js */
    (function(DX, $, undefined) {
        var _round = Math.round,
            _min = Math.min,
            _max = Math.max,
            _each = $.each,
            _inArray = $.inArray;
        var horizontalAlignmentMap = {
                left: 0,
                center: 1,
                right: 2
            };
        var verticalAlignmentMap = {
                top: 0,
                bottom: 1
            };
        function getCellIndex(options) {
            return verticalAlignmentMap[options.verticalAlignment] * 3 + horizontalAlignmentMap[options.horizontalAlignment]
        }
        function createCells(canvas, items) {
            var hstep = (canvas.right - canvas.left) / 3,
                vstep = (canvas.bottom - canvas.top) / 2,
                h1 = canvas.left,
                h2 = _round(h1 + hstep),
                h3 = _round(h1 + hstep + hstep),
                h4 = canvas.right,
                v1 = canvas.top,
                v2 = _round(v1 + vstep),
                v3 = canvas.bottom,
                cells = [{rect: [h1, v1, h2, v2]}, {
                        rect: [h2, v1, h3, v2],
                        center: true
                    }, {
                        rect: [h3, v1, h4, v2],
                        horInv: true
                    }, {
                        rect: [h1, v2, h2, v3],
                        verInv: true
                    }, {
                        rect: [h2, v2, h3, v3],
                        center: true,
                        verInv: true
                    }, {
                        rect: [h3, v2, h4, v3],
                        horInv: true,
                        verInv: true
                    }],
                itemsList = [[], [], [], [], [], []];
            _each(items, function(_, item) {
                var options = item.getLayoutOptions();
                if (options)
                    itemsList[getCellIndex(options)].push({
                        item: item,
                        width: options.width,
                        height: options.height
                    })
            });
            _each(cells, function(i, cell) {
                if (itemsList[i].length)
                    cell.items = itemsList[i];
                else {
                    if (cell.center)
                        cell.rect[0] = cell.rect[2] = (cell.rect[0] + cell.rect[2]) / 2;
                    else
                        cell.rect[cell.horInv ? 0 : 2] = cell.rect[cell.horInv ? 2 : 0];
                    cell.rect[cell.verInv ? 1 : 3] = cell.rect[cell.verInv ? 3 : 1]
                }
            });
            return cells
        }
        function adjustCellSizes(cells) {
            _each([0, 1, 2, 3, 4, 5], function(_, index) {
                var cell = cells[index],
                    otherCell = cells[(index + 3) % 6];
                if (cell.items)
                    if (!otherCell.items) {
                        cell.rect[1] = _min(cell.rect[1], otherCell.rect[3]);
                        cell.rect[3] = _max(cell.rect[3], otherCell.rect[1])
                    }
            });
            _each([1, 4], function(_, index) {
                var cell = cells[index],
                    otherCell1 = cells[index - 1],
                    otherCell2 = cells[index + 1],
                    size1,
                    size2;
                if (cell.items) {
                    if (!otherCell1.items && !otherCell2.items) {
                        size1 = cell.rect[0] - otherCell1.rect[2];
                        size2 = otherCell2.rect[0] - cell.rect[2];
                        if (size1 > size2)
                            if (size1 / size2 >= 2) {
                                cell.rect[0] -= size1;
                                cell.right = true
                            }
                            else {
                                cell.rect[0] -= size2;
                                cell.rect[2] += size2
                            }
                        else if (size2 / size1 >= 2) {
                            cell.rect[2] += size2;
                            cell.center = null
                        }
                        else {
                            cell.rect[0] -= size1;
                            cell.rect[2] += size1
                        }
                    }
                }
                else {
                    if (otherCell1.items)
                        otherCell1.rect[2] = (cell.rect[0] + cell.rect[2]) / 2;
                    if (otherCell2.items)
                        otherCell2.rect[0] = (cell.rect[0] + cell.rect[2]) / 2
                }
            })
        }
        function adjustCellsAndApplyLayout(cells, forceMode) {
            var hasHiddenItems = false;
            adjustCellSizes(cells);
            _each(cells, function(_, cell) {
                if (cell.items)
                    hasHiddenItems = applyCellLayout(cell, forceMode) || hasHiddenItems
            });
            return hasHiddenItems
        }
        function applyCellLayout(cell, forceMode) {
            var cellRect = cell.rect,
                cellWidth = cellRect[2] - cellRect[0],
                cellHeight = cellRect[3] - cellRect[1],
                xoffset = 0,
                yoffset = 0,
                currentHeight = 0,
                totalL = cellRect[2],
                totalT = cellRect[3],
                totalR = cellRect[0],
                totalB = cellRect[1],
                moves = [],
                hasHiddenItems = false;
            _each(cell.items, function(_, item) {
                if (item.width > cellWidth || item.height > cellHeight) {
                    moves.push(null);
                    hasHiddenItems = true;
                    return forceMode || false
                }
                if (xoffset + item.width > cellWidth) {
                    yoffset += currentHeight;
                    xoffset = currentHeight = 0
                }
                if (yoffset + item.height > cellHeight) {
                    moves.push(null);
                    hasHiddenItems = true;
                    return forceMode || false
                }
                currentHeight = _max(currentHeight, item.height);
                var dx = cell.horInv ? cellRect[2] - item.width - xoffset : cellRect[0] + xoffset,
                    dy = cell.verInv ? cellRect[3] - item.height - yoffset : cellRect[1] + yoffset;
                xoffset += item.width;
                totalL = _min(totalL, dx);
                totalT = _min(totalT, dy);
                totalR = _max(totalR, dx + item.width);
                totalB = _max(totalB, dy + item.height);
                moves.push([dx, dy])
            });
            if (forceMode || !hasHiddenItems) {
                xoffset = 0;
                if (cell.right)
                    xoffset = cellRect[2] - cellRect[0] - totalR + totalL;
                else if (cell.center)
                    xoffset = _round((cellRect[2] - cellRect[0] - totalR + totalL) / 2);
                _each(cell.items, function(i, item) {
                    var move = moves[i];
                    if (move)
                        item.item.locate(move[0] + xoffset, move[1]);
                    else
                        item.item.resize(null)
                });
                cell.rect = [totalL, totalT, totalR, totalB];
                cell.items = null
            }
            return hasHiddenItems
        }
        function applyLayout(canvas, items) {
            var cells = createCells(canvas, items);
            if (adjustCellsAndApplyLayout(cells))
                adjustCellsAndApplyLayout(cells, true)
        }
        function LayoutControl() {
            var that = this;
            that._items = [];
            that._suspended = true;
            that._updateLayout = function() {
                that._update()
            }
        }
        LayoutControl.prototype = {
            constructor: LayoutControl,
            dispose: function() {
                this._items = this._updateLayout = null;
                return this
            },
            setSize: function(width, height) {
                this._size = {
                    width: width,
                    height: height
                };
                this._update();
                return this
            },
            stop: function() {
                this._suspended = true;
                return this
            },
            start: function() {
                this._suspended = null;
                this._update();
                return this
            },
            addItem: function(item) {
                this._items.push(item);
                item.updateLayout = this._updateLayout;
                return this
            },
            removeItem: function(item) {
                this._items.splice(_inArray(item, this._items), 1);
                item.updateLayout = null;
                return this
            },
            _update: function() {
                if (this._suspended)
                    return;
                var size = this._size;
                _each(this._items, function(_, item) {
                    item.resize(size)
                });
                applyLayout({
                    left: 0,
                    top: 0,
                    right: size.width,
                    bottom: size.height
                }, this._items)
            }
        };
        DX.viz.map.dxVectorMap.prototype._factory.createLayoutControl = function() {
            return new LayoutControl
        };
        DX.viz.map._tests.LayoutControl = LayoutControl
    })(DevExpress, jQuery);
    /*! Module viz-vectormap, file mapItemsManager.js */
    (function(DX, $, undefined) {
        var _Number = Number,
            _String = String,
            _isFinite = isFinite,
            _isString = DX.utils.isString,
            _isArray = DX.utils.isArray,
            _isFunction = DX.utils.isFunction,
            _extend = $.extend,
            _each = $.each,
            _map = $.map,
            _noop = $.noop;
        var SELECTION_MODE_NONE = 'none',
            SELECTION_MODE_SINGLE = 'single',
            SELECTION_MODE_MULTIPLE = 'multiple';
        function createEventTriggers(context, trigger, names) {
            context.raiseHoverChanged = function(handle, state) {
                trigger(names.hoverChanged, {
                    target: handle.proxy,
                    state: state
                })
            };
            context.raiseSelectionChanged = function(handle) {
                trigger(names.selectionChanged, {target: handle.proxy})
            }
        }
        var MapItemsManager = DX.Class.inherit({
                _rootClass: null,
                ctor: function(parameters) {
                    var that = this;
                    that._params = parameters;
                    that._init();
                    parameters.projection.on({
                        project: function() {
                            that._reproject()
                        },
                        transform: function(transform) {
                            that._transform(transform);
                            that._relocate()
                        },
                        center: function(_, transform) {
                            that._transform(transform)
                        },
                        zoom: function(_, transform) {
                            that._transform(transform);
                            that._relocate()
                        }
                    })
                },
                _init: function() {
                    var that = this;
                    that._root = that._params.renderer.g().attr({'class': that._rootClass});
                    that._context = {
                        renderer: that._params.renderer,
                        root: that._root,
                        projection: that._params.projection,
                        dataKey: that._params.dataKey
                    };
                    createEventTriggers(that._context, that._params.eventTrigger, that._eventNames)
                },
                dispose: function() {
                    this._destroyHandles();
                    this._params = null;
                    this._dispose();
                    return this
                },
                _dispose: function() {
                    this._root = this._context = null
                },
                clean: function() {
                    this._rendered = false;
                    this._clean();
                    this._destroyItems();
                    return this
                },
                _clean: function() {
                    this._root.remove()
                },
                setOptions: function(options) {
                    var that = this;
                    that._processOptions(options || {});
                    if (that._rendered) {
                        that._destroyItems();
                        that._createItems()
                    }
                    return that
                },
                render: function() {
                    this._rendered = true;
                    this._render();
                    this._createItems();
                    return this
                },
                _processOptions: function(options) {
                    var that = this,
                        settings = that._commonSettings = that._getCommonSettings(options);
                    that._customizeCallback = _isFunction(settings.customize) ? settings.customize : null;
                    var context = that._context;
                    context.isHoverEnabled = 'hoverEnabled' in settings ? !!settings.hoverEnabled : true;
                    var selectionMode = _String(settings.selectionMode).toLowerCase();
                    selectionMode = selectionMode === SELECTION_MODE_NONE || selectionMode === SELECTION_MODE_SINGLE || selectionMode === SELECTION_MODE_MULTIPLE ? selectionMode : SELECTION_MODE_SINGLE;
                    context.isSelectionEnabled = selectionMode !== SELECTION_MODE_NONE;
                    context.isSingleSelection = selectionMode === SELECTION_MODE_SINGLE;
                    context.selected = context.isSingleSelection ? null : {}
                },
                _getCommonSettings: null,
                _render: function() {
                    this._root.append(this._params.container)
                },
                _destroyItems: function() {
                    this._root.clear();
                    this._handles && _each(this._handles, function(_, handle) {
                        if (handle.item) {
                            handle.item.clean().dispose();
                            handle.item = null
                        }
                    })
                },
                _destroyHandles: function() {
                    var that = this;
                    that._handles && _each(that._handles, function(_, handle) {
                        handle.dispose()
                    });
                    that._handles = null
                },
                _itemType: null,
                _initProxy: null,
                _getItemSettings: null,
                _createItem: null,
                _arrangeItems: null,
                _prepareItems: null,
                _createHandles: function(source) {
                    var that = this;
                    if (_isArray(source)) {
                        that._handles = _map(source, function(dataItem, i) {
                            dataItem = dataItem || {};
                            var handle = new MapItemHandle(that._context, that._getItemCoordinates(dataItem), that._getItemAttributes(dataItem), i, that._itemType),
                                proxy = handle.proxy;
                            that._initProxy(proxy, dataItem);
                            handle.settings = that._customizeCallback && that._customizeCallback.call(proxy, proxy) || {};
                            if (handle.settings.isSelected)
                                proxy.selected(true);
                            return handle
                        });
                        that._prepareItems()
                    }
                },
                _createItems: function() {
                    var that = this,
                        selectedItems = [];
                    if (that._handles) {
                        _each(that._handles, function(i, handle) {
                            var settings = that._getItemSettings(handle.proxy, handle.settings);
                            handle.item = that._createItem(settings).init(that._context, handle.proxy).render(settings).project().locate();
                            if (handle.proxy.selected())
                                selectedItems.push(handle.item)
                        });
                        _each(selectedItems, function(_, item) {
                            item.setSelectedState()
                        });
                        that._arrangeItems();
                        if (that._commonSettings.label.enabled) {
                            that._labelsTimeout && clearTimeout(that._labelsTimeout);
                            that._labelsTimeout = setTimeout(function() {
                                that._labelsTimeout = null;
                                if (that._rendered)
                                    _each(that._handles, function(_, handle) {
                                        handle.item.createLabel()
                                    })
                            })
                        }
                    }
                    that._params.ready && that._params.ready()
                },
                _processSource: null,
                setData: function(data) {
                    var that = this;
                    if (_isString(data))
                        $.getJSON(data).done(updateSource).fail(function(_0, _1, error) {
                            updateSource(null)
                        });
                    else
                        updateSource(data);
                    return that;
                    function updateSource(source) {
                        if (that._rendered)
                            that._params.tracker.reset();
                        that._destroyItems();
                        that._destroyHandles();
                        that._createHandles(that._processSource(source));
                        if (that._rendered)
                            that._createItems()
                    }
                },
                _transform: function(transform) {
                    this._root.attr(transform)
                },
                _reproject: function() {
                    this._rendered && this._handles && _each(this._handles, function(_, handle) {
                        handle.item.project().locate()
                    })
                },
                _relocate: function() {
                    this._rendered && this._handles && _each(this._handles, function(_, handle) {
                        handle.item.locate()
                    })
                },
                hoverItem: function(index, state) {
                    this._handles[index].setHovered(state);
                    return this
                },
                selectItem: function(index, state, noCallback) {
                    this._handles[index].setSelected(state, noCallback);
                    return this
                },
                clearSelection: function() {
                    var context = this._context;
                    if (context.isSelectionEnabled)
                        if (context.isSingleSelection)
                            context.selected && context.selected.setSelected(false);
                        else {
                            _each(context.selected, function(_, handle) {
                                handle && handle.setSelected(false)
                            });
                            context.selected = {}
                        }
                    return this
                },
                raiseClick: function(index, $event) {
                    this._params.eventTrigger(this._eventNames.click, {
                        target: this._handles[index].proxy,
                        jQueryEvent: $event
                    });
                    return this
                },
                getProxyItems: function() {
                    return _map(this._handles, function(handle) {
                            return handle.proxy
                        })
                },
                getProxyItem: function(index) {
                    return this._handles[index].proxy
                },
                _performGrouping: function(partition, settingField, valueCallback, valuesCallback) {
                    var groups = createGroups(partition),
                        values;
                    if (groups) {
                        values = valuesCallback(groups.length);
                        _each(this._handles, function(i, handle) {
                            var value,
                                index;
                            if (_isFinite(value = valueCallback(handle, i)) && (index = findGroupPosition(value, groups)) >= 0)
                                handle.settings[settingField] = values[index]
                        });
                        _each(groups, function(i, group) {
                            group.index = i;
                            group[settingField] = values[i]
                        });
                        this._params.dataExchanger.set(this._dataCategory, settingField, groups)
                    }
                },
                _groupByColor: function(colorGroups, palette, valueCallback) {
                    this._performGrouping(colorGroups, 'color', valueCallback, function(count) {
                        var _palette = new DX.viz.core.GradientPalette(palette, count),
                            i = 0,
                            list = [];
                        for (; i < count; ++i)
                            list.push(_palette.getColor(i));
                        return list
                    })
                }
            });
        DX.viz.map._internal.mapItemBehavior = {
            init: function(ctx, proxy) {
                this._ctx = ctx;
                this._data = {
                    index: proxy.index,
                    type: proxy.type
                };
                this._proxy = proxy;
                return this
            },
            dispose: function() {
                disposeItem(this);
                return this
            },
            project: function() {
                var that = this;
                that._coords = that._project(that._ctx.projection, that._proxy.coordinates());
                return this
            },
            locate: function() {
                var that = this;
                that._locate(that._transform(that._ctx.projection, that._coords));
                return that
            },
            clean: function() {
                this._root.remove();
                this._root = null;
                return this
            },
            render: function(settings) {
                var that = this;
                that._root = that._createRoot().append(that._ctx.root);
                that._settings = settings;
                that._render(settings);
                return that
            }
        };
        function MapItemHandle(context, coordinates, attributes, index, type) {
            var that = this;
            that._ctx = context;
            attributes = _extend({}, attributes);
            that.proxy = {
                index: index,
                type: type,
                coordinates: function() {
                    return coordinates
                },
                attribute: function(name, value) {
                    if (arguments.length > 1) {
                        attributes[name] = value;
                        return this
                    }
                    else
                        return arguments.length > 0 ? attributes[name] : attributes
                },
                selected: function(state, _noEvent) {
                    if (arguments.length > 0) {
                        that.setSelected(!!state, _noEvent);
                        return this
                    }
                    else
                        return that._selected
                }
            }
        }
        MapItemHandle.prototype = {
            constructor: MapItemHandle,
            _hovered: false,
            _selected: false,
            dispose: function() {
                disposeItem(this.proxy);
                disposeItem(this);
                return this
            },
            setHovered: function(state) {
                var that = this;
                if (!that._ctx.isHoverEnabled)
                    return that;
                if (that._hovered !== !!state) {
                    that._hovered = !!state;
                    var item = that.item;
                    if (item) {
                        if (that._hovered)
                            item.onHover();
                        if (!that._selected) {
                            item[that._hovered ? 'setHoveredState' : 'setDefaultState']();
                            that._ctx.raiseHoverChanged(that, that._hovered)
                        }
                    }
                }
                return that
            },
            setSelected: function(state, _noEvent) {
                var that = this,
                    context = that._ctx;
                if (!context.isSelectionEnabled)
                    return that;
                if (that._selected !== !!state) {
                    that._selected = !!state;
                    var selected = context.selected;
                    if (context.isSingleSelection) {
                        context.selected = null;
                        if (selected)
                            selected.setSelected(false);
                        if (that._selected)
                            context.selected = that
                    }
                    else
                        context.selected[that.proxy.index] = that._selected ? that : null;
                    var item = that.item;
                    if (item) {
                        item[that._selected ? 'setSelectedState' : that._hovered ? 'setHoveredState' : 'setDefaultState']();
                        if (!_noEvent)
                            context.raiseSelectionChanged(that)
                    }
                }
                return that
            }
        };
        function disposeItem(item) {
            _each(item, function(name) {
                item[name] = null
            })
        }
        function createGroups(partition) {
            var i,
                ii,
                groups = null;
            if (_isArray(partition) && partition.length > 1) {
                groups = [];
                for (i = 0, ii = partition.length - 1; i < ii; ++i)
                    groups.push({
                        start: _Number(partition[i]),
                        end: _Number(partition[i + 1])
                    })
            }
            return groups
        }
        function findGroupPosition(value, groups) {
            var group,
                i = 0,
                ii = groups.length;
            for (; i < ii; ++i)
                if (groups[i].start <= value && value <= groups[i].end)
                    return i;
            return -1
        }
        _extend(DX.viz.map._tests, {
            MapItemsManager: MapItemsManager,
            MapItemHandle: MapItemHandle,
            stubMapItemHandle: function(mapItemHandleType) {
                MapItemHandle = mapItemHandleType
            },
            restoreMapItemHandle: function() {
                MapItemHandle = DX.viz.map._tests.MapItemHandle
            }
        });
        DX.viz.map.dxVectorMap.prototype._factory.MapItemsManager = MapItemsManager
    })(DevExpress, jQuery);
    /*! Module viz-vectormap, file areasManager.js */
    (function(DX, $, undefined) {
        var _String = String,
            _abs = Math.abs,
            _sqrt = Math.sqrt,
            _isArray = DX.utils.isArray,
            _noop = $.noop,
            _patchFontOptions = DX.viz.core.utils.patchFontOptions;
        var TOLERANCE = 1;
        var AreasManager = DX.viz.map.dxVectorMap.prototype._factory.MapItemsManager.inherit({
                _rootClass: 'dxm-areas',
                _dataCategory: 'areas',
                _eventNames: {
                    click: 'areaClick',
                    hoverChanged: 'areaHoverChanged',
                    selectionChanged: 'areaSelectionChanged'
                },
                _init: function() {
                    var that = this;
                    that.callBase.apply(that, arguments);
                    that._labelRoot = that._params.renderer.g().attr({'class': 'dxm-area-labels'});
                    that._context.labelRoot = that._labelRoot
                },
                _dispose: function() {
                    this.callBase.apply(this, arguments);
                    this._labelRoot = null
                },
                _processSource: function(source) {
                    var isGeoJson = source && source.type === 'FeatureCollection';
                    this._getItemCoordinates = isGeoJson ? getCoordinatesGeoJson : getCoordinatesDefault;
                    this._getItemAttributes = isGeoJson ? getAttributesGeoJson : getAttributesDefault;
                    return isGeoJson ? source.features : source
                },
                _getCommonSettings: function(options) {
                    return this._params.themeManager.getCommonAreaSettings(options)
                },
                _initProxy: _noop,
                _itemType: 'area',
                _clean: function() {
                    this.callBase.apply(this, arguments);
                    this._labelRoot.remove()
                },
                _render: function() {
                    var that = this;
                    that.callBase.apply(that, arguments);
                    if (that._commonSettings.label.enabled)
                        that._labelRoot.append(that._params.container)
                },
                _getItemSettings: function(_, options) {
                    return this._params.themeManager.getAreaSettings(this._commonSettings, options)
                },
                _transform: function(transform) {
                    this.callBase.apply(this, arguments);
                    this._labelRoot.attr(transform)
                },
                _createItem: function() {
                    return new Area
                },
                _prepareItems: function() {
                    var commonSettings = this._commonSettings,
                        attributeName = commonSettings.colorGroupingField;
                    if (commonSettings.colorGroups)
                        this._groupByColor(commonSettings.colorGroups, commonSettings.palette, function(handle) {
                            return handle.proxy.attribute(attributeName)
                        })
                },
                _arrangeItems: _noop
            });
        function getCoordinatesDefault(dataItem) {
            return dataItem.coordinates
        }
        function getCoordinatesGeoJson(dataItem) {
            var coordinates;
            if (dataItem.geometry) {
                var type = dataItem.geometry.type;
                coordinates = dataItem.geometry.coordinates;
                if (coordinates && (type === 'Polygon' || type === 'MultiPolygon'))
                    type === 'MultiPolygon' && (coordinates = [].concat.apply([], coordinates));
                else
                    coordinates = undefined
            }
            return coordinates
        }
        function getAttributesDefault(dataItem) {
            return dataItem.attributes
        }
        function getAttributesGeoJson(dataItem) {
            return dataItem.properties
        }
        function Area(){}
        $.extend(Area.prototype, DX.viz.map._internal.mapItemBehavior, {
            _project: function(projection, coords) {
                return projection.projectArea(coords)
            },
            _createRoot: function() {
                return this._ctx.renderer.path([], "area")
            },
            _render: function(settings) {
                var that = this;
                that._styles = {
                    normal: {
                        'class': 'dxm-area',
                        stroke: settings.borderColor,
                        "stroke-width": settings.borderWidth,
                        fill: settings.color
                    },
                    hovered: {
                        'class': 'dxm-area dxm-area-hovered',
                        stroke: settings.hoveredBorderColor,
                        "stroke-width": settings.hoveredBorderWidth,
                        fill: settings.hoveredColor
                    },
                    selected: {
                        'class': 'dxm-area dxm-area-selected',
                        stroke: settings.selectedBorderColor,
                        "stroke-width": settings.selectedBorderWidth,
                        fill: settings.selectedColor
                    }
                };
                $(that._root.attr(that._styles.normal).element).data(that._ctx.dataKey, that._data);
                return that
            },
            _transform: function(projection, coords) {
                return projection.getAreaCoordinates(coords)
            },
            _locate: function(coords) {
                this._root.attr({d: coords});
                this._label && this._locateLabel()
            },
            onHover: _noop,
            setDefaultState: function() {
                this._root.attr(this._styles.normal).toBackground()
            },
            setHoveredState: function() {
                this._root.attr(this._styles.hovered).toForeground()
            },
            setSelectedState: function() {
                this._root.attr(this._styles.selected).toForeground()
            },
            createLabel: function() {
                var that = this,
                    textContent = _String(that._proxy.text || that._proxy.attribute(that._settings.label['dataField']) || '');
                if (!textContent)
                    return that;
                var centroid = calculateAreaCentroid(that._coords);
                that._centroid = centroid.coords;
                that._areaSize = _sqrt(centroid.area);
                that._label = that._ctx.renderer.g().attr({'class': 'dxm-area-label'}).append(that._ctx.labelRoot);
                var labelSettings = that._settings.label,
                    text = that._ctx.renderer.text(textContent, 0, 0).css(_patchFontOptions(labelSettings.font)).attr({
                        align: 'center',
                        stroke: labelSettings.stroke,
                        'stroke-width': labelSettings['stroke-width'],
                        'stroke-opacity': labelSettings['stroke-opacity']
                    }).append(that._label),
                    bbox = that._label.getBBox(),
                    offset = -bbox.y - bbox.height / 2;
                text.attr({y: offset});
                that._labelSize = {
                    w: bbox.width,
                    h: bbox.height
                };
                $(that._ctx.renderer.rect(bbox.x, bbox.y + offset, bbox.width, bbox.height).attr({
                    "stroke-width": 0,
                    stroke: 'none',
                    fill: '#000000',
                    opacity: 0.0001
                }).append(that._label).element).data(that._ctx.dataKey, that._data);
                that._locateLabel();
                return that
            },
            _locateLabel: function() {
                var that = this,
                    coords = that._ctx.projection.getPointCoordinates(that._centroid),
                    size = that._ctx.projection.getSquareSize([that._areaSize, that._areaSize]);
                that._label.attr({
                    translateX: coords.x,
                    translateY: coords.y,
                    visibility: that._labelSize.w / size[0] < TOLERANCE && that._labelSize.h / size[1] < TOLERANCE ? null : 'hidden'
                })
            }
        });
        function calculatePolygonCentroid(coordinates) {
            var i = 0,
                ii = coordinates.length,
                v1,
                v2 = coordinates[ii - 1],
                cross,
                cx = 0,
                cy = 0,
                area = 0;
            for (; i < ii; ++i) {
                v1 = v2;
                v2 = coordinates[i];
                cross = v1[0] * v2[1] - v2[0] * v1[1];
                area += cross;
                cx += (v1[0] + v2[0]) * cross;
                cy += (v1[1] + v2[1]) * cross
            }
            area /= 2;
            cx /= 6 * area;
            cy /= 6 * area;
            return {
                    coords: [cx, cy],
                    area: _abs(area)
                }
        }
        function calculateAreaCentroid(coordinates) {
            var i = 0,
                ii = coordinates.length,
                centroid,
                resultCentroid,
                maxArea = 0;
            for (; i < ii; ++i) {
                centroid = calculatePolygonCentroid(coordinates[i]);
                if (centroid.area > maxArea) {
                    maxArea = centroid.area;
                    resultCentroid = centroid
                }
            }
            return resultCentroid
        }
        DX.viz.map._internal.AreasManager = AreasManager;
        DX.viz.map._internal.Area = Area;
        DX.viz.map._tests.AreasManager = AreasManager;
        DX.viz.map._tests.Area = Area;
        DX.viz.map.dxVectorMap.prototype._factory.createAreasManager = function(parameters) {
            return new AreasManager(parameters)
        }
    })(DevExpress, jQuery);
    /*! Module viz-vectormap, file markersManager.js */
    (function(DX, $, undefined) {
        var _Number = Number,
            _String = String,
            _isFinite = isFinite,
            _round = Math.round,
            _max = Math.max,
            _min = Math.min,
            _extend = $.extend,
            _each = $.each,
            _isArray = DX.utils.isArray,
            _processCircleSettings = DX.viz.renderers.processCircleSettings,
            _patchFontOptions = DX.viz.core.utils.patchFontOptions;
        var CLASS_DEFAULT = 'dxm-marker',
            CLASS_HOVERED = 'dxm-marker dxm-marker-hovered',
            CLASS_SELECTED = 'dxm-marker dxm-marker-selected',
            TRACKER_SETTINGS = {
                stroke: 'none',
                "stroke-width": 0,
                fill: '#000000',
                opacity: 0.0001
            };
        var DOT = 'dot',
            BUBBLE = 'bubble',
            PIE = 'pie',
            IMAGE = 'image';
        var DEFAULT_MARKER_TYPE = null,
            MARKER_TYPES = {};
        var MarkersManager = DX.viz.map.dxVectorMap.prototype._factory.MapItemsManager.inherit({
                _rootClass: 'dxm-markers',
                _dataCategory: 'markers',
                _eventNames: {
                    click: 'markerClick',
                    hoverChanged: 'markerHoverChanged',
                    selectionChanged: 'markerSelectionChanged'
                },
                _init: function() {
                    var that = this;
                    that.callBase.apply(that, arguments);
                    that._context.getPieColors = function(count) {
                        return that._params.themeManager.getPieColors(that._commonSettings, count)
                    };
                    that._filter = that._params.renderer.shadowFilter('-40%', '-40%', '180%', '200%', 0, 1, 1, '#000000', 0.2)
                },
                _dispose: function() {
                    this.callBase.apply(this, arguments);
                    this._filter.dispose();
                    this._filter = null
                },
                _getItemCoordinates: function(dataItem) {
                    return dataItem.coordinates
                },
                _getItemAttributes: function(dataItem) {
                    return dataItem.attributes
                },
                _processSource: function(source) {
                    return source
                },
                _getCommonSettings: function(options) {
                    return this._params.themeManager.getCommonMarkerSettings(options)
                },
                _processOptions: function(options) {
                    var that = this;
                    that.callBase.apply(that, arguments);
                    that._commonSettings._filter = that._filter.ref;
                    that._commonType = parseMarkerType(options && options.type, DEFAULT_MARKER_TYPE)
                },
                _arrangeBubbles: function() {
                    var markers = this._handles,
                        bubbles = [],
                        i,
                        ii = markers.length,
                        marker,
                        values = [];
                    if (this._commonSettings._bubble.sizeGroups)
                        return;
                    for (i = 0; i < ii; ++i) {
                        marker = markers[i];
                        if (marker.item.type === BUBBLE) {
                            bubbles.push(marker);
                            if (_isFinite(marker.proxy.value))
                                values.push(marker.proxy.value)
                        }
                    }
                    var minValue = _min.apply(null, values),
                        maxValue = _max.apply(null, values),
                        deltaValue = maxValue - minValue || 1;
                    for (i = 0, ii = bubbles.length; i < ii; ++i) {
                        marker = bubbles[i];
                        marker.item.setSize(_isFinite(marker.proxy.value) ? (marker.proxy.value - minValue) / deltaValue : 0)
                    }
                },
                _itemType: 'marker',
                _initProxy: function(proxy, dataItem) {
                    _each(dataItem, function(name, value) {
                        if (proxy[name] === undefined)
                            proxy[name] = value
                    });
                    proxy._TYPE = parseMarkerType(dataItem.type, null)
                },
                _getItemSettings: function(proxy, options) {
                    var type = proxy._TYPE || this._commonType,
                        settings = this._params.themeManager.getMarkerSettings(this._commonSettings, _extend({}, proxy.style, options), type);
                    proxy.text = proxy.text || settings.text;
                    settings._type = type;
                    return settings
                },
                _createItem: function(settings) {
                    return new MARKER_TYPES[settings._type]
                },
                _prepareItems: function() {
                    var that = this,
                        markerType = that._commonType,
                        dataField,
                        commonSettings = that._commonSettings['_' + markerType];
                    if (markerType === DOT || markerType === BUBBLE)
                        if (commonSettings.colorGroups) {
                            dataField = commonSettings.colorGroupingField;
                            that._groupByColor(commonSettings.colorGroups, commonSettings.palette, function(handle) {
                                var proxy = handle.proxy;
                                return !proxy._TYPE || proxy._TYPE === markerType ? proxy.attribute(dataField) : NaN
                            })
                        }
                    if (markerType === PIE)
                        that._updateLegendForPies();
                    if (commonSettings.sizeGroups) {
                        dataField = commonSettings.sizeGroupingField;
                        that._performGrouping(commonSettings.sizeGroups, 'size', function(handle) {
                            var proxy = handle.proxy;
                            return !proxy._TYPE || proxy._TYPE === markerType ? proxy.value || proxy.attribute(dataField) : NaN
                        }, function(count) {
                            var minSize = commonSettings.minSize > 0 ? _Number(commonSettings.minSize) : 0,
                                maxSize = commonSettings.maxSize >= minSize ? _Number(commonSettings.maxSize) : 0,
                                i = 0,
                                sizes = [];
                            for (i = 0; i < count; ++i)
                                sizes.push((minSize * (count - i - 1) + maxSize * i) / (count - 1));
                            return sizes
                        })
                    }
                },
                _updateLegendForPies: function() {
                    var count = 0;
                    _each(this._handles, function(_, handle) {
                        var proxy = handle.proxy;
                        if (!proxy._TYPE || proxy._TYPE === PIE) {
                            var values = proxy.values;
                            if (values && values.length > count)
                                count = values.length
                        }
                    });
                    this._params.dataExchanger.set(this._dataCategory, 'color', $.map(this._context.getPieColors(count).slice(0, count), function(color, i) {
                        return {
                                index: i,
                                color: color
                            }
                    }))
                },
                _arrangeItems: function() {
                    this._arrangeBubbles()
                }
            });
        var baseMarkerBehavior = _extend({}, DX.viz.map._internal.mapItemBehavior, {
                _project: function(projection, coords) {
                    return projection.projectPoint(coords)
                },
                _createRoot: function() {
                    return this._ctx.renderer.g()
                },
                _render: function(settings) {
                    var that = this;
                    that._root.attr({'class': CLASS_DEFAULT});
                    that._create(settings, that._ctx.renderer, that._root);
                    return that
                },
                _transform: function(projection, coords) {
                    return projection.getPointCoordinates(coords)
                },
                _locate: function(coords) {
                    this._root.attr({
                        translateX: coords.x,
                        translateY: coords.y
                    })
                },
                onHover: function() {
                    this._root.toForeground()
                },
                setDefaultState: function() {
                    this._root.attr({'class': CLASS_DEFAULT}).toBackground();
                    this._applyDefault()
                },
                setHoveredState: function() {
                    this._root.attr({'class': CLASS_HOVERED});
                    this._applyHovered()
                },
                setSelectedState: function() {
                    this._root.attr({'class': CLASS_SELECTED}).toForeground();
                    this._applySelected()
                },
                createLabel: function() {
                    var that = this;
                    if (!that._proxy.text)
                        return;
                    var rootbox = that._root.getBBox(),
                        labelSettings = that._settings.label,
                        text = that._ctx.renderer.text(that._proxy.text, 0, 0).css(_patchFontOptions(labelSettings.font)).attr({
                            align: 'center',
                            stroke: labelSettings.stroke,
                            'stroke-width': labelSettings['stroke-width'],
                            'stroke-opacity': labelSettings['stroke-opacity']
                        }).append(that._root),
                        textBox = text.getBBox(),
                        x = _round(-textBox.x + rootbox.width / 2) + 2,
                        y = _round(-textBox.y - textBox.height / 2) - 1;
                    text.attr({
                        x: x,
                        y: y
                    });
                    $(that._ctx.renderer.rect(x + textBox.x - 1, y + textBox.y - 1, textBox.width + 2, textBox.height + 2).attr(TRACKER_SETTINGS).append(that._root).element).data(that._ctx.dataKey, that._data)
                }
            });
        function DotMarker(){}
        _extend(DotMarker.prototype, baseMarkerBehavior, {
            type: DOT,
            _create: function(style, renderer, root) {
                var that = this,
                    size = style.size > 0 ? _Number(style.size) : 0,
                    hoveredSize = size,
                    selectedSize = size + (style.selectedStep > 0 ? _Number(style.selectedStep) : 0),
                    hoveredBackSize = hoveredSize + (style.backStep > 0 ? _Number(style.backStep) : 0),
                    selectedBackSize = selectedSize + (style.backStep > 0 ? _Number(style.backStep) : 0),
                    settings = _processCircleSettings(0, 0, size, style.borderWidth);
                that._dotDefault = {
                    cx: settings.cx,
                    cy: settings.cy,
                    r: settings.r,
                    stroke: style.borderColor,
                    "stroke-width": style.borderWidth,
                    fill: style.color,
                    filter: style.shadow ? style._filter : null
                };
                that._dotHovered = {
                    cx: settings.cx,
                    cy: settings.cy,
                    r: hoveredSize / 2,
                    stroke: style.hoveredBorderColor,
                    "stroke-width": style.hoveredBorderWidth,
                    fill: style.hoveredColor
                };
                that._dotSelected = {
                    cx: settings.cx,
                    cy: settings.cy,
                    r: selectedSize / 2,
                    stroke: style.selectedBorderColor,
                    "stroke-width": style.selectedBorderWidth,
                    fill: style.selectedColor
                };
                that._backDefault = {
                    cx: settings.cx,
                    cy: settings.cy,
                    r: settings.r,
                    stroke: 'none',
                    "stroke-width": 0,
                    fill: style.backColor,
                    opacity: style.backOpacity
                };
                that._backHovered = {
                    cx: settings.cx,
                    cy: settings.cy,
                    r: hoveredBackSize / 2,
                    stroke: 'none',
                    "stroke-width": 0,
                    fill: style.backColor,
                    opacity: style.backOpacity
                };
                that._backSelected = {
                    cx: settings.cx,
                    cy: settings.cy,
                    r: selectedBackSize / 2,
                    stroke: 'none',
                    "stroke-width": 0,
                    fill: style.backColor,
                    opacity: style.backOpacity
                };
                that._back = renderer.circle().attr(that._backDefault).append(root);
                that._dot = renderer.circle().attr(that._dotDefault).append(root);
                $(that._back.element).data(that._ctx.dataKey, that._data);
                $(that._dot.element).data(that._ctx.dataKey, that._data)
            },
            _destroy: function() {
                this._back = this._dot = null
            },
            _applyDefault: function() {
                this._back.attr(this._backDefault);
                this._dot.attr(this._dotDefault)
            },
            _applyHovered: function() {
                this._back.attr(this._backHovered);
                this._dot.attr(this._dotHovered)
            },
            _applySelected: function() {
                this._back.attr(this._backSelected);
                this._dot.attr(this._dotSelected)
            }
        });
        function BubbleMarker(){}
        _extend(BubbleMarker.prototype, baseMarkerBehavior, {
            type: BUBBLE,
            _create: function(style, renderer, root) {
                var that = this;
                that._minSize = style.minSize > 0 ? _Number(style.minSize) : 0;
                that._maxSize = style.maxSize > that._minSize ? _Number(style.maxSize) : that._minSize;
                that.value = _isFinite(that._proxy.value) ? _Number(that._proxy.value) : null;
                that._default = {
                    stroke: style.borderColor,
                    "stroke-width": style.borderWidth,
                    fill: style.color,
                    opacity: style.opacity
                };
                that._hovered = {
                    stroke: style.hoveredBorderColor,
                    "stroke-width": style.hoveredBorderWidth,
                    fill: style.hoveredColor,
                    opacity: style.hoveredOpacity
                };
                that._selected = {
                    stroke: style.selectedBorderColor,
                    "stroke-width": style.selectedBorderWidth,
                    fill: style.selectedColor,
                    opacity: style.selectedOpacity
                };
                that._bubble = renderer.circle(0, 0, (style.size || style.maxSize) / 2).attr(that._default).append(root);
                $(that._bubble.element).data(that._ctx.dataKey, that._data)
            },
            _applyDefault: function() {
                this._bubble.attr(this._default)
            },
            _applyHovered: function() {
                this._bubble.attr(this._hovered)
            },
            _applySelected: function() {
                this._bubble.attr(this._selected)
            },
            setSize: function(ratio) {
                var that = this,
                    settings = _processCircleSettings(0, 0, that._minSize + ratio * (that._maxSize - that._minSize), that._default["stroke-width"]);
                that._default.cx = that._hovered.cx = that._selected.cx = settings.cx;
                that._default.cy = that._hovered.cy = that._selected.cy = settings.cy;
                that._default.r = that._hovered.r = that._selected.r = settings.r;
                that._bubble.attr(settings);
                return that
            }
        });
        function PieMarker(){}
        _extend(PieMarker.prototype, baseMarkerBehavior, {
            type: PIE,
            _create: function(style, renderer, root) {
                var that = this,
                    settings = _processCircleSettings(0, 0, style.size > 0 ? _Number(style.size) : 0, style.borderWidth);
                that._pieDefault = {opacity: style.opacity};
                that._pieHovered = {opacity: style.hoveredOpacity};
                that._pieSelected = {opacity: style.selectedOpacity};
                that._borderDefault = {
                    stroke: style.borderColor,
                    "stroke-width": style.borderWidth
                };
                that._borderHovered = {
                    stroke: style.hoveredBorderColor,
                    "stroke-width": style.hoveredBorderWidth
                };
                that._borderSelected = {
                    stroke: style.selectedBorderColor,
                    "stroke-width": style.selectedBorderWidth
                };
                var srcValues = that._proxy.values,
                    i = 0,
                    ii = _isArray(srcValues) ? srcValues.length : 0,
                    values = [],
                    value,
                    sum = 0;
                for (; i < ii; ++i) {
                    value = _Number(srcValues[i]);
                    if (_isFinite(value)) {
                        values.push(value);
                        sum += value
                    }
                }
                that._pie = renderer.g().attr(that._pieDefault);
                var translator = new DX.viz.core.Translator1D(0, sum, 90, 450),
                    startAngle = translator.translate(0),
                    endAngle,
                    colors = that._ctx.getPieColors(values.length);
                for (value = 0, i = 0, ii = values.length; i < ii; ++i) {
                    value += values[i];
                    endAngle = translator.translate(value);
                    $(renderer.arc(settings.cx, settings.cy, 0, settings.r, startAngle, endAngle).attr({
                        "stroke-linejoin": "round",
                        fill: colors[i]
                    }).append(that._pie).element).data(that._ctx.dataKey, that._data);
                    startAngle = endAngle
                }
                that._pie.append(root);
                that._border = renderer.circle(settings.cx, settings.cy, settings.r).attr(that._borderDefault).append(root);
                $(that._border.element).data(that._ctx.dataKey, that._data)
            },
            _applyDefault: function() {
                this._pie.attr(this._pieDefault);
                this._border.attr(this._borderDefault)
            },
            _applyHovered: function() {
                this._pie.attr(this._pieHovered);
                this._border.attr(this._borderHovered)
            },
            _applySelected: function() {
                this._pie.attr(this._pieSelected);
                this._border.attr(this._borderSelected)
            }
        });
        function ImageMarker(){}
        _extend(ImageMarker.prototype, baseMarkerBehavior, {
            type: IMAGE,
            _create: function(style, renderer, root) {
                var that = this,
                    size = style.size > 0 ? _Number(style.size) : 0,
                    hoveredSize = size + (style.hoveredStep > 0 ? _Number(style.hoveredStep) : 0),
                    selectedSize = size + (style.selectedStep > 0 ? _Number(style.selectedStep) : 0);
                that._default = {
                    x: -size / 2,
                    y: -size / 2,
                    width: size,
                    height: size
                };
                that._hovered = {
                    x: -hoveredSize / 2,
                    y: -hoveredSize / 2,
                    width: hoveredSize,
                    height: hoveredSize
                };
                that._selected = {
                    x: -selectedSize / 2,
                    y: -selectedSize / 2,
                    width: selectedSize,
                    height: selectedSize
                };
                that._image = renderer.image().attr(that._default).attr({
                    href: that._proxy.url,
                    location: 'center'
                }).append(root);
                that._tracker = renderer.rect().attr(that._default).attr(TRACKER_SETTINGS).append(root);
                $(that._tracker.element).data(that._ctx.dataKey, that._data)
            },
            _applyDefault: function() {
                this._image.attr(this._default);
                this._tracker.attr(this._default)
            },
            _applyHovered: function() {
                this._image.attr(this._hovered);
                this._tracker.attr(this._hovered)
            },
            _applySelected: function() {
                this._image.attr(this._selected);
                this._tracker.attr(this._selected)
            }
        });
        _each([DotMarker, BubbleMarker, PieMarker, ImageMarker], function(_, markerType) {
            DEFAULT_MARKER_TYPE = DEFAULT_MARKER_TYPE || markerType.prototype.type;
            MARKER_TYPES[markerType.prototype.type] = markerType
        });
        function parseMarkerType(type, defaultType) {
            var _type = _String(type).toLowerCase();
            return MARKER_TYPES[_type] ? _type : defaultType
        }
        var __originalDefaultMarkerType = DEFAULT_MARKER_TYPE,
            __originalMarkerTypes = _extend({}, MARKER_TYPES);
        DX.viz.map._tests.stubMarkerTypes = function(markerTypes, defaultMarkerType) {
            DEFAULT_MARKER_TYPE = defaultMarkerType;
            MARKER_TYPES = markerTypes
        };
        DX.viz.map._tests.restoreMarkerTypes = function() {
            DEFAULT_MARKER_TYPE = __originalDefaultMarkerType;
            MARKER_TYPES = __originalMarkerTypes
        };
        DX.viz.map._tests.baseMarkerBehavior = baseMarkerBehavior;
        DX.viz.map._tests.MarkersManager = MarkersManager;
        DX.viz.map._tests.DotMarker = DotMarker;
        DX.viz.map._tests.BubbleMarker = BubbleMarker;
        DX.viz.map._tests.PieMarker = PieMarker;
        DX.viz.map._tests.ImageMarker = ImageMarker;
        DX.viz.map.dxVectorMap.prototype._factory.createMarkersManager = function(parameters) {
            return new MarkersManager(parameters)
        }
    })(DevExpress, jQuery);
    DevExpress.MOD_VIZ_VECTORMAP = true
}
if (!DevExpress.MOD_VIZ_SPARKLINES) {
    if (!DevExpress.MOD_VIZ_CORE)
        throw Error('Required module is not referenced: viz-core');
    /*! Module viz-sparklines, file baseSparkline.js */
    (function($, DX) {
        var TOOLTIP_MARGIN = 100,
            TOOLTIP_ARROW_MARGIN = 10,
            DEFAULT_LINE_SPACING = 6,
            DEFAULT_EVENTS_DELAY = 200,
            TOUCH_EVENTS_DELAY = 1000,
            _extend = $.extend,
            _abs = Math.abs,
            _Number = Number,
            _round = Math.round,
            core = DX.viz.core,
            CoreFactory = core.CoreFactory;
        function DEFAULT_CUSTOMIZE_TOOLTIP(customizeObject) {
            return {text: customizeObject.valueText.join('<br/>')}
        }
        DX.viz.sparklines = {};
        DX.viz.sparklines.DEFAULT_CUSTOMIZE_TOOLTIP = DEFAULT_CUSTOMIZE_TOOLTIP;
        DX.viz.sparklines.BaseSparkline = core.BaseWidget.inherit({
            render: function() {
                this._refresh();
                return this
            },
            _rendererType: DX.viz.renderers.Renderer,
            _clean: function() {
                if (this._tooltipShown) {
                    this._tooltip.dispose();
                    this._tooltip = null;
                    this._tooltipShown = null;
                    this._tooltipGroup.clear()
                }
                this._tooltipContainer.detach();
                this._cleanWidgetElements()
            },
            _optionChanged: function(args) {
                if (args.name === 'size' && this._allOptions) {
                    this._clean();
                    this._canvas = this._calculateCanvas();
                    this._renderer.resize(this._canvas.width, this._canvas.height);
                    if (!this._isContainerVisible())
                        return;
                    this._allOptions.size = args.value;
                    this._redrawWidgetElements();
                    this._prepareTooltipContainer()
                }
                else if (args.name === 'dataSource' && this._allOptions)
                    this._refreshDataSource();
                else
                    this.callBase(args)
            },
            _init: function() {
                this.callBase();
                this._canvas = this._calculateCanvas();
                this._renderer = new this._rendererType({
                    width: this._canvas.width,
                    height: this._canvas.height,
                    cssClass: this._widgetClass + ' ' + this._widgetClass + '-' + this._widgetType,
                    pathModified: this.option('pathModified'),
                    rtl: this.option('rtlEnabled')
                });
                this._createHtmlElements();
                this._createTooltipGroups();
                this._initTooltipEvents();
                this._drawContainer()
            },
            _dispose: function() {
                this.callBase();
                this._disposeWidgetElements();
                this._disposeTooltipEvents();
                this._renderer.dispose();
                this._tooltipRenderer.dispose();
                this._translatorX = null;
                this._translatorY = null;
                delete this._renderer;
                delete this._tooltipRenderer;
                delete this._tooltipTrackerGroup;
                delete this._tooltipGroup;
                delete this._tooltipContainer
            },
            _render: function() {
                var that = this;
                that._canvas = that._calculateCanvas();
                that._renderer.resize(that._canvas.width, that._canvas.height);
                if (!that._isContainerVisible()) {
                    that._incidentOccured('W2001', [that.NAME]);
                    return
                }
                that._prepareOptions();
                that._createWidgetElements();
                that._drawWidgetElements();
                that._drawn()
            },
            _isContainerVisible: function() {
                var that = this,
                    canvas = that._canvas,
                    enoughWidth = canvas.width - canvas.left - canvas.right > 0,
                    enoughHeight = canvas.height - canvas.top - canvas.bottom > 0;
                return canvas.height && canvas.width && enoughHeight && enoughWidth
            },
            _createWidgetElements: function() {
                this._createRange();
                this._createTranslator()
            },
            _prepareOptions: function(defaultOptions) {
                var that = this,
                    userOptions = that.option() || {},
                    options,
                    defaultTheme,
                    theme;
                defaultTheme = core.findTheme('default');
                defaultTheme = defaultTheme[this._widgetType];
                options = _extend(true, {}, defaultOptions, userOptions);
                if (typeof options.theme === 'string') {
                    theme = core.findTheme(options.theme);
                    theme = theme[this._widgetType]
                }
                else
                    theme = options.theme;
                return _extend(true, {}, defaultTheme, theme, options)
            },
            _calculateCanvas: function() {
                var that = this,
                    canvas = {},
                    sizeOptions = that.option('size') || {},
                    marginOptions = that.option('margin') || {},
                    defaultSize = that._defaultSize,
                    container = that.element(),
                    width = sizeOptions.width >= 0 ? _Number(sizeOptions.width) : container.width(),
                    height = sizeOptions.height >= 0 ? _Number(sizeOptions.height) : container.height();
                if (!width && _Number(sizeOptions.width) !== 0)
                    width = defaultSize.width;
                if (!height && _Number(sizeOptions.height) !== 0)
                    height = defaultSize.height;
                return {
                        width: width,
                        height: height,
                        top: _Number(marginOptions.top) || defaultSize.top,
                        bottom: _Number(marginOptions.bottom) || defaultSize.bottom,
                        left: _Number(marginOptions.left) || defaultSize.left,
                        right: _Number(marginOptions.right) || defaultSize.right
                    }
            },
            _createTooltipGroups: function() {
                var that = this,
                    renderer,
                    root,
                    widgetClass = that._widgetClass;
                that._tooltipRenderer = renderer = new that._rendererType({
                    width: 1,
                    height: 1,
                    cssClass: widgetClass + ' ' + widgetClass + '-tooltip',
                    pathModified: this.option('pathModified'),
                    rtl: this.option('rtlEnabled')
                });
                that._tooltipContainer = $('<div style="position: relative">');
                renderer.draw(that._tooltipContainer[0]);
                root = renderer.root;
                that._tooltipGroup = renderer.g().attr({'class': widgetClass + '-tooltip-group'}).css({'z-index': '1'}).append(root);
                that._tooltipTrackerGroup = renderer.g().attr({'class': widgetClass + '-tooltip-tracker-group'}).append(root);
                that._tooltipTracker = that._createTooltipTracker().append(that._tooltipTrackerGroup)
            },
            _createTooltipTracker: function() {
                return this._tooltipRenderer.rect().attr({
                        fill: 'grey',
                        opacity: 0
                    })
            },
            _initTooltipEvents: function() {
                var that = this,
                    data = {
                        widget: that,
                        container: that._tooltipTracker
                    };
                that._showTooltipCallback = function() {
                    that._showTooltipTimeout = null;
                    if (!that._tooltipShown) {
                        that._tooltipShown = true;
                        that._showTooltip()
                    }
                    that._DEBUG_showCallback && that._DEBUG_showCallback()
                };
                that._hideTooltipCallback = function() {
                    that._hideTooltipTimeout = null;
                    if (that._tooltipShown) {
                        that._tooltipShown = false;
                        that._hideTooltip()
                    }
                    that._DEBUG_hideCallback && that._DEBUG_hideCallback()
                };
                that._disposeCallbacks = function() {
                    that = that._showTooltipCallback = that._hideTooltipCallback = that._disposeCallbacks = null
                };
                $(that._tooltipTracker.element).on(mouseEvents, data).on(touchEvents, data);
                $(that._tooltipTracker.element).on(menuEvents)
            },
            _disposeTooltipEvents: function() {
                clearTimeout(this._showTooltipTimeout);
                clearTimeout(this._hideTooltipTimeout);
                this._showTooltipTimeout = this._showTooltipTimeout = null;
                $(this._tooltipTracker.element).off();
                this._disposeCallbacks()
            },
            _drawContainer: function() {
                this._renderer.draw(this.element()[0])
            },
            _createTranslator: function() {
                this._translatorX = CoreFactory.createTranslator2D(this._ranges.arg, this._canvas, {direction: "horizontal"});
                this._translatorY = CoreFactory.createTranslator2D(this._ranges.val, this._canvas)
            },
            _prepareTooltipOptions: function() {
                var that = this,
                    canvas = that._canvas,
                    tooltipOpt = that._allOptions.tooltip,
                    size = that._getTooltipSize(true),
                    defaultOptions = {
                        canvasWidth: size.width,
                        canvasHeight: size.height,
                        paddingLeftRight: tooltipOpt.paddingLeftRight,
                        paddingTopBottom: tooltipOpt.paddingTopBottom,
                        arrowLength: tooltipOpt.arrowLength,
                        lineSpacing: tooltipOpt.font.lineSpacing !== undefined && tooltipOpt.font.lineSpacing !== null ? tooltipOpt.font.lineSpacing : DEFAULT_LINE_SPACING
                    },
                    autoJustify = !$.isFunction(that._allOptions.tooltip.customizeText) && !$.isFunction(that._allOptions.tooltip.customizeTooltip),
                    options = $.extend(defaultOptions, that._allOptions.tooltip, {
                        customizeTooltip: autoJustify ? DEFAULT_CUSTOMIZE_TOOLTIP : that._allOptions.tooltip.customizeTooltip,
                        _justify: that._allOptions.tooltip._justify || autoJustify,
                        _rtl: that.option('rtlEnabled')
                    });
                that._tooltipOptions = {
                    size: size,
                    options: options
                };
                return options
            },
            _prepareTooltipContainer: function() {
                var that = this,
                    canvas = that._canvas;
                that._updateTooltipSizeToNormal();
                that._tooltipTracker.attr({
                    width: canvas.width,
                    height: canvas.height
                });
                that._tooltipContainer.appendTo(that.element());
                that._tooltipInitializated = false;
                that._canShowTooltip = that._allOptions.tooltip.enabled
            },
            _isTooltipVisible: function() {
                return this._tooltip.enabled() && this._tooltip.prepare(this._getTooltipData(), {
                        offset: 0,
                        cloudVerticalPosition: this._allOptions.tooltip.verticalAlignment,
                        cloudHorizontalPosition: this._allOptions.tooltip.horizontalAlignment
                    })
            },
            _createTooltip: function() {
                var that = this;
                that._tooltip = CoreFactory.createTooltip(that._prepareTooltipOptions(), that._tooltipGroup, that._tooltipRenderer);
                if (that._isTooltipVisible()) {
                    that._tooltip.show();
                    that._updateTooltipSizeToWide();
                    that._checkTooltipSize();
                    that._updateTooltipSizeToNormal()
                }
                else
                    that._canShowTooltip = false
            },
            _doShowTooltip: function(delay) {
                var that = this;
                if (!that._canShowTooltip)
                    return;
                ++that._DEBUG_clearHideTooltipTimeout;
                clearTimeout(that._hideTooltipTimeout);
                that._hideTooltipTimeout = null;
                clearTimeout(that._showTooltipTimeout);
                ++that._DEBUG_showTooltipTimeoutSet;
                that._showTooltipTimeout = setTimeout(that._showTooltipCallback, delay)
            },
            _doHideTooltip: function(delay) {
                var that = this;
                if (!that._canShowTooltip)
                    return;
                ++that._DEBUG_clearShowTooltipTimeout;
                clearTimeout(that._showTooltipTimeout);
                that._showTooltipTimeout = null;
                clearTimeout(that._hideTooltipTimeout);
                ++that._DEBUG_hideTooltipTimeoutSet;
                that._hideTooltipTimeout = setTimeout(that._hideTooltipCallback, delay)
            },
            _getNormalTooltipSize: function() {
                var size = {};
                size.width = this._canvas.width;
                size.left = 0;
                size.tooltipLeft = _round(size.width / 2);
                return size
            },
            _getWideTooltipSize: function(leftWidthDelta, rightWidthDelta) {
                var that = this,
                    canvas = that._canvas,
                    horizontalPos = that._allOptions.tooltip.horizontalAlignment,
                    widthDelta = leftWidthDelta + rightWidthDelta,
                    size = {};
                size.width = canvas.width + widthDelta;
                size.left = -leftWidthDelta;
                if (horizontalPos === 'right')
                    size.tooltipLeft = _round(canvas.width / 2);
                else if (horizontalPos === 'left')
                    size.tooltipLeft = _round(canvas.width / 2) + widthDelta;
                else
                    size.tooltipLeft = _round(size.width / 2);
                return size
            },
            _getTooltipSize: function(isNormal, leftWidthDelta, rightWidthDelta, heightDelta) {
                var that = this,
                    canvas = that._canvas,
                    isVerticalPosTop = !(that._allOptions.tooltip.verticalAlignment === 'bottom'),
                    size = !isNormal && (leftWidthDelta || rightWidthDelta) ? that._getWideTooltipSize(leftWidthDelta, rightWidthDelta) : that._getNormalTooltipSize(),
                    yDelta = heightDelta > 0 ? heightDelta + TOOLTIP_MARGIN : TOOLTIP_MARGIN;
                size.height = canvas.height + yDelta;
                size.top = isVerticalPosTop ? -size.height : -canvas.height;
                size.trackerY = isVerticalPosTop ? yDelta : 0;
                size.tooltipY = isVerticalPosTop ? _round(canvas.height / 2) + yDelta - TOOLTIP_ARROW_MARGIN : _round(canvas.height / 2);
                return size
            },
            _checkTooltipSize: function() {
                var that = this,
                    tooltip = that._tooltip,
                    options = that._tooltipOptions.options,
                    tooltipBBox = tooltip.getBBox(),
                    getWide = that._allOptions.tooltip.allowContainerResizing,
                    leftDelta = -tooltipBBox.x,
                    rightDelta = tooltipBBox.x + tooltipBBox.width - that._canvas.width,
                    topDelta = tooltipBBox.height - TOOLTIP_MARGIN,
                    size;
                if (leftDelta > 0 || rightDelta > 0 || topDelta > 0)
                    if (getWide) {
                        that._tooltipOptions.size = size = that._getTooltipSize(false, leftDelta > 0 ? leftDelta : 0, rightDelta > 0 ? rightDelta : 0, topDelta > 0 ? topDelta : 0);
                        tooltip.setSize(size.width, size.height);
                        that._updateTooltipSizeToWide()
                    }
                    else {
                        that._canShowTooltip = false;
                        tooltip.hide()
                    }
            },
            _updateTooltipSizeToWide: function() {
                var that = this,
                    size = that._tooltipOptions.size,
                    renderer = that._tooltipRenderer;
                renderer.resize(size.width, size.height);
                renderer.root.css({
                    left: size.left,
                    top: size.top,
                    position: 'absolute',
                    overflow: 'hidden'
                });
                that._tooltipTracker.attr({
                    y: size.trackerY,
                    x: -size.left
                });
                that._tooltip.move(size.tooltipLeft, size.tooltipY)
            },
            _updateTooltipSizeToNormal: function() {
                var that = this,
                    renderer = that._tooltipRenderer,
                    canvas = that._canvas;
                renderer.resize(canvas.width, canvas.height);
                renderer.root.css({
                    left: 0,
                    top: -canvas.height,
                    position: 'absolute'
                });
                that._tooltipTracker.attr({
                    y: 0,
                    x: 0
                })
            },
            _showTooltip: function() {
                if (!this._tooltipInitializated) {
                    this._createTooltip();
                    this._tooltipInitializated = true;
                    if (!this._canShowTooltip)
                        return
                }
                this._updateTooltipSizeToWide();
                this._tooltip.show()
            },
            _hideTooltip: function() {
                this._updateTooltipSizeToNormal();
                this._tooltip.hide()
            },
            showLoadingIndicator: $.noop
        });
        var menuEvents = {
                'contextmenu.sparkline-tooltip': function(event) {
                    if (DX.ui.events.isTouchEvent(event) || DX.ui.events.isPointerEvent(event))
                        event.preventDefault()
                },
                'MSHoldVisual.sparkline-tooltip': function(event) {
                    event.preventDefault()
                }
            };
        var mouseEvents = {
                'mouseover.sparkline-tooltip': function(event) {
                    isPointerDownCalled = false;
                    var widget = event.data.widget;
                    widget._x = event.pageX;
                    widget._y = event.pageY;
                    $(widget._tooltipTracker.element).off(mouseMoveEvents).on(mouseMoveEvents, event.data);
                    widget._doShowTooltip(DEFAULT_EVENTS_DELAY)
                },
                'mouseout.sparkline-tooltip': function(event) {
                    if (isPointerDownCalled)
                        return;
                    var widget = event.data.widget;
                    $(widget._tooltipTracker.element).off(mouseMoveEvents);
                    widget._doHideTooltip(DEFAULT_EVENTS_DELAY)
                }
            };
        var mouseMoveEvents = {'mousemove.sparkline-tooltip': function(event) {
                    var widget = event.data.widget;
                    if (widget._showTooltipTimeout && (_abs(widget._x - event.pageX) > 3 || _abs(widget._y - event.pageY) > 3)) {
                        widget._x = event.pageX;
                        widget._y = event.pageY;
                        widget._doShowTooltip(DEFAULT_EVENTS_DELAY)
                    }
                }};
        var active_touch_tooltip_widget = null,
            touchstartTooltipProcessing = function(event) {
                event.preventDefault();
                var widget = active_touch_tooltip_widget;
                if (widget && widget !== event.data.widget)
                    widget._doHideTooltip(DEFAULT_EVENTS_DELAY);
                widget = active_touch_tooltip_widget = event.data.widget;
                widget._doShowTooltip(TOUCH_EVENTS_DELAY);
                widget._touch = true
            },
            touchstartDocumentProcessing = function() {
                var widget = active_touch_tooltip_widget;
                if (widget) {
                    if (!widget._touch) {
                        widget._doHideTooltip(DEFAULT_EVENTS_DELAY);
                        active_touch_tooltip_widget = null
                    }
                    widget._touch = null
                }
            },
            touchendDocumentProcessing = function() {
                var widget = active_touch_tooltip_widget;
                if (widget)
                    if (widget._showTooltipTimeout) {
                        widget._doHideTooltip(DEFAULT_EVENTS_DELAY);
                        active_touch_tooltip_widget = null
                    }
            },
            isPointerDownCalled = false;
        var touchEvents = {
                'pointerdown.sparkline-tooltip': function(event) {
                    touchstartTooltipProcessing(event)
                },
                'touchstart.sparkline-tooltip': function(event) {
                    touchstartTooltipProcessing(event)
                }
            };
        $(document).on({
            'pointerdown.sparkline-tooltip': function() {
                isPointerDownCalled = true;
                touchstartDocumentProcessing()
            },
            'touchstart.sparkline-tooltip': function() {
                touchstartDocumentProcessing()
            },
            'pointerup.sparkline-tooltip': function() {
                touchendDocumentProcessing()
            },
            'touchend.sparkline-tooltip': function() {
                touchendDocumentProcessing()
            }
        });
        DX.viz.sparklines.BaseSparkline._DEBUG_reset = function() {
            active_touch_tooltip_widget = null
        }
    })(jQuery, DevExpress);
    /*! Module viz-sparklines, file sparkline.js */
    (function($, DX) {
        var viz = DX.viz,
            charts = viz.charts,
            core = viz.core,
            MIN_BAR_WIDTH = 1,
            MAX_BAR_WIDTH = 50,
            DEFAULT_BAR_INTERVAL = 4,
            DEFAULT_CANVAS_WIDTH = 250,
            DEFAULT_CANVAS_HEIGHT = 30,
            DEFAULT_HORIZONTAL_MARGIN = 5,
            DEFAULT_VERTICAL_MARGIN = 3,
            DEFAULT_OPTIONS = {
                disabled: false,
                theme: "default",
                dataSource: [],
                size: {},
                margin: {},
                type: "line",
                argumentField: "arg",
                valueField: "val",
                winlossThreshold: 0,
                showFirstLast: true,
                showMinMax: false,
                redrawOnResize: false
            },
            ALLOWED_TYPES = {
                line: true,
                spline: true,
                stepline: true,
                area: true,
                steparea: true,
                splinearea: true,
                bar: true,
                winloss: true
            },
            _map = $.map,
            _extend = $.extend,
            _abs = Math.abs,
            _round = Math.round,
            _isFinite = isFinite,
            _Number = Number,
            _String = String;
        DX.registerComponent("dxSparkline", viz.sparklines, viz.sparklines.BaseSparkline.inherit({
            _widgetType: "sparkline",
            _widgetClass: "dxsl",
            _defaultSize: {
                width: DEFAULT_CANVAS_WIDTH,
                height: DEFAULT_CANVAS_HEIGHT,
                left: DEFAULT_HORIZONTAL_MARGIN,
                right: DEFAULT_HORIZONTAL_MARGIN,
                top: DEFAULT_VERTICAL_MARGIN,
                bottom: DEFAULT_VERTICAL_MARGIN
            },
            _init: function() {
                this.callBase();
                this._refreshDataSource()
            },
            _dataSourceChangedHandler: function() {
                if (this._initialized) {
                    this._clean();
                    this._createWidgetElements();
                    this._drawWidgetElements()
                }
            },
            _dataSourceOptions: function() {
                return {
                        paginate: false,
                        _preferSync: true
                    }
            },
            _redrawWidgetElements: function() {
                this._createTranslator();
                this._correctPoints();
                this._series.draw({
                    x: this._translatorX,
                    y: this._translatorY
                });
                this._seriesGroup.append(this._renderer.root)
            },
            _disposeWidgetElements: function() {
                delete this._seriesGroup;
                delete this._seriesLabelGroup
            },
            _cleanWidgetElements: function() {
                this._seriesGroup.remove();
                this._seriesLabelGroup.remove();
                this._seriesGroup.clear();
                this._seriesLabelGroup.clear()
            },
            _createWidgetElements: function() {
                this._createSeries();
                this.callBase()
            },
            _drawWidgetElements: function() {
                if (this._dataSource && this._dataSource.isLoaded())
                    this._drawSeries()
            },
            _prepareOptions: function() {
                this._allOptions = this.callBase(DEFAULT_OPTIONS);
                this._allOptions.type = _String(this._allOptions.type).toLowerCase();
                if (!ALLOWED_TYPES[this._allOptions.type])
                    this._allOptions.type = "line"
            },
            _createHtmlElements: function() {
                this._seriesGroup = this._renderer.g().attr({"class": "dxsl-series"});
                this._seriesLabelGroup = this._renderer.g().attr({"class": "dxsl-series-labels"})
            },
            _createSeries: function() {
                var that = this,
                    dataValidator;
                that._prepareDataSource();
                that._prepareSeriesOptions();
                that._series = core.CoreFactory.createSeries({
                    renderer: that._renderer,
                    seriesGroup: that._seriesGroup,
                    labelsGroup: that._seriesLabelGroup
                }, that._seriesOptions);
                dataValidator = charts.factory.createDataValidator(that._simpleDataSource, [[that._series]], that._incidentOccured, {
                    checkTypeForAllData: false,
                    convertToAxisDataType: true,
                    sortingMethod: true
                });
                that._simpleDataSource = dataValidator.validate();
                that._series._options.customizePoint = that._getCustomizeFunction();
                that._series.updateData(that._simpleDataSource)
            },
            _parseNumericDataSource: function(data, argField, valField) {
                var ignoreEmptyPoints = this.option("ignoreEmptyPoints");
                return _map(data, function(dataItem, index) {
                        var item = null,
                            isDataNumber,
                            value;
                        if (dataItem !== undefined) {
                            item = {};
                            isDataNumber = _isFinite(dataItem);
                            item[argField] = isDataNumber ? _String(index) : dataItem[argField];
                            value = isDataNumber ? dataItem : dataItem[valField];
                            item[valField] = value === null ? ignoreEmptyPoints ? undefined : value : _Number(value);
                            item = item[argField] !== undefined && item[valField] !== undefined ? item : null
                        }
                        return item
                    })
            },
            _parseWinlossDataSource: function(data, argField, valField) {
                var lowBarValue = -1,
                    zeroBarValue = 0,
                    highBarValue = 1,
                    delta = 0.0001,
                    target = this._allOptions.winlossThreshold;
                return _map(data, function(dataItem) {
                        var item = {};
                        item[argField] = dataItem[argField];
                        if (_abs(dataItem[valField] - target) < delta)
                            item[valField] = zeroBarValue;
                        else if (dataItem[valField] > target)
                            item[valField] = highBarValue;
                        else
                            item[valField] = lowBarValue;
                        return item
                    })
            },
            _prepareDataSource: function() {
                var that = this,
                    options = that._allOptions,
                    argField = options.argumentField,
                    valField = options.valueField,
                    dataSource = that._dataSource ? that._dataSource.items() : [],
                    data = that._parseNumericDataSource(dataSource, argField, valField);
                if (options.type === "winloss") {
                    that._winlossDataSource = data;
                    that._simpleDataSource = that._parseWinlossDataSource(data, argField, valField)
                }
                else
                    that._simpleDataSource = data
            },
            _prepareSeriesOptions: function() {
                var that = this,
                    options = that._allOptions,
                    defaultPointOptions = {
                        border: {},
                        hoverStyle: {border: {}},
                        selectionStyle: {border: {}}
                    },
                    customPointOptions = {
                        size: options.pointSize,
                        symbol: options.pointSymbol,
                        border: {
                            visible: true,
                            width: 2
                        },
                        color: options.pointColor
                    };
                that._seriesOptions = {
                    visible: true,
                    argumentField: options.argumentField,
                    valueField: options.valueField,
                    color: options.lineColor,
                    width: options.lineWidth,
                    widgetType: "chart"
                };
                that._seriesOptions.border = {
                    color: that._seriesOptions.color,
                    width: that._seriesOptions.width,
                    visible: true
                };
                that._seriesOptions.type = options.type === "winloss" ? "bar" : options.type;
                if (options.type === "winloss" || options.type === "bar") {
                    that._seriesOptions.argumentAxisType = "discrete";
                    that._seriesOptions.border.visible = false
                }
                if (~~options.type.indexOf("area") !== -1)
                    that._seriesOptions.opacity = that._allOptions.areaOpacity;
                that._seriesOptions.point = _extend(defaultPointOptions, customPointOptions);
                that._seriesOptions.point.visible = false
            },
            _createBarCustomizeFunction: function(pointIndexes) {
                var that = this,
                    options = that._allOptions,
                    winlossData = that._winlossDataSource;
                return function() {
                        var index = this.index,
                            isWinloss = options.type === "winloss",
                            target = isWinloss ? options.winlossThreshold : 0,
                            value = isWinloss ? winlossData[index][options.valueField] : this.value,
                            positiveColor = isWinloss ? options.winColor : options.barPositiveColor,
                            negativeColor = isWinloss ? options.lossColor : options.barNegativeColor,
                            color;
                        if (value >= target)
                            color = positiveColor;
                        else
                            color = negativeColor;
                        if (index === pointIndexes.first || index === pointIndexes.last)
                            color = options.firstLastColor;
                        if (index === pointIndexes.min)
                            color = options.minColor;
                        if (index === pointIndexes.max)
                            color = options.maxColor;
                        return {color: color}
                    }
            },
            _createLineCustomizeFunction: function(pointIndexes) {
                var that = this,
                    options = that._allOptions;
                return function() {
                        var color,
                            index = this.index;
                        if (index === pointIndexes.first || index === pointIndexes.last)
                            color = options.firstLastColor;
                        if (index === pointIndexes.min)
                            color = options.minColor;
                        if (index === pointIndexes.max)
                            color = options.maxColor;
                        return color ? {
                                visible: true,
                                border: {color: color}
                            } : {}
                    }
            },
            _getCustomizeFunction: function() {
                var that = this,
                    options = that._allOptions,
                    dataSource = that._winlossDataSource || that._simpleDataSource,
                    drawnPointIndexes = that._getExtremumPointsIndexes(dataSource),
                    customizeFunction;
                if (options.type === "winloss" || options.type === "bar")
                    customizeFunction = that._createBarCustomizeFunction(drawnPointIndexes);
                else
                    customizeFunction = that._createLineCustomizeFunction(drawnPointIndexes);
                return customizeFunction
            },
            _getExtremumPointsIndexes: function(data) {
                var that = this,
                    options = that._allOptions,
                    lastIndex = data.length - 1,
                    indexes = {};
                that._minMaxIndexes = that._findMinMax(data);
                if (options.showFirstLast) {
                    indexes.first = 0;
                    indexes.last = lastIndex
                }
                if (options.showMinMax) {
                    indexes.min = that._minMaxIndexes.minIndex;
                    indexes.max = that._minMaxIndexes.maxIndex
                }
                return indexes
            },
            _findMinMax: function(data) {
                var that = this,
                    valField = that._allOptions.valueField,
                    firstItem = data[0] || {},
                    firstValue = firstItem[valField] || 0,
                    min = firstValue,
                    max = firstValue,
                    minIndex = 0,
                    maxIndex = 0,
                    dataLength = data.length,
                    value,
                    i;
                for (i = 1; i < dataLength; i++) {
                    value = data[i][valField];
                    if (value < min) {
                        min = value;
                        minIndex = i
                    }
                    if (value > max) {
                        max = value;
                        maxIndex = i
                    }
                }
                return {
                        minIndex: minIndex,
                        maxIndex: maxIndex
                    }
            },
            _createRange: function() {
                var that = this,
                    series = that._series,
                    isBarType = series.type === "bar",
                    DEFAULT_VALUE_RANGE_MARGIN = 0.15,
                    DEFAULT_ARGUMENT_RANGE_MARGIN = 0.1,
                    rangeData = series.getRangeData(),
                    valCoef = (rangeData.val.max - rangeData.val.min) * DEFAULT_VALUE_RANGE_MARGIN,
                    argCoef;
                if (isBarType || series.type === "area" || series.type === "winloss") {
                    if (rangeData.val.min !== 0)
                        rangeData.val.min = rangeData.val.min - valCoef;
                    if (rangeData.val.max !== 0)
                        rangeData.val.max = rangeData.val.max + valCoef
                }
                else {
                    rangeData.val.min = rangeData.val.min - valCoef;
                    rangeData.val.max = rangeData.val.max + valCoef
                }
                if (series.getPoints().length > 1)
                    if (isBarType) {
                        argCoef = (rangeData.arg.max - rangeData.arg.min) * DEFAULT_ARGUMENT_RANGE_MARGIN;
                        rangeData.arg.min = rangeData.arg.min - argCoef;
                        rangeData.arg.max = rangeData.arg.max + argCoef
                    }
                    else
                        rangeData.arg.stick = true;
                that._ranges = rangeData
            },
            _getBarWidth: function(pointsCount) {
                var that = this,
                    canvas = that._canvas,
                    intervalWidth = pointsCount * DEFAULT_BAR_INTERVAL,
                    rangeWidth = canvas.width - canvas.left - canvas.right - intervalWidth,
                    width = _round(rangeWidth / pointsCount);
                if (width < MIN_BAR_WIDTH)
                    width = MIN_BAR_WIDTH;
                if (width > MAX_BAR_WIDTH)
                    width = MAX_BAR_WIDTH;
                return width
            },
            _correctPoints: function() {
                var that = this,
                    seriesType = that._allOptions.type,
                    seriesPoints = that._series.getPoints(),
                    pointsLength = seriesPoints.length,
                    barWidth,
                    i;
                if (seriesType === "bar" || seriesType === "winloss") {
                    barWidth = that._getBarWidth(pointsLength);
                    for (i = 0; i < pointsLength; i++)
                        seriesPoints[i].correctCoordinates({
                            width: barWidth,
                            offset: 0
                        })
                }
            },
            _drawSeries: function() {
                var that = this;
                if (that._simpleDataSource.length !== 0) {
                    that._correctPoints();
                    that._series.draw({
                        x: that._translatorX,
                        y: that._translatorY
                    });
                    that._seriesGroup.append(that._renderer.root);
                    that._prepareTooltipContainer()
                }
            },
            _isTooltipVisible: function() {
                return this.callBase() && this._dataSource.length !== 0
            },
            _getTooltipData: function() {
                var that = this,
                    options = that._allOptions,
                    dataSource = that._winlossDataSource || that._simpleDataSource,
                    tooltip = that._tooltip;
                if (dataSource.length === 0)
                    return {};
                var minMax = that._minMaxIndexes,
                    valueField = options.valueField,
                    first = dataSource[0][valueField],
                    last = dataSource[dataSource.length - 1][valueField],
                    min = dataSource[minMax.minIndex][valueField],
                    max = dataSource[minMax.maxIndex][valueField],
                    formattedFirst = tooltip.formatValue(first),
                    formattedLast = tooltip.formatValue(last),
                    formattedMin = tooltip.formatValue(min),
                    formattedMax = tooltip.formatValue(max),
                    customizeObject = {
                        firstValue: formattedFirst,
                        lastValue: formattedLast,
                        minValue: formattedMin,
                        maxValue: formattedMax,
                        originalFirstValue: first,
                        originalLastValue: last,
                        originalMinValue: min,
                        originalMaxValue: max,
                        valueText: ["Start:", formattedFirst, "End:", formattedLast, "Min:", formattedMin, "Max:", formattedMax]
                    };
                if (options.type === "winloss") {
                    customizeObject.originalThresholdValue = options.winlossThreshold;
                    customizeObject.thresholdValue = tooltip.formatValue(options.winlossThreshold)
                }
                return customizeObject
            }
        }).include(DX.ui.DataHelperMixin))
    })(jQuery, DevExpress);
    /*! Module viz-sparklines, file bullet.js */
    (function($, DX) {
        var charts = DX.viz.charts,
            TARGET_MIN_Y = 0.02,
            TARGET_MAX_Y = 0.98,
            BAR_VALUE_MIN_Y = 0.1,
            BAR_VALUE_MAX_Y = 0.9,
            DEFAULT_CANVAS_WIDTH = 300,
            DEFAULT_CANVAS_HEIGHT = 30,
            DEFAULT_HORIZONTAL_MARGIN = 1,
            DEFAULT_VERTICAL_MARGIN = 2,
            DEFAULT_OPTIONS = {
                disabled: false,
                theme: 'default',
                size: {},
                margin: {}
            },
            _String = String,
            _Number = Number,
            _round = Math.round,
            _isFinite = isFinite;
        DX.registerComponent("dxBullet", DX.viz.sparklines, DX.viz.sparklines.BaseSparkline.inherit({
            _widgetType: 'bullet',
            _widgetClass: 'dxb',
            _defaultSize: {
                width: DEFAULT_CANVAS_WIDTH,
                height: DEFAULT_CANVAS_HEIGHT,
                left: DEFAULT_HORIZONTAL_MARGIN,
                right: DEFAULT_HORIZONTAL_MARGIN,
                top: DEFAULT_VERTICAL_MARGIN,
                bottom: DEFAULT_VERTICAL_MARGIN
            },
            _disposeWidgetElements: function() {
                delete this._zeroLevelPath;
                delete this._targetPath;
                delete this._barValuePath
            },
            _redrawWidgetElements: function() {
                this._createTranslator();
                this._drawBarValue();
                this._drawTarget();
                this._drawZeroLevel()
            },
            _cleanWidgetElements: function() {
                this._zeroLevelPath.remove();
                this._targetPath.remove();
                this._barValuePath.remove()
            },
            _drawWidgetElements: function() {
                this._drawBullet()
            },
            _createHtmlElements: function() {
                var renderer = this._renderer;
                this._zeroLevelPath = renderer.path(undefined, "line").attr({
                    'class': 'dxb-zero-level',
                    "stroke-linecap": "square"
                });
                this._targetPath = renderer.path(undefined, "line").attr({
                    'class': 'dxb-target',
                    "stroke-linecap": "square"
                });
                this._barValuePath = renderer.path(undefined, "line").attr({
                    'class': 'dxb-bar-value',
                    "stroke-linecap": "square"
                })
            },
            _prepareOptions: function() {
                var that = this,
                    options,
                    startScaleValue,
                    endScaleValue,
                    level,
                    value,
                    target;
                that._allOptions = options = that.callBase(DEFAULT_OPTIONS);
                if (that._allOptions.value === undefined)
                    that._allOptions.value = 0;
                if (that._allOptions.target === undefined)
                    that._allOptions.target = 0;
                options.value = value = _Number(options.value);
                options.target = target = _Number(options.target);
                if (that._allOptions.startScaleValue === undefined) {
                    that._allOptions.startScaleValue = target < value ? target : value;
                    that._allOptions.startScaleValue = that._allOptions.startScaleValue < 0 ? that._allOptions.startScaleValue : 0
                }
                if (that._allOptions.endScaleValue === undefined)
                    that._allOptions.endScaleValue = target > value ? target : value;
                options.startScaleValue = startScaleValue = _Number(options.startScaleValue);
                options.endScaleValue = endScaleValue = _Number(options.endScaleValue);
                if (endScaleValue < startScaleValue) {
                    level = endScaleValue;
                    that._allOptions.endScaleValue = startScaleValue;
                    that._allOptions.startScaleValue = level;
                    that._allOptions.inverted = true
                }
            },
            _createRange: function() {
                var that = this,
                    options = that._allOptions;
                that._ranges = {
                    arg: {
                        invert: options.inverted,
                        min: options.startScaleValue,
                        max: options.endScaleValue,
                        axisType: "continuous",
                        dataType: "numeric"
                    },
                    val: {
                        min: 0,
                        max: 1,
                        axisType: "continuous",
                        dataType: "numeric"
                    }
                }
            },
            _drawBullet: function() {
                var that = this,
                    options = that._allOptions,
                    isValidBounds = options.startScaleValue !== options.endScaleValue,
                    isValidMin = _isFinite(options.startScaleValue),
                    isValidMax = _isFinite(options.endScaleValue),
                    isValidValue = _isFinite(options.value),
                    isValidTarget = _isFinite(options.target);
                if (isValidBounds && isValidMax && isValidMin && isValidTarget && isValidValue) {
                    this._drawBarValue();
                    this._drawTarget();
                    this._drawZeroLevel();
                    this._prepareTooltipContainer()
                }
            },
            _getTargetParams: function() {
                var that = this,
                    options = that._allOptions,
                    translatorY = that._translatorY,
                    x = that._translatorX.translate(options.target);
                return {
                        points: [x, translatorY.translate(TARGET_MIN_Y), x, translatorY.translate(TARGET_MAX_Y)],
                        stroke: options.targetColor,
                        "stroke-width": options.targetWidth,
                        "stroke-linecap": "square"
                    }
            },
            _getBarValueParams: function() {
                var that = this,
                    options = that._allOptions,
                    translatorX = that._translatorX,
                    translatorY = that._translatorY,
                    startLevel = options.startScaleValue,
                    endLevel = options.endScaleValue,
                    value = options.value,
                    y2 = translatorY.translate(BAR_VALUE_MIN_Y),
                    y1 = translatorY.translate(BAR_VALUE_MAX_Y),
                    x1,
                    x2;
                if (value > 0) {
                    x1 = startLevel <= 0 ? 0 : startLevel;
                    x2 = value >= endLevel ? endLevel : value
                }
                else {
                    x1 = endLevel >= 0 ? 0 : endLevel;
                    x2 = value >= startLevel ? value : startLevel
                }
                x1 = translatorX.translate(x1);
                x2 = translatorX.translate(x2);
                return {
                        points: [x1, y1, x2, y1, x2, y2, x1, y2],
                        fill: options.color
                    }
            },
            _getZeroLevelParams: function() {
                var that = this,
                    translatorY = that._translatorY,
                    x = that._translatorX.translate(0);
                return {
                        points: [x, translatorY.translate(TARGET_MIN_Y), x, translatorY.translate(TARGET_MAX_Y)],
                        stroke: that._allOptions.targetColor,
                        "stroke-width": 1,
                        "stroke-linecap": "square"
                    }
            },
            _drawZeroLevel: function() {
                var that = this,
                    options = that._allOptions;
                if (0 > options.endScaleValue || 0 < options.startScaleValue || !options.showZeroLevel)
                    return;
                that._zeroLevelPath.attr(that._getZeroLevelParams()).sharp().append(that._renderer.root)
            },
            _drawTarget: function() {
                var that = this,
                    options = that._allOptions,
                    target = options.target;
                if (target > options.endScaleValue || target < options.startScaleValue || !options.showTarget)
                    return;
                that._targetPath.attr(that._getTargetParams()).sharp().append(that._renderer.root)
            },
            _drawBarValue: function() {
                this._barValuePath.attr(this._getBarValueParams()).append(this._renderer.root)
            },
            _getTooltipData: function() {
                var that = this,
                    tooltip = that._tooltip,
                    options = that._allOptions,
                    value = options.value,
                    target = options.target;
                return {
                        originalValue: value,
                        originalTarget: target,
                        value: tooltip.formatValue(value),
                        target: tooltip.formatValue(target),
                        valueText: ['Actual Value:', value, 'Target Value:', target]
                    }
            },
            _getNormalTooltipSize: function() {
                var size = {},
                    bbox = this._barValuePath.getBBox();
                size.width = this._canvas.width;
                size.left = 0;
                size.tooltipLeft = bbox.x + _round(bbox.width / 2);
                return size
            },
            _getWideTooltipSize: function(leftWidthDelta, rightWidthDelta) {
                var that = this,
                    bbox = that._barValuePath.getBBox(),
                    horizontalPos = that._allOptions.tooltip.horizontalAlignment,
                    size = {};
                size.width = leftWidthDelta + rightWidthDelta + that._canvas.width;
                size.left = -leftWidthDelta;
                if (horizontalPos === 'right')
                    size.tooltipLeft = bbox.x + _round(bbox.width / 2);
                else if (horizontalPos === 'left')
                    size.tooltipLeft = _round(bbox.width / 2) + leftWidthDelta + rightWidthDelta + bbox.x;
                else
                    size.tooltipLeft = _round(bbox.width / 2) + bbox.x + leftWidthDelta;
                return size
            }
        }))
    })(jQuery, DevExpress);
    DevExpress.MOD_VIZ_SPARKLINES = true
}
